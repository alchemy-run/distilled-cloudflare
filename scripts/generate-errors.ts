#!/usr/bin/env bun
/**
 * Generate typed error classes from the error catalog.
 *
 * This script reads spec/error-catalog.json and generates:
 * - src/errors/generated.ts - All typed error classes
 *
 * Usage:
 *   bun scripts/generate-errors.ts
 */

import { FileSystem } from "@effect/platform";
import { NodeContext, NodeRuntime } from "@effect/platform-node";
import * as Effect from "effect/Effect";

interface ErrorCatalogEntry {
  name: string;
  category: string;
}

interface ErrorCatalogData {
  codes: Record<string, ErrorCatalogEntry>;
  patterns: Array<{ regex: string; name: string; category: string }>;
  codeRanges: Array<{ min: number; max: number; defaultCategory: string }>;
}

const generate = Effect.gen(function* () {
  const fs = yield* FileSystem.FileSystem;

  // Load error catalog
  const catalogContent = yield* fs.readFileString("spec/error-catalog.json");
  const catalog = JSON.parse(catalogContent) as ErrorCatalogData;

  console.log(`ðŸ“‚ Loaded ${Object.keys(catalog.codes).length} error codes from catalog\n`);

  // Group errors by category
  const byCategory = new Map<string, Array<{ code: number; name: string }>>();
  for (const [code, entry] of Object.entries(catalog.codes)) {
    const category = entry.category;
    if (!byCategory.has(category)) {
      byCategory.set(category, []);
    }
    byCategory.get(category)!.push({ code: Number(code), name: entry.name });
  }

  // Generate the errors file
  const lines: string[] = [
    `/**`,
    ` * Generated Cloudflare API error classes.`,
    ` *`,
    ` * DO NOT EDIT - This file is generated by scripts/generate-errors.ts`,
    ` * To add new errors, update spec/error-catalog.json and regenerate.`,
    ` */`,
    ``,
    `import * as Schema from "effect/Schema";`,
    ``,
  ];

  // Generate category base classes
  const categories = [
    "AuthError",
    "BadRequestError",
    "NotFoundError",
    "ConflictError",
    "ThrottlingError",
    "ServerError",
  ];

  // Track generated class names to avoid duplicates
  const generatedNames = new Set<string>();
  const codeToClassName = new Map<number, string>();

  for (const category of categories) {
    lines.push(`// =============================================================================`);
    lines.push(`// ${category}`);
    lines.push(`// =============================================================================`);
    lines.push(``);

    const errors = byCategory.get(category) ?? [];
    errors.sort((a, b) => a.code - b.code);

    for (const { code, name } of errors) {
      // Make sure name is a valid identifier
      let safeName = name.replace(/[^a-zA-Z0-9_]/g, "");

      // Handle duplicate names by appending the code
      if (generatedNames.has(safeName)) {
        safeName = `${safeName}_${code}`;
      }
      generatedNames.add(safeName);
      codeToClassName.set(code, safeName);

      lines.push(`/**`);
      lines.push(` * Cloudflare error code ${code}: ${name}`);
      lines.push(` */`);
      lines.push(
        `export class ${safeName} extends Schema.TaggedError<${safeName}>()("${safeName}", {`,
      );
      lines.push(`  code: Schema.Literal(${code}),`);
      lines.push(`  message: Schema.String,`);
      lines.push(`}) {`);
      lines.push(`  static readonly code = ${code};`);
      lines.push(`}`);
      lines.push(``);
    }
  }

  // Generate a union type of all errors
  lines.push(`// =============================================================================`);
  lines.push(`// Union Types`);
  lines.push(`// =============================================================================`);
  lines.push(``);

  for (const category of categories) {
    const errors = byCategory.get(category) ?? [];
    if (errors.length === 0) continue;

    const names = errors.map((e) => codeToClassName.get(e.code)!);
    lines.push(`export type ${category}s = ${names.join(" | ")};`);
  }
  lines.push(``);

  // Generate all errors union
  const allNames = Array.from(codeToClassName.values());
  lines.push(`export type CloudflareKnownError = ${allNames.join(" | ")};`);
  lines.push(``);

  // Generate a map of code to error class
  lines.push(`/**`);
  lines.push(` * Map of error codes to their error class constructors.`);
  lines.push(` */`);
  lines.push(`export const ERROR_CODE_MAP = {`);
  for (const [code, className] of codeToClassName.entries()) {
    lines.push(`  ${code}: ${className},`);
  }
  lines.push(`} as const;`);
  lines.push(``);
  lines.push(`export type ErrorCodeMap = typeof ERROR_CODE_MAP;`);
  lines.push(``);

  // Generate the error catalog for response parser
  lines.push(`/**`);
  lines.push(` * Error catalog for response parser.`);
  lines.push(` * Maps error codes to their names (matching the class identifiers).`);
  lines.push(` */`);
  lines.push(
    `export const ERROR_CATALOG: Map<number, { name: string; category: string }> = new Map([`,
  );
  for (const [code, entry] of Object.entries(catalog.codes)) {
    const className = codeToClassName.get(Number(code));
    if (className) {
      lines.push(`  [${code}, { name: "${className}", category: "${entry.category}" }],`);
    }
  }
  lines.push(`]);`);
  lines.push(``);

  // Write the file
  const content = lines.join("\n");
  yield* fs.writeFileString("src/errors/generated.ts", content);

  console.log(
    `âœ… Generated src/errors/generated.ts with ${Object.keys(catalog.codes).length} error classes\n`,
  );

  // Print summary
  console.log(`ðŸ“‹ Summary by category:`);
  for (const category of categories) {
    const count = byCategory.get(category)?.length ?? 0;
    if (count > 0) {
      console.log(`   ${category}: ${count} errors`);
    }
  }
});

// Run
generate.pipe(Effect.provide(NodeContext.layer), NodeRuntime.runMain);
