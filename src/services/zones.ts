/**
 * Cloudflare ZONES API
 *
 * Generated from Cloudflare OpenAPI specification.
 * DO NOT EDIT - regenerate with: bun generate --service zones
 */

import * as Effect from "effect/Effect";
import * as Schema from "effect/Schema";
import type { HttpClient } from "@effect/platform";
import * as API from "../client/api.ts";
import * as T from "../traits.ts";
import type { ApiToken } from "../auth.ts";
import {
  CloudflareError,
  UnknownCloudflareError,
  CloudflareNetworkError,
  CloudflareHttpError,
} from "../errors.ts";
import {
  AuthenticationError,
  InvalidToken,
  MissingToken,
  RateLimited,
  TokenExpired,
  TooManyRequests,
  Unauthorized,
} from "../errors/generated.ts";

export interface Get_Request {
  name?: string;
  status?: "initializing" | "pending" | "active" | "moved";
  "account.id"?: string;
  "account.name"?: string;
  page?: number;
  per_page?: number;
  order?: "name" | "status" | "account.id" | "account.name" | "plan.id";
  direction?: "asc" | "desc";
  match?: "any" | "all";
}

export const Get_Request = Schema.Struct({
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  status: Schema.optional(Schema.Literal("initializing", "pending", "active", "moved")).pipe(T.HttpQuery("status")),
  "account.id": Schema.optional(Schema.String).pipe(T.HttpQuery("account.id")),
  "account.name": Schema.optional(Schema.String).pipe(T.HttpQuery("account.name")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.Literal("name", "status", "account.id", "account.name", "plan.id")).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction")),
  match: Schema.optional(Schema.Literal("any", "all")).pipe(T.HttpQuery("match"))
}).pipe(
  T.Http({ method: "GET", path: "/zones" }),
).annotations({ identifier: "Get_Request" }) as unknown as Schema.Schema<Get_Request>;

export interface Get_Response {
  result: { account: { id?: string; name?: string }; activated_on: string; cname_suffix?: string; created_on: string; development_mode: number; id: string; meta: { cdn_only?: boolean; custom_certificate_quota?: number; dns_only?: boolean; foundation_dns?: boolean; page_rule_quota?: number; phishing_detected?: boolean; step?: number }; modified_on: string; name: string; name_servers: string[]; original_dnshost: string; original_name_servers: string[]; original_registrar: string; owner: { id?: string; name?: string; type?: string }; paused?: boolean; permissions?: string[]; plan: unknown; status?: "initializing" | "pending" | "active" | "moved"; tenant?: unknown; tenant_unit?: unknown; type?: "full" | "partial" | "secondary" | "internal"; vanity_name_servers?: string[]; verification_key?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  account: Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}),
  activated_on: Schema.Date,
  cname_suffix: Schema.optional(Schema.String),
  created_on: Schema.Date,
  development_mode: Schema.Number,
  id: Schema.String,
  meta: Schema.Struct({
  cdn_only: Schema.optional(Schema.Boolean),
  custom_certificate_quota: Schema.optional(Schema.Number),
  dns_only: Schema.optional(Schema.Boolean),
  foundation_dns: Schema.optional(Schema.Boolean),
  page_rule_quota: Schema.optional(Schema.Number),
  phishing_detected: Schema.optional(Schema.Boolean),
  step: Schema.optional(Schema.Number)
}),
  modified_on: Schema.Date,
  name: Schema.String,
  name_servers: Schema.Array(Schema.String),
  original_dnshost: Schema.String,
  original_name_servers: Schema.Array(Schema.String),
  original_registrar: Schema.String,
  owner: Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String)
}),
  paused: Schema.optional(Schema.Boolean),
  permissions: Schema.optional(Schema.Array(Schema.String)),
  plan: Schema.Unknown,
  status: Schema.optional(Schema.Literal("initializing", "pending", "active", "moved")),
  tenant: Schema.optional(Schema.Unknown),
  tenant_unit: Schema.optional(Schema.Unknown),
  type: Schema.optional(Schema.Literal("full", "partial", "secondary", "internal")),
  vanity_name_servers: Schema.optional(Schema.Array(Schema.String)),
  verification_key: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_Response" }) as unknown as Schema.Schema<Get_Response>;

export const get_: (
  input: Get_Request
) => Effect.Effect<
  Get_Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_Request,
  output: Get_Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRequest {
  body: { account: { id?: string }; name: string; type?: "full" | "partial" | "secondary" | "internal" };
}

export const PostRequest = Schema.Struct({
  body: Schema.Struct({
  account: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  name: Schema.String,
  type: Schema.optional(Schema.Literal("full", "partial", "secondary", "internal"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones" }),
).annotations({ identifier: "PostRequest" }) as unknown as Schema.Schema<PostRequest>;

export interface PostResponse {
  result: { account: { id?: string; name?: string }; activated_on: string; cname_suffix?: string; created_on: string; development_mode: number; id: string; meta: { cdn_only?: boolean; custom_certificate_quota?: number; dns_only?: boolean; foundation_dns?: boolean; page_rule_quota?: number; phishing_detected?: boolean; step?: number }; modified_on: string; name: string; name_servers: string[]; original_dnshost: string; original_name_servers: string[]; original_registrar: string; owner: { id?: string; name?: string; type?: string }; paused?: boolean; permissions?: string[]; plan: unknown; status?: "initializing" | "pending" | "active" | "moved"; tenant?: unknown; tenant_unit?: unknown; type?: "full" | "partial" | "secondary" | "internal"; vanity_name_servers?: string[]; verification_key?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostResponse = Schema.Struct({
  result: Schema.Struct({
  account: Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}),
  activated_on: Schema.Date,
  cname_suffix: Schema.optional(Schema.String),
  created_on: Schema.Date,
  development_mode: Schema.Number,
  id: Schema.String,
  meta: Schema.Struct({
  cdn_only: Schema.optional(Schema.Boolean),
  custom_certificate_quota: Schema.optional(Schema.Number),
  dns_only: Schema.optional(Schema.Boolean),
  foundation_dns: Schema.optional(Schema.Boolean),
  page_rule_quota: Schema.optional(Schema.Number),
  phishing_detected: Schema.optional(Schema.Boolean),
  step: Schema.optional(Schema.Number)
}),
  modified_on: Schema.Date,
  name: Schema.String,
  name_servers: Schema.Array(Schema.String),
  original_dnshost: Schema.String,
  original_name_servers: Schema.Array(Schema.String),
  original_registrar: Schema.String,
  owner: Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String)
}),
  paused: Schema.optional(Schema.Boolean),
  permissions: Schema.optional(Schema.Array(Schema.String)),
  plan: Schema.Unknown,
  status: Schema.optional(Schema.Literal("initializing", "pending", "active", "moved")),
  tenant: Schema.optional(Schema.Unknown),
  tenant_unit: Schema.optional(Schema.Unknown),
  type: Schema.optional(Schema.Literal("full", "partial", "secondary", "internal")),
  vanity_name_servers: Schema.optional(Schema.Array(Schema.String)),
  verification_key: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostResponse" }) as unknown as Schema.Schema<PostResponse>;

export const post: (
  input: PostRequest
) => Effect.Effect<
  PostResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRequest,
  output: PostResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAnalyticsByCoLocationsRequest {
  zone_identifier: string;
  until?: unknown;
  since?: unknown;
  continuous?: boolean;
}

export const GetAnalyticsByCoLocationsRequest = Schema.Struct({
  zone_identifier: Schema.String.pipe(T.HttpPath("zone_identifier")),
  until: Schema.optional(Schema.Union(Schema.String, Schema.Number)).pipe(T.HttpQuery("until")),
  since: Schema.optional(Schema.Union(Schema.String, Schema.Number)).pipe(T.HttpQuery("since")),
  continuous: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("continuous"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_identifier}/analytics/colos" }),
).annotations({ identifier: "GetAnalyticsByCoLocationsRequest" }) as unknown as Schema.Schema<GetAnalyticsByCoLocationsRequest>;

export interface GetAnalyticsByCoLocationsResponse {
  result: { colo_id?: string; timeseries?: { bandwidth?: { all?: number; cached?: number; uncached?: number }; requests?: { all?: number; cached?: number; country?: Record<string, unknown>; http_status?: Record<string, unknown>; uncached?: number }; since?: unknown; threats?: { all?: number; country?: Record<string, unknown>; type?: Record<string, unknown> }; until?: unknown }[]; totals?: { bandwidth?: { all?: number; cached?: number; uncached?: number }; requests?: { all?: number; cached?: number; country?: Record<string, unknown>; http_status?: Record<string, unknown>; uncached?: number }; since?: unknown; threats?: { all?: number; country?: Record<string, unknown>; type?: Record<string, unknown> }; until?: unknown } }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAnalyticsByCoLocationsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  colo_id: Schema.optional(Schema.String),
  timeseries: Schema.optional(Schema.Array(Schema.Struct({
  bandwidth: Schema.optional(Schema.Struct({
  all: Schema.optional(Schema.Number),
  cached: Schema.optional(Schema.Number),
  uncached: Schema.optional(Schema.Number)
})),
  requests: Schema.optional(Schema.Struct({
  all: Schema.optional(Schema.Number),
  cached: Schema.optional(Schema.Number),
  country: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Unknown })),
  http_status: Schema.optional(Schema.Struct({})),
  uncached: Schema.optional(Schema.Number)
})),
  since: Schema.optional(Schema.Union(Schema.String, Schema.Number)),
  threats: Schema.optional(Schema.Struct({
  all: Schema.optional(Schema.Number),
  country: Schema.optional(Schema.Struct({})),
  type: Schema.optional(Schema.Struct({}))
})),
  until: Schema.optional(Schema.Union(Schema.String, Schema.Number))
}))),
  totals: Schema.optional(Schema.Struct({
  bandwidth: Schema.optional(Schema.Struct({
  all: Schema.optional(Schema.Number),
  cached: Schema.optional(Schema.Number),
  uncached: Schema.optional(Schema.Number)
})),
  requests: Schema.optional(Schema.Struct({
  all: Schema.optional(Schema.Number),
  cached: Schema.optional(Schema.Number),
  country: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Unknown })),
  http_status: Schema.optional(Schema.Struct({})),
  uncached: Schema.optional(Schema.Number)
})),
  since: Schema.optional(Schema.Union(Schema.String, Schema.Number)),
  threats: Schema.optional(Schema.Struct({
  all: Schema.optional(Schema.Number),
  country: Schema.optional(Schema.Struct({})),
  type: Schema.optional(Schema.Struct({}))
})),
  until: Schema.optional(Schema.Union(Schema.String, Schema.Number))
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAnalyticsByCoLocationsResponse" }) as unknown as Schema.Schema<GetAnalyticsByCoLocationsResponse>;

export const getAnalyticsByCoLocations: (
  input: GetAnalyticsByCoLocationsRequest
) => Effect.Effect<
  GetAnalyticsByCoLocationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAnalyticsByCoLocationsRequest,
  output: GetAnalyticsByCoLocationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDashboardRequest {
  zone_identifier: string;
  until?: unknown;
  since?: unknown;
  continuous?: boolean;
}

export const GetDashboardRequest = Schema.Struct({
  zone_identifier: Schema.String.pipe(T.HttpPath("zone_identifier")),
  until: Schema.optional(Schema.Union(Schema.String, Schema.Number)).pipe(T.HttpQuery("until")),
  since: Schema.optional(Schema.Union(Schema.String, Schema.Number)).pipe(T.HttpQuery("since")),
  continuous: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("continuous"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_identifier}/analytics/dashboard" }),
).annotations({ identifier: "GetDashboardRequest" }) as unknown as Schema.Schema<GetDashboardRequest>;

export interface GetDashboardResponse {
  result: { timeseries?: { bandwidth?: { all?: number; cached?: number; content_type?: Record<string, unknown>; country?: Record<string, unknown>; ssl?: { encrypted?: number; unencrypted?: number }; ssl_protocols?: { TLSv1?: number; "TLSv1.1"?: number; "TLSv1.2"?: number; "TLSv1.3"?: number; none?: number }; uncached?: number }; pageviews?: { all?: number; search_engine?: Record<string, unknown> }; requests?: { all?: number; cached?: number; content_type?: Record<string, unknown>; country?: Record<string, unknown>; http_status?: Record<string, unknown>; ssl?: { encrypted?: number; unencrypted?: number }; ssl_protocols?: { TLSv1?: number; "TLSv1.1"?: number; "TLSv1.2"?: number; "TLSv1.3"?: number; none?: number }; uncached?: number }; since?: unknown; threats?: { all?: number; country?: Record<string, unknown>; type?: Record<string, unknown> }; uniques?: { all?: number }; until?: unknown }[]; totals?: { bandwidth?: { all?: number; cached?: number; content_type?: Record<string, unknown>; country?: Record<string, unknown>; ssl?: { encrypted?: number; unencrypted?: number }; ssl_protocols?: { TLSv1?: number; "TLSv1.1"?: number; "TLSv1.2"?: number; "TLSv1.3"?: number; none?: number }; uncached?: number }; pageviews?: { all?: number; search_engine?: Record<string, unknown> }; requests?: { all?: number; cached?: number; content_type?: Record<string, unknown>; country?: Record<string, unknown>; http_status?: Record<string, unknown>; ssl?: { encrypted?: number; unencrypted?: number }; ssl_protocols?: { TLSv1?: number; "TLSv1.1"?: number; "TLSv1.2"?: number; "TLSv1.3"?: number; none?: number }; uncached?: number }; since?: unknown; threats?: { all?: number; country?: Record<string, unknown>; type?: Record<string, unknown> }; uniques?: { all?: number }; until?: unknown } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDashboardResponse = Schema.Struct({
  result: Schema.Struct({
  timeseries: Schema.optional(Schema.Array(Schema.Struct({
  bandwidth: Schema.optional(Schema.Struct({
  all: Schema.optional(Schema.Number),
  cached: Schema.optional(Schema.Number),
  content_type: Schema.optional(Schema.Struct({})),
  country: Schema.optional(Schema.Struct({})),
  ssl: Schema.optional(Schema.Struct({
  encrypted: Schema.optional(Schema.Number),
  unencrypted: Schema.optional(Schema.Number)
})),
  ssl_protocols: Schema.optional(Schema.Struct({
  TLSv1: Schema.optional(Schema.Number),
  "TLSv1.1": Schema.optional(Schema.Number),
  "TLSv1.2": Schema.optional(Schema.Number),
  "TLSv1.3": Schema.optional(Schema.Number),
  none: Schema.optional(Schema.Number)
})),
  uncached: Schema.optional(Schema.Number)
})),
  pageviews: Schema.optional(Schema.Struct({
  all: Schema.optional(Schema.Number),
  search_engine: Schema.optional(Schema.Struct({}))
})),
  requests: Schema.optional(Schema.Struct({
  all: Schema.optional(Schema.Number),
  cached: Schema.optional(Schema.Number),
  content_type: Schema.optional(Schema.Struct({})),
  country: Schema.optional(Schema.Struct({})),
  http_status: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Unknown })),
  ssl: Schema.optional(Schema.Struct({
  encrypted: Schema.optional(Schema.Number),
  unencrypted: Schema.optional(Schema.Number)
})),
  ssl_protocols: Schema.optional(Schema.Struct({
  TLSv1: Schema.optional(Schema.Number),
  "TLSv1.1": Schema.optional(Schema.Number),
  "TLSv1.2": Schema.optional(Schema.Number),
  "TLSv1.3": Schema.optional(Schema.Number),
  none: Schema.optional(Schema.Number)
})),
  uncached: Schema.optional(Schema.Number)
})),
  since: Schema.optional(Schema.Union(Schema.String, Schema.Number)),
  threats: Schema.optional(Schema.Struct({
  all: Schema.optional(Schema.Number),
  country: Schema.optional(Schema.Struct({})),
  type: Schema.optional(Schema.Struct({}))
})),
  uniques: Schema.optional(Schema.Struct({
  all: Schema.optional(Schema.Number)
})),
  until: Schema.optional(Schema.Union(Schema.String, Schema.Number))
}))),
  totals: Schema.optional(Schema.Struct({
  bandwidth: Schema.optional(Schema.Struct({
  all: Schema.optional(Schema.Number),
  cached: Schema.optional(Schema.Number),
  content_type: Schema.optional(Schema.Struct({})),
  country: Schema.optional(Schema.Struct({})),
  ssl: Schema.optional(Schema.Struct({
  encrypted: Schema.optional(Schema.Number),
  unencrypted: Schema.optional(Schema.Number)
})),
  ssl_protocols: Schema.optional(Schema.Struct({
  TLSv1: Schema.optional(Schema.Number),
  "TLSv1.1": Schema.optional(Schema.Number),
  "TLSv1.2": Schema.optional(Schema.Number),
  "TLSv1.3": Schema.optional(Schema.Number),
  none: Schema.optional(Schema.Number)
})),
  uncached: Schema.optional(Schema.Number)
})),
  pageviews: Schema.optional(Schema.Struct({
  all: Schema.optional(Schema.Number),
  search_engine: Schema.optional(Schema.Struct({}))
})),
  requests: Schema.optional(Schema.Struct({
  all: Schema.optional(Schema.Number),
  cached: Schema.optional(Schema.Number),
  content_type: Schema.optional(Schema.Struct({})),
  country: Schema.optional(Schema.Struct({})),
  http_status: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Unknown })),
  ssl: Schema.optional(Schema.Struct({
  encrypted: Schema.optional(Schema.Number),
  unencrypted: Schema.optional(Schema.Number)
})),
  ssl_protocols: Schema.optional(Schema.Struct({
  TLSv1: Schema.optional(Schema.Number),
  "TLSv1.1": Schema.optional(Schema.Number),
  "TLSv1.2": Schema.optional(Schema.Number),
  "TLSv1.3": Schema.optional(Schema.Number),
  none: Schema.optional(Schema.Number)
})),
  uncached: Schema.optional(Schema.Number)
})),
  since: Schema.optional(Schema.Union(Schema.String, Schema.Number)),
  threats: Schema.optional(Schema.Struct({
  all: Schema.optional(Schema.Number),
  country: Schema.optional(Schema.Struct({})),
  type: Schema.optional(Schema.Struct({}))
})),
  uniques: Schema.optional(Schema.Struct({
  all: Schema.optional(Schema.Number)
})),
  until: Schema.optional(Schema.Union(Schema.String, Schema.Number))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDashboardResponse" }) as unknown as Schema.Schema<GetDashboardResponse>;

export const getDashboard: (
  input: GetDashboardRequest
) => Effect.Effect<
  GetDashboardResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDashboardRequest,
  output: GetDashboardResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListCustomPagesRequest {
  zone_identifier: string;
}

export const ListCustomPagesRequest = Schema.Struct({
  zone_identifier: Schema.String.pipe(T.HttpPath("zone_identifier"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_identifier}/custom_pages" }),
).annotations({ identifier: "ListCustomPagesRequest" }) as unknown as Schema.Schema<ListCustomPagesRequest>;

export interface ListCustomPagesResponse {
  result: { created_on?: string; description?: string; id?: string; modified_on?: string; preview_target?: string; required_tokens?: string[]; state?: "default" | "customized"; url?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListCustomPagesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  preview_target: Schema.optional(Schema.String),
  required_tokens: Schema.optional(Schema.Array(Schema.String)),
  state: Schema.optional(Schema.Literal("default", "customized")),
  url: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListCustomPagesResponse" }) as unknown as Schema.Schema<ListCustomPagesResponse>;

export const listCustomPages: (
  input: ListCustomPagesRequest
) => Effect.Effect<
  ListCustomPagesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListCustomPagesRequest,
  output: ListCustomPagesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetACustomPageRequest {
  identifier: "1000_errors" | "500_errors" | "basic_challenge" | "country_challenge" | "ip_block" | "managed_challenge" | "ratelimit_block" | "under_attack" | "waf_block" | "waf_challenge";
  zone_identifier: string;
}

export const GetACustomPageRequest = Schema.Struct({
  identifier: Schema.Literal("1000_errors", "500_errors", "basic_challenge", "country_challenge", "ip_block", "managed_challenge", "ratelimit_block", "under_attack", "waf_block", "waf_challenge").pipe(T.HttpPath("identifier")),
  zone_identifier: Schema.String.pipe(T.HttpPath("zone_identifier"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_identifier}/custom_pages/{identifier}" }),
).annotations({ identifier: "GetACustomPageRequest" }) as unknown as Schema.Schema<GetACustomPageRequest>;

export interface GetACustomPageResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetACustomPageResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetACustomPageResponse" }) as unknown as Schema.Schema<GetACustomPageResponse>;

export const getACustomPage: (
  input: GetACustomPageRequest
) => Effect.Effect<
  GetACustomPageResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetACustomPageRequest,
  output: GetACustomPageResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateACustomPageRequest {
  identifier: "1000_errors" | "500_errors" | "basic_challenge" | "country_challenge" | "ip_block" | "managed_challenge" | "ratelimit_block" | "under_attack" | "waf_block" | "waf_challenge";
  zone_identifier: string;
  body: unknown;
}

export const UpdateACustomPageRequest = Schema.Struct({
  identifier: Schema.Literal("1000_errors", "500_errors", "basic_challenge", "country_challenge", "ip_block", "managed_challenge", "ratelimit_block", "under_attack", "waf_block", "waf_challenge").pipe(T.HttpPath("identifier")),
  zone_identifier: Schema.String.pipe(T.HttpPath("zone_identifier")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_identifier}/custom_pages/{identifier}" }),
).annotations({ identifier: "UpdateACustomPageRequest" }) as unknown as Schema.Schema<UpdateACustomPageRequest>;

export interface UpdateACustomPageResponse {
  result: { created_on?: string; description?: string; id?: string; modified_on?: string; preview_target?: string; required_tokens?: string[]; state?: "default" | "customized"; url?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateACustomPageResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  preview_target: Schema.optional(Schema.String),
  required_tokens: Schema.optional(Schema.Array(Schema.String)),
  state: Schema.optional(Schema.Literal("default", "customized")),
  url: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateACustomPageResponse" }) as unknown as Schema.Schema<UpdateACustomPageResponse>;

export const updateACustomPage: (
  input: UpdateACustomPageRequest
) => Effect.Effect<
  UpdateACustomPageResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateACustomPageRequest,
  output: UpdateACustomPageResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_1Request {
  zone_id: string;
}

export const Get_1Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}" }),
).annotations({ identifier: "Get_1Request" }) as unknown as Schema.Schema<Get_1Request>;

export interface Get_1Response {
  result: { account: { id?: string; name?: string }; activated_on: string; cname_suffix?: string; created_on: string; development_mode: number; id: string; meta: { cdn_only?: boolean; custom_certificate_quota?: number; dns_only?: boolean; foundation_dns?: boolean; page_rule_quota?: number; phishing_detected?: boolean; step?: number }; modified_on: string; name: string; name_servers: string[]; original_dnshost: string; original_name_servers: string[]; original_registrar: string; owner: { id?: string; name?: string; type?: string }; paused?: boolean; permissions?: string[]; plan: unknown; status?: "initializing" | "pending" | "active" | "moved"; tenant?: unknown; tenant_unit?: unknown; type?: "full" | "partial" | "secondary" | "internal"; vanity_name_servers?: string[]; verification_key?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_1Response = Schema.Struct({
  result: Schema.Struct({
  account: Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}),
  activated_on: Schema.Date,
  cname_suffix: Schema.optional(Schema.String),
  created_on: Schema.Date,
  development_mode: Schema.Number,
  id: Schema.String,
  meta: Schema.Struct({
  cdn_only: Schema.optional(Schema.Boolean),
  custom_certificate_quota: Schema.optional(Schema.Number),
  dns_only: Schema.optional(Schema.Boolean),
  foundation_dns: Schema.optional(Schema.Boolean),
  page_rule_quota: Schema.optional(Schema.Number),
  phishing_detected: Schema.optional(Schema.Boolean),
  step: Schema.optional(Schema.Number)
}),
  modified_on: Schema.Date,
  name: Schema.String,
  name_servers: Schema.Array(Schema.String),
  original_dnshost: Schema.String,
  original_name_servers: Schema.Array(Schema.String),
  original_registrar: Schema.String,
  owner: Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String)
}),
  paused: Schema.optional(Schema.Boolean),
  permissions: Schema.optional(Schema.Array(Schema.String)),
  plan: Schema.Unknown,
  status: Schema.optional(Schema.Literal("initializing", "pending", "active", "moved")),
  tenant: Schema.optional(Schema.Unknown),
  tenant_unit: Schema.optional(Schema.Unknown),
  type: Schema.optional(Schema.Literal("full", "partial", "secondary", "internal")),
  vanity_name_servers: Schema.optional(Schema.Array(Schema.String)),
  verification_key: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_1Response" }) as unknown as Schema.Schema<Get_1Response>;

export const get_1: (
  input: Get_1Request
) => Effect.Effect<
  Get_1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_1Request,
  output: Get_1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_Request {
  zone_id: string;
}

export const Delete_Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}" }),
).annotations({ identifier: "Delete_Request" }) as unknown as Schema.Schema<Delete_Request>;

export interface Delete_Response {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_Response = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_Response" }) as unknown as Schema.Schema<Delete_Response>;

export const delete_: (
  input: Delete_Request
) => Effect.Effect<
  Delete_Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_Request,
  output: Delete_Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchRequest {
  zone_id: string;
  body: { paused?: boolean; plan?: { id?: string }; type?: "full" | "partial" | "secondary" | "internal"; vanity_name_servers?: string[] };
}

export const PatchRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  paused: Schema.optional(Schema.Boolean),
  plan: Schema.optional(Schema.Struct({
  id: Schema.optional(Schema.String)
})),
  type: Schema.optional(Schema.Literal("full", "partial", "secondary", "internal")),
  vanity_name_servers: Schema.optional(Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}" }),
).annotations({ identifier: "PatchRequest" }) as unknown as Schema.Schema<PatchRequest>;

export interface PatchResponse {
  result: { account: { id?: string; name?: string }; activated_on: string; cname_suffix?: string; created_on: string; development_mode: number; id: string; meta: { cdn_only?: boolean; custom_certificate_quota?: number; dns_only?: boolean; foundation_dns?: boolean; page_rule_quota?: number; phishing_detected?: boolean; step?: number }; modified_on: string; name: string; name_servers: string[]; original_dnshost: string; original_name_servers: string[]; original_registrar: string; owner: { id?: string; name?: string; type?: string }; paused?: boolean; permissions?: string[]; plan: unknown; status?: "initializing" | "pending" | "active" | "moved"; tenant?: unknown; tenant_unit?: unknown; type?: "full" | "partial" | "secondary" | "internal"; vanity_name_servers?: string[]; verification_key?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchResponse = Schema.Struct({
  result: Schema.Struct({
  account: Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}),
  activated_on: Schema.Date,
  cname_suffix: Schema.optional(Schema.String),
  created_on: Schema.Date,
  development_mode: Schema.Number,
  id: Schema.String,
  meta: Schema.Struct({
  cdn_only: Schema.optional(Schema.Boolean),
  custom_certificate_quota: Schema.optional(Schema.Number),
  dns_only: Schema.optional(Schema.Boolean),
  foundation_dns: Schema.optional(Schema.Boolean),
  page_rule_quota: Schema.optional(Schema.Number),
  phishing_detected: Schema.optional(Schema.Boolean),
  step: Schema.optional(Schema.Number)
}),
  modified_on: Schema.Date,
  name: Schema.String,
  name_servers: Schema.Array(Schema.String),
  original_dnshost: Schema.String,
  original_name_servers: Schema.Array(Schema.String),
  original_registrar: Schema.String,
  owner: Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String)
}),
  paused: Schema.optional(Schema.Boolean),
  permissions: Schema.optional(Schema.Array(Schema.String)),
  plan: Schema.Unknown,
  status: Schema.optional(Schema.Literal("initializing", "pending", "active", "moved")),
  tenant: Schema.optional(Schema.Unknown),
  tenant_unit: Schema.optional(Schema.Unknown),
  type: Schema.optional(Schema.Literal("full", "partial", "secondary", "internal")),
  vanity_name_servers: Schema.optional(Schema.Array(Schema.String)),
  verification_key: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchResponse" }) as unknown as Schema.Schema<PatchResponse>;

export const patch: (
  input: PatchRequest
) => Effect.Effect<
  PatchResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchRequest,
  output: PatchResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAccessApplicationsRequest {
  zone_id: string;
}

export const ListAccessApplicationsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/apps" }),
).annotations({ identifier: "ListAccessApplicationsRequest" }) as unknown as Schema.Schema<ListAccessApplicationsRequest>;

export interface ListAccessApplicationsResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAccessApplicationsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAccessApplicationsResponse" }) as unknown as Schema.Schema<ListAccessApplicationsResponse>;

export const listAccessApplications: (
  input: ListAccessApplicationsRequest
) => Effect.Effect<
  ListAccessApplicationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessApplicationsRequest,
  output: ListAccessApplicationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneLevelAccessApplicationsAddABookmarkApplicationRequest {
  zone_id: string;
  body: Record<string, unknown>;
}

export const ZoneLevelAccessApplicationsAddABookmarkApplicationRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/access/apps" }),
).annotations({ identifier: "ZoneLevelAccessApplicationsAddABookmarkApplicationRequest" }) as unknown as Schema.Schema<ZoneLevelAccessApplicationsAddABookmarkApplicationRequest>;

export interface ZoneLevelAccessApplicationsAddABookmarkApplicationResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneLevelAccessApplicationsAddABookmarkApplicationResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneLevelAccessApplicationsAddABookmarkApplicationResponse" }) as unknown as Schema.Schema<ZoneLevelAccessApplicationsAddABookmarkApplicationResponse>;

export const zoneLevelAccessApplicationsAddABookmarkApplication: (
  input: ZoneLevelAccessApplicationsAddABookmarkApplicationRequest
) => Effect.Effect<
  ZoneLevelAccessApplicationsAddABookmarkApplicationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneLevelAccessApplicationsAddABookmarkApplicationRequest,
  output: ZoneLevelAccessApplicationsAddABookmarkApplicationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListShortLivedCertificateCAsRequest {
  zone_id: string;
}

export const ListShortLivedCertificateCAsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/apps/ca" }),
).annotations({ identifier: "ListShortLivedCertificateCAsRequest" }) as unknown as Schema.Schema<ListShortLivedCertificateCAsRequest>;

export interface ListShortLivedCertificateCAsResponse {
  result: { aud?: string; id?: string; public_key?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListShortLivedCertificateCAsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  aud: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  public_key: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListShortLivedCertificateCAsResponse" }) as unknown as Schema.Schema<ListShortLivedCertificateCAsResponse>;

export const listShortLivedCertificateCAs: (
  input: ListShortLivedCertificateCAsRequest
) => Effect.Effect<
  ListShortLivedCertificateCAsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListShortLivedCertificateCAsRequest,
  output: ListShortLivedCertificateCAsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAnAccessApplicationRequest {
  app_id: unknown;
  zone_id: string;
}

export const GetAnAccessApplicationRequest = Schema.Struct({
  app_id: Schema.Union(Schema.String, Schema.String).pipe(T.HttpPath("app_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/apps/{app_id}" }),
).annotations({ identifier: "GetAnAccessApplicationRequest" }) as unknown as Schema.Schema<GetAnAccessApplicationRequest>;

export interface GetAnAccessApplicationResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAnAccessApplicationResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAnAccessApplicationResponse" }) as unknown as Schema.Schema<GetAnAccessApplicationResponse>;

export const getAnAccessApplication: (
  input: GetAnAccessApplicationRequest
) => Effect.Effect<
  GetAnAccessApplicationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAnAccessApplicationRequest,
  output: GetAnAccessApplicationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateABookmarkApplicationRequest {
  app_id: unknown;
  zone_id: string;
  body: Record<string, unknown>;
}

export const UpdateABookmarkApplicationRequest = Schema.Struct({
  app_id: Schema.Union(Schema.String, Schema.String).pipe(T.HttpPath("app_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/access/apps/{app_id}" }),
).annotations({ identifier: "UpdateABookmarkApplicationRequest" }) as unknown as Schema.Schema<UpdateABookmarkApplicationRequest>;

export interface UpdateABookmarkApplicationResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateABookmarkApplicationResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateABookmarkApplicationResponse" }) as unknown as Schema.Schema<UpdateABookmarkApplicationResponse>;

export const updateABookmarkApplication: (
  input: UpdateABookmarkApplicationRequest
) => Effect.Effect<
  UpdateABookmarkApplicationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateABookmarkApplicationRequest,
  output: UpdateABookmarkApplicationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAnAccessApplicationRequest {
  app_id: unknown;
  zone_id: string;
}

export const DeleteAnAccessApplicationRequest = Schema.Struct({
  app_id: Schema.Union(Schema.String, Schema.String).pipe(T.HttpPath("app_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/access/apps/{app_id}" }),
).annotations({ identifier: "DeleteAnAccessApplicationRequest" }) as unknown as Schema.Schema<DeleteAnAccessApplicationRequest>;

export interface DeleteAnAccessApplicationResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAnAccessApplicationResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAnAccessApplicationResponse" }) as unknown as Schema.Schema<DeleteAnAccessApplicationResponse>;

export const deleteAnAccessApplication: (
  input: DeleteAnAccessApplicationRequest
) => Effect.Effect<
  DeleteAnAccessApplicationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAnAccessApplicationRequest,
  output: DeleteAnAccessApplicationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAShortLivedCertificateCaRequest {
  app_id: string;
  zone_id: string;
}

export const GetAShortLivedCertificateCaRequest = Schema.Struct({
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/apps/{app_id}/ca" }),
).annotations({ identifier: "GetAShortLivedCertificateCaRequest" }) as unknown as Schema.Schema<GetAShortLivedCertificateCaRequest>;

export interface GetAShortLivedCertificateCaResponse {
  result: { aud?: string; id?: string; public_key?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAShortLivedCertificateCaResponse = Schema.Struct({
  result: Schema.Struct({
  aud: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  public_key: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAShortLivedCertificateCaResponse" }) as unknown as Schema.Schema<GetAShortLivedCertificateCaResponse>;

export const getAShortLivedCertificateCa: (
  input: GetAShortLivedCertificateCaRequest
) => Effect.Effect<
  GetAShortLivedCertificateCaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAShortLivedCertificateCaRequest,
  output: GetAShortLivedCertificateCaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateAShortLivedCertificateCaRequest {
  app_id: string;
  zone_id: string;
}

export const CreateAShortLivedCertificateCaRequest = Schema.Struct({
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/access/apps/{app_id}/ca" }),
).annotations({ identifier: "CreateAShortLivedCertificateCaRequest" }) as unknown as Schema.Schema<CreateAShortLivedCertificateCaRequest>;

export interface CreateAShortLivedCertificateCaResponse {
  result: { aud?: string; id?: string; public_key?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateAShortLivedCertificateCaResponse = Schema.Struct({
  result: Schema.Struct({
  aud: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  public_key: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateAShortLivedCertificateCaResponse" }) as unknown as Schema.Schema<CreateAShortLivedCertificateCaResponse>;

export const createAShortLivedCertificateCa: (
  input: CreateAShortLivedCertificateCaRequest
) => Effect.Effect<
  CreateAShortLivedCertificateCaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAShortLivedCertificateCaRequest,
  output: CreateAShortLivedCertificateCaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAShortLivedCertificateCaRequest {
  app_id: string;
  zone_id: string;
}

export const DeleteAShortLivedCertificateCaRequest = Schema.Struct({
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/access/apps/{app_id}/ca" }),
).annotations({ identifier: "DeleteAShortLivedCertificateCaRequest" }) as unknown as Schema.Schema<DeleteAShortLivedCertificateCaRequest>;

export interface DeleteAShortLivedCertificateCaResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAShortLivedCertificateCaResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAShortLivedCertificateCaResponse" }) as unknown as Schema.Schema<DeleteAShortLivedCertificateCaResponse>;

export const deleteAShortLivedCertificateCa: (
  input: DeleteAShortLivedCertificateCaRequest
) => Effect.Effect<
  DeleteAShortLivedCertificateCaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAShortLivedCertificateCaRequest,
  output: DeleteAShortLivedCertificateCaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAccessPoliciesRequest {
  app_id: string;
  zone_id: string;
}

export const ListAccessPoliciesRequest = Schema.Struct({
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/apps/{app_id}/policies" }),
).annotations({ identifier: "ListAccessPoliciesRequest" }) as unknown as Schema.Schema<ListAccessPoliciesRequest>;

export interface ListAccessPoliciesResponse {
  result: { approval_groups?: { approvals_needed: number; email_addresses?: unknown[]; email_list_uuid?: string }[]; approval_required?: boolean; created_at?: string; decision?: "allow" | "deny" | "non_identity" | "bypass"; exclude?: Record<string, unknown>[]; id?: string; include?: Record<string, unknown>[]; isolation_required?: boolean; name?: string; precedence?: number; purpose_justification_prompt?: string; purpose_justification_required?: boolean; require?: Record<string, unknown>[]; updated_at?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAccessPoliciesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  approval_groups: Schema.optional(Schema.Array(Schema.Struct({
  approvals_needed: Schema.Number,
  email_addresses: Schema.optional(Schema.Array(Schema.Unknown)),
  email_list_uuid: Schema.optional(Schema.String)
}))),
  approval_required: Schema.optional(Schema.Boolean),
  created_at: Schema.optional(Schema.Date),
  decision: Schema.optional(Schema.Literal("allow", "deny", "non_identity", "bypass")),
  exclude: Schema.optional(Schema.Array(Schema.Struct({}))),
  id: Schema.optional(Schema.String),
  include: Schema.optional(Schema.Array(Schema.Struct({}))),
  isolation_required: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  precedence: Schema.optional(Schema.Number),
  purpose_justification_prompt: Schema.optional(Schema.String),
  purpose_justification_required: Schema.optional(Schema.Boolean),
  require: Schema.optional(Schema.Array(Schema.Struct({}))),
  updated_at: Schema.optional(Schema.Date)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAccessPoliciesResponse" }) as unknown as Schema.Schema<ListAccessPoliciesResponse>;

export const listAccessPolicies: (
  input: ListAccessPoliciesRequest
) => Effect.Effect<
  ListAccessPoliciesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessPoliciesRequest,
  output: ListAccessPoliciesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateAnAccessPolicyRequest {
  app_id: string;
  zone_id: string;
  body: unknown;
}

export const CreateAnAccessPolicyRequest = Schema.Struct({
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/access/apps/{app_id}/policies" }),
).annotations({ identifier: "CreateAnAccessPolicyRequest" }) as unknown as Schema.Schema<CreateAnAccessPolicyRequest>;

export interface CreateAnAccessPolicyResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateAnAccessPolicyResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateAnAccessPolicyResponse" }) as unknown as Schema.Schema<CreateAnAccessPolicyResponse>;

export const createAnAccessPolicy: (
  input: CreateAnAccessPolicyRequest
) => Effect.Effect<
  CreateAnAccessPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAnAccessPolicyRequest,
  output: CreateAnAccessPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAnAccessPolicyRequest {
  policy_id: string;
  app_id: string;
  zone_id: string;
}

export const GetAnAccessPolicyRequest = Schema.Struct({
  policy_id: Schema.String.pipe(T.HttpPath("policy_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/apps/{app_id}/policies/{policy_id}" }),
).annotations({ identifier: "GetAnAccessPolicyRequest" }) as unknown as Schema.Schema<GetAnAccessPolicyRequest>;

export interface GetAnAccessPolicyResponse {
  result: { approval_groups?: { approvals_needed: number; email_addresses?: unknown[]; email_list_uuid?: string }[]; approval_required?: boolean; created_at?: string; decision?: "allow" | "deny" | "non_identity" | "bypass"; exclude?: Record<string, unknown>[]; id?: string; include?: Record<string, unknown>[]; isolation_required?: boolean; name?: string; precedence?: number; purpose_justification_prompt?: string; purpose_justification_required?: boolean; require?: Record<string, unknown>[]; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAnAccessPolicyResponse = Schema.Struct({
  result: Schema.Struct({
  approval_groups: Schema.optional(Schema.Array(Schema.Struct({
  approvals_needed: Schema.Number,
  email_addresses: Schema.optional(Schema.Array(Schema.Unknown)),
  email_list_uuid: Schema.optional(Schema.String)
}))),
  approval_required: Schema.optional(Schema.Boolean),
  created_at: Schema.optional(Schema.Date),
  decision: Schema.optional(Schema.Literal("allow", "deny", "non_identity", "bypass")),
  exclude: Schema.optional(Schema.Array(Schema.Struct({}))),
  id: Schema.optional(Schema.String),
  include: Schema.optional(Schema.Array(Schema.Struct({}))),
  isolation_required: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  precedence: Schema.optional(Schema.Number),
  purpose_justification_prompt: Schema.optional(Schema.String),
  purpose_justification_required: Schema.optional(Schema.Boolean),
  require: Schema.optional(Schema.Array(Schema.Struct({}))),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAnAccessPolicyResponse" }) as unknown as Schema.Schema<GetAnAccessPolicyResponse>;

export const getAnAccessPolicy: (
  input: GetAnAccessPolicyRequest
) => Effect.Effect<
  GetAnAccessPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAnAccessPolicyRequest,
  output: GetAnAccessPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAnAccessPolicyRequest {
  policy_id: string;
  app_id: string;
  zone_id: string;
  body: unknown;
}

export const UpdateAnAccessPolicyRequest = Schema.Struct({
  policy_id: Schema.String.pipe(T.HttpPath("policy_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/access/apps/{app_id}/policies/{policy_id}" }),
).annotations({ identifier: "UpdateAnAccessPolicyRequest" }) as unknown as Schema.Schema<UpdateAnAccessPolicyRequest>;

export interface UpdateAnAccessPolicyResponse {
  result: { approval_groups?: { approvals_needed: number; email_addresses?: unknown[]; email_list_uuid?: string }[]; approval_required?: boolean; created_at?: string; decision?: "allow" | "deny" | "non_identity" | "bypass"; exclude?: Record<string, unknown>[]; id?: string; include?: Record<string, unknown>[]; isolation_required?: boolean; name?: string; precedence?: number; purpose_justification_prompt?: string; purpose_justification_required?: boolean; require?: Record<string, unknown>[]; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAnAccessPolicyResponse = Schema.Struct({
  result: Schema.Struct({
  approval_groups: Schema.optional(Schema.Array(Schema.Struct({
  approvals_needed: Schema.Number,
  email_addresses: Schema.optional(Schema.Array(Schema.Unknown)),
  email_list_uuid: Schema.optional(Schema.String)
}))),
  approval_required: Schema.optional(Schema.Boolean),
  created_at: Schema.optional(Schema.Date),
  decision: Schema.optional(Schema.Literal("allow", "deny", "non_identity", "bypass")),
  exclude: Schema.optional(Schema.Array(Schema.Struct({}))),
  id: Schema.optional(Schema.String),
  include: Schema.optional(Schema.Array(Schema.Struct({}))),
  isolation_required: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  precedence: Schema.optional(Schema.Number),
  purpose_justification_prompt: Schema.optional(Schema.String),
  purpose_justification_required: Schema.optional(Schema.Boolean),
  require: Schema.optional(Schema.Array(Schema.Struct({}))),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAnAccessPolicyResponse" }) as unknown as Schema.Schema<UpdateAnAccessPolicyResponse>;

export const updateAnAccessPolicy: (
  input: UpdateAnAccessPolicyRequest
) => Effect.Effect<
  UpdateAnAccessPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAnAccessPolicyRequest,
  output: UpdateAnAccessPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAnAccessPolicyRequest {
  policy_id: string;
  app_id: string;
  zone_id: string;
}

export const DeleteAnAccessPolicyRequest = Schema.Struct({
  policy_id: Schema.String.pipe(T.HttpPath("policy_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/access/apps/{app_id}/policies/{policy_id}" }),
).annotations({ identifier: "DeleteAnAccessPolicyRequest" }) as unknown as Schema.Schema<DeleteAnAccessPolicyRequest>;

export interface DeleteAnAccessPolicyResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAnAccessPolicyResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAnAccessPolicyResponse" }) as unknown as Schema.Schema<DeleteAnAccessPolicyResponse>;

export const deleteAnAccessPolicy: (
  input: DeleteAnAccessPolicyRequest
) => Effect.Effect<
  DeleteAnAccessPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAnAccessPolicyRequest,
  output: DeleteAnAccessPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneLevelAccessApplicationsRevokeServiceTokensRequest {
  app_id: unknown;
  zone_id: string;
}

export const ZoneLevelAccessApplicationsRevokeServiceTokensRequest = Schema.Struct({
  app_id: Schema.Union(Schema.String, Schema.String).pipe(T.HttpPath("app_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/access/apps/{app_id}/revoke_tokens" }),
).annotations({ identifier: "ZoneLevelAccessApplicationsRevokeServiceTokensRequest" }) as unknown as Schema.Schema<ZoneLevelAccessApplicationsRevokeServiceTokensRequest>;

export interface ZoneLevelAccessApplicationsRevokeServiceTokensResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneLevelAccessApplicationsRevokeServiceTokensResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneLevelAccessApplicationsRevokeServiceTokensResponse" }) as unknown as Schema.Schema<ZoneLevelAccessApplicationsRevokeServiceTokensResponse>;

export const zoneLevelAccessApplicationsRevokeServiceTokens: (
  input: ZoneLevelAccessApplicationsRevokeServiceTokensRequest
) => Effect.Effect<
  ZoneLevelAccessApplicationsRevokeServiceTokensResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneLevelAccessApplicationsRevokeServiceTokensRequest,
  output: ZoneLevelAccessApplicationsRevokeServiceTokensResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAccessApplicationSettingsRequest {
  app_id: unknown;
  zone_id: string;
  body: { allow_iframe?: boolean; skip_interstitial?: boolean };
}

export const UpdateAccessApplicationSettingsRequest = Schema.Struct({
  app_id: Schema.Union(Schema.String, Schema.String).pipe(T.HttpPath("app_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  allow_iframe: Schema.optional(Schema.Boolean),
  skip_interstitial: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/access/apps/{app_id}/settings" }),
).annotations({ identifier: "UpdateAccessApplicationSettingsRequest" }) as unknown as Schema.Schema<UpdateAccessApplicationSettingsRequest>;

export interface UpdateAccessApplicationSettingsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAccessApplicationSettingsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAccessApplicationSettingsResponse" }) as unknown as Schema.Schema<UpdateAccessApplicationSettingsResponse>;

export const updateAccessApplicationSettings: (
  input: UpdateAccessApplicationSettingsRequest
) => Effect.Effect<
  UpdateAccessApplicationSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccessApplicationSettingsRequest,
  output: UpdateAccessApplicationSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAccessApplicationSettings1Request {
  app_id: unknown;
  zone_id: string;
  body: { allow_iframe?: boolean; skip_interstitial?: boolean };
}

export const UpdateAccessApplicationSettings1Request = Schema.Struct({
  app_id: Schema.Union(Schema.String, Schema.String).pipe(T.HttpPath("app_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  allow_iframe: Schema.optional(Schema.Boolean),
  skip_interstitial: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/access/apps/{app_id}/settings" }),
).annotations({ identifier: "UpdateAccessApplicationSettings1Request" }) as unknown as Schema.Schema<UpdateAccessApplicationSettings1Request>;

export interface UpdateAccessApplicationSettings1Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAccessApplicationSettings1Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAccessApplicationSettings1Response" }) as unknown as Schema.Schema<UpdateAccessApplicationSettings1Response>;

export const updateAccessApplicationSettings1: (
  input: UpdateAccessApplicationSettings1Request
) => Effect.Effect<
  UpdateAccessApplicationSettings1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccessApplicationSettings1Request,
  output: UpdateAccessApplicationSettings1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneLevelAccessApplicationsTestAccessPoliciesRequest {
  app_id: unknown;
  zone_id: string;
}

export const ZoneLevelAccessApplicationsTestAccessPoliciesRequest = Schema.Struct({
  app_id: Schema.Union(Schema.String, Schema.String).pipe(T.HttpPath("app_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/apps/{app_id}/user_policy_checks" }),
).annotations({ identifier: "ZoneLevelAccessApplicationsTestAccessPoliciesRequest" }) as unknown as Schema.Schema<ZoneLevelAccessApplicationsTestAccessPoliciesRequest>;

export interface ZoneLevelAccessApplicationsTestAccessPoliciesResponse {
  result: { app_state?: { app_uid?: string; aud?: string; hostname?: string; name?: string; policies?: unknown[]; status?: string }; user_identity?: { account_id?: string; device_sessions?: Record<string, unknown>; email?: string; geo?: { country?: string }; iat?: number; id?: string; is_gateway?: boolean; is_warp?: boolean; name?: string; user_uuid?: string; version?: number } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneLevelAccessApplicationsTestAccessPoliciesResponse = Schema.Struct({
  result: Schema.Struct({
  app_state: Schema.optional(Schema.Struct({
  app_uid: Schema.optional(Schema.String),
  aud: Schema.optional(Schema.String),
  hostname: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  policies: Schema.optional(Schema.Array(Schema.Unknown)),
  status: Schema.optional(Schema.String)
})),
  user_identity: Schema.optional(Schema.Struct({
  account_id: Schema.optional(Schema.String),
  device_sessions: Schema.optional(Schema.Struct({})),
  email: Schema.optional(Schema.String),
  geo: Schema.optional(Schema.Struct({
  country: Schema.optional(Schema.String)
})),
  iat: Schema.optional(Schema.Number),
  id: Schema.optional(Schema.String),
  is_gateway: Schema.optional(Schema.Boolean),
  is_warp: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  user_uuid: Schema.optional(Schema.String),
  version: Schema.optional(Schema.Number)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneLevelAccessApplicationsTestAccessPoliciesResponse" }) as unknown as Schema.Schema<ZoneLevelAccessApplicationsTestAccessPoliciesResponse>;

export const zoneLevelAccessApplicationsTestAccessPolicies: (
  input: ZoneLevelAccessApplicationsTestAccessPoliciesRequest
) => Effect.Effect<
  ZoneLevelAccessApplicationsTestAccessPoliciesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneLevelAccessApplicationsTestAccessPoliciesRequest,
  output: ZoneLevelAccessApplicationsTestAccessPoliciesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListMtlsCertificatesRequest {
  zone_id: string;
}

export const ListMtlsCertificatesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/certificates" }),
).annotations({ identifier: "ListMtlsCertificatesRequest" }) as unknown as Schema.Schema<ListMtlsCertificatesRequest>;

export interface ListMtlsCertificatesResponse {
  result: { associated_hostnames?: string[]; created_at?: string; expires_on?: string; fingerprint?: string; id?: unknown; name?: string; updated_at?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListMtlsCertificatesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  associated_hostnames: Schema.optional(Schema.Array(Schema.String)),
  created_at: Schema.optional(Schema.Date),
  expires_on: Schema.optional(Schema.Date),
  fingerprint: Schema.optional(Schema.String),
  id: Schema.optional(Schema.Unknown),
  name: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListMtlsCertificatesResponse" }) as unknown as Schema.Schema<ListMtlsCertificatesResponse>;

export const listMtlsCertificates: (
  input: ListMtlsCertificatesRequest
) => Effect.Effect<
  ListMtlsCertificatesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListMtlsCertificatesRequest,
  output: ListMtlsCertificatesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateRequest {
  zone_id: string;
  body: unknown;
}

export const ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/access/certificates" }),
).annotations({ identifier: "ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateRequest" }) as unknown as Schema.Schema<ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateRequest>;

export interface ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateResponse" }) as unknown as Schema.Schema<ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateResponse>;

export const zoneLevelAccessMtlsAuthenticationAddAnMtlsCertificate: (
  input: ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateRequest
) => Effect.Effect<
  ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateRequest,
  output: ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListMtlsCertificatesHostnameSettingsRequest {
  zone_id: string;
}

export const ListMtlsCertificatesHostnameSettingsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/certificates/settings" }),
).annotations({ identifier: "ListMtlsCertificatesHostnameSettingsRequest" }) as unknown as Schema.Schema<ListMtlsCertificatesHostnameSettingsRequest>;

export interface ListMtlsCertificatesHostnameSettingsResponse {
  result: { china_network: boolean; client_certificate_forwarding: boolean; hostname: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListMtlsCertificatesHostnameSettingsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  china_network: Schema.Boolean,
  client_certificate_forwarding: Schema.Boolean,
  hostname: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListMtlsCertificatesHostnameSettingsResponse" }) as unknown as Schema.Schema<ListMtlsCertificatesHostnameSettingsResponse>;

export const listMtlsCertificatesHostnameSettings: (
  input: ListMtlsCertificatesHostnameSettingsRequest
) => Effect.Effect<
  ListMtlsCertificatesHostnameSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListMtlsCertificatesHostnameSettingsRequest,
  output: ListMtlsCertificatesHostnameSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAnMtlsCertificateSettingsRequest {
  zone_id: string;
  body: { settings: { china_network: boolean; client_certificate_forwarding: boolean; hostname: string }[] };
}

export const UpdateAnMtlsCertificateSettingsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  settings: Schema.Array(Schema.Struct({
  china_network: Schema.Boolean,
  client_certificate_forwarding: Schema.Boolean,
  hostname: Schema.String
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/access/certificates/settings" }),
).annotations({ identifier: "UpdateAnMtlsCertificateSettingsRequest" }) as unknown as Schema.Schema<UpdateAnMtlsCertificateSettingsRequest>;

export interface UpdateAnMtlsCertificateSettingsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAnMtlsCertificateSettingsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAnMtlsCertificateSettingsResponse" }) as unknown as Schema.Schema<UpdateAnMtlsCertificateSettingsResponse>;

export const updateAnMtlsCertificateSettings: (
  input: UpdateAnMtlsCertificateSettingsRequest
) => Effect.Effect<
  UpdateAnMtlsCertificateSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAnMtlsCertificateSettingsRequest,
  output: UpdateAnMtlsCertificateSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAnMtlsCertificateRequest {
  certificate_id: string;
  zone_id: string;
}

export const GetAnMtlsCertificateRequest = Schema.Struct({
  certificate_id: Schema.String.pipe(T.HttpPath("certificate_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/certificates/{certificate_id}" }),
).annotations({ identifier: "GetAnMtlsCertificateRequest" }) as unknown as Schema.Schema<GetAnMtlsCertificateRequest>;

export interface GetAnMtlsCertificateResponse {
  result: { associated_hostnames?: string[]; created_at?: string; expires_on?: string; fingerprint?: string; id?: unknown; name?: string; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAnMtlsCertificateResponse = Schema.Struct({
  result: Schema.Struct({
  associated_hostnames: Schema.optional(Schema.Array(Schema.String)),
  created_at: Schema.optional(Schema.Date),
  expires_on: Schema.optional(Schema.Date),
  fingerprint: Schema.optional(Schema.String),
  id: Schema.optional(Schema.Unknown),
  name: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAnMtlsCertificateResponse" }) as unknown as Schema.Schema<GetAnMtlsCertificateResponse>;

export const getAnMtlsCertificate: (
  input: GetAnMtlsCertificateRequest
) => Effect.Effect<
  GetAnMtlsCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAnMtlsCertificateRequest,
  output: GetAnMtlsCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAnMtlsCertificateRequest {
  certificate_id: string;
  zone_id: string;
  body: unknown;
}

export const UpdateAnMtlsCertificateRequest = Schema.Struct({
  certificate_id: Schema.String.pipe(T.HttpPath("certificate_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/access/certificates/{certificate_id}" }),
).annotations({ identifier: "UpdateAnMtlsCertificateRequest" }) as unknown as Schema.Schema<UpdateAnMtlsCertificateRequest>;

export interface UpdateAnMtlsCertificateResponse {
  result: { associated_hostnames?: string[]; created_at?: string; expires_on?: string; fingerprint?: string; id?: unknown; name?: string; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAnMtlsCertificateResponse = Schema.Struct({
  result: Schema.Struct({
  associated_hostnames: Schema.optional(Schema.Array(Schema.String)),
  created_at: Schema.optional(Schema.Date),
  expires_on: Schema.optional(Schema.Date),
  fingerprint: Schema.optional(Schema.String),
  id: Schema.optional(Schema.Unknown),
  name: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAnMtlsCertificateResponse" }) as unknown as Schema.Schema<UpdateAnMtlsCertificateResponse>;

export const updateAnMtlsCertificate: (
  input: UpdateAnMtlsCertificateRequest
) => Effect.Effect<
  UpdateAnMtlsCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAnMtlsCertificateRequest,
  output: UpdateAnMtlsCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAnMtlsCertificateRequest {
  certificate_id: string;
  zone_id: string;
}

export const DeleteAnMtlsCertificateRequest = Schema.Struct({
  certificate_id: Schema.String.pipe(T.HttpPath("certificate_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/access/certificates/{certificate_id}" }),
).annotations({ identifier: "DeleteAnMtlsCertificateRequest" }) as unknown as Schema.Schema<DeleteAnMtlsCertificateRequest>;

export interface DeleteAnMtlsCertificateResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAnMtlsCertificateResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAnMtlsCertificateResponse" }) as unknown as Schema.Schema<DeleteAnMtlsCertificateResponse>;

export const deleteAnMtlsCertificate: (
  input: DeleteAnMtlsCertificateRequest
) => Effect.Effect<
  DeleteAnMtlsCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAnMtlsCertificateRequest,
  output: DeleteAnMtlsCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAccessGroupsRequest {
  zone_id: string;
}

export const ListAccessGroupsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/groups" }),
).annotations({ identifier: "ListAccessGroupsRequest" }) as unknown as Schema.Schema<ListAccessGroupsRequest>;

export interface ListAccessGroupsResponse {
  result: { created_at?: string; exclude?: Record<string, unknown>[]; id?: string; include?: Record<string, unknown>[]; name?: string; require?: Record<string, unknown>[]; updated_at?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAccessGroupsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  exclude: Schema.optional(Schema.Array(Schema.Struct({}))),
  id: Schema.optional(Schema.String),
  include: Schema.optional(Schema.Array(Schema.Struct({}))),
  name: Schema.optional(Schema.String),
  require: Schema.optional(Schema.Array(Schema.Struct({}))),
  updated_at: Schema.optional(Schema.Date)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAccessGroupsResponse" }) as unknown as Schema.Schema<ListAccessGroupsResponse>;

export const listAccessGroups: (
  input: ListAccessGroupsRequest
) => Effect.Effect<
  ListAccessGroupsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessGroupsRequest,
  output: ListAccessGroupsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateAnAccessGroupRequest {
  zone_id: string;
  body: unknown;
}

export const CreateAnAccessGroupRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/access/groups" }),
).annotations({ identifier: "CreateAnAccessGroupRequest" }) as unknown as Schema.Schema<CreateAnAccessGroupRequest>;

export interface CreateAnAccessGroupResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateAnAccessGroupResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateAnAccessGroupResponse" }) as unknown as Schema.Schema<CreateAnAccessGroupResponse>;

export const createAnAccessGroup: (
  input: CreateAnAccessGroupRequest
) => Effect.Effect<
  CreateAnAccessGroupResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAnAccessGroupRequest,
  output: CreateAnAccessGroupResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAnAccessGroupRequest {
  group_id: string;
  zone_id: string;
}

export const GetAnAccessGroupRequest = Schema.Struct({
  group_id: Schema.String.pipe(T.HttpPath("group_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/groups/{group_id}" }),
).annotations({ identifier: "GetAnAccessGroupRequest" }) as unknown as Schema.Schema<GetAnAccessGroupRequest>;

export interface GetAnAccessGroupResponse {
  result: { created_at?: string; exclude?: Record<string, unknown>[]; id?: string; include?: Record<string, unknown>[]; name?: string; require?: Record<string, unknown>[]; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAnAccessGroupResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  exclude: Schema.optional(Schema.Array(Schema.Struct({}))),
  id: Schema.optional(Schema.String),
  include: Schema.optional(Schema.Array(Schema.Struct({}))),
  name: Schema.optional(Schema.String),
  require: Schema.optional(Schema.Array(Schema.Struct({}))),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAnAccessGroupResponse" }) as unknown as Schema.Schema<GetAnAccessGroupResponse>;

export const getAnAccessGroup: (
  input: GetAnAccessGroupRequest
) => Effect.Effect<
  GetAnAccessGroupResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAnAccessGroupRequest,
  output: GetAnAccessGroupResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAnAccessGroupRequest {
  group_id: string;
  zone_id: string;
  body: unknown;
}

export const UpdateAnAccessGroupRequest = Schema.Struct({
  group_id: Schema.String.pipe(T.HttpPath("group_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/access/groups/{group_id}" }),
).annotations({ identifier: "UpdateAnAccessGroupRequest" }) as unknown as Schema.Schema<UpdateAnAccessGroupRequest>;

export interface UpdateAnAccessGroupResponse {
  result: { created_at?: string; exclude?: Record<string, unknown>[]; id?: string; include?: Record<string, unknown>[]; name?: string; require?: Record<string, unknown>[]; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAnAccessGroupResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  exclude: Schema.optional(Schema.Array(Schema.Struct({}))),
  id: Schema.optional(Schema.String),
  include: Schema.optional(Schema.Array(Schema.Struct({}))),
  name: Schema.optional(Schema.String),
  require: Schema.optional(Schema.Array(Schema.Struct({}))),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAnAccessGroupResponse" }) as unknown as Schema.Schema<UpdateAnAccessGroupResponse>;

export const updateAnAccessGroup: (
  input: UpdateAnAccessGroupRequest
) => Effect.Effect<
  UpdateAnAccessGroupResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAnAccessGroupRequest,
  output: UpdateAnAccessGroupResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAnAccessGroupRequest {
  group_id: string;
  zone_id: string;
}

export const DeleteAnAccessGroupRequest = Schema.Struct({
  group_id: Schema.String.pipe(T.HttpPath("group_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/access/groups/{group_id}" }),
).annotations({ identifier: "DeleteAnAccessGroupRequest" }) as unknown as Schema.Schema<DeleteAnAccessGroupRequest>;

export interface DeleteAnAccessGroupResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAnAccessGroupResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAnAccessGroupResponse" }) as unknown as Schema.Schema<DeleteAnAccessGroupResponse>;

export const deleteAnAccessGroup: (
  input: DeleteAnAccessGroupRequest
) => Effect.Effect<
  DeleteAnAccessGroupResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAnAccessGroupRequest,
  output: DeleteAnAccessGroupResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAccessIdentityProvidersRequest {
  zone_id: string;
}

export const ListAccessIdentityProvidersRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/identity_providers" }),
).annotations({ identifier: "ListAccessIdentityProvidersRequest" }) as unknown as Schema.Schema<ListAccessIdentityProvidersRequest>;

export interface ListAccessIdentityProvidersResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAccessIdentityProvidersResponse = Schema.Struct({
  result: Schema.Array(Schema.Union(Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAccessIdentityProvidersResponse" }) as unknown as Schema.Schema<ListAccessIdentityProvidersResponse>;

export const listAccessIdentityProviders: (
  input: ListAccessIdentityProvidersRequest
) => Effect.Effect<
  ListAccessIdentityProvidersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessIdentityProvidersRequest,
  output: ListAccessIdentityProvidersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderRequest {
  zone_id: string;
  body: unknown;
}

export const ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Union(Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/access/identity_providers" }),
).annotations({ identifier: "ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderRequest" }) as unknown as Schema.Schema<ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderRequest>;

export interface ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderResponse" }) as unknown as Schema.Schema<ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderResponse>;

export const zoneLevelAccessIdentityProvidersAddAnAccessIdentityProvider: (
  input: ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderRequest
) => Effect.Effect<
  ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderRequest,
  output: ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAnAccessIdentityProviderRequest {
  identity_provider_id: string;
  zone_id: string;
}

export const GetAnAccessIdentityProviderRequest = Schema.Struct({
  identity_provider_id: Schema.String.pipe(T.HttpPath("identity_provider_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/identity_providers/{identity_provider_id}" }),
).annotations({ identifier: "GetAnAccessIdentityProviderRequest" }) as unknown as Schema.Schema<GetAnAccessIdentityProviderRequest>;

export interface GetAnAccessIdentityProviderResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAnAccessIdentityProviderResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAnAccessIdentityProviderResponse" }) as unknown as Schema.Schema<GetAnAccessIdentityProviderResponse>;

export const getAnAccessIdentityProvider: (
  input: GetAnAccessIdentityProviderRequest
) => Effect.Effect<
  GetAnAccessIdentityProviderResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAnAccessIdentityProviderRequest,
  output: GetAnAccessIdentityProviderResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAnAccessIdentityProviderRequest {
  identity_provider_id: string;
  zone_id: string;
  body: unknown;
}

export const UpdateAnAccessIdentityProviderRequest = Schema.Struct({
  identity_provider_id: Schema.String.pipe(T.HttpPath("identity_provider_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Union(Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/access/identity_providers/{identity_provider_id}" }),
).annotations({ identifier: "UpdateAnAccessIdentityProviderRequest" }) as unknown as Schema.Schema<UpdateAnAccessIdentityProviderRequest>;

export interface UpdateAnAccessIdentityProviderResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAnAccessIdentityProviderResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAnAccessIdentityProviderResponse" }) as unknown as Schema.Schema<UpdateAnAccessIdentityProviderResponse>;

export const updateAnAccessIdentityProvider: (
  input: UpdateAnAccessIdentityProviderRequest
) => Effect.Effect<
  UpdateAnAccessIdentityProviderResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAnAccessIdentityProviderRequest,
  output: UpdateAnAccessIdentityProviderResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAnAccessIdentityProviderRequest {
  identity_provider_id: string;
  zone_id: string;
}

export const DeleteAnAccessIdentityProviderRequest = Schema.Struct({
  identity_provider_id: Schema.String.pipe(T.HttpPath("identity_provider_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/access/identity_providers/{identity_provider_id}" }),
).annotations({ identifier: "DeleteAnAccessIdentityProviderRequest" }) as unknown as Schema.Schema<DeleteAnAccessIdentityProviderRequest>;

export interface DeleteAnAccessIdentityProviderResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAnAccessIdentityProviderResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAnAccessIdentityProviderResponse" }) as unknown as Schema.Schema<DeleteAnAccessIdentityProviderResponse>;

export const deleteAnAccessIdentityProvider: (
  input: DeleteAnAccessIdentityProviderRequest
) => Effect.Effect<
  DeleteAnAccessIdentityProviderResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAnAccessIdentityProviderRequest,
  output: DeleteAnAccessIdentityProviderResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetYourZeroTrustOrganizationRequest {
  zone_id: unknown;
}

export const GetYourZeroTrustOrganizationRequest = Schema.Struct({
  zone_id: Schema.Unknown.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/organizations" }),
).annotations({ identifier: "GetYourZeroTrustOrganizationRequest" }) as unknown as Schema.Schema<GetYourZeroTrustOrganizationRequest>;

export interface GetYourZeroTrustOrganizationResponse {
  result: { auth_domain?: string; created_at?: string; is_ui_read_only?: boolean; login_design?: unknown; name?: string; ui_read_only_toggle_reason?: string; updated_at?: string; user_seat_expiration_inactive_time?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetYourZeroTrustOrganizationResponse = Schema.Struct({
  result: Schema.Struct({
  auth_domain: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  is_ui_read_only: Schema.optional(Schema.Boolean),
  login_design: Schema.optional(Schema.Unknown),
  name: Schema.optional(Schema.String),
  ui_read_only_toggle_reason: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date),
  user_seat_expiration_inactive_time: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetYourZeroTrustOrganizationResponse" }) as unknown as Schema.Schema<GetYourZeroTrustOrganizationResponse>;

export const getYourZeroTrustOrganization: (
  input: GetYourZeroTrustOrganizationRequest
) => Effect.Effect<
  GetYourZeroTrustOrganizationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetYourZeroTrustOrganizationRequest,
  output: GetYourZeroTrustOrganizationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateYourZeroTrustOrganizationRequest {
  zone_id: unknown;
  body: unknown;
}

export const CreateYourZeroTrustOrganizationRequest = Schema.Struct({
  zone_id: Schema.Unknown.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/access/organizations" }),
).annotations({ identifier: "CreateYourZeroTrustOrganizationRequest" }) as unknown as Schema.Schema<CreateYourZeroTrustOrganizationRequest>;

export interface CreateYourZeroTrustOrganizationResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateYourZeroTrustOrganizationResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateYourZeroTrustOrganizationResponse" }) as unknown as Schema.Schema<CreateYourZeroTrustOrganizationResponse>;

export const createYourZeroTrustOrganization: (
  input: CreateYourZeroTrustOrganizationRequest
) => Effect.Effect<
  CreateYourZeroTrustOrganizationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateYourZeroTrustOrganizationRequest,
  output: CreateYourZeroTrustOrganizationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateYourZeroTrustOrganizationRequest {
  zone_id: unknown;
  body: unknown;
}

export const UpdateYourZeroTrustOrganizationRequest = Schema.Struct({
  zone_id: Schema.Unknown.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/access/organizations" }),
).annotations({ identifier: "UpdateYourZeroTrustOrganizationRequest" }) as unknown as Schema.Schema<UpdateYourZeroTrustOrganizationRequest>;

export interface UpdateYourZeroTrustOrganizationResponse {
  result: { auth_domain?: string; created_at?: string; is_ui_read_only?: boolean; login_design?: unknown; name?: string; ui_read_only_toggle_reason?: string; updated_at?: string; user_seat_expiration_inactive_time?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateYourZeroTrustOrganizationResponse = Schema.Struct({
  result: Schema.Struct({
  auth_domain: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  is_ui_read_only: Schema.optional(Schema.Boolean),
  login_design: Schema.optional(Schema.Unknown),
  name: Schema.optional(Schema.String),
  ui_read_only_toggle_reason: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date),
  user_seat_expiration_inactive_time: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateYourZeroTrustOrganizationResponse" }) as unknown as Schema.Schema<UpdateYourZeroTrustOrganizationResponse>;

export const updateYourZeroTrustOrganization: (
  input: UpdateYourZeroTrustOrganizationRequest
) => Effect.Effect<
  UpdateYourZeroTrustOrganizationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateYourZeroTrustOrganizationRequest,
  output: UpdateYourZeroTrustOrganizationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserRequest {
  zone_id: unknown;
  body: unknown;
}

export const ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserRequest = Schema.Struct({
  zone_id: Schema.Unknown.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/access/organizations/revoke_user" }),
).annotations({ identifier: "ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserRequest" }) as unknown as Schema.Schema<ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserRequest>;

export interface ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserResponse {
  result: true | false;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserResponse = Schema.Struct({
  result: Schema.Literal(true, false),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserResponse" }) as unknown as Schema.Schema<ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserResponse>;

export const zoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUser: (
  input: ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserRequest
) => Effect.Effect<
  ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserRequest,
  output: ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListServiceTokensRequest {
  zone_id: string;
}

export const ListServiceTokensRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/service_tokens" }),
).annotations({ identifier: "ListServiceTokensRequest" }) as unknown as Schema.Schema<ListServiceTokensRequest>;

export interface ListServiceTokensResponse {
  result: { client_id?: string; created_at?: string; duration?: string; expires_at?: string; id?: unknown; last_seen_at?: string; name?: string; updated_at?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListServiceTokensResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  client_id: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  duration: Schema.optional(Schema.String),
  expires_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.Unknown),
  last_seen_at: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListServiceTokensResponse" }) as unknown as Schema.Schema<ListServiceTokensResponse>;

export const listServiceTokens: (
  input: ListServiceTokensRequest
) => Effect.Effect<
  ListServiceTokensResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListServiceTokensRequest,
  output: ListServiceTokensResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateAServiceTokenRequest {
  zone_id: string;
  body: unknown;
}

export const CreateAServiceTokenRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/access/service_tokens" }),
).annotations({ identifier: "CreateAServiceTokenRequest" }) as unknown as Schema.Schema<CreateAServiceTokenRequest>;

export interface CreateAServiceTokenResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateAServiceTokenResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateAServiceTokenResponse" }) as unknown as Schema.Schema<CreateAServiceTokenResponse>;

export const createAServiceToken: (
  input: CreateAServiceTokenRequest
) => Effect.Effect<
  CreateAServiceTokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAServiceTokenRequest,
  output: CreateAServiceTokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAServiceTokenRequest {
  service_token_id: string;
  zone_id: string;
}

export const GetAServiceTokenRequest = Schema.Struct({
  service_token_id: Schema.String.pipe(T.HttpPath("service_token_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/access/service_tokens/{service_token_id}" }),
).annotations({ identifier: "GetAServiceTokenRequest" }) as unknown as Schema.Schema<GetAServiceTokenRequest>;

export interface GetAServiceTokenResponse {
  result: { client_id?: string; created_at?: string; duration?: string; expires_at?: string; id?: unknown; last_seen_at?: string; name?: string; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAServiceTokenResponse = Schema.Struct({
  result: Schema.Struct({
  client_id: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  duration: Schema.optional(Schema.String),
  expires_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.Unknown),
  last_seen_at: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAServiceTokenResponse" }) as unknown as Schema.Schema<GetAServiceTokenResponse>;

export const getAServiceToken: (
  input: GetAServiceTokenRequest
) => Effect.Effect<
  GetAServiceTokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAServiceTokenRequest,
  output: GetAServiceTokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAServiceTokenRequest {
  service_token_id: string;
  zone_id: string;
  body: unknown;
}

export const UpdateAServiceTokenRequest = Schema.Struct({
  service_token_id: Schema.String.pipe(T.HttpPath("service_token_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/access/service_tokens/{service_token_id}" }),
).annotations({ identifier: "UpdateAServiceTokenRequest" }) as unknown as Schema.Schema<UpdateAServiceTokenRequest>;

export interface UpdateAServiceTokenResponse {
  result: { client_id?: string; created_at?: string; duration?: string; expires_at?: string; id?: unknown; last_seen_at?: string; name?: string; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAServiceTokenResponse = Schema.Struct({
  result: Schema.Struct({
  client_id: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  duration: Schema.optional(Schema.String),
  expires_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.Unknown),
  last_seen_at: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAServiceTokenResponse" }) as unknown as Schema.Schema<UpdateAServiceTokenResponse>;

export const updateAServiceToken: (
  input: UpdateAServiceTokenRequest
) => Effect.Effect<
  UpdateAServiceTokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAServiceTokenRequest,
  output: UpdateAServiceTokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAServiceTokenRequest {
  service_token_id: string;
  zone_id: string;
}

export const DeleteAServiceTokenRequest = Schema.Struct({
  service_token_id: Schema.String.pipe(T.HttpPath("service_token_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/access/service_tokens/{service_token_id}" }),
).annotations({ identifier: "DeleteAServiceTokenRequest" }) as unknown as Schema.Schema<DeleteAServiceTokenRequest>;

export interface DeleteAServiceTokenResponse {
  result: { client_id?: string; created_at?: string; duration?: string; expires_at?: string; id?: unknown; last_seen_at?: string; name?: string; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAServiceTokenResponse = Schema.Struct({
  result: Schema.Struct({
  client_id: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  duration: Schema.optional(Schema.String),
  expires_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.Unknown),
  last_seen_at: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAServiceTokenResponse" }) as unknown as Schema.Schema<DeleteAServiceTokenResponse>;

export const deleteAServiceToken: (
  input: DeleteAServiceTokenRequest
) => Effect.Effect<
  DeleteAServiceTokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAServiceTokenRequest,
  output: DeleteAServiceTokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDetailsRequest {
  zone_id: string;
  page?: number;
  per_page?: number;
  limit?: number;
  offset?: number;
}

export const ListDetailsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/acm/custom_trust_store" }),
).annotations({ identifier: "ListDetailsRequest" }) as unknown as Schema.Schema<ListDetailsRequest>;

export interface ListDetailsResponse {
  result: { certificate: string; expires_on: string; id: string; issuer: string; signature: string; status: "initializing" | "pending_deployment" | "active" | "pending_deletion" | "deleted" | "expired"; updated_at: string; uploaded_on: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDetailsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  certificate: Schema.String,
  expires_on: Schema.Date,
  id: Schema.String,
  issuer: Schema.String,
  signature: Schema.String,
  status: Schema.Literal("initializing", "pending_deployment", "active", "pending_deletion", "deleted", "expired"),
  updated_at: Schema.Date,
  uploaded_on: Schema.Date
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDetailsResponse" }) as unknown as Schema.Schema<ListDetailsResponse>;

export const listDetails: (
  input: ListDetailsRequest
) => Effect.Effect<
  ListDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDetailsRequest,
  output: ListDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateRequest {
  zone_id: string;
  body: unknown;
}

export const CreateRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/acm/custom_trust_store" }),
).annotations({ identifier: "CreateRequest" }) as unknown as Schema.Schema<CreateRequest>;

export interface CreateResponse {
  result: { certificate: string; expires_on: string; id: string; issuer: string; signature: string; status: "initializing" | "pending_deployment" | "active" | "pending_deletion" | "deleted" | "expired"; updated_at: string; uploaded_on: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateResponse = Schema.Struct({
  result: Schema.Struct({
  certificate: Schema.String,
  expires_on: Schema.Date,
  id: Schema.String,
  issuer: Schema.String,
  signature: Schema.String,
  status: Schema.Literal("initializing", "pending_deployment", "active", "pending_deletion", "deleted", "expired"),
  updated_at: Schema.Date,
  uploaded_on: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateResponse" }) as unknown as Schema.Schema<CreateResponse>;

export const create: (
  input: CreateRequest
) => Effect.Effect<
  CreateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateRequest,
  output: CreateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CustomOriginTrustStoreDetailsRequest {
  custom_origin_trust_store_id: string;
  zone_id: string;
}

export const CustomOriginTrustStoreDetailsRequest = Schema.Struct({
  custom_origin_trust_store_id: Schema.String.pipe(T.HttpPath("custom_origin_trust_store_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/acm/custom_trust_store/{custom_origin_trust_store_id}" }),
).annotations({ identifier: "CustomOriginTrustStoreDetailsRequest" }) as unknown as Schema.Schema<CustomOriginTrustStoreDetailsRequest>;

export interface CustomOriginTrustStoreDetailsResponse {
  result: { certificate: string; expires_on: string; id: string; issuer: string; signature: string; status: "initializing" | "pending_deployment" | "active" | "pending_deletion" | "deleted" | "expired"; updated_at: string; uploaded_on: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CustomOriginTrustStoreDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  certificate: Schema.String,
  expires_on: Schema.Date,
  id: Schema.String,
  issuer: Schema.String,
  signature: Schema.String,
  status: Schema.Literal("initializing", "pending_deployment", "active", "pending_deletion", "deleted", "expired"),
  updated_at: Schema.Date,
  uploaded_on: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CustomOriginTrustStoreDetailsResponse" }) as unknown as Schema.Schema<CustomOriginTrustStoreDetailsResponse>;

export const customOriginTrustStoreDetails: (
  input: CustomOriginTrustStoreDetailsRequest
) => Effect.Effect<
  CustomOriginTrustStoreDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CustomOriginTrustStoreDetailsRequest,
  output: CustomOriginTrustStoreDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_1Request {
  custom_origin_trust_store_id: string;
  zone_id: string;
}

export const Delete_1Request = Schema.Struct({
  custom_origin_trust_store_id: Schema.String.pipe(T.HttpPath("custom_origin_trust_store_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/acm/custom_trust_store/{custom_origin_trust_store_id}" }),
).annotations({ identifier: "Delete_1Request" }) as unknown as Schema.Schema<Delete_1Request>;

export interface Delete_1Response {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_1Response = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_1Response" }) as unknown as Schema.Schema<Delete_1Response>;

export const delete_1: (
  input: Delete_1Request
) => Effect.Effect<
  Delete_1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_1Request,
  output: Delete_1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface TotalTlsTotalTlsSettingsDetailsRequest {
  zone_id: string;
}

export const TotalTlsTotalTlsSettingsDetailsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/acm/total_tls" }),
).annotations({ identifier: "TotalTlsTotalTlsSettingsDetailsRequest" }) as unknown as Schema.Schema<TotalTlsTotalTlsSettingsDetailsRequest>;

export interface TotalTlsTotalTlsSettingsDetailsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const TotalTlsTotalTlsSettingsDetailsResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "TotalTlsTotalTlsSettingsDetailsResponse" }) as unknown as Schema.Schema<TotalTlsTotalTlsSettingsDetailsResponse>;

export const totalTlsTotalTlsSettingsDetails: (
  input: TotalTlsTotalTlsSettingsDetailsRequest
) => Effect.Effect<
  TotalTlsTotalTlsSettingsDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: TotalTlsTotalTlsSettingsDetailsRequest,
  output: TotalTlsTotalTlsSettingsDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface TotalTlsEnableOrDisableTotalTlsRequest {
  zone_id: string;
  body: unknown;
}

export const TotalTlsEnableOrDisableTotalTlsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/acm/total_tls" }),
).annotations({ identifier: "TotalTlsEnableOrDisableTotalTlsRequest" }) as unknown as Schema.Schema<TotalTlsEnableOrDisableTotalTlsRequest>;

export interface TotalTlsEnableOrDisableTotalTlsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const TotalTlsEnableOrDisableTotalTlsResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "TotalTlsEnableOrDisableTotalTlsResponse" }) as unknown as Schema.Schema<TotalTlsEnableOrDisableTotalTlsResponse>;

export const totalTlsEnableOrDisableTotalTls: (
  input: TotalTlsEnableOrDisableTotalTlsRequest
) => Effect.Effect<
  TotalTlsEnableOrDisableTotalTlsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: TotalTlsEnableOrDisableTotalTlsRequest,
  output: TotalTlsEnableOrDisableTotalTlsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PutZonesZoneIdActivationCheckRequest {
  zone_id: string;
}

export const PutZonesZoneIdActivationCheckRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/activation_check" }),
).annotations({ identifier: "PutZonesZoneIdActivationCheckRequest" }) as unknown as Schema.Schema<PutZonesZoneIdActivationCheckRequest>;

export interface PutZonesZoneIdActivationCheckResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PutZonesZoneIdActivationCheckResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PutZonesZoneIdActivationCheckResponse" }) as unknown as Schema.Schema<PutZonesZoneIdActivationCheckResponse>;

export const putZonesZoneIdActivationCheck: (
  input: PutZonesZoneIdActivationCheckRequest
) => Effect.Effect<
  PutZonesZoneIdActivationCheckResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutZonesZoneIdActivationCheckRequest,
  output: PutZonesZoneIdActivationCheckResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListHostnamesRequest {
}

export const ListHostnamesRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/addressing/regional_hostnames" }),
).annotations({ identifier: "ListHostnamesRequest" }) as unknown as Schema.Schema<ListHostnamesRequest>;

export interface ListHostnamesResponse {
  result: { created_on: unknown; hostname: string; region_key: string; routing?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListHostnamesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_on: Schema.Unknown,
  hostname: Schema.String,
  region_key: Schema.String,
  routing: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListHostnamesResponse" }) as unknown as Schema.Schema<ListHostnamesResponse>;

export const listHostnames: (
  input: ListHostnamesRequest
) => Effect.Effect<
  ListHostnamesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListHostnamesRequest,
  output: ListHostnamesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateHostnameRequest {
  body: { hostname: string; region_key: string; routing?: string };
}

export const CreateHostnameRequest = Schema.Struct({
  body: Schema.Struct({
  hostname: Schema.String,
  region_key: Schema.String,
  routing: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/addressing/regional_hostnames" }),
).annotations({ identifier: "CreateHostnameRequest" }) as unknown as Schema.Schema<CreateHostnameRequest>;

export interface CreateHostnameResponse {
  result: { created_on: unknown; hostname: string; region_key: string; routing?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateHostnameResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.Unknown,
  hostname: Schema.String,
  region_key: Schema.String,
  routing: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateHostnameResponse" }) as unknown as Schema.Schema<CreateHostnameResponse>;

export const createHostname: (
  input: CreateHostnameRequest
) => Effect.Effect<
  CreateHostnameResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateHostnameRequest,
  output: CreateHostnameResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DlsAccountRegionalHostnamesAccountFetchHostnameRequest {
}

export const DlsAccountRegionalHostnamesAccountFetchHostnameRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/addressing/regional_hostnames/{hostname}" }),
).annotations({ identifier: "DlsAccountRegionalHostnamesAccountFetchHostnameRequest" }) as unknown as Schema.Schema<DlsAccountRegionalHostnamesAccountFetchHostnameRequest>;

export interface DlsAccountRegionalHostnamesAccountFetchHostnameResponse {
  result: { created_on: unknown; hostname: string; region_key: string; routing?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DlsAccountRegionalHostnamesAccountFetchHostnameResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.Unknown,
  hostname: Schema.String,
  region_key: Schema.String,
  routing: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DlsAccountRegionalHostnamesAccountFetchHostnameResponse" }) as unknown as Schema.Schema<DlsAccountRegionalHostnamesAccountFetchHostnameResponse>;

export const dlsAccountRegionalHostnamesAccountFetchHostname: (
  input: DlsAccountRegionalHostnamesAccountFetchHostnameRequest
) => Effect.Effect<
  DlsAccountRegionalHostnamesAccountFetchHostnameResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DlsAccountRegionalHostnamesAccountFetchHostnameRequest,
  output: DlsAccountRegionalHostnamesAccountFetchHostnameResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteHostnameRequest {
}

export const DeleteHostnameRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/addressing/regional_hostnames/{hostname}" }),
).annotations({ identifier: "DeleteHostnameRequest" }) as unknown as Schema.Schema<DeleteHostnameRequest>;

export interface DeleteHostnameResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteHostnameResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteHostnameResponse" }) as unknown as Schema.Schema<DeleteHostnameResponse>;

export const deleteHostname: (
  input: DeleteHostnameRequest
) => Effect.Effect<
  DeleteHostnameResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteHostnameRequest,
  output: DeleteHostnameResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchHostnameRequest {
  body: { region_key: string };
}

export const PatchHostnameRequest = Schema.Struct({
  body: Schema.Struct({
  region_key: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/addressing/regional_hostnames/{hostname}" }),
).annotations({ identifier: "PatchHostnameRequest" }) as unknown as Schema.Schema<PatchHostnameRequest>;

export interface PatchHostnameResponse {
  result: { created_on: unknown; hostname: string; region_key: string; routing?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchHostnameResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.Unknown,
  hostname: Schema.String,
  region_key: Schema.String,
  routing: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchHostnameResponse" }) as unknown as Schema.Schema<PatchHostnameResponse>;

export const patchHostname: (
  input: PatchHostnameRequest
) => Effect.Effect<
  PatchHostnameResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchHostnameRequest,
  output: PatchHostnameResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ArgoAnalyticsForZoneArgoAnalyticsForAZoneRequest {
  zone_id: string;
  bins?: string;
}

export const ArgoAnalyticsForZoneArgoAnalyticsForAZoneRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  bins: Schema.optional(Schema.String).pipe(T.HttpQuery("bins"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/analytics/latency" }),
).annotations({ identifier: "ArgoAnalyticsForZoneArgoAnalyticsForAZoneRequest" }) as unknown as Schema.Schema<ArgoAnalyticsForZoneArgoAnalyticsForAZoneRequest>;

export interface ArgoAnalyticsForZoneArgoAnalyticsForAZoneResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ArgoAnalyticsForZoneArgoAnalyticsForAZoneResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ArgoAnalyticsForZoneArgoAnalyticsForAZoneResponse" }) as unknown as Schema.Schema<ArgoAnalyticsForZoneArgoAnalyticsForAZoneResponse>;

export const argoAnalyticsForZoneArgoAnalyticsForAZone: (
  input: ArgoAnalyticsForZoneArgoAnalyticsForAZoneRequest
) => Effect.Effect<
  ArgoAnalyticsForZoneArgoAnalyticsForAZoneResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ArgoAnalyticsForZoneArgoAnalyticsForAZoneRequest,
  output: ArgoAnalyticsForZoneArgoAnalyticsForAZoneResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsRequest {
  zone_id: string;
}

export const ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/analytics/latency/colos" }),
).annotations({ identifier: "ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsRequest" }) as unknown as Schema.Schema<ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsRequest>;

export interface ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsResponse" }) as unknown as Schema.Schema<ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsResponse>;

export const argoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPs: (
  input: ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsRequest
) => Effect.Effect<
  ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsRequest,
  output: ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesRequest {
}

export const ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/api_gateway/configuration" }),
).annotations({ identifier: "ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesRequest" }) as unknown as Schema.Schema<ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesRequest>;

export interface ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesResponse" }) as unknown as Schema.Schema<ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesResponse>;

export const apiShieldSettingsRetrieveInformationAboutSpecificConfigurationProperties: (
  input: ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesRequest
) => Effect.Effect<
  ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesRequest,
  output: ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldSettingsSetConfigurationPropertiesRequest {
  body: { auth_id_characteristics: unknown[] };
}

export const ApiShieldSettingsSetConfigurationPropertiesRequest = Schema.Struct({
  body: Schema.Struct({
  auth_id_characteristics: Schema.Array(Schema.Union(Schema.Unknown, Schema.Struct({
  name: Schema.String,
  type: Schema.Literal("jwt")
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/api_gateway/configuration" }),
).annotations({ identifier: "ApiShieldSettingsSetConfigurationPropertiesRequest" }) as unknown as Schema.Schema<ApiShieldSettingsSetConfigurationPropertiesRequest>;

export interface ApiShieldSettingsSetConfigurationPropertiesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldSettingsSetConfigurationPropertiesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldSettingsSetConfigurationPropertiesResponse" }) as unknown as Schema.Schema<ApiShieldSettingsSetConfigurationPropertiesResponse>;

export const apiShieldSettingsSetConfigurationProperties: (
  input: ApiShieldSettingsSetConfigurationPropertiesRequest
) => Effect.Effect<
  ApiShieldSettingsSetConfigurationPropertiesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldSettingsSetConfigurationPropertiesRequest,
  output: ApiShieldSettingsSetConfigurationPropertiesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiRequest {
}

export const ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/api_gateway/discovery" }),
).annotations({ identifier: "ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiRequest" }) as unknown as Schema.Schema<ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiRequest>;

export interface ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiResponse {
  result: { schemas: Record<string, unknown>[]; timestamp: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiResponse = Schema.Struct({
  result: Schema.Struct({
  schemas: Schema.Array(Schema.Struct({})),
  timestamp: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiResponse" }) as unknown as Schema.Schema<ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiResponse>;

export const apiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapi: (
  input: ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiRequest
) => Effect.Effect<
  ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiRequest,
  output: ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneRequest {
}

export const ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/api_gateway/discovery/operations" }),
).annotations({ identifier: "ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneRequest" }) as unknown as Schema.Schema<ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneRequest>;

export interface ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  features: Schema.optional(Schema.Struct({
  traffic_stats: Schema.optional(Schema.Struct({
  last_updated: Schema.String,
  period_seconds: Schema.Number,
  requests: Schema.Number
}))
})),
  id: Schema.String,
  last_updated: Schema.String,
  origin: Schema.Array(Schema.Literal("ML", "SessionIdentifier", "LabelDiscovery")),
  state: Schema.Literal("review", "saved", "ignored")
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneResponse" }) as unknown as Schema.Schema<ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneResponse>;

export const apiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZone: (
  input: ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneRequest
) => Effect.Effect<
  ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneRequest,
  output: ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchDiscoveredOperationsRequest {
  body: Record<string, unknown>;
}

export const PatchDiscoveredOperationsRequest = Schema.Struct({
  body: Schema.Record({ key: Schema.String, value: Schema.Struct({
  state: Schema.optional(Schema.Literal("review", "ignored"))
}) }).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/api_gateway/discovery/operations" }),
).annotations({ identifier: "PatchDiscoveredOperationsRequest" }) as unknown as Schema.Schema<PatchDiscoveredOperationsRequest>;

export interface PatchDiscoveredOperationsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchDiscoveredOperationsResponse = Schema.Struct({
  result: Schema.Record({ key: Schema.String, value: Schema.Struct({
  state: Schema.optional(Schema.Literal("review", "ignored"))
}) }),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchDiscoveredOperationsResponse" }) as unknown as Schema.Schema<PatchDiscoveredOperationsResponse>;

export const patchDiscoveredOperations: (
  input: PatchDiscoveredOperationsRequest
) => Effect.Effect<
  PatchDiscoveredOperationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchDiscoveredOperationsRequest,
  output: PatchDiscoveredOperationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchDiscoveredOperationRequest {
  body: { state?: unknown };
}

export const PatchDiscoveredOperationRequest = Schema.Struct({
  body: Schema.Struct({
  state: Schema.optional(Schema.Literal("review", "ignored"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/api_gateway/discovery/operations/{operation_id}" }),
).annotations({ identifier: "PatchDiscoveredOperationRequest" }) as unknown as Schema.Schema<PatchDiscoveredOperationRequest>;

export interface PatchDiscoveredOperationResponse {
  result: { state?: "review" | "saved" | "ignored" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchDiscoveredOperationResponse = Schema.Struct({
  result: Schema.Struct({
  state: Schema.optional(Schema.Literal("review", "saved", "ignored"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchDiscoveredOperationResponse" }) as unknown as Schema.Schema<PatchDiscoveredOperationResponse>;

export const patchDiscoveredOperation: (
  input: PatchDiscoveredOperationRequest
) => Effect.Effect<
  PatchDiscoveredOperationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchDiscoveredOperationRequest,
  output: PatchDiscoveredOperationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldExpressionTemplatesFallthroughRequest {
  body: { hosts: string[] };
}

export const ApiShieldExpressionTemplatesFallthroughRequest = Schema.Struct({
  body: Schema.Struct({
  hosts: Schema.Array(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/api_gateway/expression-template/fallthrough" }),
).annotations({ identifier: "ApiShieldExpressionTemplatesFallthroughRequest" }) as unknown as Schema.Schema<ApiShieldExpressionTemplatesFallthroughRequest>;

export interface ApiShieldExpressionTemplatesFallthroughResponse {
  result: { expression: string; title: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldExpressionTemplatesFallthroughResponse = Schema.Struct({
  result: Schema.Struct({
  expression: Schema.String,
  title: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldExpressionTemplatesFallthroughResponse" }) as unknown as Schema.Schema<ApiShieldExpressionTemplatesFallthroughResponse>;

export const apiShieldExpressionTemplatesFallthrough: (
  input: ApiShieldExpressionTemplatesFallthroughRequest
) => Effect.Effect<
  ApiShieldExpressionTemplatesFallthroughResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldExpressionTemplatesFallthroughRequest,
  output: ApiShieldExpressionTemplatesFallthroughResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneRequest {
  order?: "method" | "host" | "endpoint" | "thresholds.$key";
}

export const ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneRequest = Schema.Struct({
  order: Schema.optional(Schema.Literal("method", "host", "endpoint", "thresholds.$key")).pipe(T.HttpQuery("order"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/api_gateway/operations" }),
).annotations({ identifier: "ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneRequest" }) as unknown as Schema.Schema<ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneRequest>;

export interface ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  features: Schema.optional(Schema.Struct({}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneResponse" }) as unknown as Schema.Schema<ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneResponse>;

export const apiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZone: (
  input: ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneRequest
) => Effect.Effect<
  ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneRequest,
  output: ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldEndpointManagementAddOperationsToAZoneRequest {
  body: { endpoint: string; host: string; method: "GET" | "POST" | "HEAD" | "OPTIONS" | "PUT" | "DELETE" | "CONNECT" | "PATCH" | "TRACE" }[];
}

export const ApiShieldEndpointManagementAddOperationsToAZoneRequest = Schema.Struct({
  body: Schema.Array(Schema.Struct({
  endpoint: Schema.String,
  host: Schema.String,
  method: Schema.Literal("GET", "POST", "HEAD", "OPTIONS", "PUT", "DELETE", "CONNECT", "PATCH", "TRACE")
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/api_gateway/operations" }),
).annotations({ identifier: "ApiShieldEndpointManagementAddOperationsToAZoneRequest" }) as unknown as Schema.Schema<ApiShieldEndpointManagementAddOperationsToAZoneRequest>;

export interface ApiShieldEndpointManagementAddOperationsToAZoneResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldEndpointManagementAddOperationsToAZoneResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  features: Schema.optional(Schema.Struct({}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldEndpointManagementAddOperationsToAZoneResponse" }) as unknown as Schema.Schema<ApiShieldEndpointManagementAddOperationsToAZoneResponse>;

export const apiShieldEndpointManagementAddOperationsToAZone: (
  input: ApiShieldEndpointManagementAddOperationsToAZoneRequest
) => Effect.Effect<
  ApiShieldEndpointManagementAddOperationsToAZoneResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldEndpointManagementAddOperationsToAZoneRequest,
  output: ApiShieldEndpointManagementAddOperationsToAZoneResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteMultipleOperationsRequest {
  body: { operation_id: unknown }[];
}

export const DeleteMultipleOperationsRequest = Schema.Struct({
  body: Schema.Array(Schema.Struct({
  operation_id: Schema.String
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/api_gateway/operations" }),
).annotations({ identifier: "DeleteMultipleOperationsRequest" }) as unknown as Schema.Schema<DeleteMultipleOperationsRequest>;

export interface DeleteMultipleOperationsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteMultipleOperationsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteMultipleOperationsResponse" }) as unknown as Schema.Schema<DeleteMultipleOperationsResponse>;

export const deleteMultipleOperations: (
  input: DeleteMultipleOperationsRequest
) => Effect.Effect<
  DeleteMultipleOperationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteMultipleOperationsRequest,
  output: DeleteMultipleOperationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldEndpointManagementAddOperationToAZoneRequest {
  body: { endpoint: string; host: string; method: "GET" | "POST" | "HEAD" | "OPTIONS" | "PUT" | "DELETE" | "CONNECT" | "PATCH" | "TRACE" };
}

export const ApiShieldEndpointManagementAddOperationToAZoneRequest = Schema.Struct({
  body: Schema.Struct({
  endpoint: Schema.String,
  host: Schema.String,
  method: Schema.Literal("GET", "POST", "HEAD", "OPTIONS", "PUT", "DELETE", "CONNECT", "PATCH", "TRACE")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/api_gateway/operations/item" }),
).annotations({ identifier: "ApiShieldEndpointManagementAddOperationToAZoneRequest" }) as unknown as Schema.Schema<ApiShieldEndpointManagementAddOperationToAZoneRequest>;

export interface ApiShieldEndpointManagementAddOperationToAZoneResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldEndpointManagementAddOperationToAZoneResponse = Schema.Struct({
  result: Schema.Struct({
  features: Schema.optional(Schema.Struct({}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldEndpointManagementAddOperationToAZoneResponse" }) as unknown as Schema.Schema<ApiShieldEndpointManagementAddOperationToAZoneResponse>;

export const apiShieldEndpointManagementAddOperationToAZone: (
  input: ApiShieldEndpointManagementAddOperationToAZoneRequest
) => Effect.Effect<
  ApiShieldEndpointManagementAddOperationToAZoneResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldEndpointManagementAddOperationToAZoneRequest,
  output: ApiShieldEndpointManagementAddOperationToAZoneResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateMultipleOperationLevelSettingsRequest {
  body: Record<string, unknown>;
}

export const UpdateMultipleOperationLevelSettingsRequest = Schema.Struct({
  body: Schema.Record({ key: Schema.String, value: Schema.Struct({
  mitigation_action: Schema.optional(Schema.Literal("log", "block", "none", null))
}) }).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/api_gateway/operations/schema_validation" }),
).annotations({ identifier: "UpdateMultipleOperationLevelSettingsRequest" }) as unknown as Schema.Schema<UpdateMultipleOperationLevelSettingsRequest>;

export interface UpdateMultipleOperationLevelSettingsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateMultipleOperationLevelSettingsResponse = Schema.Struct({
  result: Schema.Record({ key: Schema.String, value: Schema.Struct({
  mitigation_action: Schema.optional(Schema.Literal("log", "block", "none", null))
}) }),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateMultipleOperationLevelSettingsResponse" }) as unknown as Schema.Schema<UpdateMultipleOperationLevelSettingsResponse>;

export const updateMultipleOperationLevelSettings: (
  input: UpdateMultipleOperationLevelSettingsRequest
) => Effect.Effect<
  UpdateMultipleOperationLevelSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateMultipleOperationLevelSettingsRequest,
  output: UpdateMultipleOperationLevelSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldEndpointManagementRetrieveInformationAboutAnOperationRequest {
}

export const ApiShieldEndpointManagementRetrieveInformationAboutAnOperationRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/api_gateway/operations/{operation_id}" }),
).annotations({ identifier: "ApiShieldEndpointManagementRetrieveInformationAboutAnOperationRequest" }) as unknown as Schema.Schema<ApiShieldEndpointManagementRetrieveInformationAboutAnOperationRequest>;

export interface ApiShieldEndpointManagementRetrieveInformationAboutAnOperationResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldEndpointManagementRetrieveInformationAboutAnOperationResponse = Schema.Struct({
  result: Schema.Struct({
  features: Schema.optional(Schema.Struct({}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldEndpointManagementRetrieveInformationAboutAnOperationResponse" }) as unknown as Schema.Schema<ApiShieldEndpointManagementRetrieveInformationAboutAnOperationResponse>;

export const apiShieldEndpointManagementRetrieveInformationAboutAnOperation: (
  input: ApiShieldEndpointManagementRetrieveInformationAboutAnOperationRequest
) => Effect.Effect<
  ApiShieldEndpointManagementRetrieveInformationAboutAnOperationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldEndpointManagementRetrieveInformationAboutAnOperationRequest,
  output: ApiShieldEndpointManagementRetrieveInformationAboutAnOperationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAnOperationRequest {
}

export const DeleteAnOperationRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/api_gateway/operations/{operation_id}" }),
).annotations({ identifier: "DeleteAnOperationRequest" }) as unknown as Schema.Schema<DeleteAnOperationRequest>;

export interface DeleteAnOperationResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAnOperationResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAnOperationResponse" }) as unknown as Schema.Schema<DeleteAnOperationResponse>;

export const deleteAnOperation: (
  input: DeleteAnOperationRequest
) => Effect.Effect<
  DeleteAnOperationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAnOperationRequest,
  output: DeleteAnOperationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldSchemaValidationRetrieveOperationLevelSettingsRequest {
}

export const ApiShieldSchemaValidationRetrieveOperationLevelSettingsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/api_gateway/operations/{operation_id}/schema_validation" }),
).annotations({ identifier: "ApiShieldSchemaValidationRetrieveOperationLevelSettingsRequest" }) as unknown as Schema.Schema<ApiShieldSchemaValidationRetrieveOperationLevelSettingsRequest>;

export interface ApiShieldSchemaValidationRetrieveOperationLevelSettingsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldSchemaValidationRetrieveOperationLevelSettingsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldSchemaValidationRetrieveOperationLevelSettingsResponse" }) as unknown as Schema.Schema<ApiShieldSchemaValidationRetrieveOperationLevelSettingsResponse>;

export const apiShieldSchemaValidationRetrieveOperationLevelSettings: (
  input: ApiShieldSchemaValidationRetrieveOperationLevelSettingsRequest
) => Effect.Effect<
  ApiShieldSchemaValidationRetrieveOperationLevelSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldSchemaValidationRetrieveOperationLevelSettingsRequest,
  output: ApiShieldSchemaValidationRetrieveOperationLevelSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateOperationLevelSettingsRequest {
  body: { mitigation_action?: "log" | "block" | "none" | null };
}

export const UpdateOperationLevelSettingsRequest = Schema.Struct({
  body: Schema.Struct({
  mitigation_action: Schema.optional(Schema.Literal("log", "block", "none", null))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/api_gateway/operations/{operation_id}/schema_validation" }),
).annotations({ identifier: "UpdateOperationLevelSettingsRequest" }) as unknown as Schema.Schema<UpdateOperationLevelSettingsRequest>;

export interface UpdateOperationLevelSettingsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateOperationLevelSettingsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateOperationLevelSettingsResponse" }) as unknown as Schema.Schema<UpdateOperationLevelSettingsResponse>;

export const updateOperationLevelSettings: (
  input: UpdateOperationLevelSettingsRequest
) => Effect.Effect<
  UpdateOperationLevelSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateOperationLevelSettingsRequest,
  output: UpdateOperationLevelSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasRequest {
  host?: string[];
}

export const ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasRequest = Schema.Struct({
  host: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("host"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/api_gateway/schemas" }),
).annotations({ identifier: "ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasRequest" }) as unknown as Schema.Schema<ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasRequest>;

export interface ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasResponse {
  result: { schemas?: Record<string, unknown>[]; timestamp?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasResponse = Schema.Struct({
  result: Schema.Struct({
  schemas: Schema.optional(Schema.Array(Schema.Struct({}))),
  timestamp: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasResponse" }) as unknown as Schema.Schema<ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasResponse>;

export const apiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemas: (
  input: ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasRequest
) => Effect.Effect<
  ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasRequest,
  output: ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldSchemaValidationRetrieveZoneLevelSettingsRequest {
}

export const ApiShieldSchemaValidationRetrieveZoneLevelSettingsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/api_gateway/settings/schema_validation" }),
).annotations({ identifier: "ApiShieldSchemaValidationRetrieveZoneLevelSettingsRequest" }) as unknown as Schema.Schema<ApiShieldSchemaValidationRetrieveZoneLevelSettingsRequest>;

export interface ApiShieldSchemaValidationRetrieveZoneLevelSettingsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldSchemaValidationRetrieveZoneLevelSettingsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldSchemaValidationRetrieveZoneLevelSettingsResponse" }) as unknown as Schema.Schema<ApiShieldSchemaValidationRetrieveZoneLevelSettingsResponse>;

export const apiShieldSchemaValidationRetrieveZoneLevelSettings: (
  input: ApiShieldSchemaValidationRetrieveZoneLevelSettingsRequest
) => Effect.Effect<
  ApiShieldSchemaValidationRetrieveZoneLevelSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldSchemaValidationRetrieveZoneLevelSettingsRequest,
  output: ApiShieldSchemaValidationRetrieveZoneLevelSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateZoneLevelSettingsRequest {
  body: { validation_default_mitigation_action: "none" | "log" | "block"; validation_override_mitigation_action?: "none" | "disable_override" | null };
}

export const UpdateZoneLevelSettingsRequest = Schema.Struct({
  body: Schema.Struct({
  validation_default_mitigation_action: Schema.Literal("none", "log", "block"),
  validation_override_mitigation_action: Schema.optional(Schema.Literal("none", "disable_override", null))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/api_gateway/settings/schema_validation" }),
).annotations({ identifier: "UpdateZoneLevelSettingsRequest" }) as unknown as Schema.Schema<UpdateZoneLevelSettingsRequest>;

export interface UpdateZoneLevelSettingsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateZoneLevelSettingsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateZoneLevelSettingsResponse" }) as unknown as Schema.Schema<UpdateZoneLevelSettingsResponse>;

export const updateZoneLevelSettings: (
  input: UpdateZoneLevelSettingsRequest
) => Effect.Effect<
  UpdateZoneLevelSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateZoneLevelSettingsRequest,
  output: UpdateZoneLevelSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchZoneLevelSettingsRequest {
  body: { validation_default_mitigation_action?: "none" | "log" | "block" | null; validation_override_mitigation_action?: "none" | "disable_override" | null };
}

export const PatchZoneLevelSettingsRequest = Schema.Struct({
  body: Schema.Struct({
  validation_default_mitigation_action: Schema.optional(Schema.Literal("none", "log", "block", null)),
  validation_override_mitigation_action: Schema.optional(Schema.Literal("none", "disable_override", null))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/api_gateway/settings/schema_validation" }),
).annotations({ identifier: "PatchZoneLevelSettingsRequest" }) as unknown as Schema.Schema<PatchZoneLevelSettingsRequest>;

export interface PatchZoneLevelSettingsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchZoneLevelSettingsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchZoneLevelSettingsResponse" }) as unknown as Schema.Schema<PatchZoneLevelSettingsResponse>;

export const patchZoneLevelSettings: (
  input: PatchZoneLevelSettingsRequest
) => Effect.Effect<
  PatchZoneLevelSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchZoneLevelSettingsRequest,
  output: PatchZoneLevelSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasRequest {
  validation_enabled?: boolean;
}

export const ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasRequest = Schema.Struct({
  validation_enabled: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validation_enabled"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/api_gateway/user_schemas" }),
).annotations({ identifier: "ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasRequest" }) as unknown as Schema.Schema<ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasRequest>;

export interface ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasResponse {
  result: { created_at: unknown; kind: "openapi_v3"; name: string; schema_id: unknown; source?: string; validation_enabled?: boolean }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.String,
  kind: Schema.Literal("openapi_v3"),
  name: Schema.String,
  schema_id: Schema.String,
  source: Schema.optional(Schema.String),
  validation_enabled: Schema.optional(Schema.Boolean)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasResponse" }) as unknown as Schema.Schema<ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasResponse>;

export const apiShieldSchemaValidationRetrieveInformationAboutAllSchemas: (
  input: ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasRequest
) => Effect.Effect<
  ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasRequest,
  output: ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostSchemaRequest {
  body: FormData;
}

export const PostSchemaRequest = Schema.Struct({
  body: Schema.instanceOf(FormData).pipe(T.HttpFormData())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/api_gateway/user_schemas" }),
).annotations({ identifier: "PostSchemaRequest" }) as unknown as Schema.Schema<PostSchemaRequest>;

export interface PostSchemaResponse {
  result: { schema: { created_at: unknown; kind: "openapi_v3"; name: string; schema_id: unknown; source?: string; validation_enabled?: boolean }; upload_details?: { warnings?: { code: number; locations?: string[]; message?: string }[] } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostSchemaResponse = Schema.Struct({
  result: Schema.Struct({
  schema: Schema.Struct({
  created_at: Schema.String,
  kind: Schema.Literal("openapi_v3"),
  name: Schema.String,
  schema_id: Schema.String,
  source: Schema.optional(Schema.String),
  validation_enabled: Schema.optional(Schema.Boolean)
}),
  upload_details: Schema.optional(Schema.Struct({
  warnings: Schema.optional(Schema.Array(Schema.Struct({
  code: Schema.Number,
  locations: Schema.optional(Schema.Array(Schema.String)),
  message: Schema.optional(Schema.String)
})))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostSchemaResponse" }) as unknown as Schema.Schema<PostSchemaResponse>;

export const postSchema: (
  input: PostSchemaRequest
) => Effect.Effect<
  PostSchemaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostSchemaRequest,
  output: PostSchemaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldSchemaValidationRetrieveUserSchemaHostsRequest {
}

export const ApiShieldSchemaValidationRetrieveUserSchemaHostsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/api_gateway/user_schemas/hosts" }),
).annotations({ identifier: "ApiShieldSchemaValidationRetrieveUserSchemaHostsRequest" }) as unknown as Schema.Schema<ApiShieldSchemaValidationRetrieveUserSchemaHostsRequest>;

export interface ApiShieldSchemaValidationRetrieveUserSchemaHostsResponse {
  result: { created_at: unknown; hosts: string[]; name: string; schema_id: unknown }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldSchemaValidationRetrieveUserSchemaHostsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.String,
  hosts: Schema.Array(Schema.String),
  name: Schema.String,
  schema_id: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldSchemaValidationRetrieveUserSchemaHostsResponse" }) as unknown as Schema.Schema<ApiShieldSchemaValidationRetrieveUserSchemaHostsResponse>;

export const apiShieldSchemaValidationRetrieveUserSchemaHosts: (
  input: ApiShieldSchemaValidationRetrieveUserSchemaHostsRequest
) => Effect.Effect<
  ApiShieldSchemaValidationRetrieveUserSchemaHostsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldSchemaValidationRetrieveUserSchemaHostsRequest,
  output: ApiShieldSchemaValidationRetrieveUserSchemaHostsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaRequest {
}

export const ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/api_gateway/user_schemas/{schema_id}" }),
).annotations({ identifier: "ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaRequest" }) as unknown as Schema.Schema<ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaRequest>;

export interface ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaResponse {
  result: { created_at: unknown; kind: "openapi_v3"; name: string; schema_id: unknown; source?: string; validation_enabled?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.String,
  kind: Schema.Literal("openapi_v3"),
  name: Schema.String,
  schema_id: Schema.String,
  source: Schema.optional(Schema.String),
  validation_enabled: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaResponse" }) as unknown as Schema.Schema<ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaResponse>;

export const apiShieldSchemaValidationRetrieveInformationAboutSpecificSchema: (
  input: ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaRequest
) => Effect.Effect<
  ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaRequest,
  output: ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteASchemaRequest {
}

export const DeleteASchemaRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/api_gateway/user_schemas/{schema_id}" }),
).annotations({ identifier: "DeleteASchemaRequest" }) as unknown as Schema.Schema<DeleteASchemaRequest>;

export interface DeleteASchemaResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteASchemaResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteASchemaResponse" }) as unknown as Schema.Schema<DeleteASchemaResponse>;

export const deleteASchema: (
  input: DeleteASchemaRequest
) => Effect.Effect<
  DeleteASchemaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteASchemaRequest,
  output: DeleteASchemaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldSchemaValidationEnableValidationForASchemaRequest {
  body: { validation_enabled?: unknown };
}

export const ApiShieldSchemaValidationEnableValidationForASchemaRequest = Schema.Struct({
  body: Schema.Struct({
  validation_enabled: Schema.optional(Schema.Literal(true))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/api_gateway/user_schemas/{schema_id}" }),
).annotations({ identifier: "ApiShieldSchemaValidationEnableValidationForASchemaRequest" }) as unknown as Schema.Schema<ApiShieldSchemaValidationEnableValidationForASchemaRequest>;

export interface ApiShieldSchemaValidationEnableValidationForASchemaResponse {
  result: { created_at: unknown; kind: "openapi_v3"; name: string; schema_id: unknown; source?: string; validation_enabled?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldSchemaValidationEnableValidationForASchemaResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.String,
  kind: Schema.Literal("openapi_v3"),
  name: Schema.String,
  schema_id: Schema.String,
  source: Schema.optional(Schema.String),
  validation_enabled: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldSchemaValidationEnableValidationForASchemaResponse" }) as unknown as Schema.Schema<ApiShieldSchemaValidationEnableValidationForASchemaResponse>;

export const apiShieldSchemaValidationEnableValidationForASchema: (
  input: ApiShieldSchemaValidationEnableValidationForASchemaRequest
) => Effect.Effect<
  ApiShieldSchemaValidationEnableValidationForASchemaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldSchemaValidationEnableValidationForASchemaRequest,
  output: ApiShieldSchemaValidationEnableValidationForASchemaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ApiShieldSchemaValidationExtractOperationsFromSchemaRequest {
  operation_status?: "new" | "existing";
}

export const ApiShieldSchemaValidationExtractOperationsFromSchemaRequest = Schema.Struct({
  operation_status: Schema.optional(Schema.Literal("new", "existing")).pipe(T.HttpQuery("operation_status"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/api_gateway/user_schemas/{schema_id}/operations" }),
).annotations({ identifier: "ApiShieldSchemaValidationExtractOperationsFromSchemaRequest" }) as unknown as Schema.Schema<ApiShieldSchemaValidationExtractOperationsFromSchemaRequest>;

export interface ApiShieldSchemaValidationExtractOperationsFromSchemaResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ApiShieldSchemaValidationExtractOperationsFromSchemaResponse = Schema.Struct({
  result: Schema.Array(Schema.Union(Schema.Struct({
  features: Schema.optional(Schema.Struct({}))
}), Schema.Struct({
  endpoint: Schema.String,
  host: Schema.String,
  method: Schema.Literal("GET", "POST", "HEAD", "OPTIONS", "PUT", "DELETE", "CONNECT", "PATCH", "TRACE")
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ApiShieldSchemaValidationExtractOperationsFromSchemaResponse" }) as unknown as Schema.Schema<ApiShieldSchemaValidationExtractOperationsFromSchemaResponse>;

export const apiShieldSchemaValidationExtractOperationsFromSchema: (
  input: ApiShieldSchemaValidationExtractOperationsFromSchemaRequest
) => Effect.Effect<
  ApiShieldSchemaValidationExtractOperationsFromSchemaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ApiShieldSchemaValidationExtractOperationsFromSchemaRequest,
  output: ApiShieldSchemaValidationExtractOperationsFromSchemaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetArgoSmartRoutingSettingRequest {
  zone_id: string;
}

export const GetArgoSmartRoutingSettingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/argo/smart_routing" }),
).annotations({ identifier: "GetArgoSmartRoutingSettingRequest" }) as unknown as Schema.Schema<GetArgoSmartRoutingSettingRequest>;

export interface GetArgoSmartRoutingSettingResponse {
  result: { editable: boolean; id: string; modified_on?: string; value: "on" | "off" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetArgoSmartRoutingSettingResponse = Schema.Struct({
  result: Schema.Struct({
  editable: Schema.Boolean,
  id: Schema.String,
  modified_on: Schema.optional(Schema.Date),
  value: Schema.Literal("on", "off")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetArgoSmartRoutingSettingResponse" }) as unknown as Schema.Schema<GetArgoSmartRoutingSettingResponse>;

export const getArgoSmartRoutingSetting: (
  input: GetArgoSmartRoutingSettingRequest
) => Effect.Effect<
  GetArgoSmartRoutingSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetArgoSmartRoutingSettingRequest,
  output: GetArgoSmartRoutingSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchArgoSmartRoutingSettingRequest {
  zone_id: string;
  body: { value: "on" | "off" };
}

export const PatchArgoSmartRoutingSettingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  value: Schema.Literal("on", "off")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/argo/smart_routing" }),
).annotations({ identifier: "PatchArgoSmartRoutingSettingRequest" }) as unknown as Schema.Schema<PatchArgoSmartRoutingSettingRequest>;

export interface PatchArgoSmartRoutingSettingResponse {
  result: { editable: boolean; id: string; modified_on?: string; value: "on" | "off" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchArgoSmartRoutingSettingResponse = Schema.Struct({
  result: Schema.Struct({
  editable: Schema.Boolean,
  id: Schema.String,
  modified_on: Schema.optional(Schema.Date),
  value: Schema.Literal("on", "off")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchArgoSmartRoutingSettingResponse" }) as unknown as Schema.Schema<PatchArgoSmartRoutingSettingResponse>;

export const patchArgoSmartRoutingSetting: (
  input: PatchArgoSmartRoutingSettingRequest
) => Effect.Effect<
  PatchArgoSmartRoutingSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchArgoSmartRoutingSettingRequest,
  output: PatchArgoSmartRoutingSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetTieredCachingSettingRequest {
  zone_id: string;
}

export const GetTieredCachingSettingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/argo/tiered_caching" }),
).annotations({ identifier: "GetTieredCachingSettingRequest" }) as unknown as Schema.Schema<GetTieredCachingSettingRequest>;

export interface GetTieredCachingSettingResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetTieredCachingSettingResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetTieredCachingSettingResponse" }) as unknown as Schema.Schema<GetTieredCachingSettingResponse>;

export const getTieredCachingSetting: (
  input: GetTieredCachingSettingRequest
) => Effect.Effect<
  GetTieredCachingSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTieredCachingSettingRequest,
  output: GetTieredCachingSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchTieredCachingSettingRequest {
  zone_id: string;
  body: { value: "on" | "off" };
}

export const PatchTieredCachingSettingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  value: Schema.Literal("on", "off")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/argo/tiered_caching" }),
).annotations({ identifier: "PatchTieredCachingSettingRequest" }) as unknown as Schema.Schema<PatchTieredCachingSettingRequest>;

export interface PatchTieredCachingSettingResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchTieredCachingSettingResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchTieredCachingSettingResponse" }) as unknown as Schema.Schema<PatchTieredCachingSettingResponse>;

export const patchTieredCachingSetting: (
  input: PatchTieredCachingSettingRequest
) => Effect.Effect<
  PatchTieredCachingSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchTieredCachingSettingRequest,
  output: PatchTieredCachingSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAvailablePlansRequest {
  zone_id: string;
}

export const ListAvailablePlansRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/available_plans" }),
).annotations({ identifier: "ListAvailablePlansRequest" }) as unknown as Schema.Schema<ListAvailablePlansRequest>;

export interface ListAvailablePlansResponse {
  result: { can_subscribe?: boolean; currency?: string; externally_managed?: boolean; frequency?: "weekly" | "monthly" | "quarterly" | "yearly"; id?: string; is_subscribed?: boolean; legacy_discount?: boolean; legacy_id?: string; name?: string; price?: number }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAvailablePlansResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  can_subscribe: Schema.optional(Schema.Boolean),
  currency: Schema.optional(Schema.String),
  externally_managed: Schema.optional(Schema.Boolean),
  frequency: Schema.optional(Schema.Literal("weekly", "monthly", "quarterly", "yearly")),
  id: Schema.optional(Schema.String),
  is_subscribed: Schema.optional(Schema.Boolean),
  legacy_discount: Schema.optional(Schema.Boolean),
  legacy_id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  price: Schema.optional(Schema.Number)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAvailablePlansResponse" }) as unknown as Schema.Schema<ListAvailablePlansResponse>;

export const listAvailablePlans: (
  input: ListAvailablePlansRequest
) => Effect.Effect<
  ListAvailablePlansResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAvailablePlansRequest,
  output: ListAvailablePlansResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneRatePlanAvailablePlanDetailsRequest {
  plan_identifier: string;
  zone_id: string;
}

export const ZoneRatePlanAvailablePlanDetailsRequest = Schema.Struct({
  plan_identifier: Schema.String.pipe(T.HttpPath("plan_identifier")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/available_plans/{plan_identifier}" }),
).annotations({ identifier: "ZoneRatePlanAvailablePlanDetailsRequest" }) as unknown as Schema.Schema<ZoneRatePlanAvailablePlanDetailsRequest>;

export interface ZoneRatePlanAvailablePlanDetailsResponse {
  result: { can_subscribe?: boolean; currency?: string; externally_managed?: boolean; frequency?: "weekly" | "monthly" | "quarterly" | "yearly"; id?: string; is_subscribed?: boolean; legacy_discount?: boolean; legacy_id?: string; name?: string; price?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneRatePlanAvailablePlanDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  can_subscribe: Schema.optional(Schema.Boolean),
  currency: Schema.optional(Schema.String),
  externally_managed: Schema.optional(Schema.Boolean),
  frequency: Schema.optional(Schema.Literal("weekly", "monthly", "quarterly", "yearly")),
  id: Schema.optional(Schema.String),
  is_subscribed: Schema.optional(Schema.Boolean),
  legacy_discount: Schema.optional(Schema.Boolean),
  legacy_id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  price: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneRatePlanAvailablePlanDetailsResponse" }) as unknown as Schema.Schema<ZoneRatePlanAvailablePlanDetailsResponse>;

export const zoneRatePlanAvailablePlanDetails: (
  input: ZoneRatePlanAvailablePlanDetailsRequest
) => Effect.Effect<
  ZoneRatePlanAvailablePlanDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneRatePlanAvailablePlanDetailsRequest,
  output: ZoneRatePlanAvailablePlanDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAvailableRatePlansRequest {
  zone_id: string;
}

export const ListAvailableRatePlansRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/available_rate_plans" }),
).annotations({ identifier: "ListAvailableRatePlansRequest" }) as unknown as Schema.Schema<ListAvailableRatePlansRequest>;

export interface ListAvailableRatePlansResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAvailableRatePlansResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAvailableRatePlansResponse" }) as unknown as Schema.Schema<ListAvailableRatePlansResponse>;

export const listAvailableRatePlans: (
  input: ListAvailableRatePlansRequest
) => Effect.Effect<
  ListAvailableRatePlansResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAvailableRatePlansRequest,
  output: ListAvailableRatePlansResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetConfigRequest {
  zone_id: string;
}

export const GetConfigRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/bot_management" }),
).annotations({ identifier: "GetConfigRequest" }) as unknown as Schema.Schema<GetConfigRequest>;

export interface GetConfigResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetConfigResponse = Schema.Struct({
  result: Schema.Union(Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetConfigResponse" }) as unknown as Schema.Schema<GetConfigResponse>;

export const getConfig: (
  input: GetConfigRequest
) => Effect.Effect<
  GetConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetConfigRequest,
  output: GetConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateConfigRequest {
  zone_id: string;
  body: Record<string, unknown>;
}

export const UpdateConfigRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/bot_management" }),
).annotations({ identifier: "UpdateConfigRequest" }) as unknown as Schema.Schema<UpdateConfigRequest>;

export interface UpdateConfigResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateConfigResponse = Schema.Struct({
  result: Schema.Union(Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateConfigResponse" }) as unknown as Schema.Schema<UpdateConfigResponse>;

export const updateConfig: (
  input: UpdateConfigRequest
) => Effect.Effect<
  UpdateConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateConfigRequest,
  output: UpdateConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListRequest {
  zone_id: string;
}

export const ListRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/bot_management/feedback" }),
).annotations({ identifier: "ListRequest" }) as unknown as Schema.Schema<ListRequest>;

export interface ListResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListResponse" }) as unknown as Schema.Schema<ListResponse>;

export const list: (
  input: ListRequest
) => Effect.Effect<
  ListResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListRequest,
  output: ListResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create1Request {
  zone_id: string;
  body: { created_at?: string; description: string; expression: string; first_request_seen_at: string; last_request_seen_at: string; requests: number; requests_by_attribute: Record<string, unknown>; requests_by_score: Record<string, unknown>; requests_by_score_src: Record<string, unknown>; subtype?: string; type: "false_positive" | "false_negative" };
}

export const Create1Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.String,
  expression: Schema.String,
  first_request_seen_at: Schema.Date,
  last_request_seen_at: Schema.Date,
  requests: Schema.Number,
  requests_by_attribute: Schema.Record({ key: Schema.String, value: Schema.Array(Schema.Struct({
  metric: Schema.String,
  requests: Schema.Number
})) }),
  requests_by_score: Schema.Record({ key: Schema.String, value: Schema.Number }),
  requests_by_score_src: Schema.Record({ key: Schema.String, value: Schema.Number }),
  subtype: Schema.optional(Schema.String),
  type: Schema.Literal("false_positive", "false_negative")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/bot_management/feedback" }),
).annotations({ identifier: "Create1Request" }) as unknown as Schema.Schema<Create1Request>;

export interface Create1Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create1Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create1Response" }) as unknown as Schema.Schema<Create1Response>;

export const create1: (
  input: Create1Request
) => Effect.Effect<
  Create1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create1Request,
  output: Create1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListHostnameAssociationsRequest {
  zone_id: string;
  mtls_certificate_id?: string;
}

export const ListHostnameAssociationsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  mtls_certificate_id: Schema.optional(Schema.String).pipe(T.HttpQuery("mtls_certificate_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/certificate_authorities/hostname_associations" }),
).annotations({ identifier: "ListHostnameAssociationsRequest" }) as unknown as Schema.Schema<ListHostnameAssociationsRequest>;

export interface ListHostnameAssociationsResponse {
  result: { hostnames?: string[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListHostnameAssociationsResponse = Schema.Struct({
  result: Schema.Struct({
  hostnames: Schema.optional(Schema.Array(Schema.String))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListHostnameAssociationsResponse" }) as unknown as Schema.Schema<ListHostnameAssociationsResponse>;

export const listHostnameAssociations: (
  input: ListHostnameAssociationsRequest
) => Effect.Effect<
  ListHostnameAssociationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListHostnameAssociationsRequest,
  output: ListHostnameAssociationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PutHostnameAssociationsRequest {
  zone_id: string;
  body: { hostnames?: string[]; mtls_certificate_id?: string };
}

export const PutHostnameAssociationsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  hostnames: Schema.optional(Schema.Array(Schema.String)),
  mtls_certificate_id: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/certificate_authorities/hostname_associations" }),
).annotations({ identifier: "PutHostnameAssociationsRequest" }) as unknown as Schema.Schema<PutHostnameAssociationsRequest>;

export interface PutHostnameAssociationsResponse {
  result: { hostnames?: string[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PutHostnameAssociationsResponse = Schema.Struct({
  result: Schema.Struct({
  hostnames: Schema.optional(Schema.Array(Schema.String))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PutHostnameAssociationsResponse" }) as unknown as Schema.Schema<PutHostnameAssociationsResponse>;

export const putHostnameAssociations: (
  input: PutHostnameAssociationsRequest
) => Effect.Effect<
  PutHostnameAssociationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutHostnameAssociationsRequest,
  output: PutHostnameAssociationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListClientCertificatesRequest {
  zone_id: string;
  status?: "all" | "active" | "pending_reactivation" | "pending_revocation" | "revoked";
  page?: number;
  per_page?: number;
  limit?: number;
  offset?: number;
}

export const ListClientCertificatesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  status: Schema.optional(Schema.Literal("all", "active", "pending_reactivation", "pending_revocation", "revoked")).pipe(T.HttpQuery("status")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/client_certificates" }),
).annotations({ identifier: "ListClientCertificatesRequest" }) as unknown as Schema.Schema<ListClientCertificatesRequest>;

export interface ListClientCertificatesResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListClientCertificatesResponse = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListClientCertificatesResponse" }) as unknown as Schema.Schema<ListClientCertificatesResponse>;

export const listClientCertificates: (
  input: ListClientCertificatesRequest
) => Effect.Effect<
  ListClientCertificatesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListClientCertificatesRequest,
  output: ListClientCertificatesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateClientCertificateRequest {
  zone_id: string;
  body: { csr: string; validity_days: number };
}

export const CreateClientCertificateRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  csr: Schema.String,
  validity_days: Schema.Number
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/client_certificates" }),
).annotations({ identifier: "CreateClientCertificateRequest" }) as unknown as Schema.Schema<CreateClientCertificateRequest>;

export interface CreateClientCertificateResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateClientCertificateResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateClientCertificateResponse" }) as unknown as Schema.Schema<CreateClientCertificateResponse>;

export const createClientCertificate: (
  input: CreateClientCertificateRequest
) => Effect.Effect<
  CreateClientCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateClientCertificateRequest,
  output: CreateClientCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ClientCertificateForAZoneClientCertificateDetailsRequest {
  zone_id: string;
  client_certificate_id: string;
}

export const ClientCertificateForAZoneClientCertificateDetailsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  client_certificate_id: Schema.String.pipe(T.HttpPath("client_certificate_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/client_certificates/{client_certificate_id}" }),
).annotations({ identifier: "ClientCertificateForAZoneClientCertificateDetailsRequest" }) as unknown as Schema.Schema<ClientCertificateForAZoneClientCertificateDetailsRequest>;

export interface ClientCertificateForAZoneClientCertificateDetailsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ClientCertificateForAZoneClientCertificateDetailsResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ClientCertificateForAZoneClientCertificateDetailsResponse" }) as unknown as Schema.Schema<ClientCertificateForAZoneClientCertificateDetailsResponse>;

export const clientCertificateForAZoneClientCertificateDetails: (
  input: ClientCertificateForAZoneClientCertificateDetailsRequest
) => Effect.Effect<
  ClientCertificateForAZoneClientCertificateDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ClientCertificateForAZoneClientCertificateDetailsRequest,
  output: ClientCertificateForAZoneClientCertificateDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteClientCertificateRequest {
  zone_id: string;
  client_certificate_id: string;
}

export const DeleteClientCertificateRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  client_certificate_id: Schema.String.pipe(T.HttpPath("client_certificate_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/client_certificates/{client_certificate_id}" }),
).annotations({ identifier: "DeleteClientCertificateRequest" }) as unknown as Schema.Schema<DeleteClientCertificateRequest>;

export interface DeleteClientCertificateResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteClientCertificateResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteClientCertificateResponse" }) as unknown as Schema.Schema<DeleteClientCertificateResponse>;

export const deleteClientCertificate: (
  input: DeleteClientCertificateRequest
) => Effect.Effect<
  DeleteClientCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteClientCertificateRequest,
  output: DeleteClientCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ClientCertificateForAZoneEditClientCertificateRequest {
  zone_id: string;
  client_certificate_id: string;
  body: { reactivate?: boolean };
}

export const ClientCertificateForAZoneEditClientCertificateRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  client_certificate_id: Schema.String.pipe(T.HttpPath("client_certificate_id")),
  body: Schema.Struct({
  reactivate: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/client_certificates/{client_certificate_id}" }),
).annotations({ identifier: "ClientCertificateForAZoneEditClientCertificateRequest" }) as unknown as Schema.Schema<ClientCertificateForAZoneEditClientCertificateRequest>;

export interface ClientCertificateForAZoneEditClientCertificateResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ClientCertificateForAZoneEditClientCertificateResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ClientCertificateForAZoneEditClientCertificateResponse" }) as unknown as Schema.Schema<ClientCertificateForAZoneEditClientCertificateResponse>;

export const clientCertificateForAZoneEditClientCertificate: (
  input: ClientCertificateForAZoneEditClientCertificateRequest
) => Effect.Effect<
  ClientCertificateForAZoneEditClientCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ClientCertificateForAZoneEditClientCertificateRequest,
  output: ClientCertificateForAZoneEditClientCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneCloudConnectorRulesRequest {
  zone_id: string;
}

export const ZoneCloudConnectorRulesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/cloud_connector/rules" }),
).annotations({ identifier: "ZoneCloudConnectorRulesRequest" }) as unknown as Schema.Schema<ZoneCloudConnectorRulesRequest>;

export interface ZoneCloudConnectorRulesResponse {
  result: { description?: string; enabled?: boolean; expression?: string; id?: string; parameters?: { host?: string }; provider?: "aws_s3" | "cloudflare_r2" | "gcp_storage" | "azure_storage" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneCloudConnectorRulesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  expression: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  parameters: Schema.optional(Schema.Struct({
  host: Schema.optional(Schema.String)
})),
  provider: Schema.optional(Schema.Literal("aws_s3", "cloudflare_r2", "gcp_storage", "azure_storage"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneCloudConnectorRulesResponse" }) as unknown as Schema.Schema<ZoneCloudConnectorRulesResponse>;

export const zoneCloudConnectorRules: (
  input: ZoneCloudConnectorRulesRequest
) => Effect.Effect<
  ZoneCloudConnectorRulesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneCloudConnectorRulesRequest,
  output: ZoneCloudConnectorRulesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PutRequest {
  zone_id: string;
  body: { description?: string; enabled?: boolean; expression?: string; id?: string; parameters?: { host?: string }; provider?: "aws_s3" | "cloudflare_r2" | "gcp_storage" | "azure_storage" }[];
}

export const PutRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  expression: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  parameters: Schema.optional(Schema.Struct({
  host: Schema.optional(Schema.String)
})),
  provider: Schema.optional(Schema.Literal("aws_s3", "cloudflare_r2", "gcp_storage", "azure_storage"))
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/cloud_connector/rules" }),
).annotations({ identifier: "PutRequest" }) as unknown as Schema.Schema<PutRequest>;

export interface PutResponse {
  result: { description?: string; enabled?: boolean; expression?: string; id?: string; parameters?: { host?: string }; provider?: "aws_s3" | "cloudflare_r2" | "gcp_storage" | "azure_storage" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PutResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  expression: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  parameters: Schema.optional(Schema.Struct({
  host: Schema.optional(Schema.String)
})),
  provider: Schema.optional(Schema.Literal("aws_s3", "cloudflare_r2", "gcp_storage", "azure_storage"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PutResponse" }) as unknown as Schema.Schema<PutResponse>;

export const put: (
  input: PutRequest
) => Effect.Effect<
  PutResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutRequest,
  output: PutResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface WafContentScanningDisableRequest {
  zone_id: string;
}

export const WafContentScanningDisableRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/content-upload-scan/disable" }),
).annotations({ identifier: "WafContentScanningDisableRequest" }) as unknown as Schema.Schema<WafContentScanningDisableRequest>;

export interface WafContentScanningDisableResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const WafContentScanningDisableResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({}), Schema.Array(Schema.Struct({})), Schema.String),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "WafContentScanningDisableResponse" }) as unknown as Schema.Schema<WafContentScanningDisableResponse>;

export const wafContentScanningDisable: (
  input: WafContentScanningDisableRequest
) => Effect.Effect<
  WafContentScanningDisableResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: WafContentScanningDisableRequest,
  output: WafContentScanningDisableResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface WafContentScanningEnableRequest {
  zone_id: string;
}

export const WafContentScanningEnableRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/content-upload-scan/enable" }),
).annotations({ identifier: "WafContentScanningEnableRequest" }) as unknown as Schema.Schema<WafContentScanningEnableRequest>;

export interface WafContentScanningEnableResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const WafContentScanningEnableResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({}), Schema.Array(Schema.Struct({})), Schema.String),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "WafContentScanningEnableResponse" }) as unknown as Schema.Schema<WafContentScanningEnableResponse>;

export const wafContentScanningEnable: (
  input: WafContentScanningEnableRequest
) => Effect.Effect<
  WafContentScanningEnableResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: WafContentScanningEnableRequest,
  output: WafContentScanningEnableResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListCustomScanExpressionsRequest {
  zone_id: string;
}

export const ListCustomScanExpressionsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/content-upload-scan/payloads" }),
).annotations({ identifier: "ListCustomScanExpressionsRequest" }) as unknown as Schema.Schema<ListCustomScanExpressionsRequest>;

export interface ListCustomScanExpressionsResponse {
  result: { id?: unknown; payload?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListCustomScanExpressionsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String),
  payload: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListCustomScanExpressionsResponse" }) as unknown as Schema.Schema<ListCustomScanExpressionsResponse>;

export const listCustomScanExpressions: (
  input: ListCustomScanExpressionsRequest
) => Effect.Effect<
  ListCustomScanExpressionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListCustomScanExpressionsRequest,
  output: ListCustomScanExpressionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface WafContentScanningAddCustomScanExpressionsRequest {
  zone_id: string;
  body: { payload: string }[];
}

export const WafContentScanningAddCustomScanExpressionsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Array(Schema.Struct({
  payload: Schema.String
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/content-upload-scan/payloads" }),
).annotations({ identifier: "WafContentScanningAddCustomScanExpressionsRequest" }) as unknown as Schema.Schema<WafContentScanningAddCustomScanExpressionsRequest>;

export interface WafContentScanningAddCustomScanExpressionsResponse {
  result: { id?: unknown; payload?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const WafContentScanningAddCustomScanExpressionsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String),
  payload: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "WafContentScanningAddCustomScanExpressionsResponse" }) as unknown as Schema.Schema<WafContentScanningAddCustomScanExpressionsResponse>;

export const wafContentScanningAddCustomScanExpressions: (
  input: WafContentScanningAddCustomScanExpressionsRequest
) => Effect.Effect<
  WafContentScanningAddCustomScanExpressionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: WafContentScanningAddCustomScanExpressionsRequest,
  output: WafContentScanningAddCustomScanExpressionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteCustomScanExpressionsRequest {
  zone_id: string;
  expression_id: unknown;
}

export const DeleteCustomScanExpressionsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  expression_id: Schema.String.pipe(T.HttpPath("expression_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/content-upload-scan/payloads/{expression_id}" }),
).annotations({ identifier: "DeleteCustomScanExpressionsRequest" }) as unknown as Schema.Schema<DeleteCustomScanExpressionsRequest>;

export interface DeleteCustomScanExpressionsResponse {
  result: { id?: unknown; payload?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteCustomScanExpressionsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String),
  payload: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteCustomScanExpressionsResponse" }) as unknown as Schema.Schema<DeleteCustomScanExpressionsResponse>;

export const deleteCustomScanExpressions: (
  input: DeleteCustomScanExpressionsRequest
) => Effect.Effect<
  DeleteCustomScanExpressionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteCustomScanExpressionsRequest,
  output: DeleteCustomScanExpressionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetStatusRequest {
  zone_id: string;
}

export const GetStatusRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/content-upload-scan/settings" }),
).annotations({ identifier: "GetStatusRequest" }) as unknown as Schema.Schema<GetStatusRequest>;

export interface GetStatusResponse {
  result: { modified?: string; value?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetStatusResponse = Schema.Struct({
  result: Schema.Struct({
  modified: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetStatusResponse" }) as unknown as Schema.Schema<GetStatusResponse>;

export const getStatus: (
  input: GetStatusRequest
) => Effect.Effect<
  GetStatusResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetStatusRequest,
  output: GetStatusResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateSettingsRequest {
  zone_id: string;
  body: { value: "enabled" | "disabled" };
}

export const UpdateSettingsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  value: Schema.Literal("enabled", "disabled")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/content-upload-scan/settings" }),
).annotations({ identifier: "UpdateSettingsRequest" }) as unknown as Schema.Schema<UpdateSettingsRequest>;

export interface UpdateSettingsResponse {
  result: { modified?: string; value?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateSettingsResponse = Schema.Struct({
  result: Schema.Struct({
  modified: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateSettingsResponse" }) as unknown as Schema.Schema<UpdateSettingsResponse>;

export const updateSettings: (
  input: UpdateSettingsRequest
) => Effect.Effect<
  UpdateSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateSettingsRequest,
  output: UpdateSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListSslConfigurationsRequest {
  zone_id: string;
  page?: number;
  per_page?: number;
  match?: "any" | "all";
  status?: "active" | "expired" | "deleted" | "pending" | "initializing";
}

export const ListSslConfigurationsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  match: Schema.optional(Schema.Literal("any", "all")).pipe(T.HttpQuery("match")),
  status: Schema.optional(Schema.Literal("active", "expired", "deleted", "pending", "initializing")).pipe(T.HttpQuery("status"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/custom_certificates" }),
).annotations({ identifier: "ListSslConfigurationsRequest" }) as unknown as Schema.Schema<ListSslConfigurationsRequest>;

export interface ListSslConfigurationsResponse {
  result: { bundle_method: "ubiquitous" | "optimal" | "force"; expires_on: string; geo_restrictions?: { label?: "us" | "eu" | "highest_security" }; hosts: string[]; id: string; issuer: string; keyless_server?: Record<string, unknown>; modified_on: string; policy?: string; priority: number; signature: string; status: "active" | "expired" | "deleted" | "pending" | "initializing"; uploaded_on: string; zone_id: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListSslConfigurationsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  bundle_method: Schema.Literal("ubiquitous", "optimal", "force"),
  expires_on: Schema.Date,
  geo_restrictions: Schema.optional(Schema.Struct({
  label: Schema.optional(Schema.Literal("us", "eu", "highest_security"))
})),
  hosts: Schema.Array(Schema.String),
  id: Schema.String,
  issuer: Schema.String,
  keyless_server: Schema.optional(Schema.Struct({})),
  modified_on: Schema.Date,
  policy: Schema.optional(Schema.String),
  priority: Schema.Number,
  signature: Schema.String,
  status: Schema.Literal("active", "expired", "deleted", "pending", "initializing"),
  uploaded_on: Schema.Date,
  zone_id: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListSslConfigurationsResponse" }) as unknown as Schema.Schema<ListSslConfigurationsResponse>;

export const listSslConfigurations: (
  input: ListSslConfigurationsRequest
) => Effect.Effect<
  ListSslConfigurationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListSslConfigurationsRequest,
  output: ListSslConfigurationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateSslConfigurationRequest {
  zone_id: string;
  body: { bundle_method?: "ubiquitous" | "optimal" | "force"; certificate: string; geo_restrictions?: { label?: "us" | "eu" | "highest_security" }; policy?: string; private_key: string; type?: "legacy_custom" | "sni_custom" };
}

export const CreateSslConfigurationRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  bundle_method: Schema.optional(Schema.Literal("ubiquitous", "optimal", "force")),
  certificate: Schema.String,
  geo_restrictions: Schema.optional(Schema.Struct({
  label: Schema.optional(Schema.Literal("us", "eu", "highest_security"))
})),
  policy: Schema.optional(Schema.String),
  private_key: Schema.String,
  type: Schema.optional(Schema.Literal("legacy_custom", "sni_custom"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/custom_certificates" }),
).annotations({ identifier: "CreateSslConfigurationRequest" }) as unknown as Schema.Schema<CreateSslConfigurationRequest>;

export interface CreateSslConfigurationResponse {
  result: { bundle_method: "ubiquitous" | "optimal" | "force"; expires_on: string; geo_restrictions?: { label?: "us" | "eu" | "highest_security" }; hosts: string[]; id: string; issuer: string; keyless_server?: Record<string, unknown>; modified_on: string; policy?: string; priority: number; signature: string; status: "active" | "expired" | "deleted" | "pending" | "initializing"; uploaded_on: string; zone_id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateSslConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  bundle_method: Schema.Literal("ubiquitous", "optimal", "force"),
  expires_on: Schema.Date,
  geo_restrictions: Schema.optional(Schema.Struct({
  label: Schema.optional(Schema.Literal("us", "eu", "highest_security"))
})),
  hosts: Schema.Array(Schema.String),
  id: Schema.String,
  issuer: Schema.String,
  keyless_server: Schema.optional(Schema.Struct({})),
  modified_on: Schema.Date,
  policy: Schema.optional(Schema.String),
  priority: Schema.Number,
  signature: Schema.String,
  status: Schema.Literal("active", "expired", "deleted", "pending", "initializing"),
  uploaded_on: Schema.Date,
  zone_id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateSslConfigurationResponse" }) as unknown as Schema.Schema<CreateSslConfigurationResponse>;

export const createSslConfiguration: (
  input: CreateSslConfigurationRequest
) => Effect.Effect<
  CreateSslConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateSslConfigurationRequest,
  output: CreateSslConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CustomSslForAZoneRePrioritizeSslCertificatesRequest {
  zone_id: string;
  body: unknown;
}

export const CustomSslForAZoneRePrioritizeSslCertificatesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/custom_certificates/prioritize" }),
).annotations({ identifier: "CustomSslForAZoneRePrioritizeSslCertificatesRequest" }) as unknown as Schema.Schema<CustomSslForAZoneRePrioritizeSslCertificatesRequest>;

export interface CustomSslForAZoneRePrioritizeSslCertificatesResponse {
  result: { bundle_method: "ubiquitous" | "optimal" | "force"; expires_on: string; geo_restrictions?: { label?: "us" | "eu" | "highest_security" }; hosts: string[]; id: string; issuer: string; keyless_server?: Record<string, unknown>; modified_on: string; policy?: string; priority: number; signature: string; status: "active" | "expired" | "deleted" | "pending" | "initializing"; uploaded_on: string; zone_id: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CustomSslForAZoneRePrioritizeSslCertificatesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  bundle_method: Schema.Literal("ubiquitous", "optimal", "force"),
  expires_on: Schema.Date,
  geo_restrictions: Schema.optional(Schema.Struct({
  label: Schema.optional(Schema.Literal("us", "eu", "highest_security"))
})),
  hosts: Schema.Array(Schema.String),
  id: Schema.String,
  issuer: Schema.String,
  keyless_server: Schema.optional(Schema.Struct({})),
  modified_on: Schema.Date,
  policy: Schema.optional(Schema.String),
  priority: Schema.Number,
  signature: Schema.String,
  status: Schema.Literal("active", "expired", "deleted", "pending", "initializing"),
  uploaded_on: Schema.Date,
  zone_id: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CustomSslForAZoneRePrioritizeSslCertificatesResponse" }) as unknown as Schema.Schema<CustomSslForAZoneRePrioritizeSslCertificatesResponse>;

export const customSslForAZoneRePrioritizeSslCertificates: (
  input: CustomSslForAZoneRePrioritizeSslCertificatesRequest
) => Effect.Effect<
  CustomSslForAZoneRePrioritizeSslCertificatesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CustomSslForAZoneRePrioritizeSslCertificatesRequest,
  output: CustomSslForAZoneRePrioritizeSslCertificatesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CustomSslForAZoneSslConfigurationDetailsRequest {
  custom_certificate_id: string;
  zone_id: string;
}

export const CustomSslForAZoneSslConfigurationDetailsRequest = Schema.Struct({
  custom_certificate_id: Schema.String.pipe(T.HttpPath("custom_certificate_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/custom_certificates/{custom_certificate_id}" }),
).annotations({ identifier: "CustomSslForAZoneSslConfigurationDetailsRequest" }) as unknown as Schema.Schema<CustomSslForAZoneSslConfigurationDetailsRequest>;

export interface CustomSslForAZoneSslConfigurationDetailsResponse {
  result: { bundle_method: "ubiquitous" | "optimal" | "force"; expires_on: string; geo_restrictions?: { label?: "us" | "eu" | "highest_security" }; hosts: string[]; id: string; issuer: string; keyless_server?: Record<string, unknown>; modified_on: string; policy?: string; priority: number; signature: string; status: "active" | "expired" | "deleted" | "pending" | "initializing"; uploaded_on: string; zone_id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CustomSslForAZoneSslConfigurationDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  bundle_method: Schema.Literal("ubiquitous", "optimal", "force"),
  expires_on: Schema.Date,
  geo_restrictions: Schema.optional(Schema.Struct({
  label: Schema.optional(Schema.Literal("us", "eu", "highest_security"))
})),
  hosts: Schema.Array(Schema.String),
  id: Schema.String,
  issuer: Schema.String,
  keyless_server: Schema.optional(Schema.Struct({})),
  modified_on: Schema.Date,
  policy: Schema.optional(Schema.String),
  priority: Schema.Number,
  signature: Schema.String,
  status: Schema.Literal("active", "expired", "deleted", "pending", "initializing"),
  uploaded_on: Schema.Date,
  zone_id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CustomSslForAZoneSslConfigurationDetailsResponse" }) as unknown as Schema.Schema<CustomSslForAZoneSslConfigurationDetailsResponse>;

export const customSslForAZoneSslConfigurationDetails: (
  input: CustomSslForAZoneSslConfigurationDetailsRequest
) => Effect.Effect<
  CustomSslForAZoneSslConfigurationDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CustomSslForAZoneSslConfigurationDetailsRequest,
  output: CustomSslForAZoneSslConfigurationDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteSslConfigurationRequest {
  custom_certificate_id: string;
  zone_id: string;
}

export const DeleteSslConfigurationRequest = Schema.Struct({
  custom_certificate_id: Schema.String.pipe(T.HttpPath("custom_certificate_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/custom_certificates/{custom_certificate_id}" }),
).annotations({ identifier: "DeleteSslConfigurationRequest" }) as unknown as Schema.Schema<DeleteSslConfigurationRequest>;

export interface DeleteSslConfigurationResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteSslConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteSslConfigurationResponse" }) as unknown as Schema.Schema<DeleteSslConfigurationResponse>;

export const deleteSslConfiguration: (
  input: DeleteSslConfigurationRequest
) => Effect.Effect<
  DeleteSslConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteSslConfigurationRequest,
  output: DeleteSslConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CustomSslForAZoneEditSslConfigurationRequest {
  custom_certificate_id: string;
  zone_id: string;
  body: { bundle_method?: "ubiquitous" | "optimal" | "force"; certificate?: string; geo_restrictions?: { label?: "us" | "eu" | "highest_security" }; policy?: string; private_key?: string };
}

export const CustomSslForAZoneEditSslConfigurationRequest = Schema.Struct({
  custom_certificate_id: Schema.String.pipe(T.HttpPath("custom_certificate_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  bundle_method: Schema.optional(Schema.Literal("ubiquitous", "optimal", "force")),
  certificate: Schema.optional(Schema.String),
  geo_restrictions: Schema.optional(Schema.Struct({
  label: Schema.optional(Schema.Literal("us", "eu", "highest_security"))
})),
  policy: Schema.optional(Schema.String),
  private_key: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/custom_certificates/{custom_certificate_id}" }),
).annotations({ identifier: "CustomSslForAZoneEditSslConfigurationRequest" }) as unknown as Schema.Schema<CustomSslForAZoneEditSslConfigurationRequest>;

export interface CustomSslForAZoneEditSslConfigurationResponse {
  result: { bundle_method: "ubiquitous" | "optimal" | "force"; expires_on: string; geo_restrictions?: { label?: "us" | "eu" | "highest_security" }; hosts: string[]; id: string; issuer: string; keyless_server?: Record<string, unknown>; modified_on: string; policy?: string; priority: number; signature: string; status: "active" | "expired" | "deleted" | "pending" | "initializing"; uploaded_on: string; zone_id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CustomSslForAZoneEditSslConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  bundle_method: Schema.Literal("ubiquitous", "optimal", "force"),
  expires_on: Schema.Date,
  geo_restrictions: Schema.optional(Schema.Struct({
  label: Schema.optional(Schema.Literal("us", "eu", "highest_security"))
})),
  hosts: Schema.Array(Schema.String),
  id: Schema.String,
  issuer: Schema.String,
  keyless_server: Schema.optional(Schema.Struct({})),
  modified_on: Schema.Date,
  policy: Schema.optional(Schema.String),
  priority: Schema.Number,
  signature: Schema.String,
  status: Schema.Literal("active", "expired", "deleted", "pending", "initializing"),
  uploaded_on: Schema.Date,
  zone_id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CustomSslForAZoneEditSslConfigurationResponse" }) as unknown as Schema.Schema<CustomSslForAZoneEditSslConfigurationResponse>;

export const customSslForAZoneEditSslConfiguration: (
  input: CustomSslForAZoneEditSslConfigurationRequest
) => Effect.Effect<
  CustomSslForAZoneEditSslConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CustomSslForAZoneEditSslConfigurationRequest,
  output: CustomSslForAZoneEditSslConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListCustomHostnamesRequest {
  zone_id: string;
  hostname?: string;
  id?: string;
  page?: number;
  per_page?: number;
  order?: "ssl" | "ssl_status";
  direction?: "asc" | "desc";
  ssl?: 0 | 1;
}

export const ListCustomHostnamesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  hostname: Schema.optional(Schema.String).pipe(T.HttpQuery("hostname")),
  id: Schema.optional(Schema.String).pipe(T.HttpQuery("id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.Literal("ssl", "ssl_status")).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction")),
  ssl: Schema.optional(Schema.Literal(0, 1)).pipe(T.HttpQuery("ssl"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/custom_hostnames" }),
).annotations({ identifier: "ListCustomHostnamesRequest" }) as unknown as Schema.Schema<ListCustomHostnamesRequest>;

export interface ListCustomHostnamesResponse {
  result: { hostname: string; id: string; ssl: Record<string, unknown> }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListCustomHostnamesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  hostname: Schema.String,
  id: Schema.String,
  ssl: Schema.Struct({})
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListCustomHostnamesResponse" }) as unknown as Schema.Schema<ListCustomHostnamesResponse>;

export const listCustomHostnames: (
  input: ListCustomHostnamesRequest
) => Effect.Effect<
  ListCustomHostnamesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListCustomHostnamesRequest,
  output: ListCustomHostnamesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateCustomHostnameRequest {
  zone_id: string;
  body: { custom_metadata?: Record<string, unknown>; hostname: string; ssl: Record<string, unknown> };
}

export const CreateCustomHostnameRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  custom_metadata: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  hostname: Schema.String,
  ssl: Schema.Struct({})
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/custom_hostnames" }),
).annotations({ identifier: "CreateCustomHostnameRequest" }) as unknown as Schema.Schema<CreateCustomHostnameRequest>;

export interface CreateCustomHostnameResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateCustomHostnameResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateCustomHostnameResponse" }) as unknown as Schema.Schema<CreateCustomHostnameResponse>;

export const createCustomHostname: (
  input: CreateCustomHostnameRequest
) => Effect.Effect<
  CreateCustomHostnameResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateCustomHostnameRequest,
  output: CreateCustomHostnameResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetFallbackOriginForCustomHostnamesRequest {
  zone_id: string;
}

export const GetFallbackOriginForCustomHostnamesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/custom_hostnames/fallback_origin" }),
).annotations({ identifier: "GetFallbackOriginForCustomHostnamesRequest" }) as unknown as Schema.Schema<GetFallbackOriginForCustomHostnamesRequest>;

export interface GetFallbackOriginForCustomHostnamesResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetFallbackOriginForCustomHostnamesResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetFallbackOriginForCustomHostnamesResponse" }) as unknown as Schema.Schema<GetFallbackOriginForCustomHostnamesResponse>;

export const getFallbackOriginForCustomHostnames: (
  input: GetFallbackOriginForCustomHostnamesRequest
) => Effect.Effect<
  GetFallbackOriginForCustomHostnamesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetFallbackOriginForCustomHostnamesRequest,
  output: GetFallbackOriginForCustomHostnamesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateFallbackOriginForCustomHostnamesRequest {
  zone_id: string;
  body: { origin: string };
}

export const UpdateFallbackOriginForCustomHostnamesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  origin: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/custom_hostnames/fallback_origin" }),
).annotations({ identifier: "UpdateFallbackOriginForCustomHostnamesRequest" }) as unknown as Schema.Schema<UpdateFallbackOriginForCustomHostnamesRequest>;

export interface UpdateFallbackOriginForCustomHostnamesResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateFallbackOriginForCustomHostnamesResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateFallbackOriginForCustomHostnamesResponse" }) as unknown as Schema.Schema<UpdateFallbackOriginForCustomHostnamesResponse>;

export const updateFallbackOriginForCustomHostnames: (
  input: UpdateFallbackOriginForCustomHostnamesRequest
) => Effect.Effect<
  UpdateFallbackOriginForCustomHostnamesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateFallbackOriginForCustomHostnamesRequest,
  output: UpdateFallbackOriginForCustomHostnamesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteFallbackOriginForCustomHostnamesRequest {
  zone_id: string;
}

export const DeleteFallbackOriginForCustomHostnamesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/custom_hostnames/fallback_origin" }),
).annotations({ identifier: "DeleteFallbackOriginForCustomHostnamesRequest" }) as unknown as Schema.Schema<DeleteFallbackOriginForCustomHostnamesRequest>;

export interface DeleteFallbackOriginForCustomHostnamesResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteFallbackOriginForCustomHostnamesResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteFallbackOriginForCustomHostnamesResponse" }) as unknown as Schema.Schema<DeleteFallbackOriginForCustomHostnamesResponse>;

export const deleteFallbackOriginForCustomHostnames: (
  input: DeleteFallbackOriginForCustomHostnamesRequest
) => Effect.Effect<
  DeleteFallbackOriginForCustomHostnamesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteFallbackOriginForCustomHostnamesRequest,
  output: DeleteFallbackOriginForCustomHostnamesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CustomHostnameForAZoneCustomHostnameDetailsRequest {
  custom_hostname_id: string;
  zone_id: string;
}

export const CustomHostnameForAZoneCustomHostnameDetailsRequest = Schema.Struct({
  custom_hostname_id: Schema.String.pipe(T.HttpPath("custom_hostname_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/custom_hostnames/{custom_hostname_id}" }),
).annotations({ identifier: "CustomHostnameForAZoneCustomHostnameDetailsRequest" }) as unknown as Schema.Schema<CustomHostnameForAZoneCustomHostnameDetailsRequest>;

export interface CustomHostnameForAZoneCustomHostnameDetailsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CustomHostnameForAZoneCustomHostnameDetailsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CustomHostnameForAZoneCustomHostnameDetailsResponse" }) as unknown as Schema.Schema<CustomHostnameForAZoneCustomHostnameDetailsResponse>;

export const customHostnameForAZoneCustomHostnameDetails: (
  input: CustomHostnameForAZoneCustomHostnameDetailsRequest
) => Effect.Effect<
  CustomHostnameForAZoneCustomHostnameDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CustomHostnameForAZoneCustomHostnameDetailsRequest,
  output: CustomHostnameForAZoneCustomHostnameDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteCustomHostnameAndAnyIssuedSslCertificatesRequest {
  custom_hostname_id: string;
  zone_id: string;
}

export const DeleteCustomHostnameAndAnyIssuedSslCertificatesRequest = Schema.Struct({
  custom_hostname_id: Schema.String.pipe(T.HttpPath("custom_hostname_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/custom_hostnames/{custom_hostname_id}" }),
).annotations({ identifier: "DeleteCustomHostnameAndAnyIssuedSslCertificatesRequest" }) as unknown as Schema.Schema<DeleteCustomHostnameAndAnyIssuedSslCertificatesRequest>;

export interface DeleteCustomHostnameAndAnyIssuedSslCertificatesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteCustomHostnameAndAnyIssuedSslCertificatesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteCustomHostnameAndAnyIssuedSslCertificatesResponse" }) as unknown as Schema.Schema<DeleteCustomHostnameAndAnyIssuedSslCertificatesResponse>;

export const deleteCustomHostnameAndAnyIssuedSslCertificates: (
  input: DeleteCustomHostnameAndAnyIssuedSslCertificatesRequest
) => Effect.Effect<
  DeleteCustomHostnameAndAnyIssuedSslCertificatesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteCustomHostnameAndAnyIssuedSslCertificatesRequest,
  output: DeleteCustomHostnameAndAnyIssuedSslCertificatesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CustomHostnameForAZoneEditCustomHostnameRequest {
  custom_hostname_id: string;
  zone_id: string;
  body: { custom_metadata?: Record<string, unknown>; custom_origin_server?: string; custom_origin_sni?: string; ssl?: Record<string, unknown> };
}

export const CustomHostnameForAZoneEditCustomHostnameRequest = Schema.Struct({
  custom_hostname_id: Schema.String.pipe(T.HttpPath("custom_hostname_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  custom_metadata: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  custom_origin_server: Schema.optional(Schema.String),
  custom_origin_sni: Schema.optional(Schema.String),
  ssl: Schema.optional(Schema.Struct({}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/custom_hostnames/{custom_hostname_id}" }),
).annotations({ identifier: "CustomHostnameForAZoneEditCustomHostnameRequest" }) as unknown as Schema.Schema<CustomHostnameForAZoneEditCustomHostnameRequest>;

export interface CustomHostnameForAZoneEditCustomHostnameResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CustomHostnameForAZoneEditCustomHostnameResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CustomHostnameForAZoneEditCustomHostnameResponse" }) as unknown as Schema.Schema<CustomHostnameForAZoneEditCustomHostnameResponse>;

export const customHostnameForAZoneEditCustomHostname: (
  input: CustomHostnameForAZoneEditCustomHostnameRequest
) => Effect.Effect<
  CustomHostnameForAZoneEditCustomHostnameResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CustomHostnameForAZoneEditCustomHostnameRequest,
  output: CustomHostnameForAZoneEditCustomHostnameResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CustomHostnameForAZoneEditCustomCertificateCustomHostnameRequest {
  custom_hostname_id: string;
  certificate_pack_id: string;
  certificate_id: string;
  zone_id: string;
  body: { custom_certificate: string; custom_key: string };
}

export const CustomHostnameForAZoneEditCustomCertificateCustomHostnameRequest = Schema.Struct({
  custom_hostname_id: Schema.String.pipe(T.HttpPath("custom_hostname_id")),
  certificate_pack_id: Schema.String.pipe(T.HttpPath("certificate_pack_id")),
  certificate_id: Schema.String.pipe(T.HttpPath("certificate_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  custom_certificate: Schema.String,
  custom_key: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/custom_hostnames/{custom_hostname_id}/certificate_pack/{certificate_pack_id}/certificates/{certificate_id}" }),
).annotations({ identifier: "CustomHostnameForAZoneEditCustomCertificateCustomHostnameRequest" }) as unknown as Schema.Schema<CustomHostnameForAZoneEditCustomCertificateCustomHostnameRequest>;

export interface CustomHostnameForAZoneEditCustomCertificateCustomHostnameResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CustomHostnameForAZoneEditCustomCertificateCustomHostnameResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CustomHostnameForAZoneEditCustomCertificateCustomHostnameResponse" }) as unknown as Schema.Schema<CustomHostnameForAZoneEditCustomCertificateCustomHostnameResponse>;

export const customHostnameForAZoneEditCustomCertificateCustomHostname: (
  input: CustomHostnameForAZoneEditCustomCertificateCustomHostnameRequest
) => Effect.Effect<
  CustomHostnameForAZoneEditCustomCertificateCustomHostnameResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CustomHostnameForAZoneEditCustomCertificateCustomHostnameRequest,
  output: CustomHostnameForAZoneEditCustomCertificateCustomHostnameResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteSingleCertificateAndKeyInACustomHostnameRequest {
  custom_hostname_id: string;
  certificate_pack_id: string;
  certificate_id: string;
  zone_id: string;
}

export const DeleteSingleCertificateAndKeyInACustomHostnameRequest = Schema.Struct({
  custom_hostname_id: Schema.String.pipe(T.HttpPath("custom_hostname_id")),
  certificate_pack_id: Schema.String.pipe(T.HttpPath("certificate_pack_id")),
  certificate_id: Schema.String.pipe(T.HttpPath("certificate_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/custom_hostnames/{custom_hostname_id}/certificate_pack/{certificate_pack_id}/certificates/{certificate_id}" }),
).annotations({ identifier: "DeleteSingleCertificateAndKeyInACustomHostnameRequest" }) as unknown as Schema.Schema<DeleteSingleCertificateAndKeyInACustomHostnameRequest>;

export interface DeleteSingleCertificateAndKeyInACustomHostnameResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteSingleCertificateAndKeyInACustomHostnameResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteSingleCertificateAndKeyInACustomHostnameResponse" }) as unknown as Schema.Schema<DeleteSingleCertificateAndKeyInACustomHostnameResponse>;

export const deleteSingleCertificateAndKeyInACustomHostname: (
  input: DeleteSingleCertificateAndKeyInACustomHostnameRequest
) => Effect.Effect<
  DeleteSingleCertificateAndKeyInACustomHostnameResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteSingleCertificateAndKeyInACustomHostnameRequest,
  output: DeleteSingleCertificateAndKeyInACustomHostnameResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountCustomNameserverRelatedZoneMetadataRequest {
  zone_id: string;
}

export const GetAccountCustomNameserverRelatedZoneMetadataRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/custom_ns" }),
).annotations({ identifier: "GetAccountCustomNameserverRelatedZoneMetadataRequest" }) as unknown as Schema.Schema<GetAccountCustomNameserverRelatedZoneMetadataRequest>;

export interface GetAccountCustomNameserverRelatedZoneMetadataResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountCustomNameserverRelatedZoneMetadataResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountCustomNameserverRelatedZoneMetadataResponse" }) as unknown as Schema.Schema<GetAccountCustomNameserverRelatedZoneMetadataResponse>;

export const getAccountCustomNameserverRelatedZoneMetadata: (
  input: GetAccountCustomNameserverRelatedZoneMetadataRequest
) => Effect.Effect<
  GetAccountCustomNameserverRelatedZoneMetadataResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountCustomNameserverRelatedZoneMetadataRequest,
  output: GetAccountCustomNameserverRelatedZoneMetadataResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataRequest {
  zone_id: string;
  body: { enabled?: boolean; ns_set?: number };
}

export const AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  ns_set: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/custom_ns" }),
).annotations({ identifier: "AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataRequest" }) as unknown as Schema.Schema<AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataRequest>;

export interface AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataResponse {
  result: string[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataResponse = Schema.Struct({
  result: Schema.Array(Schema.String),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataResponse" }) as unknown as Schema.Schema<AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataResponse>;

export const accountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadata: (
  input: AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataRequest
) => Effect.Effect<
  AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataRequest,
  output: AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_2Request {
  zone_id: string;
}

export const Get_2Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/dcv_delegation/uuid" }),
).annotations({ identifier: "Get_2Request" }) as unknown as Schema.Schema<Get_2Request>;

export interface Get_2Response {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_2Response = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_2Response" }) as unknown as Schema.Schema<Get_2Response>;

export const get_2: (
  input: Get_2Request
) => Effect.Effect<
  Get_2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_2Request,
  output: Get_2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetPolicyCertificatesRequest {
  zone_id: unknown;
}

export const GetPolicyCertificatesRequest = Schema.Struct({
  zone_id: Schema.Unknown.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/devices/policy/certificates" }),
).annotations({ identifier: "GetPolicyCertificatesRequest" }) as unknown as Schema.Schema<GetPolicyCertificatesRequest>;

export interface GetPolicyCertificatesResponse {
  result: { enabled: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetPolicyCertificatesResponse = Schema.Struct({
  result: Schema.Struct({
  enabled: Schema.Boolean
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetPolicyCertificatesResponse" }) as unknown as Schema.Schema<GetPolicyCertificatesResponse>;

export const getPolicyCertificates: (
  input: GetPolicyCertificatesRequest
) => Effect.Effect<
  GetPolicyCertificatesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetPolicyCertificatesRequest,
  output: GetPolicyCertificatesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatePolicyCertificatesRequest {
  zone_id: unknown;
  body: { enabled: boolean };
}

export const UpdatePolicyCertificatesRequest = Schema.Struct({
  zone_id: Schema.Unknown.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  enabled: Schema.Boolean
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/devices/policy/certificates" }),
).annotations({ identifier: "UpdatePolicyCertificatesRequest" }) as unknown as Schema.Schema<UpdatePolicyCertificatesRequest>;

export interface UpdatePolicyCertificatesResponse {
  result: { enabled: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatePolicyCertificatesResponse = Schema.Struct({
  result: Schema.Struct({
  enabled: Schema.Boolean
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatePolicyCertificatesResponse" }) as unknown as Schema.Schema<UpdatePolicyCertificatesResponse>;

export const updatePolicyCertificates: (
  input: UpdatePolicyCertificatesRequest
) => Effect.Effect<
  UpdatePolicyCertificatesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatePolicyCertificatesRequest,
  output: UpdatePolicyCertificatesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DnsAnalyticsTableRequest {
  zone_id: string;
  metrics?: string;
  dimensions?: string;
  since?: string;
  until?: string;
  limit?: number;
  sort?: string;
  filters?: string;
}

export const DnsAnalyticsTableRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  metrics: Schema.optional(Schema.String).pipe(T.HttpQuery("metrics")),
  dimensions: Schema.optional(Schema.String).pipe(T.HttpQuery("dimensions")),
  since: Schema.optional(Schema.Date).pipe(T.HttpQuery("since")),
  until: Schema.optional(Schema.Date).pipe(T.HttpQuery("until")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  sort: Schema.optional(Schema.String).pipe(T.HttpQuery("sort")),
  filters: Schema.optional(Schema.String).pipe(T.HttpQuery("filters"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/dns_analytics/report" }),
).annotations({ identifier: "DnsAnalyticsTableRequest" }) as unknown as Schema.Schema<DnsAnalyticsTableRequest>;

export interface DnsAnalyticsTableResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DnsAnalyticsTableResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DnsAnalyticsTableResponse" }) as unknown as Schema.Schema<DnsAnalyticsTableResponse>;

export const dnsAnalyticsTable: (
  input: DnsAnalyticsTableRequest
) => Effect.Effect<
  DnsAnalyticsTableResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DnsAnalyticsTableRequest,
  output: DnsAnalyticsTableResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DnsAnalyticsByTimeRequest {
  zone_id: string;
  metrics?: string;
  dimensions?: string;
  since?: string;
  until?: string;
  limit?: number;
  sort?: string;
  filters?: string;
  time_delta?: "all" | "auto" | "year" | "quarter" | "month" | "week" | "day" | "hour" | "dekaminute" | "minute";
}

export const DnsAnalyticsByTimeRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  metrics: Schema.optional(Schema.String).pipe(T.HttpQuery("metrics")),
  dimensions: Schema.optional(Schema.String).pipe(T.HttpQuery("dimensions")),
  since: Schema.optional(Schema.Date).pipe(T.HttpQuery("since")),
  until: Schema.optional(Schema.Date).pipe(T.HttpQuery("until")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  sort: Schema.optional(Schema.String).pipe(T.HttpQuery("sort")),
  filters: Schema.optional(Schema.String).pipe(T.HttpQuery("filters")),
  time_delta: Schema.optional(Schema.Literal("all", "auto", "year", "quarter", "month", "week", "day", "hour", "dekaminute", "minute")).pipe(T.HttpQuery("time_delta"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/dns_analytics/report/bytime" }),
).annotations({ identifier: "DnsAnalyticsByTimeRequest" }) as unknown as Schema.Schema<DnsAnalyticsByTimeRequest>;

export interface DnsAnalyticsByTimeResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DnsAnalyticsByTimeResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DnsAnalyticsByTimeResponse" }) as unknown as Schema.Schema<DnsAnalyticsByTimeResponse>;

export const dnsAnalyticsByTime: (
  input: DnsAnalyticsByTimeRequest
) => Effect.Effect<
  DnsAnalyticsByTimeResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DnsAnalyticsByTimeRequest,
  output: DnsAnalyticsByTimeResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDnsSettingsRequest {
  zone_id: string;
}

export const ListDnsSettingsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/dns_settings" }),
).annotations({ identifier: "ListDnsSettingsRequest" }) as unknown as Schema.Schema<ListDnsSettingsRequest>;

export interface ListDnsSettingsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDnsSettingsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDnsSettingsResponse" }) as unknown as Schema.Schema<ListDnsSettingsResponse>;

export const listDnsSettings: (
  input: ListDnsSettingsRequest
) => Effect.Effect<
  ListDnsSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDnsSettingsRequest,
  output: ListDnsSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateDnsSettingsRequest {
  zone_id: string;
  body: Record<string, unknown>;
}

export const UpdateDnsSettingsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/dns_settings" }),
).annotations({ identifier: "UpdateDnsSettingsRequest" }) as unknown as Schema.Schema<UpdateDnsSettingsRequest>;

export interface UpdateDnsSettingsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateDnsSettingsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateDnsSettingsResponse" }) as unknown as Schema.Schema<UpdateDnsSettingsResponse>;

export const updateDnsSettings: (
  input: UpdateDnsSettingsRequest
) => Effect.Effect<
  UpdateDnsSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDnsSettingsRequest,
  output: UpdateDnsSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DnssecDnssecDetailsRequest {
  zone_id: string;
}

export const DnssecDnssecDetailsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/dnssec" }),
).annotations({ identifier: "DnssecDnssecDetailsRequest" }) as unknown as Schema.Schema<DnssecDnssecDetailsRequest>;

export interface DnssecDnssecDetailsResponse {
  result: { algorithm?: string; digest?: string; digest_algorithm?: string; digest_type?: string; dnssec_multi_signer?: boolean; dnssec_presigned?: boolean; dnssec_use_nsec3?: boolean; ds?: string; flags?: number; key_tag?: number; key_type?: string; modified_on?: string; public_key?: string; status?: "active" | "pending" | "disabled" | "pending-disabled" | "error" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DnssecDnssecDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  algorithm: Schema.optional(Schema.String),
  digest: Schema.optional(Schema.String),
  digest_algorithm: Schema.optional(Schema.String),
  digest_type: Schema.optional(Schema.String),
  dnssec_multi_signer: Schema.optional(Schema.Boolean),
  dnssec_presigned: Schema.optional(Schema.Boolean),
  dnssec_use_nsec3: Schema.optional(Schema.Boolean),
  ds: Schema.optional(Schema.String),
  flags: Schema.optional(Schema.Number),
  key_tag: Schema.optional(Schema.Number),
  key_type: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  public_key: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("active", "pending", "disabled", "pending-disabled", "error"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DnssecDnssecDetailsResponse" }) as unknown as Schema.Schema<DnssecDnssecDetailsResponse>;

export const dnssecDnssecDetails: (
  input: DnssecDnssecDetailsRequest
) => Effect.Effect<
  DnssecDnssecDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DnssecDnssecDetailsRequest,
  output: DnssecDnssecDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDnssecRecordsRequest {
  zone_id: string;
}

export const DeleteDnssecRecordsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/dnssec" }),
).annotations({ identifier: "DeleteDnssecRecordsRequest" }) as unknown as Schema.Schema<DeleteDnssecRecordsRequest>;

export interface DeleteDnssecRecordsResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDnssecRecordsResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDnssecRecordsResponse" }) as unknown as Schema.Schema<DeleteDnssecRecordsResponse>;

export const deleteDnssecRecords: (
  input: DeleteDnssecRecordsRequest
) => Effect.Effect<
  DeleteDnssecRecordsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDnssecRecordsRequest,
  output: DeleteDnssecRecordsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DnssecEditDnssecStatusRequest {
  zone_id: string;
  body: { dnssec_multi_signer?: boolean; dnssec_presigned?: boolean; dnssec_use_nsec3?: boolean; status?: "active" | "disabled" };
}

export const DnssecEditDnssecStatusRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  dnssec_multi_signer: Schema.optional(Schema.Boolean),
  dnssec_presigned: Schema.optional(Schema.Boolean),
  dnssec_use_nsec3: Schema.optional(Schema.Boolean),
  status: Schema.optional(Schema.Literal("active", "disabled"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/dnssec" }),
).annotations({ identifier: "DnssecEditDnssecStatusRequest" }) as unknown as Schema.Schema<DnssecEditDnssecStatusRequest>;

export interface DnssecEditDnssecStatusResponse {
  result: { algorithm?: string; digest?: string; digest_algorithm?: string; digest_type?: string; dnssec_multi_signer?: boolean; dnssec_presigned?: boolean; dnssec_use_nsec3?: boolean; ds?: string; flags?: number; key_tag?: number; key_type?: string; modified_on?: string; public_key?: string; status?: "active" | "pending" | "disabled" | "pending-disabled" | "error" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DnssecEditDnssecStatusResponse = Schema.Struct({
  result: Schema.Struct({
  algorithm: Schema.optional(Schema.String),
  digest: Schema.optional(Schema.String),
  digest_algorithm: Schema.optional(Schema.String),
  digest_type: Schema.optional(Schema.String),
  dnssec_multi_signer: Schema.optional(Schema.Boolean),
  dnssec_presigned: Schema.optional(Schema.Boolean),
  dnssec_use_nsec3: Schema.optional(Schema.Boolean),
  ds: Schema.optional(Schema.String),
  flags: Schema.optional(Schema.Number),
  key_tag: Schema.optional(Schema.Number),
  key_type: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  public_key: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("active", "pending", "disabled", "pending-disabled", "error"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DnssecEditDnssecStatusResponse" }) as unknown as Schema.Schema<DnssecEditDnssecStatusResponse>;

export const dnssecEditDnssecStatus: (
  input: DnssecEditDnssecStatusRequest
) => Effect.Effect<
  DnssecEditDnssecStatusResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DnssecEditDnssecStatusRequest,
  output: DnssecEditDnssecStatusResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetEmailRoutingSettingsRequest {
  zone_id: string;
}

export const GetEmailRoutingSettingsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/email/routing" }),
).annotations({ identifier: "GetEmailRoutingSettingsRequest" }) as unknown as Schema.Schema<GetEmailRoutingSettingsRequest>;

export interface GetEmailRoutingSettingsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetEmailRoutingSettingsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetEmailRoutingSettingsResponse" }) as unknown as Schema.Schema<GetEmailRoutingSettingsResponse>;

export const getEmailRoutingSettings: (
  input: GetEmailRoutingSettingsRequest
) => Effect.Effect<
  GetEmailRoutingSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailRoutingSettingsRequest,
  output: GetEmailRoutingSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface EmailRoutingSettingsDisableEmailRoutingRequest {
  zone_id: string;
}

export const EmailRoutingSettingsDisableEmailRoutingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/email/routing/disable" }),
).annotations({ identifier: "EmailRoutingSettingsDisableEmailRoutingRequest" }) as unknown as Schema.Schema<EmailRoutingSettingsDisableEmailRoutingRequest>;

export interface EmailRoutingSettingsDisableEmailRoutingResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const EmailRoutingSettingsDisableEmailRoutingResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "EmailRoutingSettingsDisableEmailRoutingResponse" }) as unknown as Schema.Schema<EmailRoutingSettingsDisableEmailRoutingResponse>;

export const emailRoutingSettingsDisableEmailRouting: (
  input: EmailRoutingSettingsDisableEmailRoutingRequest
) => Effect.Effect<
  EmailRoutingSettingsDisableEmailRoutingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: EmailRoutingSettingsDisableEmailRoutingRequest,
  output: EmailRoutingSettingsDisableEmailRoutingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface EmailRoutingSettingsEmailRoutingDnsSettingsRequest {
  zone_id: string;
  subdomain?: string;
}

export const EmailRoutingSettingsEmailRoutingDnsSettingsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  subdomain: Schema.optional(Schema.String).pipe(T.HttpQuery("subdomain"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/email/routing/dns" }),
).annotations({ identifier: "EmailRoutingSettingsEmailRoutingDnsSettingsRequest" }) as unknown as Schema.Schema<EmailRoutingSettingsEmailRoutingDnsSettingsRequest>;

export interface EmailRoutingSettingsEmailRoutingDnsSettingsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const EmailRoutingSettingsEmailRoutingDnsSettingsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "EmailRoutingSettingsEmailRoutingDnsSettingsResponse" }) as unknown as Schema.Schema<EmailRoutingSettingsEmailRoutingDnsSettingsResponse>;

export const emailRoutingSettingsEmailRoutingDnsSettings: (
  input: EmailRoutingSettingsEmailRoutingDnsSettingsRequest
) => Effect.Effect<
  EmailRoutingSettingsEmailRoutingDnsSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: EmailRoutingSettingsEmailRoutingDnsSettingsRequest,
  output: EmailRoutingSettingsEmailRoutingDnsSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface EmailRoutingSettingsEnableEmailRoutingDnsRequest {
  zone_id: string;
  body: { name?: string };
}

export const EmailRoutingSettingsEnableEmailRoutingDnsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/email/routing/dns" }),
).annotations({ identifier: "EmailRoutingSettingsEnableEmailRoutingDnsRequest" }) as unknown as Schema.Schema<EmailRoutingSettingsEnableEmailRoutingDnsRequest>;

export interface EmailRoutingSettingsEnableEmailRoutingDnsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const EmailRoutingSettingsEnableEmailRoutingDnsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "EmailRoutingSettingsEnableEmailRoutingDnsResponse" }) as unknown as Schema.Schema<EmailRoutingSettingsEnableEmailRoutingDnsResponse>;

export const emailRoutingSettingsEnableEmailRoutingDns: (
  input: EmailRoutingSettingsEnableEmailRoutingDnsRequest
) => Effect.Effect<
  EmailRoutingSettingsEnableEmailRoutingDnsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: EmailRoutingSettingsEnableEmailRoutingDnsRequest,
  output: EmailRoutingSettingsEnableEmailRoutingDnsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface EmailRoutingSettingsDisableEmailRoutingDnsRequest {
  zone_id: string;
  body: { name?: string };
}

export const EmailRoutingSettingsDisableEmailRoutingDnsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/email/routing/dns" }),
).annotations({ identifier: "EmailRoutingSettingsDisableEmailRoutingDnsRequest" }) as unknown as Schema.Schema<EmailRoutingSettingsDisableEmailRoutingDnsRequest>;

export interface EmailRoutingSettingsDisableEmailRoutingDnsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const EmailRoutingSettingsDisableEmailRoutingDnsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "EmailRoutingSettingsDisableEmailRoutingDnsResponse" }) as unknown as Schema.Schema<EmailRoutingSettingsDisableEmailRoutingDnsResponse>;

export const emailRoutingSettingsDisableEmailRoutingDns: (
  input: EmailRoutingSettingsDisableEmailRoutingDnsRequest
) => Effect.Effect<
  EmailRoutingSettingsDisableEmailRoutingDnsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: EmailRoutingSettingsDisableEmailRoutingDnsRequest,
  output: EmailRoutingSettingsDisableEmailRoutingDnsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface EmailRoutingSettingsUnlockEmailRoutingDnsRequest {
  zone_id: string;
  body: { name?: string };
}

export const EmailRoutingSettingsUnlockEmailRoutingDnsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/email/routing/dns" }),
).annotations({ identifier: "EmailRoutingSettingsUnlockEmailRoutingDnsRequest" }) as unknown as Schema.Schema<EmailRoutingSettingsUnlockEmailRoutingDnsRequest>;

export interface EmailRoutingSettingsUnlockEmailRoutingDnsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const EmailRoutingSettingsUnlockEmailRoutingDnsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "EmailRoutingSettingsUnlockEmailRoutingDnsResponse" }) as unknown as Schema.Schema<EmailRoutingSettingsUnlockEmailRoutingDnsResponse>;

export const emailRoutingSettingsUnlockEmailRoutingDns: (
  input: EmailRoutingSettingsUnlockEmailRoutingDnsRequest
) => Effect.Effect<
  EmailRoutingSettingsUnlockEmailRoutingDnsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: EmailRoutingSettingsUnlockEmailRoutingDnsRequest,
  output: EmailRoutingSettingsUnlockEmailRoutingDnsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface EmailRoutingSettingsEnableEmailRoutingRequest {
  zone_id: string;
}

export const EmailRoutingSettingsEnableEmailRoutingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/email/routing/enable" }),
).annotations({ identifier: "EmailRoutingSettingsEnableEmailRoutingRequest" }) as unknown as Schema.Schema<EmailRoutingSettingsEnableEmailRoutingRequest>;

export interface EmailRoutingSettingsEnableEmailRoutingResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const EmailRoutingSettingsEnableEmailRoutingResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "EmailRoutingSettingsEnableEmailRoutingResponse" }) as unknown as Schema.Schema<EmailRoutingSettingsEnableEmailRoutingResponse>;

export const emailRoutingSettingsEnableEmailRouting: (
  input: EmailRoutingSettingsEnableEmailRoutingRequest
) => Effect.Effect<
  EmailRoutingSettingsEnableEmailRoutingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: EmailRoutingSettingsEnableEmailRoutingRequest,
  output: EmailRoutingSettingsEnableEmailRoutingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListRoutingRulesRequest {
  zone_id: string;
  page?: number;
  per_page?: number;
  enabled?: true | false;
}

export const ListRoutingRulesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  enabled: Schema.optional(Schema.Literal(true, false)).pipe(T.HttpQuery("enabled"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/email/routing/rules" }),
).annotations({ identifier: "ListRoutingRulesRequest" }) as unknown as Schema.Schema<ListRoutingRulesRequest>;

export interface ListRoutingRulesResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListRoutingRulesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListRoutingRulesResponse" }) as unknown as Schema.Schema<ListRoutingRulesResponse>;

export const listRoutingRules: (
  input: ListRoutingRulesRequest
) => Effect.Effect<
  ListRoutingRulesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListRoutingRulesRequest,
  output: ListRoutingRulesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateRoutingRuleRequest {
  zone_id: string;
  body: { actions: { type: "drop" | "forward" | "worker"; value?: string[] }[]; enabled?: true | false; matchers: { field?: "to"; type: "all" | "literal"; value?: string }[]; name?: string; priority?: number };
}

export const CreateRoutingRuleRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  actions: Schema.Array(Schema.Struct({
  type: Schema.Literal("drop", "forward", "worker"),
  value: Schema.optional(Schema.Array(Schema.String))
})),
  enabled: Schema.optional(Schema.Literal(true, false)),
  matchers: Schema.Array(Schema.Struct({
  field: Schema.optional(Schema.Literal("to")),
  type: Schema.Literal("all", "literal"),
  value: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/email/routing/rules" }),
).annotations({ identifier: "CreateRoutingRuleRequest" }) as unknown as Schema.Schema<CreateRoutingRuleRequest>;

export interface CreateRoutingRuleResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateRoutingRuleResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateRoutingRuleResponse" }) as unknown as Schema.Schema<CreateRoutingRuleResponse>;

export const createRoutingRule: (
  input: CreateRoutingRuleRequest
) => Effect.Effect<
  CreateRoutingRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateRoutingRuleRequest,
  output: CreateRoutingRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetCatchAllRuleRequest {
  zone_id: string;
}

export const GetCatchAllRuleRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/email/routing/rules/catch_all" }),
).annotations({ identifier: "GetCatchAllRuleRequest" }) as unknown as Schema.Schema<GetCatchAllRuleRequest>;

export interface GetCatchAllRuleResponse {
  result: { actions?: { type: "drop" | "forward" | "worker"; value?: string[] }[]; enabled?: true | false; id?: string; matchers?: { type: "all" }[]; name?: string; tag?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetCatchAllRuleResponse = Schema.Struct({
  result: Schema.Struct({
  actions: Schema.optional(Schema.Array(Schema.Struct({
  type: Schema.Literal("drop", "forward", "worker"),
  value: Schema.optional(Schema.Array(Schema.String))
}))),
  enabled: Schema.optional(Schema.Literal(true, false)),
  id: Schema.optional(Schema.String),
  matchers: Schema.optional(Schema.Array(Schema.Struct({
  type: Schema.Literal("all")
}))),
  name: Schema.optional(Schema.String),
  tag: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetCatchAllRuleResponse" }) as unknown as Schema.Schema<GetCatchAllRuleResponse>;

export const getCatchAllRule: (
  input: GetCatchAllRuleRequest
) => Effect.Effect<
  GetCatchAllRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCatchAllRuleRequest,
  output: GetCatchAllRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateCatchAllRuleRequest {
  zone_id: string;
  body: { actions: { type: "drop" | "forward" | "worker"; value?: string[] }[]; enabled?: true | false; matchers: { type: "all" }[]; name?: string };
}

export const UpdateCatchAllRuleRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  actions: Schema.Array(Schema.Struct({
  type: Schema.Literal("drop", "forward", "worker"),
  value: Schema.optional(Schema.Array(Schema.String))
})),
  enabled: Schema.optional(Schema.Literal(true, false)),
  matchers: Schema.Array(Schema.Struct({
  type: Schema.Literal("all")
})),
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/email/routing/rules/catch_all" }),
).annotations({ identifier: "UpdateCatchAllRuleRequest" }) as unknown as Schema.Schema<UpdateCatchAllRuleRequest>;

export interface UpdateCatchAllRuleResponse {
  result: { actions?: { type: "drop" | "forward" | "worker"; value?: string[] }[]; enabled?: true | false; id?: string; matchers?: { type: "all" }[]; name?: string; tag?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateCatchAllRuleResponse = Schema.Struct({
  result: Schema.Struct({
  actions: Schema.optional(Schema.Array(Schema.Struct({
  type: Schema.Literal("drop", "forward", "worker"),
  value: Schema.optional(Schema.Array(Schema.String))
}))),
  enabled: Schema.optional(Schema.Literal(true, false)),
  id: Schema.optional(Schema.String),
  matchers: Schema.optional(Schema.Array(Schema.Struct({
  type: Schema.Literal("all")
}))),
  name: Schema.optional(Schema.String),
  tag: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateCatchAllRuleResponse" }) as unknown as Schema.Schema<UpdateCatchAllRuleResponse>;

export const updateCatchAllRule: (
  input: UpdateCatchAllRuleRequest
) => Effect.Effect<
  UpdateCatchAllRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateCatchAllRuleRequest,
  output: UpdateCatchAllRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetRoutingRuleRequest {
  rule_identifier: string;
  zone_id: string;
}

export const GetRoutingRuleRequest = Schema.Struct({
  rule_identifier: Schema.String.pipe(T.HttpPath("rule_identifier")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/email/routing/rules/{rule_identifier}" }),
).annotations({ identifier: "GetRoutingRuleRequest" }) as unknown as Schema.Schema<GetRoutingRuleRequest>;

export interface GetRoutingRuleResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetRoutingRuleResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetRoutingRuleResponse" }) as unknown as Schema.Schema<GetRoutingRuleResponse>;

export const getRoutingRule: (
  input: GetRoutingRuleRequest
) => Effect.Effect<
  GetRoutingRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRoutingRuleRequest,
  output: GetRoutingRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateRoutingRuleRequest {
  rule_identifier: string;
  zone_id: string;
  body: { actions: { type: "drop" | "forward" | "worker"; value?: string[] }[]; enabled?: true | false; matchers: { field?: "to"; type: "all" | "literal"; value?: string }[]; name?: string; priority?: number };
}

export const UpdateRoutingRuleRequest = Schema.Struct({
  rule_identifier: Schema.String.pipe(T.HttpPath("rule_identifier")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  actions: Schema.Array(Schema.Struct({
  type: Schema.Literal("drop", "forward", "worker"),
  value: Schema.optional(Schema.Array(Schema.String))
})),
  enabled: Schema.optional(Schema.Literal(true, false)),
  matchers: Schema.Array(Schema.Struct({
  field: Schema.optional(Schema.Literal("to")),
  type: Schema.Literal("all", "literal"),
  value: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/email/routing/rules/{rule_identifier}" }),
).annotations({ identifier: "UpdateRoutingRuleRequest" }) as unknown as Schema.Schema<UpdateRoutingRuleRequest>;

export interface UpdateRoutingRuleResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateRoutingRuleResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateRoutingRuleResponse" }) as unknown as Schema.Schema<UpdateRoutingRuleResponse>;

export const updateRoutingRule: (
  input: UpdateRoutingRuleRequest
) => Effect.Effect<
  UpdateRoutingRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateRoutingRuleRequest,
  output: UpdateRoutingRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteRoutingRuleRequest {
  rule_identifier: string;
  zone_id: string;
}

export const DeleteRoutingRuleRequest = Schema.Struct({
  rule_identifier: Schema.String.pipe(T.HttpPath("rule_identifier")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/email/routing/rules/{rule_identifier}" }),
).annotations({ identifier: "DeleteRoutingRuleRequest" }) as unknown as Schema.Schema<DeleteRoutingRuleRequest>;

export interface DeleteRoutingRuleResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteRoutingRuleResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteRoutingRuleResponse" }) as unknown as Schema.Schema<DeleteRoutingRuleResponse>;

export const deleteRoutingRule: (
  input: DeleteRoutingRuleRequest
) => Effect.Effect<
  DeleteRoutingRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteRoutingRuleRequest,
  output: DeleteRoutingRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListFiltersRequest {
  zone_id: string;
  paused?: unknown;
  expression?: string;
  description?: string;
  ref?: string;
  page?: number;
  per_page?: number;
  id?: string;
}

export const ListFiltersRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  paused: Schema.optional(Schema.Union(Schema.Boolean)).pipe(T.HttpQuery("paused")),
  expression: Schema.optional(Schema.String).pipe(T.HttpQuery("expression")),
  description: Schema.optional(Schema.String).pipe(T.HttpQuery("description")),
  ref: Schema.optional(Schema.String).pipe(T.HttpQuery("ref")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  id: Schema.optional(Schema.String).pipe(T.HttpQuery("id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/filters" }),
).annotations({ identifier: "ListFiltersRequest" }) as unknown as Schema.Schema<ListFiltersRequest>;

export interface ListFiltersResponse {
  result: { description?: string; expression?: string; id?: string; paused?: boolean; ref?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListFiltersResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  expression: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  paused: Schema.optional(Schema.Boolean),
  ref: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListFiltersResponse" }) as unknown as Schema.Schema<ListFiltersResponse>;

export const listFilters: (
  input: ListFiltersRequest
) => Effect.Effect<
  ListFiltersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListFiltersRequest,
  output: ListFiltersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateFiltersRequest {
  zone_id: string;
  body: { description?: string; expression?: string; id?: string; paused?: boolean; ref?: string }[];
}

export const CreateFiltersRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  expression: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  paused: Schema.optional(Schema.Boolean),
  ref: Schema.optional(Schema.String)
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/filters" }),
).annotations({ identifier: "CreateFiltersRequest" }) as unknown as Schema.Schema<CreateFiltersRequest>;

export interface CreateFiltersResponse {
  result: { description?: string; expression?: string; id?: string; paused?: boolean; ref?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateFiltersResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  expression: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  paused: Schema.optional(Schema.Boolean),
  ref: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateFiltersResponse" }) as unknown as Schema.Schema<CreateFiltersResponse>;

export const createFilters: (
  input: CreateFiltersRequest
) => Effect.Effect<
  CreateFiltersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateFiltersRequest,
  output: CreateFiltersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateFiltersRequest {
  zone_id: string;
  body: unknown[];
}

export const UpdateFiltersRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String)
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/filters" }),
).annotations({ identifier: "UpdateFiltersRequest" }) as unknown as Schema.Schema<UpdateFiltersRequest>;

export interface UpdateFiltersResponse {
  result: { description?: string; expression?: string; id?: string; paused?: boolean; ref?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateFiltersResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  expression: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  paused: Schema.optional(Schema.Boolean),
  ref: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateFiltersResponse" }) as unknown as Schema.Schema<UpdateFiltersResponse>;

export const updateFilters: (
  input: UpdateFiltersRequest
) => Effect.Effect<
  UpdateFiltersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateFiltersRequest,
  output: UpdateFiltersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteFiltersRequest {
  zone_id: string;
  id: string[];
}

export const DeleteFiltersRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  id: Schema.Array(Schema.String).pipe(T.HttpQuery("id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/filters" }),
).annotations({ identifier: "DeleteFiltersRequest" }) as unknown as Schema.Schema<DeleteFiltersRequest>;

export interface DeleteFiltersResponse {
  result: { id?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteFiltersResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteFiltersResponse" }) as unknown as Schema.Schema<DeleteFiltersResponse>;

export const deleteFilters: (
  input: DeleteFiltersRequest
) => Effect.Effect<
  DeleteFiltersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteFiltersRequest,
  output: DeleteFiltersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAFilterRequest {
  filter_id: string;
  zone_id: string;
}

export const GetAFilterRequest = Schema.Struct({
  filter_id: Schema.String.pipe(T.HttpPath("filter_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/filters/{filter_id}" }),
).annotations({ identifier: "GetAFilterRequest" }) as unknown as Schema.Schema<GetAFilterRequest>;

export interface GetAFilterResponse {
  result: { description?: string; expression?: string; id?: string; paused?: boolean; ref?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAFilterResponse = Schema.Struct({
  result: Schema.Struct({
  description: Schema.optional(Schema.String),
  expression: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  paused: Schema.optional(Schema.Boolean),
  ref: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAFilterResponse" }) as unknown as Schema.Schema<GetAFilterResponse>;

export const getAFilter: (
  input: GetAFilterRequest
) => Effect.Effect<
  GetAFilterResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAFilterRequest,
  output: GetAFilterResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAFilterRequest {
  filter_id: string;
  zone_id: string;
  body: { description?: string; expression?: string; id?: string; paused?: boolean; ref?: string };
}

export const UpdateAFilterRequest = Schema.Struct({
  filter_id: Schema.String.pipe(T.HttpPath("filter_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  expression: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  paused: Schema.optional(Schema.Boolean),
  ref: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/filters/{filter_id}" }),
).annotations({ identifier: "UpdateAFilterRequest" }) as unknown as Schema.Schema<UpdateAFilterRequest>;

export interface UpdateAFilterResponse {
  result: { description?: string; expression?: string; id?: string; paused?: boolean; ref?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAFilterResponse = Schema.Struct({
  result: Schema.Struct({
  description: Schema.optional(Schema.String),
  expression: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  paused: Schema.optional(Schema.Boolean),
  ref: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAFilterResponse" }) as unknown as Schema.Schema<UpdateAFilterResponse>;

export const updateAFilter: (
  input: UpdateAFilterRequest
) => Effect.Effect<
  UpdateAFilterResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAFilterRequest,
  output: UpdateAFilterResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAFilterRequest {
  filter_id: string;
  zone_id: string;
}

export const DeleteAFilterRequest = Schema.Struct({
  filter_id: Schema.String.pipe(T.HttpPath("filter_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/filters/{filter_id}" }),
).annotations({ identifier: "DeleteAFilterRequest" }) as unknown as Schema.Schema<DeleteAFilterRequest>;

export interface DeleteAFilterResponse {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAFilterResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAFilterResponse" }) as unknown as Schema.Schema<DeleteAFilterResponse>;

export const deleteAFilter: (
  input: DeleteAFilterRequest
) => Effect.Effect<
  DeleteAFilterResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAFilterRequest,
  output: DeleteAFilterResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListHealthChecksRequest {
  zone_id: string;
}

export const ListHealthChecksRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/healthchecks" }),
).annotations({ identifier: "ListHealthChecksRequest" }) as unknown as Schema.Schema<ListHealthChecksRequest>;

export interface ListHealthChecksResponse {
  result: { address?: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; created_on?: string; description?: string; failure_reason?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; id?: string; interval?: number; modified_on?: string; name?: string; retries?: number; status?: "unknown" | "healthy" | "unhealthy" | "suspended"; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListHealthChecksResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  address: Schema.optional(Schema.String),
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  failure_reason: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("unknown", "healthy", "unhealthy", "suspended")),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListHealthChecksResponse" }) as unknown as Schema.Schema<ListHealthChecksResponse>;

export const listHealthChecks: (
  input: ListHealthChecksRequest
) => Effect.Effect<
  ListHealthChecksResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListHealthChecksRequest,
  output: ListHealthChecksResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateHealthCheckRequest {
  zone_id: string;
  body: { address: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; description?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; interval?: number; name: string; retries?: number; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string };
}

export const CreateHealthCheckRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  address: Schema.String,
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  description: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  interval: Schema.optional(Schema.Number),
  name: Schema.String,
  retries: Schema.optional(Schema.Number),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/healthchecks" }),
).annotations({ identifier: "CreateHealthCheckRequest" }) as unknown as Schema.Schema<CreateHealthCheckRequest>;

export interface CreateHealthCheckResponse {
  result: { address?: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; created_on?: string; description?: string; failure_reason?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; id?: string; interval?: number; modified_on?: string; name?: string; retries?: number; status?: "unknown" | "healthy" | "unhealthy" | "suspended"; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateHealthCheckResponse = Schema.Struct({
  result: Schema.Struct({
  address: Schema.optional(Schema.String),
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  failure_reason: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("unknown", "healthy", "unhealthy", "suspended")),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateHealthCheckResponse" }) as unknown as Schema.Schema<CreateHealthCheckResponse>;

export const createHealthCheck: (
  input: CreateHealthCheckRequest
) => Effect.Effect<
  CreateHealthCheckResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateHealthCheckRequest,
  output: CreateHealthCheckResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatePreviewHealthCheckRequest {
  zone_id: string;
  body: { address: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; description?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; interval?: number; name: string; retries?: number; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string };
}

export const CreatePreviewHealthCheckRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  address: Schema.String,
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  description: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  interval: Schema.optional(Schema.Number),
  name: Schema.String,
  retries: Schema.optional(Schema.Number),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/healthchecks/preview" }),
).annotations({ identifier: "CreatePreviewHealthCheckRequest" }) as unknown as Schema.Schema<CreatePreviewHealthCheckRequest>;

export interface CreatePreviewHealthCheckResponse {
  result: { address?: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; created_on?: string; description?: string; failure_reason?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; id?: string; interval?: number; modified_on?: string; name?: string; retries?: number; status?: "unknown" | "healthy" | "unhealthy" | "suspended"; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatePreviewHealthCheckResponse = Schema.Struct({
  result: Schema.Struct({
  address: Schema.optional(Schema.String),
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  failure_reason: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("unknown", "healthy", "unhealthy", "suspended")),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatePreviewHealthCheckResponse" }) as unknown as Schema.Schema<CreatePreviewHealthCheckResponse>;

export const createPreviewHealthCheck: (
  input: CreatePreviewHealthCheckRequest
) => Effect.Effect<
  CreatePreviewHealthCheckResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatePreviewHealthCheckRequest,
  output: CreatePreviewHealthCheckResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface HealthChecksHealthCheckPreviewDetailsRequest {
  healthcheck_id: string;
  zone_id: string;
}

export const HealthChecksHealthCheckPreviewDetailsRequest = Schema.Struct({
  healthcheck_id: Schema.String.pipe(T.HttpPath("healthcheck_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/healthchecks/preview/{healthcheck_id}" }),
).annotations({ identifier: "HealthChecksHealthCheckPreviewDetailsRequest" }) as unknown as Schema.Schema<HealthChecksHealthCheckPreviewDetailsRequest>;

export interface HealthChecksHealthCheckPreviewDetailsResponse {
  result: { address?: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; created_on?: string; description?: string; failure_reason?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; id?: string; interval?: number; modified_on?: string; name?: string; retries?: number; status?: "unknown" | "healthy" | "unhealthy" | "suspended"; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const HealthChecksHealthCheckPreviewDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  address: Schema.optional(Schema.String),
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  failure_reason: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("unknown", "healthy", "unhealthy", "suspended")),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "HealthChecksHealthCheckPreviewDetailsResponse" }) as unknown as Schema.Schema<HealthChecksHealthCheckPreviewDetailsResponse>;

export const healthChecksHealthCheckPreviewDetails: (
  input: HealthChecksHealthCheckPreviewDetailsRequest
) => Effect.Effect<
  HealthChecksHealthCheckPreviewDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: HealthChecksHealthCheckPreviewDetailsRequest,
  output: HealthChecksHealthCheckPreviewDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletePreviewHealthCheckRequest {
  healthcheck_id: string;
  zone_id: string;
}

export const DeletePreviewHealthCheckRequest = Schema.Struct({
  healthcheck_id: Schema.String.pipe(T.HttpPath("healthcheck_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/healthchecks/preview/{healthcheck_id}" }),
).annotations({ identifier: "DeletePreviewHealthCheckRequest" }) as unknown as Schema.Schema<DeletePreviewHealthCheckRequest>;

export interface DeletePreviewHealthCheckResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletePreviewHealthCheckResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletePreviewHealthCheckResponse" }) as unknown as Schema.Schema<DeletePreviewHealthCheckResponse>;

export const deletePreviewHealthCheck: (
  input: DeletePreviewHealthCheckRequest
) => Effect.Effect<
  DeletePreviewHealthCheckResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletePreviewHealthCheckRequest,
  output: DeletePreviewHealthCheckResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface HealthChecksHealthCheckDetailsRequest {
  healthcheck_id: string;
  zone_id: string;
}

export const HealthChecksHealthCheckDetailsRequest = Schema.Struct({
  healthcheck_id: Schema.String.pipe(T.HttpPath("healthcheck_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/healthchecks/{healthcheck_id}" }),
).annotations({ identifier: "HealthChecksHealthCheckDetailsRequest" }) as unknown as Schema.Schema<HealthChecksHealthCheckDetailsRequest>;

export interface HealthChecksHealthCheckDetailsResponse {
  result: { address?: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; created_on?: string; description?: string; failure_reason?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; id?: string; interval?: number; modified_on?: string; name?: string; retries?: number; status?: "unknown" | "healthy" | "unhealthy" | "suspended"; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const HealthChecksHealthCheckDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  address: Schema.optional(Schema.String),
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  failure_reason: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("unknown", "healthy", "unhealthy", "suspended")),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "HealthChecksHealthCheckDetailsResponse" }) as unknown as Schema.Schema<HealthChecksHealthCheckDetailsResponse>;

export const healthChecksHealthCheckDetails: (
  input: HealthChecksHealthCheckDetailsRequest
) => Effect.Effect<
  HealthChecksHealthCheckDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: HealthChecksHealthCheckDetailsRequest,
  output: HealthChecksHealthCheckDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateHealthCheckRequest {
  healthcheck_id: string;
  zone_id: string;
  body: { address: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; description?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; interval?: number; name: string; retries?: number; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string };
}

export const UpdateHealthCheckRequest = Schema.Struct({
  healthcheck_id: Schema.String.pipe(T.HttpPath("healthcheck_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  address: Schema.String,
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  description: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  interval: Schema.optional(Schema.Number),
  name: Schema.String,
  retries: Schema.optional(Schema.Number),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/healthchecks/{healthcheck_id}" }),
).annotations({ identifier: "UpdateHealthCheckRequest" }) as unknown as Schema.Schema<UpdateHealthCheckRequest>;

export interface UpdateHealthCheckResponse {
  result: { address?: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; created_on?: string; description?: string; failure_reason?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; id?: string; interval?: number; modified_on?: string; name?: string; retries?: number; status?: "unknown" | "healthy" | "unhealthy" | "suspended"; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateHealthCheckResponse = Schema.Struct({
  result: Schema.Struct({
  address: Schema.optional(Schema.String),
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  failure_reason: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("unknown", "healthy", "unhealthy", "suspended")),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateHealthCheckResponse" }) as unknown as Schema.Schema<UpdateHealthCheckResponse>;

export const updateHealthCheck: (
  input: UpdateHealthCheckRequest
) => Effect.Effect<
  UpdateHealthCheckResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateHealthCheckRequest,
  output: UpdateHealthCheckResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteHealthCheckRequest {
  healthcheck_id: string;
  zone_id: string;
}

export const DeleteHealthCheckRequest = Schema.Struct({
  healthcheck_id: Schema.String.pipe(T.HttpPath("healthcheck_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/healthchecks/{healthcheck_id}" }),
).annotations({ identifier: "DeleteHealthCheckRequest" }) as unknown as Schema.Schema<DeleteHealthCheckRequest>;

export interface DeleteHealthCheckResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteHealthCheckResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteHealthCheckResponse" }) as unknown as Schema.Schema<DeleteHealthCheckResponse>;

export const deleteHealthCheck: (
  input: DeleteHealthCheckRequest
) => Effect.Effect<
  DeleteHealthCheckResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteHealthCheckRequest,
  output: DeleteHealthCheckResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchHealthCheckRequest {
  healthcheck_id: string;
  zone_id: string;
  body: { address: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; description?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; interval?: number; name: string; retries?: number; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string };
}

export const PatchHealthCheckRequest = Schema.Struct({
  healthcheck_id: Schema.String.pipe(T.HttpPath("healthcheck_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  address: Schema.String,
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  description: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  interval: Schema.optional(Schema.Number),
  name: Schema.String,
  retries: Schema.optional(Schema.Number),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/healthchecks/{healthcheck_id}" }),
).annotations({ identifier: "PatchHealthCheckRequest" }) as unknown as Schema.Schema<PatchHealthCheckRequest>;

export interface PatchHealthCheckResponse {
  result: { address?: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; created_on?: string; description?: string; failure_reason?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; id?: string; interval?: number; modified_on?: string; name?: string; retries?: number; status?: "unknown" | "healthy" | "unhealthy" | "suspended"; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchHealthCheckResponse = Schema.Struct({
  result: Schema.Struct({
  address: Schema.optional(Schema.String),
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  failure_reason: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("unknown", "healthy", "unhealthy", "suspended")),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchHealthCheckResponse" }) as unknown as Schema.Schema<PatchHealthCheckResponse>;

export const patchHealthCheck: (
  input: PatchHealthCheckRequest
) => Effect.Effect<
  PatchHealthCheckResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchHealthCheckRequest,
  output: PatchHealthCheckResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_3Request {
  zone_id: string;
}

export const Get_3Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/hold" }),
).annotations({ identifier: "Get_3Request" }) as unknown as Schema.Schema<Get_3Request>;

export interface Get_3Response {
  result: { hold?: boolean; hold_after?: string; include_subdomains?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_3Response = Schema.Struct({
  result: Schema.Struct({
  hold: Schema.optional(Schema.Boolean),
  hold_after: Schema.optional(Schema.String),
  include_subdomains: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_3Response" }) as unknown as Schema.Schema<Get_3Response>;

export const get_3: (
  input: Get_3Request
) => Effect.Effect<
  Get_3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_3Request,
  output: Get_3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Post1Request {
  zone_id: string;
  include_subdomains?: boolean;
}

export const Post1Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  include_subdomains: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("include_subdomains"))
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/hold" }),
).annotations({ identifier: "Post1Request" }) as unknown as Schema.Schema<Post1Request>;

export interface Post1Response {
  result: { hold?: boolean; hold_after?: string; include_subdomains?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Post1Response = Schema.Struct({
  result: Schema.Struct({
  hold: Schema.optional(Schema.Boolean),
  hold_after: Schema.optional(Schema.String),
  include_subdomains: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Post1Response" }) as unknown as Schema.Schema<Post1Response>;

export const post1: (
  input: Post1Request
) => Effect.Effect<
  Post1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Post1Request,
  output: Post1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_2Request {
  zone_id: string;
  hold_after?: string;
}

export const Delete_2Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  hold_after: Schema.optional(Schema.String).pipe(T.HttpQuery("hold_after"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/hold" }),
).annotations({ identifier: "Delete_2Request" }) as unknown as Schema.Schema<Delete_2Request>;

export interface Delete_2Response {
  result: { hold?: boolean; hold_after?: string; include_subdomains?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_2Response = Schema.Struct({
  result: Schema.Struct({
  hold: Schema.optional(Schema.Boolean),
  hold_after: Schema.optional(Schema.String),
  include_subdomains: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_2Response" }) as unknown as Schema.Schema<Delete_2Response>;

export const delete_2: (
  input: Delete_2Request
) => Effect.Effect<
  Delete_2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_2Request,
  output: Delete_2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Patch1Request {
  zone_id: string;
  body: { hold_after?: string; include_subdomains?: boolean };
}

export const Patch1Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  hold_after: Schema.optional(Schema.String),
  include_subdomains: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/hold" }),
).annotations({ identifier: "Patch1Request" }) as unknown as Schema.Schema<Patch1Request>;

export interface Patch1Response {
  result: { hold?: boolean; hold_after?: string; include_subdomains?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Patch1Response = Schema.Struct({
  result: Schema.Struct({
  hold: Schema.optional(Schema.Boolean),
  hold_after: Schema.optional(Schema.String),
  include_subdomains: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Patch1Response" }) as unknown as Schema.Schema<Patch1Response>;

export const patch1: (
  input: Patch1Request
) => Effect.Effect<
  Patch1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Patch1Request,
  output: Patch1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List1Request {
  zone_id: string;
  setting_id: "ciphers" | "min_tls_version" | "http2";
}

export const List1Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  setting_id: Schema.Literal("ciphers", "min_tls_version", "http2").pipe(T.HttpPath("setting_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/hostnames/settings/{setting_id}" }),
).annotations({ identifier: "List1Request" }) as unknown as Schema.Schema<List1Request>;

export interface List1Response {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List1Response = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List1Response" }) as unknown as Schema.Schema<List1Response>;

export const list1: (
  input: List1Request
) => Effect.Effect<
  List1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List1Request,
  output: List1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_4Request {
  zone_id: string;
  setting_id: "ciphers" | "min_tls_version" | "http2";
  hostname: string;
  body: { value: unknown };
}

export const Get_4Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  setting_id: Schema.Literal("ciphers", "min_tls_version", "http2").pipe(T.HttpPath("setting_id")),
  hostname: Schema.String.pipe(T.HttpPath("hostname")),
  body: Schema.Struct({
  value: Schema.Union(Schema.Number, Schema.String, Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/hostnames/settings/{setting_id}/{hostname}" }),
).annotations({ identifier: "Get_4Request" }) as unknown as Schema.Schema<Get_4Request>;

export interface Get_4Response {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_4Response = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_4Response" }) as unknown as Schema.Schema<Get_4Response>;

export const get_4: (
  input: Get_4Request
) => Effect.Effect<
  Get_4Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_4Request,
  output: Get_4Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Put1Request {
  zone_id: string;
  setting_id: "ciphers" | "min_tls_version" | "http2";
  hostname: string;
  body: { value: unknown };
}

export const Put1Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  setting_id: Schema.Literal("ciphers", "min_tls_version", "http2").pipe(T.HttpPath("setting_id")),
  hostname: Schema.String.pipe(T.HttpPath("hostname")),
  body: Schema.Struct({
  value: Schema.Union(Schema.Number, Schema.String, Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/hostnames/settings/{setting_id}/{hostname}" }),
).annotations({ identifier: "Put1Request" }) as unknown as Schema.Schema<Put1Request>;

export interface Put1Response {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Put1Response = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Put1Response" }) as unknown as Schema.Schema<Put1Response>;

export const put1: (
  input: Put1Request
) => Effect.Effect<
  Put1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Put1Request,
  output: Put1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_3Request {
  zone_id: string;
  setting_id: "ciphers" | "min_tls_version" | "http2";
  hostname: string;
}

export const Delete_3Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  setting_id: Schema.Literal("ciphers", "min_tls_version", "http2").pipe(T.HttpPath("setting_id")),
  hostname: Schema.String.pipe(T.HttpPath("hostname"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/hostnames/settings/{setting_id}/{hostname}" }),
).annotations({ identifier: "Delete_3Request" }) as unknown as Schema.Schema<Delete_3Request>;

export interface Delete_3Response {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_3Response = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_3Response" }) as unknown as Schema.Schema<Delete_3Response>;

export const delete_3: (
  input: Delete_3Request
) => Effect.Effect<
  Delete_3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_3Request,
  output: Delete_3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListKeylessSslConfigurationsRequest {
  zone_id: string;
}

export const ListKeylessSslConfigurationsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/keyless_certificates" }),
).annotations({ identifier: "ListKeylessSslConfigurationsRequest" }) as unknown as Schema.Schema<ListKeylessSslConfigurationsRequest>;

export interface ListKeylessSslConfigurationsResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListKeylessSslConfigurationsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListKeylessSslConfigurationsResponse" }) as unknown as Schema.Schema<ListKeylessSslConfigurationsResponse>;

export const listKeylessSslConfigurations: (
  input: ListKeylessSslConfigurationsRequest
) => Effect.Effect<
  ListKeylessSslConfigurationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListKeylessSslConfigurationsRequest,
  output: ListKeylessSslConfigurationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateKeylessSslConfigurationRequest {
  zone_id: string;
  body: { bundle_method?: "ubiquitous" | "optimal" | "force"; certificate: string; host: string; name?: string; port: number; tunnel?: { private_ip: string; vnet_id: string } };
}

export const CreateKeylessSslConfigurationRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  bundle_method: Schema.optional(Schema.Literal("ubiquitous", "optimal", "force")),
  certificate: Schema.String,
  host: Schema.String,
  name: Schema.optional(Schema.String),
  port: Schema.Number,
  tunnel: Schema.optional(Schema.Struct({
  private_ip: Schema.String,
  vnet_id: Schema.String
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/keyless_certificates" }),
).annotations({ identifier: "CreateKeylessSslConfigurationRequest" }) as unknown as Schema.Schema<CreateKeylessSslConfigurationRequest>;

export interface CreateKeylessSslConfigurationResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateKeylessSslConfigurationResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateKeylessSslConfigurationResponse" }) as unknown as Schema.Schema<CreateKeylessSslConfigurationResponse>;

export const createKeylessSslConfiguration: (
  input: CreateKeylessSslConfigurationRequest
) => Effect.Effect<
  CreateKeylessSslConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateKeylessSslConfigurationRequest,
  output: CreateKeylessSslConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetKeylessSslConfigurationRequest {
  keyless_certificate_id: string;
  zone_id: string;
}

export const GetKeylessSslConfigurationRequest = Schema.Struct({
  keyless_certificate_id: Schema.String.pipe(T.HttpPath("keyless_certificate_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/keyless_certificates/{keyless_certificate_id}" }),
).annotations({ identifier: "GetKeylessSslConfigurationRequest" }) as unknown as Schema.Schema<GetKeylessSslConfigurationRequest>;

export interface GetKeylessSslConfigurationResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetKeylessSslConfigurationResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetKeylessSslConfigurationResponse" }) as unknown as Schema.Schema<GetKeylessSslConfigurationResponse>;

export const getKeylessSslConfiguration: (
  input: GetKeylessSslConfigurationRequest
) => Effect.Effect<
  GetKeylessSslConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetKeylessSslConfigurationRequest,
  output: GetKeylessSslConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteKeylessSslConfigurationRequest {
  keyless_certificate_id: string;
  zone_id: string;
}

export const DeleteKeylessSslConfigurationRequest = Schema.Struct({
  keyless_certificate_id: Schema.String.pipe(T.HttpPath("keyless_certificate_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/keyless_certificates/{keyless_certificate_id}" }),
).annotations({ identifier: "DeleteKeylessSslConfigurationRequest" }) as unknown as Schema.Schema<DeleteKeylessSslConfigurationRequest>;

export interface DeleteKeylessSslConfigurationResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteKeylessSslConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteKeylessSslConfigurationResponse" }) as unknown as Schema.Schema<DeleteKeylessSslConfigurationResponse>;

export const deleteKeylessSslConfiguration: (
  input: DeleteKeylessSslConfigurationRequest
) => Effect.Effect<
  DeleteKeylessSslConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteKeylessSslConfigurationRequest,
  output: DeleteKeylessSslConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface KeylessSslForAZoneEditKeylessSslConfigurationRequest {
  keyless_certificate_id: string;
  zone_id: string;
  body: { enabled?: boolean; host?: string; name?: string; port?: number; tunnel?: { private_ip: string; vnet_id: string } };
}

export const KeylessSslForAZoneEditKeylessSslConfigurationRequest = Schema.Struct({
  keyless_certificate_id: Schema.String.pipe(T.HttpPath("keyless_certificate_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  host: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  tunnel: Schema.optional(Schema.Struct({
  private_ip: Schema.String,
  vnet_id: Schema.String
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/keyless_certificates/{keyless_certificate_id}" }),
).annotations({ identifier: "KeylessSslForAZoneEditKeylessSslConfigurationRequest" }) as unknown as Schema.Schema<KeylessSslForAZoneEditKeylessSslConfigurationRequest>;

export interface KeylessSslForAZoneEditKeylessSslConfigurationResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const KeylessSslForAZoneEditKeylessSslConfigurationResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "KeylessSslForAZoneEditKeylessSslConfigurationResponse" }) as unknown as Schema.Schema<KeylessSslForAZoneEditKeylessSslConfigurationResponse>;

export const keylessSslForAZoneEditKeylessSslConfiguration: (
  input: KeylessSslForAZoneEditKeylessSslConfigurationRequest
) => Effect.Effect<
  KeylessSslForAZoneEditKeylessSslConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: KeylessSslForAZoneEditKeylessSslConfigurationRequest,
  output: KeylessSslForAZoneEditKeylessSslConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetStatus1Request {
  zone_id: string;
}

export const GetStatus1Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/leaked-credential-checks" }),
).annotations({ identifier: "GetStatus1Request" }) as unknown as Schema.Schema<GetStatus1Request>;

export interface GetStatus1Response {
  result: { enabled?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetStatus1Response = Schema.Struct({
  result: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetStatus1Response" }) as unknown as Schema.Schema<GetStatus1Response>;

export const getStatus1: (
  input: GetStatus1Request
) => Effect.Effect<
  GetStatus1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetStatus1Request,
  output: GetStatus1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface WafProductApiLeakedCredentialsSetStatusRequest {
  zone_id: string;
  body: { enabled?: boolean };
}

export const WafProductApiLeakedCredentialsSetStatusRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/leaked-credential-checks" }),
).annotations({ identifier: "WafProductApiLeakedCredentialsSetStatusRequest" }) as unknown as Schema.Schema<WafProductApiLeakedCredentialsSetStatusRequest>;

export interface WafProductApiLeakedCredentialsSetStatusResponse {
  result: { enabled?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const WafProductApiLeakedCredentialsSetStatusResponse = Schema.Struct({
  result: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "WafProductApiLeakedCredentialsSetStatusResponse" }) as unknown as Schema.Schema<WafProductApiLeakedCredentialsSetStatusResponse>;

export const wafProductApiLeakedCredentialsSetStatus: (
  input: WafProductApiLeakedCredentialsSetStatusRequest
) => Effect.Effect<
  WafProductApiLeakedCredentialsSetStatusResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: WafProductApiLeakedCredentialsSetStatusRequest,
  output: WafProductApiLeakedCredentialsSetStatusResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDetectionsRequest {
  zone_id: string;
}

export const ListDetectionsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/leaked-credential-checks/detections" }),
).annotations({ identifier: "ListDetectionsRequest" }) as unknown as Schema.Schema<ListDetectionsRequest>;

export interface ListDetectionsResponse {
  result: { id?: unknown; password?: string; username?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDetectionsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String),
  password: Schema.optional(Schema.String),
  username: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDetectionsResponse" }) as unknown as Schema.Schema<ListDetectionsResponse>;

export const listDetections: (
  input: ListDetectionsRequest
) => Effect.Effect<
  ListDetectionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDetectionsRequest,
  output: ListDetectionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateDetectionRequest {
  zone_id: string;
  body: { id?: unknown; password?: string; username?: string };
}

export const CreateDetectionRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  id: Schema.optional(Schema.String),
  password: Schema.optional(Schema.String),
  username: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/leaked-credential-checks/detections" }),
).annotations({ identifier: "CreateDetectionRequest" }) as unknown as Schema.Schema<CreateDetectionRequest>;

export interface CreateDetectionResponse {
  result: { id?: unknown; password?: string; username?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateDetectionResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String),
  password: Schema.optional(Schema.String),
  username: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateDetectionResponse" }) as unknown as Schema.Schema<CreateDetectionResponse>;

export const createDetection: (
  input: CreateDetectionRequest
) => Effect.Effect<
  CreateDetectionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDetectionRequest,
  output: CreateDetectionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDetectionRequest {
  zone_id: string;
  detection_id: unknown;
}

export const GetDetectionRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  detection_id: Schema.String.pipe(T.HttpPath("detection_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/leaked-credential-checks/detections/{detection_id}" }),
).annotations({ identifier: "GetDetectionRequest" }) as unknown as Schema.Schema<GetDetectionRequest>;

export interface GetDetectionResponse {
  result: { id?: unknown; password?: string; username?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDetectionResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String),
  password: Schema.optional(Schema.String),
  username: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDetectionResponse" }) as unknown as Schema.Schema<GetDetectionResponse>;

export const getDetection: (
  input: GetDetectionRequest
) => Effect.Effect<
  GetDetectionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDetectionRequest,
  output: GetDetectionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateDetectionRequest {
  zone_id: string;
  detection_id: unknown;
  body: { id?: unknown; password?: string; username?: string };
}

export const UpdateDetectionRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  detection_id: Schema.String.pipe(T.HttpPath("detection_id")),
  body: Schema.Struct({
  id: Schema.optional(Schema.String),
  password: Schema.optional(Schema.String),
  username: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/leaked-credential-checks/detections/{detection_id}" }),
).annotations({ identifier: "UpdateDetectionRequest" }) as unknown as Schema.Schema<UpdateDetectionRequest>;

export interface UpdateDetectionResponse {
  result: { id?: unknown; password?: string; username?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateDetectionResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String),
  password: Schema.optional(Schema.String),
  username: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateDetectionResponse" }) as unknown as Schema.Schema<UpdateDetectionResponse>;

export const updateDetection: (
  input: UpdateDetectionRequest
) => Effect.Effect<
  UpdateDetectionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDetectionRequest,
  output: UpdateDetectionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDetectionRequest {
  zone_id: string;
  detection_id: unknown;
}

export const DeleteDetectionRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  detection_id: Schema.String.pipe(T.HttpPath("detection_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/leaked-credential-checks/detections/{detection_id}" }),
).annotations({ identifier: "DeleteDetectionRequest" }) as unknown as Schema.Schema<DeleteDetectionRequest>;

export interface DeleteDetectionResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDetectionResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({}), Schema.Array(Schema.Struct({})), Schema.String),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDetectionResponse" }) as unknown as Schema.Schema<DeleteDetectionResponse>;

export const deleteDetection: (
  input: DeleteDetectionRequest
) => Effect.Effect<
  DeleteDetectionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDetectionRequest,
  output: DeleteDetectionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListLoadBalancersRequest {
  zone_id: string;
}

export const ListLoadBalancersRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/load_balancers" }),
).annotations({ identifier: "ListLoadBalancersRequest" }) as unknown as Schema.Schema<ListLoadBalancersRequest>;

export interface ListLoadBalancersResponse {
  result: { adaptive_routing?: { failover_across_pools?: boolean }; country_pools?: Record<string, unknown>; created_on?: string; default_pools?: string[]; description?: string; enabled?: boolean; fallback_pool?: string; id?: string; location_strategy?: { mode?: "pop" | "resolver_ip"; prefer_ecs?: "always" | "never" | "proximity" | "geo" }; modified_on?: string; name?: string; networks?: string[]; pop_pools?: Record<string, unknown>; proxied?: boolean; random_steering?: { default_weight?: number; pool_weights?: Record<string, unknown> }; region_pools?: Record<string, unknown>; rules?: { condition?: string; disabled?: boolean; fixed_response?: { content_type?: string; location?: string; message_body?: string; status_code?: number }; name?: string; overrides?: { adaptive_routing?: { failover_across_pools?: boolean }; country_pools?: Record<string, unknown>; default_pools?: string[]; fallback_pool?: string; location_strategy?: { mode?: "pop" | "resolver_ip"; prefer_ecs?: "always" | "never" | "proximity" | "geo" }; pop_pools?: Record<string, unknown>; random_steering?: { default_weight?: number; pool_weights?: Record<string, unknown> }; region_pools?: Record<string, unknown>; session_affinity?: "none" | "cookie" | "ip_cookie" | "header"; session_affinity_attributes?: { drain_duration?: number; headers?: string[]; require_all_headers?: boolean; samesite?: "Auto" | "Lax" | "None" | "Strict"; secure?: "Auto" | "Always" | "Never"; zero_downtime_failover?: "none" | "temporary" | "sticky" }; session_affinity_ttl?: number; steering_policy?: "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | ""; ttl?: number }; priority?: number; terminates?: boolean }[]; session_affinity?: "none" | "cookie" | "ip_cookie" | "header"; session_affinity_attributes?: { drain_duration?: number; headers?: string[]; require_all_headers?: boolean; samesite?: "Auto" | "Lax" | "None" | "Strict"; secure?: "Auto" | "Always" | "Never"; zero_downtime_failover?: "none" | "temporary" | "sticky" }; session_affinity_ttl?: number; steering_policy?: "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | ""; ttl?: number; zone_name?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListLoadBalancersResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  adaptive_routing: Schema.optional(Schema.Struct({
  failover_across_pools: Schema.optional(Schema.Boolean)
})),
  country_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  created_on: Schema.optional(Schema.Date),
  default_pools: Schema.optional(Schema.Array(Schema.String)),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  fallback_pool: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  location_strategy: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.Literal("pop", "resolver_ip")),
  prefer_ecs: Schema.optional(Schema.Literal("always", "never", "proximity", "geo"))
})),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(Schema.Array(Schema.String)),
  pop_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  proxied: Schema.optional(Schema.Boolean),
  random_steering: Schema.optional(Schema.Struct({
  default_weight: Schema.optional(Schema.Number),
  pool_weights: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Number }))
})),
  region_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  rules: Schema.optional(Schema.Array(Schema.Struct({
  condition: Schema.optional(Schema.String),
  disabled: Schema.optional(Schema.Boolean),
  fixed_response: Schema.optional(Schema.Struct({
  content_type: Schema.optional(Schema.String),
  location: Schema.optional(Schema.String),
  message_body: Schema.optional(Schema.String),
  status_code: Schema.optional(Schema.Number)
})),
  name: Schema.optional(Schema.String),
  overrides: Schema.optional(Schema.Struct({
  adaptive_routing: Schema.optional(Schema.Struct({
  failover_across_pools: Schema.optional(Schema.Boolean)
})),
  country_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  default_pools: Schema.optional(Schema.Array(Schema.String)),
  fallback_pool: Schema.optional(Schema.String),
  location_strategy: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.Literal("pop", "resolver_ip")),
  prefer_ecs: Schema.optional(Schema.Literal("always", "never", "proximity", "geo"))
})),
  pop_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  random_steering: Schema.optional(Schema.Struct({
  default_weight: Schema.optional(Schema.Number),
  pool_weights: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Number }))
})),
  region_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  session_affinity: Schema.optional(Schema.Literal("none", "cookie", "ip_cookie", "header")),
  session_affinity_attributes: Schema.optional(Schema.Struct({
  drain_duration: Schema.optional(Schema.Number),
  headers: Schema.optional(Schema.Array(Schema.String)),
  require_all_headers: Schema.optional(Schema.Boolean),
  samesite: Schema.optional(Schema.Literal("Auto", "Lax", "None", "Strict")),
  secure: Schema.optional(Schema.Literal("Auto", "Always", "Never")),
  zero_downtime_failover: Schema.optional(Schema.Literal("none", "temporary", "sticky"))
})),
  session_affinity_ttl: Schema.optional(Schema.Number),
  steering_policy: Schema.optional(Schema.Literal("off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "")),
  ttl: Schema.optional(Schema.Number)
})),
  priority: Schema.optional(Schema.Number),
  terminates: Schema.optional(Schema.Boolean)
}))),
  session_affinity: Schema.optional(Schema.Literal("none", "cookie", "ip_cookie", "header")),
  session_affinity_attributes: Schema.optional(Schema.Struct({
  drain_duration: Schema.optional(Schema.Number),
  headers: Schema.optional(Schema.Array(Schema.String)),
  require_all_headers: Schema.optional(Schema.Boolean),
  samesite: Schema.optional(Schema.Literal("Auto", "Lax", "None", "Strict")),
  secure: Schema.optional(Schema.Literal("Auto", "Always", "Never")),
  zero_downtime_failover: Schema.optional(Schema.Literal("none", "temporary", "sticky"))
})),
  session_affinity_ttl: Schema.optional(Schema.Number),
  steering_policy: Schema.optional(Schema.Literal("off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "")),
  ttl: Schema.optional(Schema.Number),
  zone_name: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListLoadBalancersResponse" }) as unknown as Schema.Schema<ListLoadBalancersResponse>;

export const listLoadBalancers: (
  input: ListLoadBalancersRequest
) => Effect.Effect<
  ListLoadBalancersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListLoadBalancersRequest,
  output: ListLoadBalancersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateLoadBalancerRequest {
  zone_id: string;
  body: { adaptive_routing?: { failover_across_pools?: boolean }; country_pools?: Record<string, unknown>; default_pools: string[]; description?: string; fallback_pool: string; location_strategy?: { mode?: "pop" | "resolver_ip"; prefer_ecs?: "always" | "never" | "proximity" | "geo" }; name: string; networks?: string[]; pop_pools?: Record<string, unknown>; proxied?: boolean; random_steering?: { default_weight?: number; pool_weights?: Record<string, unknown> }; region_pools?: Record<string, unknown>; rules?: { condition?: string; disabled?: boolean; fixed_response?: { content_type?: string; location?: string; message_body?: string; status_code?: number }; name?: string; overrides?: { adaptive_routing?: { failover_across_pools?: boolean }; country_pools?: Record<string, unknown>; default_pools?: string[]; fallback_pool?: string; location_strategy?: { mode?: "pop" | "resolver_ip"; prefer_ecs?: "always" | "never" | "proximity" | "geo" }; pop_pools?: Record<string, unknown>; random_steering?: { default_weight?: number; pool_weights?: Record<string, unknown> }; region_pools?: Record<string, unknown>; session_affinity?: "none" | "cookie" | "ip_cookie" | "header"; session_affinity_attributes?: { drain_duration?: number; headers?: string[]; require_all_headers?: boolean; samesite?: "Auto" | "Lax" | "None" | "Strict"; secure?: "Auto" | "Always" | "Never"; zero_downtime_failover?: "none" | "temporary" | "sticky" }; session_affinity_ttl?: number; steering_policy?: "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | ""; ttl?: number }; priority?: number; terminates?: boolean }[]; session_affinity?: "none" | "cookie" | "ip_cookie" | "header"; session_affinity_attributes?: { drain_duration?: number; headers?: string[]; require_all_headers?: boolean; samesite?: "Auto" | "Lax" | "None" | "Strict"; secure?: "Auto" | "Always" | "Never"; zero_downtime_failover?: "none" | "temporary" | "sticky" }; session_affinity_ttl?: number; steering_policy?: "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | ""; ttl?: number };
}

export const CreateLoadBalancerRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  adaptive_routing: Schema.optional(Schema.Struct({
  failover_across_pools: Schema.optional(Schema.Boolean)
})),
  country_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  default_pools: Schema.Array(Schema.String),
  description: Schema.optional(Schema.String),
  fallback_pool: Schema.String,
  location_strategy: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.Literal("pop", "resolver_ip")),
  prefer_ecs: Schema.optional(Schema.Literal("always", "never", "proximity", "geo"))
})),
  name: Schema.String,
  networks: Schema.optional(Schema.Array(Schema.String)),
  pop_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  proxied: Schema.optional(Schema.Boolean),
  random_steering: Schema.optional(Schema.Struct({
  default_weight: Schema.optional(Schema.Number),
  pool_weights: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Number }))
})),
  region_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  rules: Schema.optional(Schema.Array(Schema.Struct({
  condition: Schema.optional(Schema.String),
  disabled: Schema.optional(Schema.Boolean),
  fixed_response: Schema.optional(Schema.Struct({
  content_type: Schema.optional(Schema.String),
  location: Schema.optional(Schema.String),
  message_body: Schema.optional(Schema.String),
  status_code: Schema.optional(Schema.Number)
})),
  name: Schema.optional(Schema.String),
  overrides: Schema.optional(Schema.Struct({
  adaptive_routing: Schema.optional(Schema.Struct({
  failover_across_pools: Schema.optional(Schema.Boolean)
})),
  country_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  default_pools: Schema.optional(Schema.Array(Schema.String)),
  fallback_pool: Schema.optional(Schema.String),
  location_strategy: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.Literal("pop", "resolver_ip")),
  prefer_ecs: Schema.optional(Schema.Literal("always", "never", "proximity", "geo"))
})),
  pop_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  random_steering: Schema.optional(Schema.Struct({
  default_weight: Schema.optional(Schema.Number),
  pool_weights: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Number }))
})),
  region_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  session_affinity: Schema.optional(Schema.Literal("none", "cookie", "ip_cookie", "header")),
  session_affinity_attributes: Schema.optional(Schema.Struct({
  drain_duration: Schema.optional(Schema.Number),
  headers: Schema.optional(Schema.Array(Schema.String)),
  require_all_headers: Schema.optional(Schema.Boolean),
  samesite: Schema.optional(Schema.Literal("Auto", "Lax", "None", "Strict")),
  secure: Schema.optional(Schema.Literal("Auto", "Always", "Never")),
  zero_downtime_failover: Schema.optional(Schema.Literal("none", "temporary", "sticky"))
})),
  session_affinity_ttl: Schema.optional(Schema.Number),
  steering_policy: Schema.optional(Schema.Literal("off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "")),
  ttl: Schema.optional(Schema.Number)
})),
  priority: Schema.optional(Schema.Number),
  terminates: Schema.optional(Schema.Boolean)
}))),
  session_affinity: Schema.optional(Schema.Literal("none", "cookie", "ip_cookie", "header")),
  session_affinity_attributes: Schema.optional(Schema.Struct({
  drain_duration: Schema.optional(Schema.Number),
  headers: Schema.optional(Schema.Array(Schema.String)),
  require_all_headers: Schema.optional(Schema.Boolean),
  samesite: Schema.optional(Schema.Literal("Auto", "Lax", "None", "Strict")),
  secure: Schema.optional(Schema.Literal("Auto", "Always", "Never")),
  zero_downtime_failover: Schema.optional(Schema.Literal("none", "temporary", "sticky"))
})),
  session_affinity_ttl: Schema.optional(Schema.Number),
  steering_policy: Schema.optional(Schema.Literal("off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "")),
  ttl: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/load_balancers" }),
).annotations({ identifier: "CreateLoadBalancerRequest" }) as unknown as Schema.Schema<CreateLoadBalancerRequest>;

export interface CreateLoadBalancerResponse {
  result: { adaptive_routing?: { failover_across_pools?: boolean }; country_pools?: Record<string, unknown>; created_on?: string; default_pools?: string[]; description?: string; enabled?: boolean; fallback_pool?: string; id?: string; location_strategy?: { mode?: "pop" | "resolver_ip"; prefer_ecs?: "always" | "never" | "proximity" | "geo" }; modified_on?: string; name?: string; networks?: string[]; pop_pools?: Record<string, unknown>; proxied?: boolean; random_steering?: { default_weight?: number; pool_weights?: Record<string, unknown> }; region_pools?: Record<string, unknown>; rules?: { condition?: string; disabled?: boolean; fixed_response?: { content_type?: string; location?: string; message_body?: string; status_code?: number }; name?: string; overrides?: { adaptive_routing?: { failover_across_pools?: boolean }; country_pools?: Record<string, unknown>; default_pools?: string[]; fallback_pool?: string; location_strategy?: { mode?: "pop" | "resolver_ip"; prefer_ecs?: "always" | "never" | "proximity" | "geo" }; pop_pools?: Record<string, unknown>; random_steering?: { default_weight?: number; pool_weights?: Record<string, unknown> }; region_pools?: Record<string, unknown>; session_affinity?: "none" | "cookie" | "ip_cookie" | "header"; session_affinity_attributes?: { drain_duration?: number; headers?: string[]; require_all_headers?: boolean; samesite?: "Auto" | "Lax" | "None" | "Strict"; secure?: "Auto" | "Always" | "Never"; zero_downtime_failover?: "none" | "temporary" | "sticky" }; session_affinity_ttl?: number; steering_policy?: "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | ""; ttl?: number }; priority?: number; terminates?: boolean }[]; session_affinity?: "none" | "cookie" | "ip_cookie" | "header"; session_affinity_attributes?: { drain_duration?: number; headers?: string[]; require_all_headers?: boolean; samesite?: "Auto" | "Lax" | "None" | "Strict"; secure?: "Auto" | "Always" | "Never"; zero_downtime_failover?: "none" | "temporary" | "sticky" }; session_affinity_ttl?: number; steering_policy?: "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | ""; ttl?: number; zone_name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateLoadBalancerResponse = Schema.Struct({
  result: Schema.Struct({
  adaptive_routing: Schema.optional(Schema.Struct({
  failover_across_pools: Schema.optional(Schema.Boolean)
})),
  country_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  created_on: Schema.optional(Schema.Date),
  default_pools: Schema.optional(Schema.Array(Schema.String)),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  fallback_pool: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  location_strategy: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.Literal("pop", "resolver_ip")),
  prefer_ecs: Schema.optional(Schema.Literal("always", "never", "proximity", "geo"))
})),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(Schema.Array(Schema.String)),
  pop_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  proxied: Schema.optional(Schema.Boolean),
  random_steering: Schema.optional(Schema.Struct({
  default_weight: Schema.optional(Schema.Number),
  pool_weights: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Number }))
})),
  region_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  rules: Schema.optional(Schema.Array(Schema.Struct({
  condition: Schema.optional(Schema.String),
  disabled: Schema.optional(Schema.Boolean),
  fixed_response: Schema.optional(Schema.Struct({
  content_type: Schema.optional(Schema.String),
  location: Schema.optional(Schema.String),
  message_body: Schema.optional(Schema.String),
  status_code: Schema.optional(Schema.Number)
})),
  name: Schema.optional(Schema.String),
  overrides: Schema.optional(Schema.Struct({
  adaptive_routing: Schema.optional(Schema.Struct({
  failover_across_pools: Schema.optional(Schema.Boolean)
})),
  country_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  default_pools: Schema.optional(Schema.Array(Schema.String)),
  fallback_pool: Schema.optional(Schema.String),
  location_strategy: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.Literal("pop", "resolver_ip")),
  prefer_ecs: Schema.optional(Schema.Literal("always", "never", "proximity", "geo"))
})),
  pop_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  random_steering: Schema.optional(Schema.Struct({
  default_weight: Schema.optional(Schema.Number),
  pool_weights: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Number }))
})),
  region_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  session_affinity: Schema.optional(Schema.Literal("none", "cookie", "ip_cookie", "header")),
  session_affinity_attributes: Schema.optional(Schema.Struct({
  drain_duration: Schema.optional(Schema.Number),
  headers: Schema.optional(Schema.Array(Schema.String)),
  require_all_headers: Schema.optional(Schema.Boolean),
  samesite: Schema.optional(Schema.Literal("Auto", "Lax", "None", "Strict")),
  secure: Schema.optional(Schema.Literal("Auto", "Always", "Never")),
  zero_downtime_failover: Schema.optional(Schema.Literal("none", "temporary", "sticky"))
})),
  session_affinity_ttl: Schema.optional(Schema.Number),
  steering_policy: Schema.optional(Schema.Literal("off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "")),
  ttl: Schema.optional(Schema.Number)
})),
  priority: Schema.optional(Schema.Number),
  terminates: Schema.optional(Schema.Boolean)
}))),
  session_affinity: Schema.optional(Schema.Literal("none", "cookie", "ip_cookie", "header")),
  session_affinity_attributes: Schema.optional(Schema.Struct({
  drain_duration: Schema.optional(Schema.Number),
  headers: Schema.optional(Schema.Array(Schema.String)),
  require_all_headers: Schema.optional(Schema.Boolean),
  samesite: Schema.optional(Schema.Literal("Auto", "Lax", "None", "Strict")),
  secure: Schema.optional(Schema.Literal("Auto", "Always", "Never")),
  zero_downtime_failover: Schema.optional(Schema.Literal("none", "temporary", "sticky"))
})),
  session_affinity_ttl: Schema.optional(Schema.Number),
  steering_policy: Schema.optional(Schema.Literal("off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "")),
  ttl: Schema.optional(Schema.Number),
  zone_name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateLoadBalancerResponse" }) as unknown as Schema.Schema<CreateLoadBalancerResponse>;

export const createLoadBalancer: (
  input: CreateLoadBalancerRequest
) => Effect.Effect<
  CreateLoadBalancerResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateLoadBalancerRequest,
  output: CreateLoadBalancerResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface LoadBalancersLoadBalancerDetailsRequest {
  zone_id: string;
  load_balancer_id: string;
}

export const LoadBalancersLoadBalancerDetailsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  load_balancer_id: Schema.String.pipe(T.HttpPath("load_balancer_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/load_balancers/{load_balancer_id}" }),
).annotations({ identifier: "LoadBalancersLoadBalancerDetailsRequest" }) as unknown as Schema.Schema<LoadBalancersLoadBalancerDetailsRequest>;

export interface LoadBalancersLoadBalancerDetailsResponse {
  result: { adaptive_routing?: { failover_across_pools?: boolean }; country_pools?: Record<string, unknown>; created_on?: string; default_pools?: string[]; description?: string; enabled?: boolean; fallback_pool?: string; id?: string; location_strategy?: { mode?: "pop" | "resolver_ip"; prefer_ecs?: "always" | "never" | "proximity" | "geo" }; modified_on?: string; name?: string; networks?: string[]; pop_pools?: Record<string, unknown>; proxied?: boolean; random_steering?: { default_weight?: number; pool_weights?: Record<string, unknown> }; region_pools?: Record<string, unknown>; rules?: { condition?: string; disabled?: boolean; fixed_response?: { content_type?: string; location?: string; message_body?: string; status_code?: number }; name?: string; overrides?: { adaptive_routing?: { failover_across_pools?: boolean }; country_pools?: Record<string, unknown>; default_pools?: string[]; fallback_pool?: string; location_strategy?: { mode?: "pop" | "resolver_ip"; prefer_ecs?: "always" | "never" | "proximity" | "geo" }; pop_pools?: Record<string, unknown>; random_steering?: { default_weight?: number; pool_weights?: Record<string, unknown> }; region_pools?: Record<string, unknown>; session_affinity?: "none" | "cookie" | "ip_cookie" | "header"; session_affinity_attributes?: { drain_duration?: number; headers?: string[]; require_all_headers?: boolean; samesite?: "Auto" | "Lax" | "None" | "Strict"; secure?: "Auto" | "Always" | "Never"; zero_downtime_failover?: "none" | "temporary" | "sticky" }; session_affinity_ttl?: number; steering_policy?: "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | ""; ttl?: number }; priority?: number; terminates?: boolean }[]; session_affinity?: "none" | "cookie" | "ip_cookie" | "header"; session_affinity_attributes?: { drain_duration?: number; headers?: string[]; require_all_headers?: boolean; samesite?: "Auto" | "Lax" | "None" | "Strict"; secure?: "Auto" | "Always" | "Never"; zero_downtime_failover?: "none" | "temporary" | "sticky" }; session_affinity_ttl?: number; steering_policy?: "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | ""; ttl?: number; zone_name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const LoadBalancersLoadBalancerDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  adaptive_routing: Schema.optional(Schema.Struct({
  failover_across_pools: Schema.optional(Schema.Boolean)
})),
  country_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  created_on: Schema.optional(Schema.Date),
  default_pools: Schema.optional(Schema.Array(Schema.String)),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  fallback_pool: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  location_strategy: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.Literal("pop", "resolver_ip")),
  prefer_ecs: Schema.optional(Schema.Literal("always", "never", "proximity", "geo"))
})),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(Schema.Array(Schema.String)),
  pop_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  proxied: Schema.optional(Schema.Boolean),
  random_steering: Schema.optional(Schema.Struct({
  default_weight: Schema.optional(Schema.Number),
  pool_weights: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Number }))
})),
  region_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  rules: Schema.optional(Schema.Array(Schema.Struct({
  condition: Schema.optional(Schema.String),
  disabled: Schema.optional(Schema.Boolean),
  fixed_response: Schema.optional(Schema.Struct({
  content_type: Schema.optional(Schema.String),
  location: Schema.optional(Schema.String),
  message_body: Schema.optional(Schema.String),
  status_code: Schema.optional(Schema.Number)
})),
  name: Schema.optional(Schema.String),
  overrides: Schema.optional(Schema.Struct({
  adaptive_routing: Schema.optional(Schema.Struct({
  failover_across_pools: Schema.optional(Schema.Boolean)
})),
  country_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  default_pools: Schema.optional(Schema.Array(Schema.String)),
  fallback_pool: Schema.optional(Schema.String),
  location_strategy: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.Literal("pop", "resolver_ip")),
  prefer_ecs: Schema.optional(Schema.Literal("always", "never", "proximity", "geo"))
})),
  pop_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  random_steering: Schema.optional(Schema.Struct({
  default_weight: Schema.optional(Schema.Number),
  pool_weights: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Number }))
})),
  region_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  session_affinity: Schema.optional(Schema.Literal("none", "cookie", "ip_cookie", "header")),
  session_affinity_attributes: Schema.optional(Schema.Struct({
  drain_duration: Schema.optional(Schema.Number),
  headers: Schema.optional(Schema.Array(Schema.String)),
  require_all_headers: Schema.optional(Schema.Boolean),
  samesite: Schema.optional(Schema.Literal("Auto", "Lax", "None", "Strict")),
  secure: Schema.optional(Schema.Literal("Auto", "Always", "Never")),
  zero_downtime_failover: Schema.optional(Schema.Literal("none", "temporary", "sticky"))
})),
  session_affinity_ttl: Schema.optional(Schema.Number),
  steering_policy: Schema.optional(Schema.Literal("off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "")),
  ttl: Schema.optional(Schema.Number)
})),
  priority: Schema.optional(Schema.Number),
  terminates: Schema.optional(Schema.Boolean)
}))),
  session_affinity: Schema.optional(Schema.Literal("none", "cookie", "ip_cookie", "header")),
  session_affinity_attributes: Schema.optional(Schema.Struct({
  drain_duration: Schema.optional(Schema.Number),
  headers: Schema.optional(Schema.Array(Schema.String)),
  require_all_headers: Schema.optional(Schema.Boolean),
  samesite: Schema.optional(Schema.Literal("Auto", "Lax", "None", "Strict")),
  secure: Schema.optional(Schema.Literal("Auto", "Always", "Never")),
  zero_downtime_failover: Schema.optional(Schema.Literal("none", "temporary", "sticky"))
})),
  session_affinity_ttl: Schema.optional(Schema.Number),
  steering_policy: Schema.optional(Schema.Literal("off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "")),
  ttl: Schema.optional(Schema.Number),
  zone_name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "LoadBalancersLoadBalancerDetailsResponse" }) as unknown as Schema.Schema<LoadBalancersLoadBalancerDetailsResponse>;

export const loadBalancersLoadBalancerDetails: (
  input: LoadBalancersLoadBalancerDetailsRequest
) => Effect.Effect<
  LoadBalancersLoadBalancerDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: LoadBalancersLoadBalancerDetailsRequest,
  output: LoadBalancersLoadBalancerDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateLoadBalancerRequest {
  zone_id: string;
  load_balancer_id: string;
  body: { adaptive_routing?: { failover_across_pools?: boolean }; country_pools?: Record<string, unknown>; default_pools: string[]; description?: string; enabled?: boolean; fallback_pool: string; location_strategy?: { mode?: "pop" | "resolver_ip"; prefer_ecs?: "always" | "never" | "proximity" | "geo" }; name: string; networks?: string[]; pop_pools?: Record<string, unknown>; proxied?: boolean; random_steering?: { default_weight?: number; pool_weights?: Record<string, unknown> }; region_pools?: Record<string, unknown>; rules?: { condition?: string; disabled?: boolean; fixed_response?: { content_type?: string; location?: string; message_body?: string; status_code?: number }; name?: string; overrides?: { adaptive_routing?: { failover_across_pools?: boolean }; country_pools?: Record<string, unknown>; default_pools?: string[]; fallback_pool?: string; location_strategy?: { mode?: "pop" | "resolver_ip"; prefer_ecs?: "always" | "never" | "proximity" | "geo" }; pop_pools?: Record<string, unknown>; random_steering?: { default_weight?: number; pool_weights?: Record<string, unknown> }; region_pools?: Record<string, unknown>; session_affinity?: "none" | "cookie" | "ip_cookie" | "header"; session_affinity_attributes?: { drain_duration?: number; headers?: string[]; require_all_headers?: boolean; samesite?: "Auto" | "Lax" | "None" | "Strict"; secure?: "Auto" | "Always" | "Never"; zero_downtime_failover?: "none" | "temporary" | "sticky" }; session_affinity_ttl?: number; steering_policy?: "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | ""; ttl?: number }; priority?: number; terminates?: boolean }[]; session_affinity?: "none" | "cookie" | "ip_cookie" | "header"; session_affinity_attributes?: { drain_duration?: number; headers?: string[]; require_all_headers?: boolean; samesite?: "Auto" | "Lax" | "None" | "Strict"; secure?: "Auto" | "Always" | "Never"; zero_downtime_failover?: "none" | "temporary" | "sticky" }; session_affinity_ttl?: number; steering_policy?: "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | ""; ttl?: number };
}

export const UpdateLoadBalancerRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  load_balancer_id: Schema.String.pipe(T.HttpPath("load_balancer_id")),
  body: Schema.Struct({
  adaptive_routing: Schema.optional(Schema.Struct({
  failover_across_pools: Schema.optional(Schema.Boolean)
})),
  country_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  default_pools: Schema.Array(Schema.String),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  fallback_pool: Schema.String,
  location_strategy: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.Literal("pop", "resolver_ip")),
  prefer_ecs: Schema.optional(Schema.Literal("always", "never", "proximity", "geo"))
})),
  name: Schema.String,
  networks: Schema.optional(Schema.Array(Schema.String)),
  pop_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  proxied: Schema.optional(Schema.Boolean),
  random_steering: Schema.optional(Schema.Struct({
  default_weight: Schema.optional(Schema.Number),
  pool_weights: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Number }))
})),
  region_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  rules: Schema.optional(Schema.Array(Schema.Struct({
  condition: Schema.optional(Schema.String),
  disabled: Schema.optional(Schema.Boolean),
  fixed_response: Schema.optional(Schema.Struct({
  content_type: Schema.optional(Schema.String),
  location: Schema.optional(Schema.String),
  message_body: Schema.optional(Schema.String),
  status_code: Schema.optional(Schema.Number)
})),
  name: Schema.optional(Schema.String),
  overrides: Schema.optional(Schema.Struct({
  adaptive_routing: Schema.optional(Schema.Struct({
  failover_across_pools: Schema.optional(Schema.Boolean)
})),
  country_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  default_pools: Schema.optional(Schema.Array(Schema.String)),
  fallback_pool: Schema.optional(Schema.String),
  location_strategy: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.Literal("pop", "resolver_ip")),
  prefer_ecs: Schema.optional(Schema.Literal("always", "never", "proximity", "geo"))
})),
  pop_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  random_steering: Schema.optional(Schema.Struct({
  default_weight: Schema.optional(Schema.Number),
  pool_weights: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Number }))
})),
  region_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  session_affinity: Schema.optional(Schema.Literal("none", "cookie", "ip_cookie", "header")),
  session_affinity_attributes: Schema.optional(Schema.Struct({
  drain_duration: Schema.optional(Schema.Number),
  headers: Schema.optional(Schema.Array(Schema.String)),
  require_all_headers: Schema.optional(Schema.Boolean),
  samesite: Schema.optional(Schema.Literal("Auto", "Lax", "None", "Strict")),
  secure: Schema.optional(Schema.Literal("Auto", "Always", "Never")),
  zero_downtime_failover: Schema.optional(Schema.Literal("none", "temporary", "sticky"))
})),
  session_affinity_ttl: Schema.optional(Schema.Number),
  steering_policy: Schema.optional(Schema.Literal("off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "")),
  ttl: Schema.optional(Schema.Number)
})),
  priority: Schema.optional(Schema.Number),
  terminates: Schema.optional(Schema.Boolean)
}))),
  session_affinity: Schema.optional(Schema.Literal("none", "cookie", "ip_cookie", "header")),
  session_affinity_attributes: Schema.optional(Schema.Struct({
  drain_duration: Schema.optional(Schema.Number),
  headers: Schema.optional(Schema.Array(Schema.String)),
  require_all_headers: Schema.optional(Schema.Boolean),
  samesite: Schema.optional(Schema.Literal("Auto", "Lax", "None", "Strict")),
  secure: Schema.optional(Schema.Literal("Auto", "Always", "Never")),
  zero_downtime_failover: Schema.optional(Schema.Literal("none", "temporary", "sticky"))
})),
  session_affinity_ttl: Schema.optional(Schema.Number),
  steering_policy: Schema.optional(Schema.Literal("off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "")),
  ttl: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/load_balancers/{load_balancer_id}" }),
).annotations({ identifier: "UpdateLoadBalancerRequest" }) as unknown as Schema.Schema<UpdateLoadBalancerRequest>;

export interface UpdateLoadBalancerResponse {
  result: { adaptive_routing?: { failover_across_pools?: boolean }; country_pools?: Record<string, unknown>; created_on?: string; default_pools?: string[]; description?: string; enabled?: boolean; fallback_pool?: string; id?: string; location_strategy?: { mode?: "pop" | "resolver_ip"; prefer_ecs?: "always" | "never" | "proximity" | "geo" }; modified_on?: string; name?: string; networks?: string[]; pop_pools?: Record<string, unknown>; proxied?: boolean; random_steering?: { default_weight?: number; pool_weights?: Record<string, unknown> }; region_pools?: Record<string, unknown>; rules?: { condition?: string; disabled?: boolean; fixed_response?: { content_type?: string; location?: string; message_body?: string; status_code?: number }; name?: string; overrides?: { adaptive_routing?: { failover_across_pools?: boolean }; country_pools?: Record<string, unknown>; default_pools?: string[]; fallback_pool?: string; location_strategy?: { mode?: "pop" | "resolver_ip"; prefer_ecs?: "always" | "never" | "proximity" | "geo" }; pop_pools?: Record<string, unknown>; random_steering?: { default_weight?: number; pool_weights?: Record<string, unknown> }; region_pools?: Record<string, unknown>; session_affinity?: "none" | "cookie" | "ip_cookie" | "header"; session_affinity_attributes?: { drain_duration?: number; headers?: string[]; require_all_headers?: boolean; samesite?: "Auto" | "Lax" | "None" | "Strict"; secure?: "Auto" | "Always" | "Never"; zero_downtime_failover?: "none" | "temporary" | "sticky" }; session_affinity_ttl?: number; steering_policy?: "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | ""; ttl?: number }; priority?: number; terminates?: boolean }[]; session_affinity?: "none" | "cookie" | "ip_cookie" | "header"; session_affinity_attributes?: { drain_duration?: number; headers?: string[]; require_all_headers?: boolean; samesite?: "Auto" | "Lax" | "None" | "Strict"; secure?: "Auto" | "Always" | "Never"; zero_downtime_failover?: "none" | "temporary" | "sticky" }; session_affinity_ttl?: number; steering_policy?: "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | ""; ttl?: number; zone_name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateLoadBalancerResponse = Schema.Struct({
  result: Schema.Struct({
  adaptive_routing: Schema.optional(Schema.Struct({
  failover_across_pools: Schema.optional(Schema.Boolean)
})),
  country_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  created_on: Schema.optional(Schema.Date),
  default_pools: Schema.optional(Schema.Array(Schema.String)),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  fallback_pool: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  location_strategy: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.Literal("pop", "resolver_ip")),
  prefer_ecs: Schema.optional(Schema.Literal("always", "never", "proximity", "geo"))
})),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(Schema.Array(Schema.String)),
  pop_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  proxied: Schema.optional(Schema.Boolean),
  random_steering: Schema.optional(Schema.Struct({
  default_weight: Schema.optional(Schema.Number),
  pool_weights: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Number }))
})),
  region_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  rules: Schema.optional(Schema.Array(Schema.Struct({
  condition: Schema.optional(Schema.String),
  disabled: Schema.optional(Schema.Boolean),
  fixed_response: Schema.optional(Schema.Struct({
  content_type: Schema.optional(Schema.String),
  location: Schema.optional(Schema.String),
  message_body: Schema.optional(Schema.String),
  status_code: Schema.optional(Schema.Number)
})),
  name: Schema.optional(Schema.String),
  overrides: Schema.optional(Schema.Struct({
  adaptive_routing: Schema.optional(Schema.Struct({
  failover_across_pools: Schema.optional(Schema.Boolean)
})),
  country_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  default_pools: Schema.optional(Schema.Array(Schema.String)),
  fallback_pool: Schema.optional(Schema.String),
  location_strategy: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.Literal("pop", "resolver_ip")),
  prefer_ecs: Schema.optional(Schema.Literal("always", "never", "proximity", "geo"))
})),
  pop_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  random_steering: Schema.optional(Schema.Struct({
  default_weight: Schema.optional(Schema.Number),
  pool_weights: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Number }))
})),
  region_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  session_affinity: Schema.optional(Schema.Literal("none", "cookie", "ip_cookie", "header")),
  session_affinity_attributes: Schema.optional(Schema.Struct({
  drain_duration: Schema.optional(Schema.Number),
  headers: Schema.optional(Schema.Array(Schema.String)),
  require_all_headers: Schema.optional(Schema.Boolean),
  samesite: Schema.optional(Schema.Literal("Auto", "Lax", "None", "Strict")),
  secure: Schema.optional(Schema.Literal("Auto", "Always", "Never")),
  zero_downtime_failover: Schema.optional(Schema.Literal("none", "temporary", "sticky"))
})),
  session_affinity_ttl: Schema.optional(Schema.Number),
  steering_policy: Schema.optional(Schema.Literal("off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "")),
  ttl: Schema.optional(Schema.Number)
})),
  priority: Schema.optional(Schema.Number),
  terminates: Schema.optional(Schema.Boolean)
}))),
  session_affinity: Schema.optional(Schema.Literal("none", "cookie", "ip_cookie", "header")),
  session_affinity_attributes: Schema.optional(Schema.Struct({
  drain_duration: Schema.optional(Schema.Number),
  headers: Schema.optional(Schema.Array(Schema.String)),
  require_all_headers: Schema.optional(Schema.Boolean),
  samesite: Schema.optional(Schema.Literal("Auto", "Lax", "None", "Strict")),
  secure: Schema.optional(Schema.Literal("Auto", "Always", "Never")),
  zero_downtime_failover: Schema.optional(Schema.Literal("none", "temporary", "sticky"))
})),
  session_affinity_ttl: Schema.optional(Schema.Number),
  steering_policy: Schema.optional(Schema.Literal("off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "")),
  ttl: Schema.optional(Schema.Number),
  zone_name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateLoadBalancerResponse" }) as unknown as Schema.Schema<UpdateLoadBalancerResponse>;

export const updateLoadBalancer: (
  input: UpdateLoadBalancerRequest
) => Effect.Effect<
  UpdateLoadBalancerResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateLoadBalancerRequest,
  output: UpdateLoadBalancerResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteLoadBalancerRequest {
  zone_id: string;
  load_balancer_id: string;
}

export const DeleteLoadBalancerRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  load_balancer_id: Schema.String.pipe(T.HttpPath("load_balancer_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/load_balancers/{load_balancer_id}" }),
).annotations({ identifier: "DeleteLoadBalancerRequest" }) as unknown as Schema.Schema<DeleteLoadBalancerRequest>;

export interface DeleteLoadBalancerResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteLoadBalancerResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteLoadBalancerResponse" }) as unknown as Schema.Schema<DeleteLoadBalancerResponse>;

export const deleteLoadBalancer: (
  input: DeleteLoadBalancerRequest
) => Effect.Effect<
  DeleteLoadBalancerResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteLoadBalancerRequest,
  output: DeleteLoadBalancerResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchLoadBalancerRequest {
  zone_id: string;
  load_balancer_id: string;
  body: { adaptive_routing?: { failover_across_pools?: boolean }; country_pools?: Record<string, unknown>; default_pools?: string[]; description?: string; enabled?: boolean; fallback_pool?: string; location_strategy?: { mode?: "pop" | "resolver_ip"; prefer_ecs?: "always" | "never" | "proximity" | "geo" }; name?: string; pop_pools?: Record<string, unknown>; proxied?: boolean; random_steering?: { default_weight?: number; pool_weights?: Record<string, unknown> }; region_pools?: Record<string, unknown>; rules?: { condition?: string; disabled?: boolean; fixed_response?: { content_type?: string; location?: string; message_body?: string; status_code?: number }; name?: string; overrides?: { adaptive_routing?: { failover_across_pools?: boolean }; country_pools?: Record<string, unknown>; default_pools?: string[]; fallback_pool?: string; location_strategy?: { mode?: "pop" | "resolver_ip"; prefer_ecs?: "always" | "never" | "proximity" | "geo" }; pop_pools?: Record<string, unknown>; random_steering?: { default_weight?: number; pool_weights?: Record<string, unknown> }; region_pools?: Record<string, unknown>; session_affinity?: "none" | "cookie" | "ip_cookie" | "header"; session_affinity_attributes?: { drain_duration?: number; headers?: string[]; require_all_headers?: boolean; samesite?: "Auto" | "Lax" | "None" | "Strict"; secure?: "Auto" | "Always" | "Never"; zero_downtime_failover?: "none" | "temporary" | "sticky" }; session_affinity_ttl?: number; steering_policy?: "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | ""; ttl?: number }; priority?: number; terminates?: boolean }[]; session_affinity?: "none" | "cookie" | "ip_cookie" | "header"; session_affinity_attributes?: { drain_duration?: number; headers?: string[]; require_all_headers?: boolean; samesite?: "Auto" | "Lax" | "None" | "Strict"; secure?: "Auto" | "Always" | "Never"; zero_downtime_failover?: "none" | "temporary" | "sticky" }; session_affinity_ttl?: number; steering_policy?: "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | ""; ttl?: number };
}

export const PatchLoadBalancerRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  load_balancer_id: Schema.String.pipe(T.HttpPath("load_balancer_id")),
  body: Schema.Struct({
  adaptive_routing: Schema.optional(Schema.Struct({
  failover_across_pools: Schema.optional(Schema.Boolean)
})),
  country_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  default_pools: Schema.optional(Schema.Array(Schema.String)),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  fallback_pool: Schema.optional(Schema.String),
  location_strategy: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.Literal("pop", "resolver_ip")),
  prefer_ecs: Schema.optional(Schema.Literal("always", "never", "proximity", "geo"))
})),
  name: Schema.optional(Schema.String),
  pop_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  proxied: Schema.optional(Schema.Boolean),
  random_steering: Schema.optional(Schema.Struct({
  default_weight: Schema.optional(Schema.Number),
  pool_weights: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Number }))
})),
  region_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  rules: Schema.optional(Schema.Array(Schema.Struct({
  condition: Schema.optional(Schema.String),
  disabled: Schema.optional(Schema.Boolean),
  fixed_response: Schema.optional(Schema.Struct({
  content_type: Schema.optional(Schema.String),
  location: Schema.optional(Schema.String),
  message_body: Schema.optional(Schema.String),
  status_code: Schema.optional(Schema.Number)
})),
  name: Schema.optional(Schema.String),
  overrides: Schema.optional(Schema.Struct({
  adaptive_routing: Schema.optional(Schema.Struct({
  failover_across_pools: Schema.optional(Schema.Boolean)
})),
  country_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  default_pools: Schema.optional(Schema.Array(Schema.String)),
  fallback_pool: Schema.optional(Schema.String),
  location_strategy: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.Literal("pop", "resolver_ip")),
  prefer_ecs: Schema.optional(Schema.Literal("always", "never", "proximity", "geo"))
})),
  pop_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  random_steering: Schema.optional(Schema.Struct({
  default_weight: Schema.optional(Schema.Number),
  pool_weights: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Number }))
})),
  region_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  session_affinity: Schema.optional(Schema.Literal("none", "cookie", "ip_cookie", "header")),
  session_affinity_attributes: Schema.optional(Schema.Struct({
  drain_duration: Schema.optional(Schema.Number),
  headers: Schema.optional(Schema.Array(Schema.String)),
  require_all_headers: Schema.optional(Schema.Boolean),
  samesite: Schema.optional(Schema.Literal("Auto", "Lax", "None", "Strict")),
  secure: Schema.optional(Schema.Literal("Auto", "Always", "Never")),
  zero_downtime_failover: Schema.optional(Schema.Literal("none", "temporary", "sticky"))
})),
  session_affinity_ttl: Schema.optional(Schema.Number),
  steering_policy: Schema.optional(Schema.Literal("off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "")),
  ttl: Schema.optional(Schema.Number)
})),
  priority: Schema.optional(Schema.Number),
  terminates: Schema.optional(Schema.Boolean)
}))),
  session_affinity: Schema.optional(Schema.Literal("none", "cookie", "ip_cookie", "header")),
  session_affinity_attributes: Schema.optional(Schema.Struct({
  drain_duration: Schema.optional(Schema.Number),
  headers: Schema.optional(Schema.Array(Schema.String)),
  require_all_headers: Schema.optional(Schema.Boolean),
  samesite: Schema.optional(Schema.Literal("Auto", "Lax", "None", "Strict")),
  secure: Schema.optional(Schema.Literal("Auto", "Always", "Never")),
  zero_downtime_failover: Schema.optional(Schema.Literal("none", "temporary", "sticky"))
})),
  session_affinity_ttl: Schema.optional(Schema.Number),
  steering_policy: Schema.optional(Schema.Literal("off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "")),
  ttl: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/load_balancers/{load_balancer_id}" }),
).annotations({ identifier: "PatchLoadBalancerRequest" }) as unknown as Schema.Schema<PatchLoadBalancerRequest>;

export interface PatchLoadBalancerResponse {
  result: { adaptive_routing?: { failover_across_pools?: boolean }; country_pools?: Record<string, unknown>; created_on?: string; default_pools?: string[]; description?: string; enabled?: boolean; fallback_pool?: string; id?: string; location_strategy?: { mode?: "pop" | "resolver_ip"; prefer_ecs?: "always" | "never" | "proximity" | "geo" }; modified_on?: string; name?: string; networks?: string[]; pop_pools?: Record<string, unknown>; proxied?: boolean; random_steering?: { default_weight?: number; pool_weights?: Record<string, unknown> }; region_pools?: Record<string, unknown>; rules?: { condition?: string; disabled?: boolean; fixed_response?: { content_type?: string; location?: string; message_body?: string; status_code?: number }; name?: string; overrides?: { adaptive_routing?: { failover_across_pools?: boolean }; country_pools?: Record<string, unknown>; default_pools?: string[]; fallback_pool?: string; location_strategy?: { mode?: "pop" | "resolver_ip"; prefer_ecs?: "always" | "never" | "proximity" | "geo" }; pop_pools?: Record<string, unknown>; random_steering?: { default_weight?: number; pool_weights?: Record<string, unknown> }; region_pools?: Record<string, unknown>; session_affinity?: "none" | "cookie" | "ip_cookie" | "header"; session_affinity_attributes?: { drain_duration?: number; headers?: string[]; require_all_headers?: boolean; samesite?: "Auto" | "Lax" | "None" | "Strict"; secure?: "Auto" | "Always" | "Never"; zero_downtime_failover?: "none" | "temporary" | "sticky" }; session_affinity_ttl?: number; steering_policy?: "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | ""; ttl?: number }; priority?: number; terminates?: boolean }[]; session_affinity?: "none" | "cookie" | "ip_cookie" | "header"; session_affinity_attributes?: { drain_duration?: number; headers?: string[]; require_all_headers?: boolean; samesite?: "Auto" | "Lax" | "None" | "Strict"; secure?: "Auto" | "Always" | "Never"; zero_downtime_failover?: "none" | "temporary" | "sticky" }; session_affinity_ttl?: number; steering_policy?: "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | ""; ttl?: number; zone_name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchLoadBalancerResponse = Schema.Struct({
  result: Schema.Struct({
  adaptive_routing: Schema.optional(Schema.Struct({
  failover_across_pools: Schema.optional(Schema.Boolean)
})),
  country_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  created_on: Schema.optional(Schema.Date),
  default_pools: Schema.optional(Schema.Array(Schema.String)),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  fallback_pool: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  location_strategy: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.Literal("pop", "resolver_ip")),
  prefer_ecs: Schema.optional(Schema.Literal("always", "never", "proximity", "geo"))
})),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(Schema.Array(Schema.String)),
  pop_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  proxied: Schema.optional(Schema.Boolean),
  random_steering: Schema.optional(Schema.Struct({
  default_weight: Schema.optional(Schema.Number),
  pool_weights: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Number }))
})),
  region_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  rules: Schema.optional(Schema.Array(Schema.Struct({
  condition: Schema.optional(Schema.String),
  disabled: Schema.optional(Schema.Boolean),
  fixed_response: Schema.optional(Schema.Struct({
  content_type: Schema.optional(Schema.String),
  location: Schema.optional(Schema.String),
  message_body: Schema.optional(Schema.String),
  status_code: Schema.optional(Schema.Number)
})),
  name: Schema.optional(Schema.String),
  overrides: Schema.optional(Schema.Struct({
  adaptive_routing: Schema.optional(Schema.Struct({
  failover_across_pools: Schema.optional(Schema.Boolean)
})),
  country_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  default_pools: Schema.optional(Schema.Array(Schema.String)),
  fallback_pool: Schema.optional(Schema.String),
  location_strategy: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.Literal("pop", "resolver_ip")),
  prefer_ecs: Schema.optional(Schema.Literal("always", "never", "proximity", "geo"))
})),
  pop_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  random_steering: Schema.optional(Schema.Struct({
  default_weight: Schema.optional(Schema.Number),
  pool_weights: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Number }))
})),
  region_pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  session_affinity: Schema.optional(Schema.Literal("none", "cookie", "ip_cookie", "header")),
  session_affinity_attributes: Schema.optional(Schema.Struct({
  drain_duration: Schema.optional(Schema.Number),
  headers: Schema.optional(Schema.Array(Schema.String)),
  require_all_headers: Schema.optional(Schema.Boolean),
  samesite: Schema.optional(Schema.Literal("Auto", "Lax", "None", "Strict")),
  secure: Schema.optional(Schema.Literal("Auto", "Always", "Never")),
  zero_downtime_failover: Schema.optional(Schema.Literal("none", "temporary", "sticky"))
})),
  session_affinity_ttl: Schema.optional(Schema.Number),
  steering_policy: Schema.optional(Schema.Literal("off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "")),
  ttl: Schema.optional(Schema.Number)
})),
  priority: Schema.optional(Schema.Number),
  terminates: Schema.optional(Schema.Boolean)
}))),
  session_affinity: Schema.optional(Schema.Literal("none", "cookie", "ip_cookie", "header")),
  session_affinity_attributes: Schema.optional(Schema.Struct({
  drain_duration: Schema.optional(Schema.Number),
  headers: Schema.optional(Schema.Array(Schema.String)),
  require_all_headers: Schema.optional(Schema.Boolean),
  samesite: Schema.optional(Schema.Literal("Auto", "Lax", "None", "Strict")),
  secure: Schema.optional(Schema.Literal("Auto", "Always", "Never")),
  zero_downtime_failover: Schema.optional(Schema.Literal("none", "temporary", "sticky"))
})),
  session_affinity_ttl: Schema.optional(Schema.Number),
  steering_policy: Schema.optional(Schema.Literal("off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "")),
  ttl: Schema.optional(Schema.Number),
  zone_name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchLoadBalancerResponse" }) as unknown as Schema.Schema<PatchLoadBalancerResponse>;

export const patchLoadBalancer: (
  input: PatchLoadBalancerRequest
) => Effect.Effect<
  PatchLoadBalancerResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchLoadBalancerRequest,
  output: PatchLoadBalancerResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZonesZoneIdLogpushDatasetsDatasetIdFieldsRequest {
  dataset_id: "access_requests" | "audit_logs" | "audit_logs_v2" | "biso_user_actions" | "casb_findings" | "device_posture_results" | "dex_application_tests" | "dex_device_state_events" | "dlp_forensic_copies" | "dns_firewall_logs" | "dns_logs" | "email_security_alerts" | "firewall_events" | "gateway_dns" | "gateway_http" | "gateway_network" | "http_requests" | "ipsec_logs" | "magic_ids_detections" | "nel_reports" | "network_analytics_logs" | "page_shield_events" | "sinkhole_http_logs" | "spectrum_events" | "ssh_logs" | "warp_config_changes" | "warp_toggle_changes" | "workers_trace_events" | "zaraz_events" | "zero_trust_network_sessions";
  zone_id: string;
}

export const GetZonesZoneIdLogpushDatasetsDatasetIdFieldsRequest = Schema.Struct({
  dataset_id: Schema.Literal("access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions").pipe(T.HttpPath("dataset_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/logpush/datasets/{dataset_id}/fields" }),
).annotations({ identifier: "GetZonesZoneIdLogpushDatasetsDatasetIdFieldsRequest" }) as unknown as Schema.Schema<GetZonesZoneIdLogpushDatasetsDatasetIdFieldsRequest>;

export interface GetZonesZoneIdLogpushDatasetsDatasetIdFieldsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZonesZoneIdLogpushDatasetsDatasetIdFieldsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZonesZoneIdLogpushDatasetsDatasetIdFieldsResponse" }) as unknown as Schema.Schema<GetZonesZoneIdLogpushDatasetsDatasetIdFieldsResponse>;

export const getZonesZoneIdLogpushDatasetsDatasetIdFields: (
  input: GetZonesZoneIdLogpushDatasetsDatasetIdFieldsRequest
) => Effect.Effect<
  GetZonesZoneIdLogpushDatasetsDatasetIdFieldsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZonesZoneIdLogpushDatasetsDatasetIdFieldsRequest,
  output: GetZonesZoneIdLogpushDatasetsDatasetIdFieldsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZonesZoneIdLogpushDatasetsDatasetIdJobsRequest {
  dataset_id: "access_requests" | "audit_logs" | "audit_logs_v2" | "biso_user_actions" | "casb_findings" | "device_posture_results" | "dex_application_tests" | "dex_device_state_events" | "dlp_forensic_copies" | "dns_firewall_logs" | "dns_logs" | "email_security_alerts" | "firewall_events" | "gateway_dns" | "gateway_http" | "gateway_network" | "http_requests" | "ipsec_logs" | "magic_ids_detections" | "nel_reports" | "network_analytics_logs" | "page_shield_events" | "sinkhole_http_logs" | "spectrum_events" | "ssh_logs" | "warp_config_changes" | "warp_toggle_changes" | "workers_trace_events" | "zaraz_events" | "zero_trust_network_sessions";
  zone_id: string;
}

export const GetZonesZoneIdLogpushDatasetsDatasetIdJobsRequest = Schema.Struct({
  dataset_id: Schema.Literal("access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions").pipe(T.HttpPath("dataset_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/logpush/datasets/{dataset_id}/jobs" }),
).annotations({ identifier: "GetZonesZoneIdLogpushDatasetsDatasetIdJobsRequest" }) as unknown as Schema.Schema<GetZonesZoneIdLogpushDatasetsDatasetIdJobsRequest>;

export interface GetZonesZoneIdLogpushDatasetsDatasetIdJobsResponse {
  result: { dataset?: "access_requests" | "audit_logs" | "audit_logs_v2" | "biso_user_actions" | "casb_findings" | "device_posture_results" | "dex_application_tests" | "dex_device_state_events" | "dlp_forensic_copies" | "dns_firewall_logs" | "dns_logs" | "email_security_alerts" | "firewall_events" | "gateway_dns" | "gateway_http" | "gateway_network" | "http_requests" | "ipsec_logs" | "magic_ids_detections" | "nel_reports" | "network_analytics_logs" | "page_shield_events" | "sinkhole_http_logs" | "spectrum_events" | "ssh_logs" | "warp_config_changes" | "warp_toggle_changes" | "workers_trace_events" | "zaraz_events" | "zero_trust_network_sessions"; destination_conf?: string; enabled?: boolean; error_message?: string; frequency?: "high" | "low"; id?: number; kind?: "" | "edge"; last_complete?: string; last_error?: string; logpull_options?: string; max_upload_bytes?: number; max_upload_interval_seconds?: number; max_upload_records?: number; name?: string; output_options?: { "CVE-2021-44228"?: boolean; batch_prefix?: string; batch_suffix?: string; field_delimiter?: string; field_names?: string[]; output_type?: "ndjson" | "csv"; record_delimiter?: string; record_prefix?: string; record_suffix?: string; record_template?: string; sample_rate?: number; timestamp_format?: "unixnano" | "unix" | "rfc3339" } }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZonesZoneIdLogpushDatasetsDatasetIdJobsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  dataset: Schema.optional(Schema.Literal("access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions")),
  destination_conf: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  error_message: Schema.optional(Schema.String),
  frequency: Schema.optional(Schema.Literal("high", "low")),
  id: Schema.optional(Schema.Number),
  kind: Schema.optional(Schema.Literal("", "edge")),
  last_complete: Schema.optional(Schema.Date),
  last_error: Schema.optional(Schema.Date),
  logpull_options: Schema.optional(Schema.String),
  max_upload_bytes: Schema.optional(Schema.Number),
  max_upload_interval_seconds: Schema.optional(Schema.Number),
  max_upload_records: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  output_options: Schema.optional(Schema.Struct({
  "CVE-2021-44228": Schema.optional(Schema.Boolean),
  batch_prefix: Schema.optional(Schema.String),
  batch_suffix: Schema.optional(Schema.String),
  field_delimiter: Schema.optional(Schema.String),
  field_names: Schema.optional(Schema.Array(Schema.String)),
  output_type: Schema.optional(Schema.Literal("ndjson", "csv")),
  record_delimiter: Schema.optional(Schema.String),
  record_prefix: Schema.optional(Schema.String),
  record_suffix: Schema.optional(Schema.String),
  record_template: Schema.optional(Schema.String),
  sample_rate: Schema.optional(Schema.Number),
  timestamp_format: Schema.optional(Schema.Literal("unixnano", "unix", "rfc3339"))
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZonesZoneIdLogpushDatasetsDatasetIdJobsResponse" }) as unknown as Schema.Schema<GetZonesZoneIdLogpushDatasetsDatasetIdJobsResponse>;

export const getZonesZoneIdLogpushDatasetsDatasetIdJobs: (
  input: GetZonesZoneIdLogpushDatasetsDatasetIdJobsRequest
) => Effect.Effect<
  GetZonesZoneIdLogpushDatasetsDatasetIdJobsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZonesZoneIdLogpushDatasetsDatasetIdJobsRequest,
  output: GetZonesZoneIdLogpushDatasetsDatasetIdJobsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZonesZoneIdLogpushEdgeJobsRequest {
  zone_id: string;
}

export const GetZonesZoneIdLogpushEdgeJobsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/logpush/edge/jobs" }),
).annotations({ identifier: "GetZonesZoneIdLogpushEdgeJobsRequest" }) as unknown as Schema.Schema<GetZonesZoneIdLogpushEdgeJobsRequest>;

export interface GetZonesZoneIdLogpushEdgeJobsResponse {
  result: { destination_conf?: string; fields?: string; filter?: string; sample?: number; session_id?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZonesZoneIdLogpushEdgeJobsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  destination_conf: Schema.optional(Schema.String),
  fields: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
  sample: Schema.optional(Schema.Number),
  session_id: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZonesZoneIdLogpushEdgeJobsResponse" }) as unknown as Schema.Schema<GetZonesZoneIdLogpushEdgeJobsResponse>;

export const getZonesZoneIdLogpushEdgeJobs: (
  input: GetZonesZoneIdLogpushEdgeJobsRequest
) => Effect.Effect<
  GetZonesZoneIdLogpushEdgeJobsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZonesZoneIdLogpushEdgeJobsRequest,
  output: GetZonesZoneIdLogpushEdgeJobsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostZonesZoneIdLogpushEdgeJobsRequest {
  zone_id: string;
  body: { fields?: string; filter?: string; sample?: number };
}

export const PostZonesZoneIdLogpushEdgeJobsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  fields: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
  sample: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/logpush/edge/jobs" }),
).annotations({ identifier: "PostZonesZoneIdLogpushEdgeJobsRequest" }) as unknown as Schema.Schema<PostZonesZoneIdLogpushEdgeJobsRequest>;

export interface PostZonesZoneIdLogpushEdgeJobsResponse {
  result: { destination_conf?: string; fields?: string; filter?: string; sample?: number; session_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostZonesZoneIdLogpushEdgeJobsResponse = Schema.Struct({
  result: Schema.Struct({
  destination_conf: Schema.optional(Schema.String),
  fields: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
  sample: Schema.optional(Schema.Number),
  session_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostZonesZoneIdLogpushEdgeJobsResponse" }) as unknown as Schema.Schema<PostZonesZoneIdLogpushEdgeJobsResponse>;

export const postZonesZoneIdLogpushEdgeJobs: (
  input: PostZonesZoneIdLogpushEdgeJobsRequest
) => Effect.Effect<
  PostZonesZoneIdLogpushEdgeJobsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostZonesZoneIdLogpushEdgeJobsRequest,
  output: PostZonesZoneIdLogpushEdgeJobsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZonesZoneIdLogpushJobsRequest {
  zone_id: string;
}

export const GetZonesZoneIdLogpushJobsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/logpush/jobs" }),
).annotations({ identifier: "GetZonesZoneIdLogpushJobsRequest" }) as unknown as Schema.Schema<GetZonesZoneIdLogpushJobsRequest>;

export interface GetZonesZoneIdLogpushJobsResponse {
  result: { dataset?: "access_requests" | "audit_logs" | "audit_logs_v2" | "biso_user_actions" | "casb_findings" | "device_posture_results" | "dex_application_tests" | "dex_device_state_events" | "dlp_forensic_copies" | "dns_firewall_logs" | "dns_logs" | "email_security_alerts" | "firewall_events" | "gateway_dns" | "gateway_http" | "gateway_network" | "http_requests" | "ipsec_logs" | "magic_ids_detections" | "nel_reports" | "network_analytics_logs" | "page_shield_events" | "sinkhole_http_logs" | "spectrum_events" | "ssh_logs" | "warp_config_changes" | "warp_toggle_changes" | "workers_trace_events" | "zaraz_events" | "zero_trust_network_sessions"; destination_conf?: string; enabled?: boolean; error_message?: string; frequency?: "high" | "low"; id?: number; kind?: "" | "edge"; last_complete?: string; last_error?: string; logpull_options?: string; max_upload_bytes?: number; max_upload_interval_seconds?: number; max_upload_records?: number; name?: string; output_options?: { "CVE-2021-44228"?: boolean; batch_prefix?: string; batch_suffix?: string; field_delimiter?: string; field_names?: string[]; output_type?: "ndjson" | "csv"; record_delimiter?: string; record_prefix?: string; record_suffix?: string; record_template?: string; sample_rate?: number; timestamp_format?: "unixnano" | "unix" | "rfc3339" } }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZonesZoneIdLogpushJobsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  dataset: Schema.optional(Schema.Literal("access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions")),
  destination_conf: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  error_message: Schema.optional(Schema.String),
  frequency: Schema.optional(Schema.Literal("high", "low")),
  id: Schema.optional(Schema.Number),
  kind: Schema.optional(Schema.Literal("", "edge")),
  last_complete: Schema.optional(Schema.Date),
  last_error: Schema.optional(Schema.Date),
  logpull_options: Schema.optional(Schema.String),
  max_upload_bytes: Schema.optional(Schema.Number),
  max_upload_interval_seconds: Schema.optional(Schema.Number),
  max_upload_records: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  output_options: Schema.optional(Schema.Struct({
  "CVE-2021-44228": Schema.optional(Schema.Boolean),
  batch_prefix: Schema.optional(Schema.String),
  batch_suffix: Schema.optional(Schema.String),
  field_delimiter: Schema.optional(Schema.String),
  field_names: Schema.optional(Schema.Array(Schema.String)),
  output_type: Schema.optional(Schema.Literal("ndjson", "csv")),
  record_delimiter: Schema.optional(Schema.String),
  record_prefix: Schema.optional(Schema.String),
  record_suffix: Schema.optional(Schema.String),
  record_template: Schema.optional(Schema.String),
  sample_rate: Schema.optional(Schema.Number),
  timestamp_format: Schema.optional(Schema.Literal("unixnano", "unix", "rfc3339"))
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZonesZoneIdLogpushJobsResponse" }) as unknown as Schema.Schema<GetZonesZoneIdLogpushJobsResponse>;

export const getZonesZoneIdLogpushJobs: (
  input: GetZonesZoneIdLogpushJobsRequest
) => Effect.Effect<
  GetZonesZoneIdLogpushJobsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZonesZoneIdLogpushJobsRequest,
  output: GetZonesZoneIdLogpushJobsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostZonesZoneIdLogpushJobsRequest {
  zone_id: string;
  body: { dataset?: "access_requests" | "audit_logs" | "audit_logs_v2" | "biso_user_actions" | "casb_findings" | "device_posture_results" | "dex_application_tests" | "dex_device_state_events" | "dlp_forensic_copies" | "dns_firewall_logs" | "dns_logs" | "email_security_alerts" | "firewall_events" | "gateway_dns" | "gateway_http" | "gateway_network" | "http_requests" | "ipsec_logs" | "magic_ids_detections" | "nel_reports" | "network_analytics_logs" | "page_shield_events" | "sinkhole_http_logs" | "spectrum_events" | "ssh_logs" | "warp_config_changes" | "warp_toggle_changes" | "workers_trace_events" | "zaraz_events" | "zero_trust_network_sessions"; destination_conf: string; enabled?: boolean; filter?: string; frequency?: "high" | "low"; kind?: "" | "edge"; logpull_options?: string; max_upload_bytes?: number; max_upload_interval_seconds?: number; max_upload_records?: number; name?: string; output_options?: { "CVE-2021-44228"?: boolean; batch_prefix?: string; batch_suffix?: string; field_delimiter?: string; field_names?: string[]; output_type?: "ndjson" | "csv"; record_delimiter?: string; record_prefix?: string; record_suffix?: string; record_template?: string; sample_rate?: number; timestamp_format?: "unixnano" | "unix" | "rfc3339" }; ownership_challenge?: string };
}

export const PostZonesZoneIdLogpushJobsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  dataset: Schema.optional(Schema.Literal("access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions")),
  destination_conf: Schema.String,
  enabled: Schema.optional(Schema.Boolean),
  filter: Schema.optional(Schema.String),
  frequency: Schema.optional(Schema.Literal("high", "low")),
  kind: Schema.optional(Schema.Literal("", "edge")),
  logpull_options: Schema.optional(Schema.String),
  max_upload_bytes: Schema.optional(Schema.Number),
  max_upload_interval_seconds: Schema.optional(Schema.Number),
  max_upload_records: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  output_options: Schema.optional(Schema.Struct({
  "CVE-2021-44228": Schema.optional(Schema.Boolean),
  batch_prefix: Schema.optional(Schema.String),
  batch_suffix: Schema.optional(Schema.String),
  field_delimiter: Schema.optional(Schema.String),
  field_names: Schema.optional(Schema.Array(Schema.String)),
  output_type: Schema.optional(Schema.Literal("ndjson", "csv")),
  record_delimiter: Schema.optional(Schema.String),
  record_prefix: Schema.optional(Schema.String),
  record_suffix: Schema.optional(Schema.String),
  record_template: Schema.optional(Schema.String),
  sample_rate: Schema.optional(Schema.Number),
  timestamp_format: Schema.optional(Schema.Literal("unixnano", "unix", "rfc3339"))
})),
  ownership_challenge: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/logpush/jobs" }),
).annotations({ identifier: "PostZonesZoneIdLogpushJobsRequest" }) as unknown as Schema.Schema<PostZonesZoneIdLogpushJobsRequest>;

export interface PostZonesZoneIdLogpushJobsResponse {
  result: { dataset?: "access_requests" | "audit_logs" | "audit_logs_v2" | "biso_user_actions" | "casb_findings" | "device_posture_results" | "dex_application_tests" | "dex_device_state_events" | "dlp_forensic_copies" | "dns_firewall_logs" | "dns_logs" | "email_security_alerts" | "firewall_events" | "gateway_dns" | "gateway_http" | "gateway_network" | "http_requests" | "ipsec_logs" | "magic_ids_detections" | "nel_reports" | "network_analytics_logs" | "page_shield_events" | "sinkhole_http_logs" | "spectrum_events" | "ssh_logs" | "warp_config_changes" | "warp_toggle_changes" | "workers_trace_events" | "zaraz_events" | "zero_trust_network_sessions"; destination_conf?: string; enabled?: boolean; error_message?: string; frequency?: "high" | "low"; id?: number; kind?: "" | "edge"; last_complete?: string; last_error?: string; logpull_options?: string; max_upload_bytes?: number; max_upload_interval_seconds?: number; max_upload_records?: number; name?: string; output_options?: { "CVE-2021-44228"?: boolean; batch_prefix?: string; batch_suffix?: string; field_delimiter?: string; field_names?: string[]; output_type?: "ndjson" | "csv"; record_delimiter?: string; record_prefix?: string; record_suffix?: string; record_template?: string; sample_rate?: number; timestamp_format?: "unixnano" | "unix" | "rfc3339" } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostZonesZoneIdLogpushJobsResponse = Schema.Struct({
  result: Schema.Struct({
  dataset: Schema.optional(Schema.Literal("access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions")),
  destination_conf: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  error_message: Schema.optional(Schema.String),
  frequency: Schema.optional(Schema.Literal("high", "low")),
  id: Schema.optional(Schema.Number),
  kind: Schema.optional(Schema.Literal("", "edge")),
  last_complete: Schema.optional(Schema.Date),
  last_error: Schema.optional(Schema.Date),
  logpull_options: Schema.optional(Schema.String),
  max_upload_bytes: Schema.optional(Schema.Number),
  max_upload_interval_seconds: Schema.optional(Schema.Number),
  max_upload_records: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  output_options: Schema.optional(Schema.Struct({
  "CVE-2021-44228": Schema.optional(Schema.Boolean),
  batch_prefix: Schema.optional(Schema.String),
  batch_suffix: Schema.optional(Schema.String),
  field_delimiter: Schema.optional(Schema.String),
  field_names: Schema.optional(Schema.Array(Schema.String)),
  output_type: Schema.optional(Schema.Literal("ndjson", "csv")),
  record_delimiter: Schema.optional(Schema.String),
  record_prefix: Schema.optional(Schema.String),
  record_suffix: Schema.optional(Schema.String),
  record_template: Schema.optional(Schema.String),
  sample_rate: Schema.optional(Schema.Number),
  timestamp_format: Schema.optional(Schema.Literal("unixnano", "unix", "rfc3339"))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostZonesZoneIdLogpushJobsResponse" }) as unknown as Schema.Schema<PostZonesZoneIdLogpushJobsResponse>;

export const postZonesZoneIdLogpushJobs: (
  input: PostZonesZoneIdLogpushJobsRequest
) => Effect.Effect<
  PostZonesZoneIdLogpushJobsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostZonesZoneIdLogpushJobsRequest,
  output: PostZonesZoneIdLogpushJobsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZonesZoneIdLogpushJobsJobIdRequest {
  job_id: number;
  zone_id: string;
}

export const GetZonesZoneIdLogpushJobsJobIdRequest = Schema.Struct({
  job_id: Schema.Number.pipe(T.HttpPath("job_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/logpush/jobs/{job_id}" }),
).annotations({ identifier: "GetZonesZoneIdLogpushJobsJobIdRequest" }) as unknown as Schema.Schema<GetZonesZoneIdLogpushJobsJobIdRequest>;

export interface GetZonesZoneIdLogpushJobsJobIdResponse {
  result: { dataset?: "access_requests" | "audit_logs" | "audit_logs_v2" | "biso_user_actions" | "casb_findings" | "device_posture_results" | "dex_application_tests" | "dex_device_state_events" | "dlp_forensic_copies" | "dns_firewall_logs" | "dns_logs" | "email_security_alerts" | "firewall_events" | "gateway_dns" | "gateway_http" | "gateway_network" | "http_requests" | "ipsec_logs" | "magic_ids_detections" | "nel_reports" | "network_analytics_logs" | "page_shield_events" | "sinkhole_http_logs" | "spectrum_events" | "ssh_logs" | "warp_config_changes" | "warp_toggle_changes" | "workers_trace_events" | "zaraz_events" | "zero_trust_network_sessions"; destination_conf?: string; enabled?: boolean; error_message?: string; frequency?: "high" | "low"; id?: number; kind?: "" | "edge"; last_complete?: string; last_error?: string; logpull_options?: string; max_upload_bytes?: number; max_upload_interval_seconds?: number; max_upload_records?: number; name?: string; output_options?: { "CVE-2021-44228"?: boolean; batch_prefix?: string; batch_suffix?: string; field_delimiter?: string; field_names?: string[]; output_type?: "ndjson" | "csv"; record_delimiter?: string; record_prefix?: string; record_suffix?: string; record_template?: string; sample_rate?: number; timestamp_format?: "unixnano" | "unix" | "rfc3339" } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZonesZoneIdLogpushJobsJobIdResponse = Schema.Struct({
  result: Schema.Struct({
  dataset: Schema.optional(Schema.Literal("access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions")),
  destination_conf: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  error_message: Schema.optional(Schema.String),
  frequency: Schema.optional(Schema.Literal("high", "low")),
  id: Schema.optional(Schema.Number),
  kind: Schema.optional(Schema.Literal("", "edge")),
  last_complete: Schema.optional(Schema.Date),
  last_error: Schema.optional(Schema.Date),
  logpull_options: Schema.optional(Schema.String),
  max_upload_bytes: Schema.optional(Schema.Number),
  max_upload_interval_seconds: Schema.optional(Schema.Number),
  max_upload_records: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  output_options: Schema.optional(Schema.Struct({
  "CVE-2021-44228": Schema.optional(Schema.Boolean),
  batch_prefix: Schema.optional(Schema.String),
  batch_suffix: Schema.optional(Schema.String),
  field_delimiter: Schema.optional(Schema.String),
  field_names: Schema.optional(Schema.Array(Schema.String)),
  output_type: Schema.optional(Schema.Literal("ndjson", "csv")),
  record_delimiter: Schema.optional(Schema.String),
  record_prefix: Schema.optional(Schema.String),
  record_suffix: Schema.optional(Schema.String),
  record_template: Schema.optional(Schema.String),
  sample_rate: Schema.optional(Schema.Number),
  timestamp_format: Schema.optional(Schema.Literal("unixnano", "unix", "rfc3339"))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZonesZoneIdLogpushJobsJobIdResponse" }) as unknown as Schema.Schema<GetZonesZoneIdLogpushJobsJobIdResponse>;

export const getZonesZoneIdLogpushJobsJobId: (
  input: GetZonesZoneIdLogpushJobsJobIdRequest
) => Effect.Effect<
  GetZonesZoneIdLogpushJobsJobIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZonesZoneIdLogpushJobsJobIdRequest,
  output: GetZonesZoneIdLogpushJobsJobIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PutZonesZoneIdLogpushJobsJobIdRequest {
  job_id: number;
  zone_id: string;
  body: { destination_conf?: string; enabled?: boolean; filter?: string; frequency?: "high" | "low"; kind?: "" | "edge"; logpull_options?: string; max_upload_bytes?: number; max_upload_interval_seconds?: number; max_upload_records?: number; name?: string; output_options?: { "CVE-2021-44228"?: boolean; batch_prefix?: string; batch_suffix?: string; field_delimiter?: string; field_names?: string[]; output_type?: "ndjson" | "csv"; record_delimiter?: string; record_prefix?: string; record_suffix?: string; record_template?: string; sample_rate?: number; timestamp_format?: "unixnano" | "unix" | "rfc3339" }; ownership_challenge?: string };
}

export const PutZonesZoneIdLogpushJobsJobIdRequest = Schema.Struct({
  job_id: Schema.Number.pipe(T.HttpPath("job_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  destination_conf: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  filter: Schema.optional(Schema.String),
  frequency: Schema.optional(Schema.Literal("high", "low")),
  kind: Schema.optional(Schema.Literal("", "edge")),
  logpull_options: Schema.optional(Schema.String),
  max_upload_bytes: Schema.optional(Schema.Number),
  max_upload_interval_seconds: Schema.optional(Schema.Number),
  max_upload_records: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  output_options: Schema.optional(Schema.Struct({
  "CVE-2021-44228": Schema.optional(Schema.Boolean),
  batch_prefix: Schema.optional(Schema.String),
  batch_suffix: Schema.optional(Schema.String),
  field_delimiter: Schema.optional(Schema.String),
  field_names: Schema.optional(Schema.Array(Schema.String)),
  output_type: Schema.optional(Schema.Literal("ndjson", "csv")),
  record_delimiter: Schema.optional(Schema.String),
  record_prefix: Schema.optional(Schema.String),
  record_suffix: Schema.optional(Schema.String),
  record_template: Schema.optional(Schema.String),
  sample_rate: Schema.optional(Schema.Number),
  timestamp_format: Schema.optional(Schema.Literal("unixnano", "unix", "rfc3339"))
})),
  ownership_challenge: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/logpush/jobs/{job_id}" }),
).annotations({ identifier: "PutZonesZoneIdLogpushJobsJobIdRequest" }) as unknown as Schema.Schema<PutZonesZoneIdLogpushJobsJobIdRequest>;

export interface PutZonesZoneIdLogpushJobsJobIdResponse {
  result: { dataset?: "access_requests" | "audit_logs" | "audit_logs_v2" | "biso_user_actions" | "casb_findings" | "device_posture_results" | "dex_application_tests" | "dex_device_state_events" | "dlp_forensic_copies" | "dns_firewall_logs" | "dns_logs" | "email_security_alerts" | "firewall_events" | "gateway_dns" | "gateway_http" | "gateway_network" | "http_requests" | "ipsec_logs" | "magic_ids_detections" | "nel_reports" | "network_analytics_logs" | "page_shield_events" | "sinkhole_http_logs" | "spectrum_events" | "ssh_logs" | "warp_config_changes" | "warp_toggle_changes" | "workers_trace_events" | "zaraz_events" | "zero_trust_network_sessions"; destination_conf?: string; enabled?: boolean; error_message?: string; frequency?: "high" | "low"; id?: number; kind?: "" | "edge"; last_complete?: string; last_error?: string; logpull_options?: string; max_upload_bytes?: number; max_upload_interval_seconds?: number; max_upload_records?: number; name?: string; output_options?: { "CVE-2021-44228"?: boolean; batch_prefix?: string; batch_suffix?: string; field_delimiter?: string; field_names?: string[]; output_type?: "ndjson" | "csv"; record_delimiter?: string; record_prefix?: string; record_suffix?: string; record_template?: string; sample_rate?: number; timestamp_format?: "unixnano" | "unix" | "rfc3339" } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PutZonesZoneIdLogpushJobsJobIdResponse = Schema.Struct({
  result: Schema.Struct({
  dataset: Schema.optional(Schema.Literal("access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions")),
  destination_conf: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  error_message: Schema.optional(Schema.String),
  frequency: Schema.optional(Schema.Literal("high", "low")),
  id: Schema.optional(Schema.Number),
  kind: Schema.optional(Schema.Literal("", "edge")),
  last_complete: Schema.optional(Schema.Date),
  last_error: Schema.optional(Schema.Date),
  logpull_options: Schema.optional(Schema.String),
  max_upload_bytes: Schema.optional(Schema.Number),
  max_upload_interval_seconds: Schema.optional(Schema.Number),
  max_upload_records: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  output_options: Schema.optional(Schema.Struct({
  "CVE-2021-44228": Schema.optional(Schema.Boolean),
  batch_prefix: Schema.optional(Schema.String),
  batch_suffix: Schema.optional(Schema.String),
  field_delimiter: Schema.optional(Schema.String),
  field_names: Schema.optional(Schema.Array(Schema.String)),
  output_type: Schema.optional(Schema.Literal("ndjson", "csv")),
  record_delimiter: Schema.optional(Schema.String),
  record_prefix: Schema.optional(Schema.String),
  record_suffix: Schema.optional(Schema.String),
  record_template: Schema.optional(Schema.String),
  sample_rate: Schema.optional(Schema.Number),
  timestamp_format: Schema.optional(Schema.Literal("unixnano", "unix", "rfc3339"))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PutZonesZoneIdLogpushJobsJobIdResponse" }) as unknown as Schema.Schema<PutZonesZoneIdLogpushJobsJobIdResponse>;

export const putZonesZoneIdLogpushJobsJobId: (
  input: PutZonesZoneIdLogpushJobsJobIdRequest
) => Effect.Effect<
  PutZonesZoneIdLogpushJobsJobIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutZonesZoneIdLogpushJobsJobIdRequest,
  output: PutZonesZoneIdLogpushJobsJobIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteZonesZoneIdLogpushJobsJobIdRequest {
  job_id: number;
  zone_id: string;
}

export const DeleteZonesZoneIdLogpushJobsJobIdRequest = Schema.Struct({
  job_id: Schema.Number.pipe(T.HttpPath("job_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/logpush/jobs/{job_id}" }),
).annotations({ identifier: "DeleteZonesZoneIdLogpushJobsJobIdRequest" }) as unknown as Schema.Schema<DeleteZonesZoneIdLogpushJobsJobIdRequest>;

export interface DeleteZonesZoneIdLogpushJobsJobIdResponse {
  result: { id?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteZonesZoneIdLogpushJobsJobIdResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteZonesZoneIdLogpushJobsJobIdResponse" }) as unknown as Schema.Schema<DeleteZonesZoneIdLogpushJobsJobIdResponse>;

export const deleteZonesZoneIdLogpushJobsJobId: (
  input: DeleteZonesZoneIdLogpushJobsJobIdRequest
) => Effect.Effect<
  DeleteZonesZoneIdLogpushJobsJobIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteZonesZoneIdLogpushJobsJobIdRequest,
  output: DeleteZonesZoneIdLogpushJobsJobIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostZonesZoneIdLogpushOwnershipRequest {
  zone_id: string;
  body: { destination_conf: string };
}

export const PostZonesZoneIdLogpushOwnershipRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  destination_conf: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/logpush/ownership" }),
).annotations({ identifier: "PostZonesZoneIdLogpushOwnershipRequest" }) as unknown as Schema.Schema<PostZonesZoneIdLogpushOwnershipRequest>;

export interface PostZonesZoneIdLogpushOwnershipResponse {
  result: { filename?: string; message?: string; valid?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostZonesZoneIdLogpushOwnershipResponse = Schema.Struct({
  result: Schema.Struct({
  filename: Schema.optional(Schema.String),
  message: Schema.optional(Schema.String),
  valid: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostZonesZoneIdLogpushOwnershipResponse" }) as unknown as Schema.Schema<PostZonesZoneIdLogpushOwnershipResponse>;

export const postZonesZoneIdLogpushOwnership: (
  input: PostZonesZoneIdLogpushOwnershipRequest
) => Effect.Effect<
  PostZonesZoneIdLogpushOwnershipResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostZonesZoneIdLogpushOwnershipRequest,
  output: PostZonesZoneIdLogpushOwnershipResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostZonesZoneIdLogpushOwnershipValidateRequest {
  zone_id: string;
  body: { destination_conf: string; ownership_challenge: string };
}

export const PostZonesZoneIdLogpushOwnershipValidateRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  destination_conf: Schema.String,
  ownership_challenge: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/logpush/ownership/validate" }),
).annotations({ identifier: "PostZonesZoneIdLogpushOwnershipValidateRequest" }) as unknown as Schema.Schema<PostZonesZoneIdLogpushOwnershipValidateRequest>;

export interface PostZonesZoneIdLogpushOwnershipValidateResponse {
  result: { valid?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostZonesZoneIdLogpushOwnershipValidateResponse = Schema.Struct({
  result: Schema.Struct({
  valid: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostZonesZoneIdLogpushOwnershipValidateResponse" }) as unknown as Schema.Schema<PostZonesZoneIdLogpushOwnershipValidateResponse>;

export const postZonesZoneIdLogpushOwnershipValidate: (
  input: PostZonesZoneIdLogpushOwnershipValidateRequest
) => Effect.Effect<
  PostZonesZoneIdLogpushOwnershipValidateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostZonesZoneIdLogpushOwnershipValidateRequest,
  output: PostZonesZoneIdLogpushOwnershipValidateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostZonesZoneIdLogpushValidateDestinationRequest {
  zone_id: string;
  body: { destination_conf: string };
}

export const PostZonesZoneIdLogpushValidateDestinationRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  destination_conf: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/logpush/validate/destination" }),
).annotations({ identifier: "PostZonesZoneIdLogpushValidateDestinationRequest" }) as unknown as Schema.Schema<PostZonesZoneIdLogpushValidateDestinationRequest>;

export interface PostZonesZoneIdLogpushValidateDestinationResponse {
  result: { message?: string; valid?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostZonesZoneIdLogpushValidateDestinationResponse = Schema.Struct({
  result: Schema.Struct({
  message: Schema.optional(Schema.String),
  valid: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostZonesZoneIdLogpushValidateDestinationResponse" }) as unknown as Schema.Schema<PostZonesZoneIdLogpushValidateDestinationResponse>;

export const postZonesZoneIdLogpushValidateDestination: (
  input: PostZonesZoneIdLogpushValidateDestinationRequest
) => Effect.Effect<
  PostZonesZoneIdLogpushValidateDestinationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostZonesZoneIdLogpushValidateDestinationRequest,
  output: PostZonesZoneIdLogpushValidateDestinationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostZonesZoneIdLogpushValidateDestinationExistsRequest {
  zone_id: string;
  body: { destination_conf: string };
}

export const PostZonesZoneIdLogpushValidateDestinationExistsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  destination_conf: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/logpush/validate/destination/exists" }),
).annotations({ identifier: "PostZonesZoneIdLogpushValidateDestinationExistsRequest" }) as unknown as Schema.Schema<PostZonesZoneIdLogpushValidateDestinationExistsRequest>;

export interface PostZonesZoneIdLogpushValidateDestinationExistsResponse {
  result: { exists?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostZonesZoneIdLogpushValidateDestinationExistsResponse = Schema.Struct({
  result: Schema.Struct({
  exists: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostZonesZoneIdLogpushValidateDestinationExistsResponse" }) as unknown as Schema.Schema<PostZonesZoneIdLogpushValidateDestinationExistsResponse>;

export const postZonesZoneIdLogpushValidateDestinationExists: (
  input: PostZonesZoneIdLogpushValidateDestinationExistsRequest
) => Effect.Effect<
  PostZonesZoneIdLogpushValidateDestinationExistsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostZonesZoneIdLogpushValidateDestinationExistsRequest,
  output: PostZonesZoneIdLogpushValidateDestinationExistsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostZonesZoneIdLogpushValidateOriginRequest {
  zone_id: string;
  body: { logpull_options: string };
}

export const PostZonesZoneIdLogpushValidateOriginRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  logpull_options: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/logpush/validate/origin" }),
).annotations({ identifier: "PostZonesZoneIdLogpushValidateOriginRequest" }) as unknown as Schema.Schema<PostZonesZoneIdLogpushValidateOriginRequest>;

export interface PostZonesZoneIdLogpushValidateOriginResponse {
  result: { message?: string; valid?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostZonesZoneIdLogpushValidateOriginResponse = Schema.Struct({
  result: Schema.Struct({
  message: Schema.optional(Schema.String),
  valid: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostZonesZoneIdLogpushValidateOriginResponse" }) as unknown as Schema.Schema<PostZonesZoneIdLogpushValidateOriginResponse>;

export const postZonesZoneIdLogpushValidateOrigin: (
  input: PostZonesZoneIdLogpushValidateOriginRequest
) => Effect.Effect<
  PostZonesZoneIdLogpushValidateOriginResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostZonesZoneIdLogpushValidateOriginRequest,
  output: PostZonesZoneIdLogpushValidateOriginResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZonesZoneIdLogsControlRetentionFlagRequest {
  zone_id: string;
}

export const GetZonesZoneIdLogsControlRetentionFlagRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/logs/control/retention/flag" }),
).annotations({ identifier: "GetZonesZoneIdLogsControlRetentionFlagRequest" }) as unknown as Schema.Schema<GetZonesZoneIdLogsControlRetentionFlagRequest>;

export interface GetZonesZoneIdLogsControlRetentionFlagResponse {
  result: { flag?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZonesZoneIdLogsControlRetentionFlagResponse = Schema.Struct({
  result: Schema.Struct({
  flag: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZonesZoneIdLogsControlRetentionFlagResponse" }) as unknown as Schema.Schema<GetZonesZoneIdLogsControlRetentionFlagResponse>;

export const getZonesZoneIdLogsControlRetentionFlag: (
  input: GetZonesZoneIdLogsControlRetentionFlagRequest
) => Effect.Effect<
  GetZonesZoneIdLogsControlRetentionFlagResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZonesZoneIdLogsControlRetentionFlagRequest,
  output: GetZonesZoneIdLogsControlRetentionFlagResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostZonesZoneIdLogsControlRetentionFlagRequest {
  zone_id: string;
  body: { flag?: boolean };
}

export const PostZonesZoneIdLogsControlRetentionFlagRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  flag: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/logs/control/retention/flag" }),
).annotations({ identifier: "PostZonesZoneIdLogsControlRetentionFlagRequest" }) as unknown as Schema.Schema<PostZonesZoneIdLogsControlRetentionFlagRequest>;

export interface PostZonesZoneIdLogsControlRetentionFlagResponse {
  result: { flag?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostZonesZoneIdLogsControlRetentionFlagResponse = Schema.Struct({
  result: Schema.Struct({
  flag: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostZonesZoneIdLogsControlRetentionFlagResponse" }) as unknown as Schema.Schema<PostZonesZoneIdLogsControlRetentionFlagResponse>;

export const postZonesZoneIdLogsControlRetentionFlag: (
  input: PostZonesZoneIdLogsControlRetentionFlagRequest
) => Effect.Effect<
  PostZonesZoneIdLogsControlRetentionFlagResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostZonesZoneIdLogsControlRetentionFlagRequest,
  output: PostZonesZoneIdLogsControlRetentionFlagResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZonesZoneIdLogsRayidsRayIdRequest {
  zone_id: string;
  ray_id: string;
  fields?: string;
  timestamps?: "unix" | "unixnano" | "rfc3339";
}

export const GetZonesZoneIdLogsRayidsRayIdRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  ray_id: Schema.String.pipe(T.HttpPath("ray_id")),
  fields: Schema.optional(Schema.String).pipe(T.HttpQuery("fields")),
  timestamps: Schema.optional(Schema.Literal("unix", "unixnano", "rfc3339")).pipe(T.HttpQuery("timestamps"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/logs/rayids/{ray_id}" }),
).annotations({ identifier: "GetZonesZoneIdLogsRayidsRayIdRequest" }) as unknown as Schema.Schema<GetZonesZoneIdLogsRayidsRayIdRequest>;

export interface GetZonesZoneIdLogsRayidsRayIdResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZonesZoneIdLogsRayidsRayIdResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZonesZoneIdLogsRayidsRayIdResponse" }) as unknown as Schema.Schema<GetZonesZoneIdLogsRayidsRayIdResponse>;

export const getZonesZoneIdLogsRayidsRayId: (
  input: GetZonesZoneIdLogsRayidsRayIdRequest
) => Effect.Effect<
  GetZonesZoneIdLogsRayidsRayIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZonesZoneIdLogsRayidsRayIdRequest,
  output: GetZonesZoneIdLogsRayidsRayIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZonesZoneIdLogsReceivedRequest {
  zone_id: string;
  start?: unknown;
  end: unknown;
  fields?: string;
  sample?: number;
  count?: number;
  timestamps?: "unix" | "unixnano" | "rfc3339";
}

export const GetZonesZoneIdLogsReceivedRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  start: Schema.optional(Schema.Union(Schema.String, Schema.Number)).pipe(T.HttpQuery("start")),
  end: Schema.Union(Schema.String, Schema.Number).pipe(T.HttpQuery("end")),
  fields: Schema.optional(Schema.String).pipe(T.HttpQuery("fields")),
  sample: Schema.optional(Schema.Number).pipe(T.HttpQuery("sample")),
  count: Schema.optional(Schema.Number).pipe(T.HttpQuery("count")),
  timestamps: Schema.optional(Schema.Literal("unix", "unixnano", "rfc3339")).pipe(T.HttpQuery("timestamps"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/logs/received" }),
).annotations({ identifier: "GetZonesZoneIdLogsReceivedRequest" }) as unknown as Schema.Schema<GetZonesZoneIdLogsReceivedRequest>;

export interface GetZonesZoneIdLogsReceivedResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZonesZoneIdLogsReceivedResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZonesZoneIdLogsReceivedResponse" }) as unknown as Schema.Schema<GetZonesZoneIdLogsReceivedResponse>;

export const getZonesZoneIdLogsReceived: (
  input: GetZonesZoneIdLogsReceivedRequest
) => Effect.Effect<
  GetZonesZoneIdLogsReceivedResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZonesZoneIdLogsReceivedRequest,
  output: GetZonesZoneIdLogsReceivedResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZonesZoneIdLogsReceivedFieldsRequest {
  zone_id: string;
}

export const GetZonesZoneIdLogsReceivedFieldsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/logs/received/fields" }),
).annotations({ identifier: "GetZonesZoneIdLogsReceivedFieldsRequest" }) as unknown as Schema.Schema<GetZonesZoneIdLogsReceivedFieldsRequest>;

export interface GetZonesZoneIdLogsReceivedFieldsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZonesZoneIdLogsReceivedFieldsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZonesZoneIdLogsReceivedFieldsResponse" }) as unknown as Schema.Schema<GetZonesZoneIdLogsReceivedFieldsResponse>;

export const getZonesZoneIdLogsReceivedFields: (
  input: GetZonesZoneIdLogsReceivedFieldsRequest
) => Effect.Effect<
  GetZonesZoneIdLogsReceivedFieldsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZonesZoneIdLogsReceivedFieldsRequest,
  output: GetZonesZoneIdLogsReceivedFieldsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListmanagedtransformsRequest {
  zone_id: string;
}

export const ListmanagedtransformsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/managed_headers" }),
).annotations({ identifier: "ListmanagedtransformsRequest" }) as unknown as Schema.Schema<ListmanagedtransformsRequest>;

export interface ListmanagedtransformsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListmanagedtransformsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListmanagedtransformsResponse" }) as unknown as Schema.Schema<ListmanagedtransformsResponse>;

export const listmanagedtransforms: (
  input: ListmanagedtransformsRequest
) => Effect.Effect<
  ListmanagedtransformsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListmanagedtransformsRequest,
  output: ListmanagedtransformsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletemanagedtransformsRequest {
  zone_id: string;
}

export const DeletemanagedtransformsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/managed_headers" }),
).annotations({ identifier: "DeletemanagedtransformsRequest" }) as unknown as Schema.Schema<DeletemanagedtransformsRequest>;

export interface DeletemanagedtransformsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletemanagedtransformsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletemanagedtransformsResponse" }) as unknown as Schema.Schema<DeletemanagedtransformsResponse>;

export const deletemanagedtransforms: (
  input: DeletemanagedtransformsRequest
) => Effect.Effect<
  DeletemanagedtransformsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletemanagedtransformsRequest,
  output: DeletemanagedtransformsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatemanagedtransformsRequest {
  zone_id: string;
  body: { managed_request_headers: unknown[]; managed_response_headers: unknown[] };
}

export const UpdatemanagedtransformsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  managed_request_headers: Schema.Array(Schema.Unknown),
  managed_response_headers: Schema.Array(Schema.Unknown)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/managed_headers" }),
).annotations({ identifier: "UpdatemanagedtransformsRequest" }) as unknown as Schema.Schema<UpdatemanagedtransformsRequest>;

export interface UpdatemanagedtransformsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatemanagedtransformsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatemanagedtransformsResponse" }) as unknown as Schema.Schema<UpdatemanagedtransformsResponse>;

export const updatemanagedtransforms: (
  input: UpdatemanagedtransformsRequest
) => Effect.Effect<
  UpdatemanagedtransformsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatemanagedtransformsRequest,
  output: UpdatemanagedtransformsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListCertificatesRequest {
  zone_id: string;
}

export const ListCertificatesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/origin_tls_client_auth" }),
).annotations({ identifier: "ListCertificatesRequest" }) as unknown as Schema.Schema<ListCertificatesRequest>;

export interface ListCertificatesResponse {
  result: { certificate?: string; enabled?: boolean; id?: string; private_key?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListCertificatesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  certificate: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  private_key: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListCertificatesResponse" }) as unknown as Schema.Schema<ListCertificatesResponse>;

export const listCertificates: (
  input: ListCertificatesRequest
) => Effect.Effect<
  ListCertificatesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListCertificatesRequest,
  output: ListCertificatesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneLevelAuthenticatedOriginPullsUploadCertificateRequest {
  zone_id: string;
  body: { certificate: string; private_key: string };
}

export const ZoneLevelAuthenticatedOriginPullsUploadCertificateRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  certificate: Schema.String,
  private_key: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/origin_tls_client_auth" }),
).annotations({ identifier: "ZoneLevelAuthenticatedOriginPullsUploadCertificateRequest" }) as unknown as Schema.Schema<ZoneLevelAuthenticatedOriginPullsUploadCertificateRequest>;

export interface ZoneLevelAuthenticatedOriginPullsUploadCertificateResponse {
  result: { certificate?: string; enabled?: boolean; id?: string; private_key?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneLevelAuthenticatedOriginPullsUploadCertificateResponse = Schema.Struct({
  result: Schema.Struct({
  certificate: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  private_key: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneLevelAuthenticatedOriginPullsUploadCertificateResponse" }) as unknown as Schema.Schema<ZoneLevelAuthenticatedOriginPullsUploadCertificateResponse>;

export const zoneLevelAuthenticatedOriginPullsUploadCertificate: (
  input: ZoneLevelAuthenticatedOriginPullsUploadCertificateRequest
) => Effect.Effect<
  ZoneLevelAuthenticatedOriginPullsUploadCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneLevelAuthenticatedOriginPullsUploadCertificateRequest,
  output: ZoneLevelAuthenticatedOriginPullsUploadCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationRequest {
  zone_id: string;
  body: unknown;
}

export const PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/origin_tls_client_auth/hostnames" }),
).annotations({ identifier: "PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationRequest" }) as unknown as Schema.Schema<PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationRequest>;

export interface PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationResponse {
  result: { cert_id?: string; certificate?: string; enabled?: boolean; hostname?: string; id?: string; private_key?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  cert_id: Schema.optional(Schema.String),
  certificate: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  hostname: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  private_key: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationResponse" }) as unknown as Schema.Schema<PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationResponse>;

export const perHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthentication: (
  input: PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationRequest
) => Effect.Effect<
  PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationRequest,
  output: PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListCertificates1Request {
  zone_id: string;
}

export const ListCertificates1Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/origin_tls_client_auth/hostnames/certificates" }),
).annotations({ identifier: "ListCertificates1Request" }) as unknown as Schema.Schema<ListCertificates1Request>;

export interface ListCertificates1Response {
  result: { cert_id?: string; certificate?: string; enabled?: boolean; hostname?: string; id?: string; private_key?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListCertificates1Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  cert_id: Schema.optional(Schema.String),
  certificate: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  hostname: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  private_key: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListCertificates1Response" }) as unknown as Schema.Schema<ListCertificates1Response>;

export const listCertificates1: (
  input: ListCertificates1Request
) => Effect.Effect<
  ListCertificates1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListCertificates1Request,
  output: ListCertificates1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateRequest {
  zone_id: string;
  body: { certificate: string; private_key: string };
}

export const PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  certificate: Schema.String,
  private_key: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/origin_tls_client_auth/hostnames/certificates" }),
).annotations({ identifier: "PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateRequest" }) as unknown as Schema.Schema<PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateRequest>;

export interface PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateResponse" }) as unknown as Schema.Schema<PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateResponse>;

export const perHostnameAuthenticatedOriginPullUploadAHostnameClientCertificate: (
  input: PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateRequest
) => Effect.Effect<
  PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateRequest,
  output: PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetTheHostnameClientCertificateRequest {
  certificate_id: string;
  zone_id: string;
}

export const GetTheHostnameClientCertificateRequest = Schema.Struct({
  certificate_id: Schema.String.pipe(T.HttpPath("certificate_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/origin_tls_client_auth/hostnames/certificates/{certificate_id}" }),
).annotations({ identifier: "GetTheHostnameClientCertificateRequest" }) as unknown as Schema.Schema<GetTheHostnameClientCertificateRequest>;

export interface GetTheHostnameClientCertificateResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetTheHostnameClientCertificateResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetTheHostnameClientCertificateResponse" }) as unknown as Schema.Schema<GetTheHostnameClientCertificateResponse>;

export const getTheHostnameClientCertificate: (
  input: GetTheHostnameClientCertificateRequest
) => Effect.Effect<
  GetTheHostnameClientCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTheHostnameClientCertificateRequest,
  output: GetTheHostnameClientCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteHostnameClientCertificateRequest {
  certificate_id: string;
  zone_id: string;
}

export const DeleteHostnameClientCertificateRequest = Schema.Struct({
  certificate_id: Schema.String.pipe(T.HttpPath("certificate_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/origin_tls_client_auth/hostnames/certificates/{certificate_id}" }),
).annotations({ identifier: "DeleteHostnameClientCertificateRequest" }) as unknown as Schema.Schema<DeleteHostnameClientCertificateRequest>;

export interface DeleteHostnameClientCertificateResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteHostnameClientCertificateResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteHostnameClientCertificateResponse" }) as unknown as Schema.Schema<DeleteHostnameClientCertificateResponse>;

export const deleteHostnameClientCertificate: (
  input: DeleteHostnameClientCertificateRequest
) => Effect.Effect<
  DeleteHostnameClientCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteHostnameClientCertificateRequest,
  output: DeleteHostnameClientCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetTheHostnameStatusForClientAuthenticationRequest {
  hostname: string;
  zone_id: string;
}

export const GetTheHostnameStatusForClientAuthenticationRequest = Schema.Struct({
  hostname: Schema.String.pipe(T.HttpPath("hostname")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/origin_tls_client_auth/hostnames/{hostname}" }),
).annotations({ identifier: "GetTheHostnameStatusForClientAuthenticationRequest" }) as unknown as Schema.Schema<GetTheHostnameStatusForClientAuthenticationRequest>;

export interface GetTheHostnameStatusForClientAuthenticationResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetTheHostnameStatusForClientAuthenticationResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetTheHostnameStatusForClientAuthenticationResponse" }) as unknown as Schema.Schema<GetTheHostnameStatusForClientAuthenticationResponse>;

export const getTheHostnameStatusForClientAuthentication: (
  input: GetTheHostnameStatusForClientAuthenticationRequest
) => Effect.Effect<
  GetTheHostnameStatusForClientAuthenticationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTheHostnameStatusForClientAuthenticationRequest,
  output: GetTheHostnameStatusForClientAuthenticationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetEnablementSettingForZoneRequest {
  zone_id: string;
}

export const GetEnablementSettingForZoneRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/origin_tls_client_auth/settings" }),
).annotations({ identifier: "GetEnablementSettingForZoneRequest" }) as unknown as Schema.Schema<GetEnablementSettingForZoneRequest>;

export interface GetEnablementSettingForZoneResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetEnablementSettingForZoneResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetEnablementSettingForZoneResponse" }) as unknown as Schema.Schema<GetEnablementSettingForZoneResponse>;

export const getEnablementSettingForZone: (
  input: GetEnablementSettingForZoneRequest
) => Effect.Effect<
  GetEnablementSettingForZoneResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEnablementSettingForZoneRequest,
  output: GetEnablementSettingForZoneResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneRequest {
  zone_id: string;
  body: { enabled: boolean };
}

export const ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  enabled: Schema.Boolean
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/origin_tls_client_auth/settings" }),
).annotations({ identifier: "ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneRequest" }) as unknown as Schema.Schema<ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneRequest>;

export interface ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneResponse" }) as unknown as Schema.Schema<ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneResponse>;

export const zoneLevelAuthenticatedOriginPullsSetEnablementForZone: (
  input: ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneRequest
) => Effect.Effect<
  ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneRequest,
  output: ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetCertificateDetailsRequest {
  certificate_id: string;
  zone_id: string;
}

export const GetCertificateDetailsRequest = Schema.Struct({
  certificate_id: Schema.String.pipe(T.HttpPath("certificate_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/origin_tls_client_auth/{certificate_id}" }),
).annotations({ identifier: "GetCertificateDetailsRequest" }) as unknown as Schema.Schema<GetCertificateDetailsRequest>;

export interface GetCertificateDetailsResponse {
  result: { certificate?: string; enabled?: boolean; id?: string; private_key?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetCertificateDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  certificate: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  private_key: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetCertificateDetailsResponse" }) as unknown as Schema.Schema<GetCertificateDetailsResponse>;

export const getCertificateDetails: (
  input: GetCertificateDetailsRequest
) => Effect.Effect<
  GetCertificateDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCertificateDetailsRequest,
  output: GetCertificateDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteCertificateRequest {
  certificate_id: string;
  zone_id: string;
}

export const DeleteCertificateRequest = Schema.Struct({
  certificate_id: Schema.String.pipe(T.HttpPath("certificate_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/origin_tls_client_auth/{certificate_id}" }),
).annotations({ identifier: "DeleteCertificateRequest" }) as unknown as Schema.Schema<DeleteCertificateRequest>;

export interface DeleteCertificateResponse {
  result: { certificate?: string; enabled?: boolean; id?: string; private_key?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteCertificateResponse = Schema.Struct({
  result: Schema.Struct({
  certificate: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  private_key: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteCertificateResponse" }) as unknown as Schema.Schema<DeleteCertificateResponse>;

export const deleteCertificate: (
  input: DeleteCertificateRequest
) => Effect.Effect<
  DeleteCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteCertificateRequest,
  output: DeleteCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSettingsRequest {
  zone_id: string;
}

export const GetSettingsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/page_shield" }),
).annotations({ identifier: "GetSettingsRequest" }) as unknown as Schema.Schema<GetSettingsRequest>;

export interface GetSettingsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSettingsResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSettingsResponse" }) as unknown as Schema.Schema<GetSettingsResponse>;

export const getSettings: (
  input: GetSettingsRequest
) => Effect.Effect<
  GetSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSettingsRequest,
  output: GetSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateSettings1Request {
  zone_id: string;
  body: unknown;
}

export const UpdateSettings1Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/page_shield" }),
).annotations({ identifier: "UpdateSettings1Request" }) as unknown as Schema.Schema<UpdateSettings1Request>;

export interface UpdateSettings1Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateSettings1Response = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateSettings1Response" }) as unknown as Schema.Schema<UpdateSettings1Response>;

export const updateSettings1: (
  input: UpdateSettings1Request
) => Effect.Effect<
  UpdateSettings1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateSettings1Request,
  output: UpdateSettings1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListConnectionsRequest {
  zone_id: string;
  exclude_urls?: string;
  urls?: string;
  hosts?: string;
  page?: string;
  per_page?: number;
  order_by?: "first_seen_at" | "last_seen_at";
  direction?: "asc" | "desc";
  prioritize_malicious?: boolean;
  exclude_cdn_cgi?: boolean;
  status?: string;
  page_url?: string;
  export?: "csv";
}

export const ListConnectionsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  exclude_urls: Schema.optional(Schema.String).pipe(T.HttpQuery("exclude_urls")),
  urls: Schema.optional(Schema.String).pipe(T.HttpQuery("urls")),
  hosts: Schema.optional(Schema.String).pipe(T.HttpQuery("hosts")),
  page: Schema.optional(Schema.String).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order_by: Schema.optional(Schema.Literal("first_seen_at", "last_seen_at")).pipe(T.HttpQuery("order_by")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction")),
  prioritize_malicious: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("prioritize_malicious")),
  exclude_cdn_cgi: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("exclude_cdn_cgi")),
  status: Schema.optional(Schema.String).pipe(T.HttpQuery("status")),
  page_url: Schema.optional(Schema.String).pipe(T.HttpQuery("page_url")),
  export: Schema.optional(Schema.Literal("csv")).pipe(T.HttpQuery("export"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/page_shield/connections" }),
).annotations({ identifier: "ListConnectionsRequest" }) as unknown as Schema.Schema<ListConnectionsRequest>;

export interface ListConnectionsResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListConnectionsResponse = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListConnectionsResponse" }) as unknown as Schema.Schema<ListConnectionsResponse>;

export const listConnections: (
  input: ListConnectionsRequest
) => Effect.Effect<
  ListConnectionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListConnectionsRequest,
  output: ListConnectionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetConnectionRequest {
  zone_id: string;
  connection_id: string;
}

export const GetConnectionRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  connection_id: Schema.String.pipe(T.HttpPath("connection_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/page_shield/connections/{connection_id}" }),
).annotations({ identifier: "GetConnectionRequest" }) as unknown as Schema.Schema<GetConnectionRequest>;

export interface GetConnectionResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetConnectionResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetConnectionResponse" }) as unknown as Schema.Schema<GetConnectionResponse>;

export const getConnection: (
  input: GetConnectionRequest
) => Effect.Effect<
  GetConnectionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetConnectionRequest,
  output: GetConnectionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListCookiesRequest {
  zone_id: string;
  hosts?: string;
  page?: string;
  per_page?: number;
  order_by?: "first_seen_at" | "last_seen_at";
  direction?: "asc" | "desc";
  page_url?: string;
  export?: "csv";
  name?: string;
  secure?: boolean;
  http_only?: boolean;
  same_site?: "lax" | "strict" | "none";
  type?: "first_party" | "unknown";
  path?: string;
  domain?: string;
}

export const ListCookiesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  hosts: Schema.optional(Schema.String).pipe(T.HttpQuery("hosts")),
  page: Schema.optional(Schema.String).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order_by: Schema.optional(Schema.Literal("first_seen_at", "last_seen_at")).pipe(T.HttpQuery("order_by")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction")),
  page_url: Schema.optional(Schema.String).pipe(T.HttpQuery("page_url")),
  export: Schema.optional(Schema.Literal("csv")).pipe(T.HttpQuery("export")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  secure: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("secure")),
  http_only: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("http_only")),
  same_site: Schema.optional(Schema.Literal("lax", "strict", "none")).pipe(T.HttpQuery("same_site")),
  type: Schema.optional(Schema.Literal("first_party", "unknown")).pipe(T.HttpQuery("type")),
  path: Schema.optional(Schema.String).pipe(T.HttpQuery("path")),
  domain: Schema.optional(Schema.String).pipe(T.HttpQuery("domain"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/page_shield/cookies" }),
).annotations({ identifier: "ListCookiesRequest" }) as unknown as Schema.Schema<ListCookiesRequest>;

export interface ListCookiesResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListCookiesResponse = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListCookiesResponse" }) as unknown as Schema.Schema<ListCookiesResponse>;

export const listCookies: (
  input: ListCookiesRequest
) => Effect.Effect<
  ListCookiesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListCookiesRequest,
  output: ListCookiesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetCookieRequest {
  zone_id: string;
  cookie_id: string;
}

export const GetCookieRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  cookie_id: Schema.String.pipe(T.HttpPath("cookie_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/page_shield/cookies/{cookie_id}" }),
).annotations({ identifier: "GetCookieRequest" }) as unknown as Schema.Schema<GetCookieRequest>;

export interface GetCookieResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetCookieResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetCookieResponse" }) as unknown as Schema.Schema<GetCookieResponse>;

export const getCookie: (
  input: GetCookieRequest
) => Effect.Effect<
  GetCookieResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCookieRequest,
  output: GetCookieResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListPoliciesRequest {
  zone_id: string;
}

export const ListPoliciesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/page_shield/policies" }),
).annotations({ identifier: "ListPoliciesRequest" }) as unknown as Schema.Schema<ListPoliciesRequest>;

export interface ListPoliciesResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListPoliciesResponse = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListPoliciesResponse" }) as unknown as Schema.Schema<ListPoliciesResponse>;

export const listPolicies: (
  input: ListPoliciesRequest
) => Effect.Effect<
  ListPoliciesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListPoliciesRequest,
  output: ListPoliciesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatePolicyRequest {
  zone_id: string;
  body: unknown;
}

export const CreatePolicyRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/page_shield/policies" }),
).annotations({ identifier: "CreatePolicyRequest" }) as unknown as Schema.Schema<CreatePolicyRequest>;

export interface CreatePolicyResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatePolicyResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatePolicyResponse" }) as unknown as Schema.Schema<CreatePolicyResponse>;

export const createPolicy: (
  input: CreatePolicyRequest
) => Effect.Effect<
  CreatePolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatePolicyRequest,
  output: CreatePolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetPolicyRequest {
  zone_id: string;
  policy_id: string;
}

export const GetPolicyRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  policy_id: Schema.String.pipe(T.HttpPath("policy_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/page_shield/policies/{policy_id}" }),
).annotations({ identifier: "GetPolicyRequest" }) as unknown as Schema.Schema<GetPolicyRequest>;

export interface GetPolicyResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetPolicyResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetPolicyResponse" }) as unknown as Schema.Schema<GetPolicyResponse>;

export const getPolicy: (
  input: GetPolicyRequest
) => Effect.Effect<
  GetPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetPolicyRequest,
  output: GetPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatePolicyRequest {
  zone_id: string;
  policy_id: string;
  body: unknown;
}

export const UpdatePolicyRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  policy_id: Schema.String.pipe(T.HttpPath("policy_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/page_shield/policies/{policy_id}" }),
).annotations({ identifier: "UpdatePolicyRequest" }) as unknown as Schema.Schema<UpdatePolicyRequest>;

export interface UpdatePolicyResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatePolicyResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatePolicyResponse" }) as unknown as Schema.Schema<UpdatePolicyResponse>;

export const updatePolicy: (
  input: UpdatePolicyRequest
) => Effect.Effect<
  UpdatePolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatePolicyRequest,
  output: UpdatePolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletePolicyRequest {
  zone_id: string;
  policy_id: string;
}

export const DeletePolicyRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  policy_id: Schema.String.pipe(T.HttpPath("policy_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/page_shield/policies/{policy_id}" }),
).annotations({ identifier: "DeletePolicyRequest" }) as unknown as Schema.Schema<DeletePolicyRequest>;

export interface DeletePolicyResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletePolicyResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletePolicyResponse" }) as unknown as Schema.Schema<DeletePolicyResponse>;

export const deletePolicy: (
  input: DeletePolicyRequest
) => Effect.Effect<
  DeletePolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletePolicyRequest,
  output: DeletePolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListScriptsRequest {
  zone_id: string;
  exclude_urls?: string;
  urls?: string;
  hosts?: string;
  page?: string;
  per_page?: number;
  order_by?: "first_seen_at" | "last_seen_at";
  direction?: "asc" | "desc";
  prioritize_malicious?: boolean;
  exclude_cdn_cgi?: boolean;
  exclude_duplicates?: boolean;
  status?: string;
  page_url?: string;
  export?: "csv";
}

export const ListScriptsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  exclude_urls: Schema.optional(Schema.String).pipe(T.HttpQuery("exclude_urls")),
  urls: Schema.optional(Schema.String).pipe(T.HttpQuery("urls")),
  hosts: Schema.optional(Schema.String).pipe(T.HttpQuery("hosts")),
  page: Schema.optional(Schema.String).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order_by: Schema.optional(Schema.Literal("first_seen_at", "last_seen_at")).pipe(T.HttpQuery("order_by")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction")),
  prioritize_malicious: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("prioritize_malicious")),
  exclude_cdn_cgi: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("exclude_cdn_cgi")),
  exclude_duplicates: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("exclude_duplicates")),
  status: Schema.optional(Schema.String).pipe(T.HttpQuery("status")),
  page_url: Schema.optional(Schema.String).pipe(T.HttpQuery("page_url")),
  export: Schema.optional(Schema.Literal("csv")).pipe(T.HttpQuery("export"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/page_shield/scripts" }),
).annotations({ identifier: "ListScriptsRequest" }) as unknown as Schema.Schema<ListScriptsRequest>;

export interface ListScriptsResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListScriptsResponse = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListScriptsResponse" }) as unknown as Schema.Schema<ListScriptsResponse>;

export const listScripts: (
  input: ListScriptsRequest
) => Effect.Effect<
  ListScriptsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListScriptsRequest,
  output: ListScriptsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetScriptRequest {
  zone_id: string;
  script_id: string;
}

export const GetScriptRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  script_id: Schema.String.pipe(T.HttpPath("script_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/page_shield/scripts/{script_id}" }),
).annotations({ identifier: "GetScriptRequest" }) as unknown as Schema.Schema<GetScriptRequest>;

export interface GetScriptResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetScriptResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetScriptResponse" }) as unknown as Schema.Schema<GetScriptResponse>;

export const getScript: (
  input: GetScriptRequest
) => Effect.Effect<
  GetScriptResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetScriptRequest,
  output: GetScriptResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListPageRulesRequest {
  zone_id: string;
  order?: "status" | "priority";
  direction?: "asc" | "desc";
  match?: "any" | "all";
  status?: "active" | "disabled";
}

export const ListPageRulesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  order: Schema.optional(Schema.Literal("status", "priority")).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction")),
  match: Schema.optional(Schema.Literal("any", "all")).pipe(T.HttpQuery("match")),
  status: Schema.optional(Schema.Literal("active", "disabled")).pipe(T.HttpQuery("status"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/pagerules" }),
).annotations({ identifier: "ListPageRulesRequest" }) as unknown as Schema.Schema<ListPageRulesRequest>;

export interface ListPageRulesResponse {
  result: { actions: unknown[]; created_on: string; id: string; modified_on: string; priority: number; status: "active" | "disabled"; targets: unknown[] }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListPageRulesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  actions: Schema.Array(Schema.Union(Schema.Struct({
  id: Schema.optional(Schema.Literal("always_use_https"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("automatic_https_rewrites")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("browser_cache_ttl")),
  value: Schema.optional(Schema.Number)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("browser_check")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("bypass_cache_on_cookie")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_by_device_type")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_deception_armor")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_key_fields")),
  value: Schema.optional(Schema.Struct({
  cookie: Schema.optional(Schema.Struct({
  check_presence: Schema.optional(Schema.Array(Schema.String)),
  include: Schema.optional(Schema.Array(Schema.String))
})),
  header: Schema.optional(Schema.Struct({
  check_presence: Schema.optional(Schema.Array(Schema.String)),
  exclude: Schema.optional(Schema.Array(Schema.String)),
  include: Schema.optional(Schema.Array(Schema.String))
})),
  host: Schema.optional(Schema.Struct({
  resolved: Schema.optional(Schema.Boolean)
})),
  query_string: Schema.optional(Schema.Struct({
  exclude: Schema.optional(Schema.Union(Schema.Literal("*"), Schema.Array(Schema.String))),
  include: Schema.optional(Schema.Union(Schema.Literal("*"), Schema.Array(Schema.String)))
})),
  user: Schema.optional(Schema.Struct({
  device_type: Schema.optional(Schema.Boolean),
  geo: Schema.optional(Schema.Boolean),
  lang: Schema.optional(Schema.Boolean)
}))
}))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_level")),
  value: Schema.optional(Schema.Literal("bypass", "basic", "simplified", "aggressive", "cache_everything"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_on_cookie")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_ttl_by_status")),
  value: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Union(Schema.Literal("no-cache", "no-store"), Schema.Number) }))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_apps"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_performance"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_security"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_zaraz"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("edge_cache_ttl")),
  value: Schema.optional(Schema.Number)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("email_obfuscation")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("explicit_cache_control")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("forwarding_url")),
  value: Schema.optional(Schema.Unknown)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("host_header_override")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("ip_geolocation")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("mirage")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("opportunistic_encryption")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("origin_error_page_pass_thru")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("polish")),
  value: Schema.optional(Schema.Literal("off", "lossless", "lossy"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("resolve_override")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("respect_strong_etag")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("response_buffering")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("rocket_loader")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("security_level")),
  value: Schema.optional(Schema.Literal("off", "essentially_off", "low", "medium", "high", "under_attack"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("sort_query_string_for_cache")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("ssl")),
  value: Schema.optional(Schema.Literal("off", "flexible", "full", "strict", "origin_pull"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("true_client_ip_header")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("waf")),
  value: Schema.optional(Schema.Literal("on", "off"))
}))),
  created_on: Schema.Date,
  id: Schema.String,
  modified_on: Schema.Date,
  priority: Schema.Number,
  status: Schema.Literal("active", "disabled"),
  targets: Schema.Array(Schema.Union(Schema.Struct({
  constraint: Schema.optional(Schema.Struct({})),
  target: Schema.optional(Schema.Literal("url"))
})))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListPageRulesResponse" }) as unknown as Schema.Schema<ListPageRulesResponse>;

export const listPageRules: (
  input: ListPageRulesRequest
) => Effect.Effect<
  ListPageRulesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListPageRulesRequest,
  output: ListPageRulesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateAPageRuleRequest {
  zone_id: string;
  body: { actions: unknown[]; priority?: number; status?: "active" | "disabled"; targets: unknown[] };
}

export const CreateAPageRuleRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  actions: Schema.Array(Schema.Union(Schema.Struct({
  id: Schema.optional(Schema.Literal("always_use_https"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("automatic_https_rewrites")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("browser_cache_ttl")),
  value: Schema.optional(Schema.Number)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("browser_check")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("bypass_cache_on_cookie")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_by_device_type")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_deception_armor")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_key_fields")),
  value: Schema.optional(Schema.Struct({
  cookie: Schema.optional(Schema.Struct({
  check_presence: Schema.optional(Schema.Array(Schema.String)),
  include: Schema.optional(Schema.Array(Schema.String))
})),
  header: Schema.optional(Schema.Struct({
  check_presence: Schema.optional(Schema.Array(Schema.String)),
  exclude: Schema.optional(Schema.Array(Schema.String)),
  include: Schema.optional(Schema.Array(Schema.String))
})),
  host: Schema.optional(Schema.Struct({
  resolved: Schema.optional(Schema.Boolean)
})),
  query_string: Schema.optional(Schema.Struct({
  exclude: Schema.optional(Schema.Union(Schema.Literal("*"), Schema.Array(Schema.String))),
  include: Schema.optional(Schema.Union(Schema.Literal("*"), Schema.Array(Schema.String)))
})),
  user: Schema.optional(Schema.Struct({
  device_type: Schema.optional(Schema.Boolean),
  geo: Schema.optional(Schema.Boolean),
  lang: Schema.optional(Schema.Boolean)
}))
}))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_level")),
  value: Schema.optional(Schema.Literal("bypass", "basic", "simplified", "aggressive", "cache_everything"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_on_cookie")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_ttl_by_status")),
  value: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Union(Schema.Literal("no-cache", "no-store"), Schema.Number) }))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_apps"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_performance"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_security"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_zaraz"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("edge_cache_ttl")),
  value: Schema.optional(Schema.Number)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("email_obfuscation")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("explicit_cache_control")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("forwarding_url")),
  value: Schema.optional(Schema.Unknown)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("host_header_override")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("ip_geolocation")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("mirage")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("opportunistic_encryption")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("origin_error_page_pass_thru")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("polish")),
  value: Schema.optional(Schema.Literal("off", "lossless", "lossy"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("resolve_override")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("respect_strong_etag")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("response_buffering")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("rocket_loader")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("security_level")),
  value: Schema.optional(Schema.Literal("off", "essentially_off", "low", "medium", "high", "under_attack"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("sort_query_string_for_cache")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("ssl")),
  value: Schema.optional(Schema.Literal("off", "flexible", "full", "strict", "origin_pull"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("true_client_ip_header")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("waf")),
  value: Schema.optional(Schema.Literal("on", "off"))
}))),
  priority: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("active", "disabled")),
  targets: Schema.Array(Schema.Union(Schema.Struct({
  constraint: Schema.optional(Schema.Struct({})),
  target: Schema.optional(Schema.Literal("url"))
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/pagerules" }),
).annotations({ identifier: "CreateAPageRuleRequest" }) as unknown as Schema.Schema<CreateAPageRuleRequest>;

export interface CreateAPageRuleResponse {
  result: { actions: unknown[]; created_on: string; id: string; modified_on: string; priority: number; status: "active" | "disabled"; targets: unknown[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateAPageRuleResponse = Schema.Struct({
  result: Schema.Struct({
  actions: Schema.Array(Schema.Union(Schema.Struct({
  id: Schema.optional(Schema.Literal("always_use_https"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("automatic_https_rewrites")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("browser_cache_ttl")),
  value: Schema.optional(Schema.Number)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("browser_check")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("bypass_cache_on_cookie")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_by_device_type")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_deception_armor")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_key_fields")),
  value: Schema.optional(Schema.Struct({
  cookie: Schema.optional(Schema.Struct({
  check_presence: Schema.optional(Schema.Array(Schema.String)),
  include: Schema.optional(Schema.Array(Schema.String))
})),
  header: Schema.optional(Schema.Struct({
  check_presence: Schema.optional(Schema.Array(Schema.String)),
  exclude: Schema.optional(Schema.Array(Schema.String)),
  include: Schema.optional(Schema.Array(Schema.String))
})),
  host: Schema.optional(Schema.Struct({
  resolved: Schema.optional(Schema.Boolean)
})),
  query_string: Schema.optional(Schema.Struct({
  exclude: Schema.optional(Schema.Union(Schema.Literal("*"), Schema.Array(Schema.String))),
  include: Schema.optional(Schema.Union(Schema.Literal("*"), Schema.Array(Schema.String)))
})),
  user: Schema.optional(Schema.Struct({
  device_type: Schema.optional(Schema.Boolean),
  geo: Schema.optional(Schema.Boolean),
  lang: Schema.optional(Schema.Boolean)
}))
}))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_level")),
  value: Schema.optional(Schema.Literal("bypass", "basic", "simplified", "aggressive", "cache_everything"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_on_cookie")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_ttl_by_status")),
  value: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Union(Schema.Literal("no-cache", "no-store"), Schema.Number) }))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_apps"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_performance"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_security"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_zaraz"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("edge_cache_ttl")),
  value: Schema.optional(Schema.Number)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("email_obfuscation")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("explicit_cache_control")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("forwarding_url")),
  value: Schema.optional(Schema.Unknown)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("host_header_override")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("ip_geolocation")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("mirage")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("opportunistic_encryption")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("origin_error_page_pass_thru")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("polish")),
  value: Schema.optional(Schema.Literal("off", "lossless", "lossy"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("resolve_override")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("respect_strong_etag")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("response_buffering")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("rocket_loader")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("security_level")),
  value: Schema.optional(Schema.Literal("off", "essentially_off", "low", "medium", "high", "under_attack"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("sort_query_string_for_cache")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("ssl")),
  value: Schema.optional(Schema.Literal("off", "flexible", "full", "strict", "origin_pull"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("true_client_ip_header")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("waf")),
  value: Schema.optional(Schema.Literal("on", "off"))
}))),
  created_on: Schema.Date,
  id: Schema.String,
  modified_on: Schema.Date,
  priority: Schema.Number,
  status: Schema.Literal("active", "disabled"),
  targets: Schema.Array(Schema.Union(Schema.Struct({
  constraint: Schema.optional(Schema.Struct({})),
  target: Schema.optional(Schema.Literal("url"))
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateAPageRuleResponse" }) as unknown as Schema.Schema<CreateAPageRuleResponse>;

export const createAPageRule: (
  input: CreateAPageRuleRequest
) => Effect.Effect<
  CreateAPageRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAPageRuleRequest,
  output: CreateAPageRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAvailablePageRulesSettingsRequest {
  zone_id: string;
}

export const ListAvailablePageRulesSettingsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/pagerules/settings" }),
).annotations({ identifier: "ListAvailablePageRulesSettingsRequest" }) as unknown as Schema.Schema<ListAvailablePageRulesSettingsRequest>;

export interface ListAvailablePageRulesSettingsResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAvailablePageRulesSettingsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAvailablePageRulesSettingsResponse" }) as unknown as Schema.Schema<ListAvailablePageRulesSettingsResponse>;

export const listAvailablePageRulesSettings: (
  input: ListAvailablePageRulesSettingsRequest
) => Effect.Effect<
  ListAvailablePageRulesSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAvailablePageRulesSettingsRequest,
  output: ListAvailablePageRulesSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAPageRuleRequest {
  pagerule_id: string;
  zone_id: string;
}

export const GetAPageRuleRequest = Schema.Struct({
  pagerule_id: Schema.String.pipe(T.HttpPath("pagerule_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/pagerules/{pagerule_id}" }),
).annotations({ identifier: "GetAPageRuleRequest" }) as unknown as Schema.Schema<GetAPageRuleRequest>;

export interface GetAPageRuleResponse {
  result: { actions: unknown[]; created_on: string; id: string; modified_on: string; priority: number; status: "active" | "disabled"; targets: unknown[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAPageRuleResponse = Schema.Struct({
  result: Schema.Struct({
  actions: Schema.Array(Schema.Union(Schema.Struct({
  id: Schema.optional(Schema.Literal("always_use_https"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("automatic_https_rewrites")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("browser_cache_ttl")),
  value: Schema.optional(Schema.Number)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("browser_check")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("bypass_cache_on_cookie")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_by_device_type")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_deception_armor")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_key_fields")),
  value: Schema.optional(Schema.Struct({
  cookie: Schema.optional(Schema.Struct({
  check_presence: Schema.optional(Schema.Array(Schema.String)),
  include: Schema.optional(Schema.Array(Schema.String))
})),
  header: Schema.optional(Schema.Struct({
  check_presence: Schema.optional(Schema.Array(Schema.String)),
  exclude: Schema.optional(Schema.Array(Schema.String)),
  include: Schema.optional(Schema.Array(Schema.String))
})),
  host: Schema.optional(Schema.Struct({
  resolved: Schema.optional(Schema.Boolean)
})),
  query_string: Schema.optional(Schema.Struct({
  exclude: Schema.optional(Schema.Union(Schema.Literal("*"), Schema.Array(Schema.String))),
  include: Schema.optional(Schema.Union(Schema.Literal("*"), Schema.Array(Schema.String)))
})),
  user: Schema.optional(Schema.Struct({
  device_type: Schema.optional(Schema.Boolean),
  geo: Schema.optional(Schema.Boolean),
  lang: Schema.optional(Schema.Boolean)
}))
}))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_level")),
  value: Schema.optional(Schema.Literal("bypass", "basic", "simplified", "aggressive", "cache_everything"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_on_cookie")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_ttl_by_status")),
  value: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Union(Schema.Literal("no-cache", "no-store"), Schema.Number) }))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_apps"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_performance"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_security"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_zaraz"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("edge_cache_ttl")),
  value: Schema.optional(Schema.Number)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("email_obfuscation")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("explicit_cache_control")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("forwarding_url")),
  value: Schema.optional(Schema.Unknown)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("host_header_override")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("ip_geolocation")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("mirage")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("opportunistic_encryption")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("origin_error_page_pass_thru")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("polish")),
  value: Schema.optional(Schema.Literal("off", "lossless", "lossy"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("resolve_override")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("respect_strong_etag")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("response_buffering")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("rocket_loader")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("security_level")),
  value: Schema.optional(Schema.Literal("off", "essentially_off", "low", "medium", "high", "under_attack"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("sort_query_string_for_cache")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("ssl")),
  value: Schema.optional(Schema.Literal("off", "flexible", "full", "strict", "origin_pull"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("true_client_ip_header")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("waf")),
  value: Schema.optional(Schema.Literal("on", "off"))
}))),
  created_on: Schema.Date,
  id: Schema.String,
  modified_on: Schema.Date,
  priority: Schema.Number,
  status: Schema.Literal("active", "disabled"),
  targets: Schema.Array(Schema.Union(Schema.Struct({
  constraint: Schema.optional(Schema.Struct({})),
  target: Schema.optional(Schema.Literal("url"))
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAPageRuleResponse" }) as unknown as Schema.Schema<GetAPageRuleResponse>;

export const getAPageRule: (
  input: GetAPageRuleRequest
) => Effect.Effect<
  GetAPageRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAPageRuleRequest,
  output: GetAPageRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAPageRuleRequest {
  pagerule_id: string;
  zone_id: string;
  body: { actions: unknown[]; priority?: number; status?: "active" | "disabled"; targets: unknown[] };
}

export const UpdateAPageRuleRequest = Schema.Struct({
  pagerule_id: Schema.String.pipe(T.HttpPath("pagerule_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  actions: Schema.Array(Schema.Union(Schema.Struct({
  id: Schema.optional(Schema.Literal("always_use_https"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("automatic_https_rewrites")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("browser_cache_ttl")),
  value: Schema.optional(Schema.Number)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("browser_check")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("bypass_cache_on_cookie")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_by_device_type")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_deception_armor")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_key_fields")),
  value: Schema.optional(Schema.Struct({
  cookie: Schema.optional(Schema.Struct({
  check_presence: Schema.optional(Schema.Array(Schema.String)),
  include: Schema.optional(Schema.Array(Schema.String))
})),
  header: Schema.optional(Schema.Struct({
  check_presence: Schema.optional(Schema.Array(Schema.String)),
  exclude: Schema.optional(Schema.Array(Schema.String)),
  include: Schema.optional(Schema.Array(Schema.String))
})),
  host: Schema.optional(Schema.Struct({
  resolved: Schema.optional(Schema.Boolean)
})),
  query_string: Schema.optional(Schema.Struct({
  exclude: Schema.optional(Schema.Union(Schema.Literal("*"), Schema.Array(Schema.String))),
  include: Schema.optional(Schema.Union(Schema.Literal("*"), Schema.Array(Schema.String)))
})),
  user: Schema.optional(Schema.Struct({
  device_type: Schema.optional(Schema.Boolean),
  geo: Schema.optional(Schema.Boolean),
  lang: Schema.optional(Schema.Boolean)
}))
}))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_level")),
  value: Schema.optional(Schema.Literal("bypass", "basic", "simplified", "aggressive", "cache_everything"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_on_cookie")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_ttl_by_status")),
  value: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Union(Schema.Literal("no-cache", "no-store"), Schema.Number) }))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_apps"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_performance"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_security"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_zaraz"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("edge_cache_ttl")),
  value: Schema.optional(Schema.Number)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("email_obfuscation")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("explicit_cache_control")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("forwarding_url")),
  value: Schema.optional(Schema.Unknown)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("host_header_override")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("ip_geolocation")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("mirage")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("opportunistic_encryption")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("origin_error_page_pass_thru")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("polish")),
  value: Schema.optional(Schema.Literal("off", "lossless", "lossy"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("resolve_override")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("respect_strong_etag")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("response_buffering")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("rocket_loader")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("security_level")),
  value: Schema.optional(Schema.Literal("off", "essentially_off", "low", "medium", "high", "under_attack"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("sort_query_string_for_cache")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("ssl")),
  value: Schema.optional(Schema.Literal("off", "flexible", "full", "strict", "origin_pull"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("true_client_ip_header")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("waf")),
  value: Schema.optional(Schema.Literal("on", "off"))
}))),
  priority: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("active", "disabled")),
  targets: Schema.Array(Schema.Union(Schema.Struct({
  constraint: Schema.optional(Schema.Struct({})),
  target: Schema.optional(Schema.Literal("url"))
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/pagerules/{pagerule_id}" }),
).annotations({ identifier: "UpdateAPageRuleRequest" }) as unknown as Schema.Schema<UpdateAPageRuleRequest>;

export interface UpdateAPageRuleResponse {
  result: { actions: unknown[]; created_on: string; id: string; modified_on: string; priority: number; status: "active" | "disabled"; targets: unknown[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAPageRuleResponse = Schema.Struct({
  result: Schema.Struct({
  actions: Schema.Array(Schema.Union(Schema.Struct({
  id: Schema.optional(Schema.Literal("always_use_https"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("automatic_https_rewrites")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("browser_cache_ttl")),
  value: Schema.optional(Schema.Number)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("browser_check")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("bypass_cache_on_cookie")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_by_device_type")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_deception_armor")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_key_fields")),
  value: Schema.optional(Schema.Struct({
  cookie: Schema.optional(Schema.Struct({
  check_presence: Schema.optional(Schema.Array(Schema.String)),
  include: Schema.optional(Schema.Array(Schema.String))
})),
  header: Schema.optional(Schema.Struct({
  check_presence: Schema.optional(Schema.Array(Schema.String)),
  exclude: Schema.optional(Schema.Array(Schema.String)),
  include: Schema.optional(Schema.Array(Schema.String))
})),
  host: Schema.optional(Schema.Struct({
  resolved: Schema.optional(Schema.Boolean)
})),
  query_string: Schema.optional(Schema.Struct({
  exclude: Schema.optional(Schema.Union(Schema.Literal("*"), Schema.Array(Schema.String))),
  include: Schema.optional(Schema.Union(Schema.Literal("*"), Schema.Array(Schema.String)))
})),
  user: Schema.optional(Schema.Struct({
  device_type: Schema.optional(Schema.Boolean),
  geo: Schema.optional(Schema.Boolean),
  lang: Schema.optional(Schema.Boolean)
}))
}))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_level")),
  value: Schema.optional(Schema.Literal("bypass", "basic", "simplified", "aggressive", "cache_everything"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_on_cookie")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_ttl_by_status")),
  value: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Union(Schema.Literal("no-cache", "no-store"), Schema.Number) }))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_apps"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_performance"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_security"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_zaraz"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("edge_cache_ttl")),
  value: Schema.optional(Schema.Number)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("email_obfuscation")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("explicit_cache_control")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("forwarding_url")),
  value: Schema.optional(Schema.Unknown)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("host_header_override")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("ip_geolocation")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("mirage")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("opportunistic_encryption")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("origin_error_page_pass_thru")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("polish")),
  value: Schema.optional(Schema.Literal("off", "lossless", "lossy"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("resolve_override")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("respect_strong_etag")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("response_buffering")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("rocket_loader")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("security_level")),
  value: Schema.optional(Schema.Literal("off", "essentially_off", "low", "medium", "high", "under_attack"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("sort_query_string_for_cache")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("ssl")),
  value: Schema.optional(Schema.Literal("off", "flexible", "full", "strict", "origin_pull"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("true_client_ip_header")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("waf")),
  value: Schema.optional(Schema.Literal("on", "off"))
}))),
  created_on: Schema.Date,
  id: Schema.String,
  modified_on: Schema.Date,
  priority: Schema.Number,
  status: Schema.Literal("active", "disabled"),
  targets: Schema.Array(Schema.Union(Schema.Struct({
  constraint: Schema.optional(Schema.Struct({})),
  target: Schema.optional(Schema.Literal("url"))
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAPageRuleResponse" }) as unknown as Schema.Schema<UpdateAPageRuleResponse>;

export const updateAPageRule: (
  input: UpdateAPageRuleRequest
) => Effect.Effect<
  UpdateAPageRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAPageRuleRequest,
  output: UpdateAPageRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAPageRuleRequest {
  pagerule_id: string;
  zone_id: string;
}

export const DeleteAPageRuleRequest = Schema.Struct({
  pagerule_id: Schema.String.pipe(T.HttpPath("pagerule_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/pagerules/{pagerule_id}" }),
).annotations({ identifier: "DeleteAPageRuleRequest" }) as unknown as Schema.Schema<DeleteAPageRuleRequest>;

export interface DeleteAPageRuleResponse {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAPageRuleResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAPageRuleResponse" }) as unknown as Schema.Schema<DeleteAPageRuleResponse>;

export const deleteAPageRule: (
  input: DeleteAPageRuleRequest
) => Effect.Effect<
  DeleteAPageRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAPageRuleRequest,
  output: DeleteAPageRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PageRulesEditAPageRuleRequest {
  pagerule_id: string;
  zone_id: string;
  body: { actions?: unknown[]; priority?: number; status?: "active" | "disabled"; targets?: unknown[] };
}

export const PageRulesEditAPageRuleRequest = Schema.Struct({
  pagerule_id: Schema.String.pipe(T.HttpPath("pagerule_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  actions: Schema.optional(Schema.Array(Schema.Union(Schema.Struct({
  id: Schema.optional(Schema.Literal("always_use_https"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("automatic_https_rewrites")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("browser_cache_ttl")),
  value: Schema.optional(Schema.Number)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("browser_check")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("bypass_cache_on_cookie")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_by_device_type")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_deception_armor")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_key_fields")),
  value: Schema.optional(Schema.Struct({
  cookie: Schema.optional(Schema.Struct({
  check_presence: Schema.optional(Schema.Array(Schema.String)),
  include: Schema.optional(Schema.Array(Schema.String))
})),
  header: Schema.optional(Schema.Struct({
  check_presence: Schema.optional(Schema.Array(Schema.String)),
  exclude: Schema.optional(Schema.Array(Schema.String)),
  include: Schema.optional(Schema.Array(Schema.String))
})),
  host: Schema.optional(Schema.Struct({
  resolved: Schema.optional(Schema.Boolean)
})),
  query_string: Schema.optional(Schema.Struct({
  exclude: Schema.optional(Schema.Union(Schema.Literal("*"), Schema.Array(Schema.String))),
  include: Schema.optional(Schema.Union(Schema.Literal("*"), Schema.Array(Schema.String)))
})),
  user: Schema.optional(Schema.Struct({
  device_type: Schema.optional(Schema.Boolean),
  geo: Schema.optional(Schema.Boolean),
  lang: Schema.optional(Schema.Boolean)
}))
}))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_level")),
  value: Schema.optional(Schema.Literal("bypass", "basic", "simplified", "aggressive", "cache_everything"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_on_cookie")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_ttl_by_status")),
  value: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Union(Schema.Literal("no-cache", "no-store"), Schema.Number) }))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_apps"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_performance"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_security"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_zaraz"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("edge_cache_ttl")),
  value: Schema.optional(Schema.Number)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("email_obfuscation")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("explicit_cache_control")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("forwarding_url")),
  value: Schema.optional(Schema.Unknown)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("host_header_override")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("ip_geolocation")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("mirage")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("opportunistic_encryption")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("origin_error_page_pass_thru")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("polish")),
  value: Schema.optional(Schema.Literal("off", "lossless", "lossy"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("resolve_override")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("respect_strong_etag")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("response_buffering")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("rocket_loader")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("security_level")),
  value: Schema.optional(Schema.Literal("off", "essentially_off", "low", "medium", "high", "under_attack"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("sort_query_string_for_cache")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("ssl")),
  value: Schema.optional(Schema.Literal("off", "flexible", "full", "strict", "origin_pull"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("true_client_ip_header")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("waf")),
  value: Schema.optional(Schema.Literal("on", "off"))
})))),
  priority: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("active", "disabled")),
  targets: Schema.optional(Schema.Array(Schema.Union(Schema.Struct({
  constraint: Schema.optional(Schema.Struct({})),
  target: Schema.optional(Schema.Literal("url"))
}))))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/pagerules/{pagerule_id}" }),
).annotations({ identifier: "PageRulesEditAPageRuleRequest" }) as unknown as Schema.Schema<PageRulesEditAPageRuleRequest>;

export interface PageRulesEditAPageRuleResponse {
  result: { actions: unknown[]; created_on: string; id: string; modified_on: string; priority: number; status: "active" | "disabled"; targets: unknown[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PageRulesEditAPageRuleResponse = Schema.Struct({
  result: Schema.Struct({
  actions: Schema.Array(Schema.Union(Schema.Struct({
  id: Schema.optional(Schema.Literal("always_use_https"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("automatic_https_rewrites")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("browser_cache_ttl")),
  value: Schema.optional(Schema.Number)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("browser_check")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("bypass_cache_on_cookie")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_by_device_type")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_deception_armor")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_key_fields")),
  value: Schema.optional(Schema.Struct({
  cookie: Schema.optional(Schema.Struct({
  check_presence: Schema.optional(Schema.Array(Schema.String)),
  include: Schema.optional(Schema.Array(Schema.String))
})),
  header: Schema.optional(Schema.Struct({
  check_presence: Schema.optional(Schema.Array(Schema.String)),
  exclude: Schema.optional(Schema.Array(Schema.String)),
  include: Schema.optional(Schema.Array(Schema.String))
})),
  host: Schema.optional(Schema.Struct({
  resolved: Schema.optional(Schema.Boolean)
})),
  query_string: Schema.optional(Schema.Struct({
  exclude: Schema.optional(Schema.Union(Schema.Literal("*"), Schema.Array(Schema.String))),
  include: Schema.optional(Schema.Union(Schema.Literal("*"), Schema.Array(Schema.String)))
})),
  user: Schema.optional(Schema.Struct({
  device_type: Schema.optional(Schema.Boolean),
  geo: Schema.optional(Schema.Boolean),
  lang: Schema.optional(Schema.Boolean)
}))
}))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_level")),
  value: Schema.optional(Schema.Literal("bypass", "basic", "simplified", "aggressive", "cache_everything"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_on_cookie")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("cache_ttl_by_status")),
  value: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Union(Schema.Literal("no-cache", "no-store"), Schema.Number) }))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_apps"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_performance"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_security"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("disable_zaraz"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("edge_cache_ttl")),
  value: Schema.optional(Schema.Number)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("email_obfuscation")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("explicit_cache_control")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("forwarding_url")),
  value: Schema.optional(Schema.Unknown)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("host_header_override")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("ip_geolocation")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("mirage")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("opportunistic_encryption")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("origin_error_page_pass_thru")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("polish")),
  value: Schema.optional(Schema.Literal("off", "lossless", "lossy"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("resolve_override")),
  value: Schema.optional(Schema.String)
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("respect_strong_etag")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("response_buffering")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("rocket_loader")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("security_level")),
  value: Schema.optional(Schema.Literal("off", "essentially_off", "low", "medium", "high", "under_attack"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("sort_query_string_for_cache")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("ssl")),
  value: Schema.optional(Schema.Literal("off", "flexible", "full", "strict", "origin_pull"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("true_client_ip_header")),
  value: Schema.optional(Schema.Literal("on", "off"))
}), Schema.Struct({
  id: Schema.optional(Schema.Literal("waf")),
  value: Schema.optional(Schema.Literal("on", "off"))
}))),
  created_on: Schema.Date,
  id: Schema.String,
  modified_on: Schema.Date,
  priority: Schema.Number,
  status: Schema.Literal("active", "disabled"),
  targets: Schema.Array(Schema.Union(Schema.Struct({
  constraint: Schema.optional(Schema.Struct({})),
  target: Schema.optional(Schema.Literal("url"))
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PageRulesEditAPageRuleResponse" }) as unknown as Schema.Schema<PageRulesEditAPageRuleResponse>;

export const pageRulesEditAPageRule: (
  input: PageRulesEditAPageRuleRequest
) => Effect.Effect<
  PageRulesEditAPageRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PageRulesEditAPageRuleRequest,
  output: PageRulesEditAPageRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PayPerCrawlgetconfigRequest {
  zone_id: string;
}

export const PayPerCrawlgetconfigRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/pay-per-crawl/configuration" }),
).annotations({ identifier: "PayPerCrawlgetconfigRequest" }) as unknown as Schema.Schema<PayPerCrawlgetconfigRequest>;

export interface PayPerCrawlgetconfigResponse {
  result: { bot_overrides?: Record<string, unknown>; enabled?: boolean; price_usd_microcents?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PayPerCrawlgetconfigResponse = Schema.Struct({
  result: Schema.Struct({
  bot_overrides: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Literal("charge", "bypass") })),
  enabled: Schema.optional(Schema.Boolean),
  price_usd_microcents: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PayPerCrawlgetconfigResponse" }) as unknown as Schema.Schema<PayPerCrawlgetconfigResponse>;

export const payPerCrawlgetconfig: (
  input: PayPerCrawlgetconfigRequest
) => Effect.Effect<
  PayPerCrawlgetconfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PayPerCrawlgetconfigRequest,
  output: PayPerCrawlgetconfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PayPerCrawlcreateconfigRequest {
  zone_id: string;
  body: { bot_overrides?: Record<string, unknown>; enabled?: boolean; price_usd_microcents?: number };
}

export const PayPerCrawlcreateconfigRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  bot_overrides: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Literal("charge", "bypass") })),
  enabled: Schema.optional(Schema.Boolean),
  price_usd_microcents: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/pay-per-crawl/configuration" }),
).annotations({ identifier: "PayPerCrawlcreateconfigRequest" }) as unknown as Schema.Schema<PayPerCrawlcreateconfigRequest>;

export interface PayPerCrawlcreateconfigResponse {
  result: { bot_overrides?: Record<string, unknown>; enabled?: boolean; price_usd_microcents?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PayPerCrawlcreateconfigResponse = Schema.Struct({
  result: Schema.Struct({
  bot_overrides: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Literal("charge", "bypass") })),
  enabled: Schema.optional(Schema.Boolean),
  price_usd_microcents: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PayPerCrawlcreateconfigResponse" }) as unknown as Schema.Schema<PayPerCrawlcreateconfigResponse>;

export const payPerCrawlcreateconfig: (
  input: PayPerCrawlcreateconfigRequest
) => Effect.Effect<
  PayPerCrawlcreateconfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PayPerCrawlcreateconfigRequest,
  output: PayPerCrawlcreateconfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PayPerCrawlpatchconfigRequest {
  zone_id: string;
  body: { bot_overrides?: Record<string, unknown>; enabled?: boolean; price_usd_microcents?: number };
}

export const PayPerCrawlpatchconfigRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  bot_overrides: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Literal("charge", "bypass") })),
  enabled: Schema.optional(Schema.Boolean),
  price_usd_microcents: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/pay-per-crawl/configuration" }),
).annotations({ identifier: "PayPerCrawlpatchconfigRequest" }) as unknown as Schema.Schema<PayPerCrawlpatchconfigRequest>;

export interface PayPerCrawlpatchconfigResponse {
  result: { bot_overrides?: Record<string, unknown>; enabled?: boolean; price_usd_microcents?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PayPerCrawlpatchconfigResponse = Schema.Struct({
  result: Schema.Struct({
  bot_overrides: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Literal("charge", "bypass") })),
  enabled: Schema.optional(Schema.Boolean),
  price_usd_microcents: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PayPerCrawlpatchconfigResponse" }) as unknown as Schema.Schema<PayPerCrawlpatchconfigResponse>;

export const payPerCrawlpatchconfig: (
  input: PayPerCrawlpatchconfigRequest
) => Effect.Effect<
  PayPerCrawlpatchconfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PayPerCrawlpatchconfigRequest,
  output: PayPerCrawlpatchconfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZonePurgeRequest {
  zone_id: string;
  body: unknown;
}

export const ZonePurgeRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Union(Schema.Struct({
  tags: Schema.optional(Schema.Array(Schema.String))
}), Schema.Struct({
  hosts: Schema.optional(Schema.Array(Schema.String))
}), Schema.Struct({
  prefixes: Schema.optional(Schema.Array(Schema.String))
}), Schema.Struct({
  purge_everything: Schema.optional(Schema.Boolean)
}), Schema.Struct({
  files: Schema.optional(Schema.Array(Schema.String))
}), Schema.Struct({
  files: Schema.optional(Schema.Array(Schema.Struct({
  headers: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  url: Schema.optional(Schema.String)
})))
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/purge_cache" }),
).annotations({ identifier: "ZonePurgeRequest" }) as unknown as Schema.Schema<ZonePurgeRequest>;

export interface ZonePurgeResponse {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZonePurgeResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZonePurgeResponse" }) as unknown as Schema.Schema<ZonePurgeResponse>;

export const zonePurge: (
  input: ZonePurgeRequest
) => Effect.Effect<
  ZonePurgeResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZonePurgeRequest,
  output: ZonePurgeResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListRateLimitsRequest {
  zone_id: string;
  page?: number;
  per_page?: number;
}

export const ListRateLimitsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/rate_limits" }),
).annotations({ identifier: "ListRateLimitsRequest" }) as unknown as Schema.Schema<ListRateLimitsRequest>;

export interface ListRateLimitsResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListRateLimitsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListRateLimitsResponse" }) as unknown as Schema.Schema<ListRateLimitsResponse>;

export const listRateLimits: (
  input: ListRateLimitsRequest
) => Effect.Effect<
  ListRateLimitsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListRateLimitsRequest,
  output: ListRateLimitsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateARateLimitRequest {
  zone_id: string;
  body: { action: Record<string, unknown>; match: Record<string, unknown>; period: number; threshold: number };
}

export const CreateARateLimitRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  action: Schema.Struct({}),
  match: Schema.Struct({}),
  period: Schema.Number,
  threshold: Schema.Number
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/rate_limits" }),
).annotations({ identifier: "CreateARateLimitRequest" }) as unknown as Schema.Schema<CreateARateLimitRequest>;

export interface CreateARateLimitResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateARateLimitResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateARateLimitResponse" }) as unknown as Schema.Schema<CreateARateLimitResponse>;

export const createARateLimit: (
  input: CreateARateLimitRequest
) => Effect.Effect<
  CreateARateLimitResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateARateLimitRequest,
  output: CreateARateLimitResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetARateLimitRequest {
  rate_limit_id: string;
  zone_id: string;
}

export const GetARateLimitRequest = Schema.Struct({
  rate_limit_id: Schema.String.pipe(T.HttpPath("rate_limit_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/rate_limits/{rate_limit_id}" }),
).annotations({ identifier: "GetARateLimitRequest" }) as unknown as Schema.Schema<GetARateLimitRequest>;

export interface GetARateLimitResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetARateLimitResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetARateLimitResponse" }) as unknown as Schema.Schema<GetARateLimitResponse>;

export const getARateLimit: (
  input: GetARateLimitRequest
) => Effect.Effect<
  GetARateLimitResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetARateLimitRequest,
  output: GetARateLimitResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateARateLimitRequest {
  rate_limit_id: string;
  zone_id: string;
  body: { action: Record<string, unknown>; match: Record<string, unknown>; period: number; threshold: number };
}

export const UpdateARateLimitRequest = Schema.Struct({
  rate_limit_id: Schema.String.pipe(T.HttpPath("rate_limit_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  action: Schema.Struct({}),
  match: Schema.Struct({}),
  period: Schema.Number,
  threshold: Schema.Number
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/rate_limits/{rate_limit_id}" }),
).annotations({ identifier: "UpdateARateLimitRequest" }) as unknown as Schema.Schema<UpdateARateLimitRequest>;

export interface UpdateARateLimitResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateARateLimitResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateARateLimitResponse" }) as unknown as Schema.Schema<UpdateARateLimitResponse>;

export const updateARateLimit: (
  input: UpdateARateLimitRequest
) => Effect.Effect<
  UpdateARateLimitResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateARateLimitRequest,
  output: UpdateARateLimitResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteARateLimitRequest {
  rate_limit_id: string;
  zone_id: string;
}

export const DeleteARateLimitRequest = Schema.Struct({
  rate_limit_id: Schema.String.pipe(T.HttpPath("rate_limit_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/rate_limits/{rate_limit_id}" }),
).annotations({ identifier: "DeleteARateLimitRequest" }) as unknown as Schema.Schema<DeleteARateLimitRequest>;

export interface DeleteARateLimitResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteARateLimitResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteARateLimitResponse" }) as unknown as Schema.Schema<DeleteARateLimitResponse>;

export const deleteARateLimit: (
  input: DeleteARateLimitRequest
) => Effect.Effect<
  DeleteARateLimitResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteARateLimitRequest,
  output: DeleteARateLimitResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListzonerulesetsRequest {
  zone_id: string;
  cursor?: string;
  per_page?: number;
}

export const ListzonerulesetsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  cursor: Schema.optional(Schema.String).pipe(T.HttpQuery("cursor")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/rulesets" }),
).annotations({ identifier: "ListzonerulesetsRequest" }) as unknown as Schema.Schema<ListzonerulesetsRequest>;

export interface ListzonerulesetsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListzonerulesetsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListzonerulesetsResponse" }) as unknown as Schema.Schema<ListzonerulesetsResponse>;

export const listzonerulesets: (
  input: ListzonerulesetsRequest
) => Effect.Effect<
  ListzonerulesetsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListzonerulesetsRequest,
  output: ListzonerulesetsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatezonerulesetRequest {
  zone_id: string;
  body: unknown;
}

export const CreatezonerulesetRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/rulesets" }),
).annotations({ identifier: "CreatezonerulesetRequest" }) as unknown as Schema.Schema<CreatezonerulesetRequest>;

export interface CreatezonerulesetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatezonerulesetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatezonerulesetResponse" }) as unknown as Schema.Schema<CreatezonerulesetResponse>;

export const createzoneruleset: (
  input: CreatezonerulesetRequest
) => Effect.Effect<
  CreatezonerulesetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatezonerulesetRequest,
  output: CreatezonerulesetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetzoneentrypointrulesetRequest {
  ruleset_phase: "ddos_l4" | "ddos_l7" | "http_config_settings" | "http_custom_errors" | "http_log_custom_fields" | "http_ratelimit" | "http_request_cache_settings" | "http_request_dynamic_redirect" | "http_request_firewall_custom" | "http_request_firewall_managed" | "http_request_late_transform" | "http_request_origin" | "http_request_redirect" | "http_request_sanitize" | "http_request_sbfm" | "http_request_transform" | "http_response_compression" | "http_response_firewall_managed" | "http_response_headers_transform" | "magic_transit" | "magic_transit_ids_managed" | "magic_transit_managed" | "magic_transit_ratelimit";
  zone_id: string;
}

export const GetzoneentrypointrulesetRequest = Schema.Struct({
  ruleset_phase: Schema.Literal("ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed", "magic_transit_ratelimit").pipe(T.HttpPath("ruleset_phase")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/rulesets/phases/{ruleset_phase}/entrypoint" }),
).annotations({ identifier: "GetzoneentrypointrulesetRequest" }) as unknown as Schema.Schema<GetzoneentrypointrulesetRequest>;

export interface GetzoneentrypointrulesetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetzoneentrypointrulesetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetzoneentrypointrulesetResponse" }) as unknown as Schema.Schema<GetzoneentrypointrulesetResponse>;

export const getzoneentrypointruleset: (
  input: GetzoneentrypointrulesetRequest
) => Effect.Effect<
  GetzoneentrypointrulesetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetzoneentrypointrulesetRequest,
  output: GetzoneentrypointrulesetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatezoneentrypointrulesetRequest {
  ruleset_phase: "ddos_l4" | "ddos_l7" | "http_config_settings" | "http_custom_errors" | "http_log_custom_fields" | "http_ratelimit" | "http_request_cache_settings" | "http_request_dynamic_redirect" | "http_request_firewall_custom" | "http_request_firewall_managed" | "http_request_late_transform" | "http_request_origin" | "http_request_redirect" | "http_request_sanitize" | "http_request_sbfm" | "http_request_transform" | "http_response_compression" | "http_response_firewall_managed" | "http_response_headers_transform" | "magic_transit" | "magic_transit_ids_managed" | "magic_transit_managed" | "magic_transit_ratelimit";
  zone_id: string;
  body: unknown;
}

export const UpdatezoneentrypointrulesetRequest = Schema.Struct({
  ruleset_phase: Schema.Literal("ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed", "magic_transit_ratelimit").pipe(T.HttpPath("ruleset_phase")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/rulesets/phases/{ruleset_phase}/entrypoint" }),
).annotations({ identifier: "UpdatezoneentrypointrulesetRequest" }) as unknown as Schema.Schema<UpdatezoneentrypointrulesetRequest>;

export interface UpdatezoneentrypointrulesetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatezoneentrypointrulesetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatezoneentrypointrulesetResponse" }) as unknown as Schema.Schema<UpdatezoneentrypointrulesetResponse>;

export const updatezoneentrypointruleset: (
  input: UpdatezoneentrypointrulesetRequest
) => Effect.Effect<
  UpdatezoneentrypointrulesetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatezoneentrypointrulesetRequest,
  output: UpdatezoneentrypointrulesetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListzoneentrypointrulesetversionsRequest {
  ruleset_phase: "ddos_l4" | "ddos_l7" | "http_config_settings" | "http_custom_errors" | "http_log_custom_fields" | "http_ratelimit" | "http_request_cache_settings" | "http_request_dynamic_redirect" | "http_request_firewall_custom" | "http_request_firewall_managed" | "http_request_late_transform" | "http_request_origin" | "http_request_redirect" | "http_request_sanitize" | "http_request_sbfm" | "http_request_transform" | "http_response_compression" | "http_response_firewall_managed" | "http_response_headers_transform" | "magic_transit" | "magic_transit_ids_managed" | "magic_transit_managed" | "magic_transit_ratelimit";
  zone_id: string;
}

export const ListzoneentrypointrulesetversionsRequest = Schema.Struct({
  ruleset_phase: Schema.Literal("ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed", "magic_transit_ratelimit").pipe(T.HttpPath("ruleset_phase")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/rulesets/phases/{ruleset_phase}/entrypoint/versions" }),
).annotations({ identifier: "ListzoneentrypointrulesetversionsRequest" }) as unknown as Schema.Schema<ListzoneentrypointrulesetversionsRequest>;

export interface ListzoneentrypointrulesetversionsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListzoneentrypointrulesetversionsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListzoneentrypointrulesetversionsResponse" }) as unknown as Schema.Schema<ListzoneentrypointrulesetversionsResponse>;

export const listzoneentrypointrulesetversions: (
  input: ListzoneentrypointrulesetversionsRequest
) => Effect.Effect<
  ListzoneentrypointrulesetversionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListzoneentrypointrulesetversionsRequest,
  output: ListzoneentrypointrulesetversionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetzoneentrypointrulesetversionRequest {
  ruleset_version: string;
  ruleset_phase: "ddos_l4" | "ddos_l7" | "http_config_settings" | "http_custom_errors" | "http_log_custom_fields" | "http_ratelimit" | "http_request_cache_settings" | "http_request_dynamic_redirect" | "http_request_firewall_custom" | "http_request_firewall_managed" | "http_request_late_transform" | "http_request_origin" | "http_request_redirect" | "http_request_sanitize" | "http_request_sbfm" | "http_request_transform" | "http_response_compression" | "http_response_firewall_managed" | "http_response_headers_transform" | "magic_transit" | "magic_transit_ids_managed" | "magic_transit_managed" | "magic_transit_ratelimit";
  zone_id: string;
}

export const GetzoneentrypointrulesetversionRequest = Schema.Struct({
  ruleset_version: Schema.String.pipe(T.HttpPath("ruleset_version")),
  ruleset_phase: Schema.Literal("ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed", "magic_transit_ratelimit").pipe(T.HttpPath("ruleset_phase")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/rulesets/phases/{ruleset_phase}/entrypoint/versions/{ruleset_version}" }),
).annotations({ identifier: "GetzoneentrypointrulesetversionRequest" }) as unknown as Schema.Schema<GetzoneentrypointrulesetversionRequest>;

export interface GetzoneentrypointrulesetversionResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetzoneentrypointrulesetversionResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetzoneentrypointrulesetversionResponse" }) as unknown as Schema.Schema<GetzoneentrypointrulesetversionResponse>;

export const getzoneentrypointrulesetversion: (
  input: GetzoneentrypointrulesetversionRequest
) => Effect.Effect<
  GetzoneentrypointrulesetversionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetzoneentrypointrulesetversionRequest,
  output: GetzoneentrypointrulesetversionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetzonerulesetRequest {
  ruleset_id: string;
  zone_id: string;
}

export const GetzonerulesetRequest = Schema.Struct({
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/rulesets/{ruleset_id}" }),
).annotations({ identifier: "GetzonerulesetRequest" }) as unknown as Schema.Schema<GetzonerulesetRequest>;

export interface GetzonerulesetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetzonerulesetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetzonerulesetResponse" }) as unknown as Schema.Schema<GetzonerulesetResponse>;

export const getzoneruleset: (
  input: GetzonerulesetRequest
) => Effect.Effect<
  GetzonerulesetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetzonerulesetRequest,
  output: GetzonerulesetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatezonerulesetRequest {
  ruleset_id: string;
  zone_id: string;
  body: unknown;
}

export const UpdatezonerulesetRequest = Schema.Struct({
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/rulesets/{ruleset_id}" }),
).annotations({ identifier: "UpdatezonerulesetRequest" }) as unknown as Schema.Schema<UpdatezonerulesetRequest>;

export interface UpdatezonerulesetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatezonerulesetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatezonerulesetResponse" }) as unknown as Schema.Schema<UpdatezonerulesetResponse>;

export const updatezoneruleset: (
  input: UpdatezonerulesetRequest
) => Effect.Effect<
  UpdatezonerulesetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatezonerulesetRequest,
  output: UpdatezonerulesetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletezonerulesetRequest {
  ruleset_id: string;
  zone_id: string;
}

export const DeletezonerulesetRequest = Schema.Struct({
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/rulesets/{ruleset_id}" }),
).annotations({ identifier: "DeletezonerulesetRequest" }) as unknown as Schema.Schema<DeletezonerulesetRequest>;

export interface DeletezonerulesetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletezonerulesetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletezonerulesetResponse" }) as unknown as Schema.Schema<DeletezonerulesetResponse>;

export const deletezoneruleset: (
  input: DeletezonerulesetRequest
) => Effect.Effect<
  DeletezonerulesetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletezonerulesetRequest,
  output: DeletezonerulesetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatezonerulesetruleRequest {
  ruleset_id: string;
  zone_id: string;
  body: unknown;
}

export const CreatezonerulesetruleRequest = Schema.Struct({
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/rulesets/{ruleset_id}/rules" }),
).annotations({ identifier: "CreatezonerulesetruleRequest" }) as unknown as Schema.Schema<CreatezonerulesetruleRequest>;

export interface CreatezonerulesetruleResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatezonerulesetruleResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatezonerulesetruleResponse" }) as unknown as Schema.Schema<CreatezonerulesetruleResponse>;

export const createzonerulesetrule: (
  input: CreatezonerulesetruleRequest
) => Effect.Effect<
  CreatezonerulesetruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatezonerulesetruleRequest,
  output: CreatezonerulesetruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletezonerulesetruleRequest {
  rule_id: string;
  ruleset_id: string;
  zone_id: string;
}

export const DeletezonerulesetruleRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/rulesets/{ruleset_id}/rules/{rule_id}" }),
).annotations({ identifier: "DeletezonerulesetruleRequest" }) as unknown as Schema.Schema<DeletezonerulesetruleRequest>;

export interface DeletezonerulesetruleResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletezonerulesetruleResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletezonerulesetruleResponse" }) as unknown as Schema.Schema<DeletezonerulesetruleResponse>;

export const deletezonerulesetrule: (
  input: DeletezonerulesetruleRequest
) => Effect.Effect<
  DeletezonerulesetruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletezonerulesetruleRequest,
  output: DeletezonerulesetruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatezonerulesetruleRequest {
  rule_id: string;
  ruleset_id: string;
  zone_id: string;
  body: unknown;
}

export const UpdatezonerulesetruleRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/rulesets/{ruleset_id}/rules/{rule_id}" }),
).annotations({ identifier: "UpdatezonerulesetruleRequest" }) as unknown as Schema.Schema<UpdatezonerulesetruleRequest>;

export interface UpdatezonerulesetruleResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatezonerulesetruleResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatezonerulesetruleResponse" }) as unknown as Schema.Schema<UpdatezonerulesetruleResponse>;

export const updatezonerulesetrule: (
  input: UpdatezonerulesetruleRequest
) => Effect.Effect<
  UpdatezonerulesetruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatezonerulesetruleRequest,
  output: UpdatezonerulesetruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListzonerulesetversionsRequest {
  ruleset_id: string;
  zone_id: string;
}

export const ListzonerulesetversionsRequest = Schema.Struct({
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/rulesets/{ruleset_id}/versions" }),
).annotations({ identifier: "ListzonerulesetversionsRequest" }) as unknown as Schema.Schema<ListzonerulesetversionsRequest>;

export interface ListzonerulesetversionsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListzonerulesetversionsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListzonerulesetversionsResponse" }) as unknown as Schema.Schema<ListzonerulesetversionsResponse>;

export const listzonerulesetversions: (
  input: ListzonerulesetversionsRequest
) => Effect.Effect<
  ListzonerulesetversionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListzonerulesetversionsRequest,
  output: ListzonerulesetversionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetzonerulesetversionRequest {
  ruleset_version: string;
  ruleset_id: string;
  zone_id: string;
}

export const GetzonerulesetversionRequest = Schema.Struct({
  ruleset_version: Schema.String.pipe(T.HttpPath("ruleset_version")),
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/rulesets/{ruleset_id}/versions/{ruleset_version}" }),
).annotations({ identifier: "GetzonerulesetversionRequest" }) as unknown as Schema.Schema<GetzonerulesetversionRequest>;

export interface GetzonerulesetversionResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetzonerulesetversionResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetzonerulesetversionResponse" }) as unknown as Schema.Schema<GetzonerulesetversionResponse>;

export const getzonerulesetversion: (
  input: GetzonerulesetversionRequest
) => Effect.Effect<
  GetzonerulesetversionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetzonerulesetversionRequest,
  output: GetzonerulesetversionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletezonerulesetversionRequest {
  ruleset_version: string;
  ruleset_id: string;
  zone_id: string;
}

export const DeletezonerulesetversionRequest = Schema.Struct({
  ruleset_version: Schema.String.pipe(T.HttpPath("ruleset_version")),
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/rulesets/{ruleset_id}/versions/{ruleset_version}" }),
).annotations({ identifier: "DeletezonerulesetversionRequest" }) as unknown as Schema.Schema<DeletezonerulesetversionRequest>;

export interface DeletezonerulesetversionResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletezonerulesetversionResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletezonerulesetversionResponse" }) as unknown as Schema.Schema<DeletezonerulesetversionResponse>;

export const deletezonerulesetversion: (
  input: DeletezonerulesetversionRequest
) => Effect.Effect<
  DeletezonerulesetversionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletezonerulesetversionRequest,
  output: DeletezonerulesetversionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListzonerulesetversionrulesbytagRequest {
  rule_tag: string;
  ruleset_version: string;
  ruleset_id: string;
  zone_id: string;
}

export const ListzonerulesetversionrulesbytagRequest = Schema.Struct({
  rule_tag: Schema.String.pipe(T.HttpPath("rule_tag")),
  ruleset_version: Schema.String.pipe(T.HttpPath("ruleset_version")),
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/rulesets/{ruleset_id}/versions/{ruleset_version}/by_tag/{rule_tag}" }),
).annotations({ identifier: "ListzonerulesetversionrulesbytagRequest" }) as unknown as Schema.Schema<ListzonerulesetversionrulesbytagRequest>;

export interface ListzonerulesetversionrulesbytagResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListzonerulesetversionrulesbytagResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListzonerulesetversionrulesbytagResponse" }) as unknown as Schema.Schema<ListzonerulesetversionrulesbytagResponse>;

export const listzonerulesetversionrulesbytag: (
  input: ListzonerulesetversionrulesbytagRequest
) => Effect.Effect<
  ListzonerulesetversionrulesbytagResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListzonerulesetversionrulesbytagRequest,
  output: ListzonerulesetversionrulesbytagResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListSchemasPaginatedRequest {
  validation_enabled?: boolean;
}

export const ListSchemasPaginatedRequest = Schema.Struct({
  validation_enabled: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validation_enabled"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/schema_validation/schemas" }),
).annotations({ identifier: "ListSchemasPaginatedRequest" }) as unknown as Schema.Schema<ListSchemasPaginatedRequest>;

export interface ListSchemasPaginatedResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListSchemasPaginatedResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListSchemasPaginatedResponse" }) as unknown as Schema.Schema<ListSchemasPaginatedResponse>;

export const listSchemasPaginated: (
  input: ListSchemasPaginatedRequest
) => Effect.Effect<
  ListSchemasPaginatedResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListSchemasPaginatedRequest,
  output: ListSchemasPaginatedResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateSchemaRequest {
  body: { kind: "openapi_v3"; name: string; source: string; validation_enabled: boolean };
}

export const CreateSchemaRequest = Schema.Struct({
  body: Schema.Struct({
  kind: Schema.Literal("openapi_v3"),
  name: Schema.String,
  source: Schema.String,
  validation_enabled: Schema.Boolean
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/schema_validation/schemas" }),
).annotations({ identifier: "CreateSchemaRequest" }) as unknown as Schema.Schema<CreateSchemaRequest>;

export interface CreateSchemaResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateSchemaResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateSchemaResponse" }) as unknown as Schema.Schema<CreateSchemaResponse>;

export const createSchema: (
  input: CreateSchemaRequest
) => Effect.Effect<
  CreateSchemaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateSchemaRequest,
  output: CreateSchemaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListSchemaHostsRequest {
}

export const ListSchemaHostsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/schema_validation/schemas/hosts" }),
).annotations({ identifier: "ListSchemaHostsRequest" }) as unknown as Schema.Schema<ListSchemaHostsRequest>;

export interface ListSchemaHostsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListSchemaHostsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListSchemaHostsResponse" }) as unknown as Schema.Schema<ListSchemaHostsResponse>;

export const listSchemaHosts: (
  input: ListSchemaHostsRequest
) => Effect.Effect<
  ListSchemaHostsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListSchemaHostsRequest,
  output: ListSchemaHostsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSchemaRequest {
}

export const GetSchemaRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/schema_validation/schemas/{schema_id}" }),
).annotations({ identifier: "GetSchemaRequest" }) as unknown as Schema.Schema<GetSchemaRequest>;

export interface GetSchemaResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSchemaResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSchemaResponse" }) as unknown as Schema.Schema<GetSchemaResponse>;

export const getSchema: (
  input: GetSchemaRequest
) => Effect.Effect<
  GetSchemaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSchemaRequest,
  output: GetSchemaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteSchemaRequest {
}

export const DeleteSchemaRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/schema_validation/schemas/{schema_id}" }),
).annotations({ identifier: "DeleteSchemaRequest" }) as unknown as Schema.Schema<DeleteSchemaRequest>;

export interface DeleteSchemaResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteSchemaResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteSchemaResponse" }) as unknown as Schema.Schema<DeleteSchemaResponse>;

export const deleteSchema: (
  input: DeleteSchemaRequest
) => Effect.Effect<
  DeleteSchemaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteSchemaRequest,
  output: DeleteSchemaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SchemaValidationEditSchemaRequest {
  body: { validation_enabled?: boolean };
}

export const SchemaValidationEditSchemaRequest = Schema.Struct({
  body: Schema.Struct({
  validation_enabled: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/schema_validation/schemas/{schema_id}" }),
).annotations({ identifier: "SchemaValidationEditSchemaRequest" }) as unknown as Schema.Schema<SchemaValidationEditSchemaRequest>;

export interface SchemaValidationEditSchemaResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SchemaValidationEditSchemaResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SchemaValidationEditSchemaResponse" }) as unknown as Schema.Schema<SchemaValidationEditSchemaResponse>;

export const schemaValidationEditSchema: (
  input: SchemaValidationEditSchemaRequest
) => Effect.Effect<
  SchemaValidationEditSchemaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SchemaValidationEditSchemaRequest,
  output: SchemaValidationEditSchemaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SchemaValidationExtractOperationsFromSchemaRequest {
  operation_status?: "new" | "existing";
}

export const SchemaValidationExtractOperationsFromSchemaRequest = Schema.Struct({
  operation_status: Schema.optional(Schema.Literal("new", "existing")).pipe(T.HttpQuery("operation_status"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/schema_validation/schemas/{schema_id}/operations" }),
).annotations({ identifier: "SchemaValidationExtractOperationsFromSchemaRequest" }) as unknown as Schema.Schema<SchemaValidationExtractOperationsFromSchemaRequest>;

export interface SchemaValidationExtractOperationsFromSchemaResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SchemaValidationExtractOperationsFromSchemaResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SchemaValidationExtractOperationsFromSchemaResponse" }) as unknown as Schema.Schema<SchemaValidationExtractOperationsFromSchemaResponse>;

export const schemaValidationExtractOperationsFromSchema: (
  input: SchemaValidationExtractOperationsFromSchemaRequest
) => Effect.Effect<
  SchemaValidationExtractOperationsFromSchemaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SchemaValidationExtractOperationsFromSchemaRequest,
  output: SchemaValidationExtractOperationsFromSchemaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSettings1Request {
}

export const GetSettings1Request = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/schema_validation/settings" }),
).annotations({ identifier: "GetSettings1Request" }) as unknown as Schema.Schema<GetSettings1Request>;

export interface GetSettings1Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSettings1Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSettings1Response" }) as unknown as Schema.Schema<GetSettings1Response>;

export const getSettings1: (
  input: GetSettings1Request
) => Effect.Effect<
  GetSettings1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSettings1Request,
  output: GetSettings1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateSettings2Request {
  body: Record<string, unknown>;
}

export const UpdateSettings2Request = Schema.Struct({
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/schema_validation/settings" }),
).annotations({ identifier: "UpdateSettings2Request" }) as unknown as Schema.Schema<UpdateSettings2Request>;

export interface UpdateSettings2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateSettings2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateSettings2Response" }) as unknown as Schema.Schema<UpdateSettings2Response>;

export const updateSettings2: (
  input: UpdateSettings2Request
) => Effect.Effect<
  UpdateSettings2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateSettings2Request,
  output: UpdateSettings2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SchemaValidationEditSettingsRequest {
  body: { validation_default_mitigation_action?: "none" | "log" | "block"; validation_override_mitigation_action?: "none" | null };
}

export const SchemaValidationEditSettingsRequest = Schema.Struct({
  body: Schema.Struct({
  validation_default_mitigation_action: Schema.optional(Schema.Literal("none", "log", "block")),
  validation_override_mitigation_action: Schema.optional(Schema.Literal("none", null))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/schema_validation/settings" }),
).annotations({ identifier: "SchemaValidationEditSettingsRequest" }) as unknown as Schema.Schema<SchemaValidationEditSettingsRequest>;

export interface SchemaValidationEditSettingsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SchemaValidationEditSettingsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SchemaValidationEditSettingsResponse" }) as unknown as Schema.Schema<SchemaValidationEditSettingsResponse>;

export const schemaValidationEditSettings: (
  input: SchemaValidationEditSettingsRequest
) => Effect.Effect<
  SchemaValidationEditSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SchemaValidationEditSettingsRequest,
  output: SchemaValidationEditSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListPerOperationSettingsRequest {
}

export const ListPerOperationSettingsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/schema_validation/settings/operations" }),
).annotations({ identifier: "ListPerOperationSettingsRequest" }) as unknown as Schema.Schema<ListPerOperationSettingsRequest>;

export interface ListPerOperationSettingsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListPerOperationSettingsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListPerOperationSettingsResponse" }) as unknown as Schema.Schema<ListPerOperationSettingsResponse>;

export const listPerOperationSettings: (
  input: ListPerOperationSettingsRequest
) => Effect.Effect<
  ListPerOperationSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListPerOperationSettingsRequest,
  output: ListPerOperationSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SchemaValidationBulkEditPerOperationSettingsRequest {
  body: Record<string, unknown>;
}

export const SchemaValidationBulkEditPerOperationSettingsRequest = Schema.Struct({
  body: Schema.Record({ key: Schema.String, value: Schema.Struct({
  mitigation_action: Schema.optional(Schema.Literal("none", "log", "block", null))
}) }).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/schema_validation/settings/operations" }),
).annotations({ identifier: "SchemaValidationBulkEditPerOperationSettingsRequest" }) as unknown as Schema.Schema<SchemaValidationBulkEditPerOperationSettingsRequest>;

export interface SchemaValidationBulkEditPerOperationSettingsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SchemaValidationBulkEditPerOperationSettingsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SchemaValidationBulkEditPerOperationSettingsResponse" }) as unknown as Schema.Schema<SchemaValidationBulkEditPerOperationSettingsResponse>;

export const schemaValidationBulkEditPerOperationSettings: (
  input: SchemaValidationBulkEditPerOperationSettingsRequest
) => Effect.Effect<
  SchemaValidationBulkEditPerOperationSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SchemaValidationBulkEditPerOperationSettingsRequest,
  output: SchemaValidationBulkEditPerOperationSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetPerOperationSettingRequest {
}

export const GetPerOperationSettingRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/schema_validation/settings/operations/{operation_id}" }),
).annotations({ identifier: "GetPerOperationSettingRequest" }) as unknown as Schema.Schema<GetPerOperationSettingRequest>;

export interface GetPerOperationSettingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetPerOperationSettingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetPerOperationSettingResponse" }) as unknown as Schema.Schema<GetPerOperationSettingResponse>;

export const getPerOperationSetting: (
  input: GetPerOperationSettingRequest
) => Effect.Effect<
  GetPerOperationSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetPerOperationSettingRequest,
  output: GetPerOperationSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatePerOperationSettingRequest {
  body: Record<string, unknown>;
}

export const UpdatePerOperationSettingRequest = Schema.Struct({
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/schema_validation/settings/operations/{operation_id}" }),
).annotations({ identifier: "UpdatePerOperationSettingRequest" }) as unknown as Schema.Schema<UpdatePerOperationSettingRequest>;

export interface UpdatePerOperationSettingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatePerOperationSettingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatePerOperationSettingResponse" }) as unknown as Schema.Schema<UpdatePerOperationSettingResponse>;

export const updatePerOperationSetting: (
  input: UpdatePerOperationSettingRequest
) => Effect.Effect<
  UpdatePerOperationSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatePerOperationSettingRequest,
  output: UpdatePerOperationSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletePerOperationSettingRequest {
}

export const DeletePerOperationSettingRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/schema_validation/settings/operations/{operation_id}" }),
).annotations({ identifier: "DeletePerOperationSettingRequest" }) as unknown as Schema.Schema<DeletePerOperationSettingRequest>;

export interface DeletePerOperationSettingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletePerOperationSettingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletePerOperationSettingResponse" }) as unknown as Schema.Schema<DeletePerOperationSettingResponse>;

export const deletePerOperationSetting: (
  input: DeletePerOperationSettingRequest
) => Effect.Effect<
  DeletePerOperationSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletePerOperationSettingRequest,
  output: DeletePerOperationSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SecondaryDnsSecondaryZoneForceAxfrRequest {
  zone_id: string;
}

export const SecondaryDnsSecondaryZoneForceAxfrRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/secondary_dns/force_axfr" }),
).annotations({ identifier: "SecondaryDnsSecondaryZoneForceAxfrRequest" }) as unknown as Schema.Schema<SecondaryDnsSecondaryZoneForceAxfrRequest>;

export interface SecondaryDnsSecondaryZoneForceAxfrResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SecondaryDnsSecondaryZoneForceAxfrResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SecondaryDnsSecondaryZoneForceAxfrResponse" }) as unknown as Schema.Schema<SecondaryDnsSecondaryZoneForceAxfrResponse>;

export const secondaryDnsSecondaryZoneForceAxfr: (
  input: SecondaryDnsSecondaryZoneForceAxfrRequest
) => Effect.Effect<
  SecondaryDnsSecondaryZoneForceAxfrResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SecondaryDnsSecondaryZoneForceAxfrRequest,
  output: SecondaryDnsSecondaryZoneForceAxfrResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsRequest {
  zone_id: string;
}

export const SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/secondary_dns/incoming" }),
).annotations({ identifier: "SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsRequest" }) as unknown as Schema.Schema<SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsRequest>;

export interface SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsResponse {
  result: { auto_refresh_seconds?: number; checked_time?: string; created_time?: string; id?: string; modified_time?: string; name?: string; peers?: string[]; soa_serial?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  auto_refresh_seconds: Schema.optional(Schema.Number),
  checked_time: Schema.optional(Schema.String),
  created_time: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_time: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  peers: Schema.optional(Schema.Array(Schema.String)),
  soa_serial: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsResponse" }) as unknown as Schema.Schema<SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsResponse>;

export const secondaryDnsSecondaryZoneSecondaryZoneConfigurationDetails: (
  input: SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsRequest
) => Effect.Effect<
  SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsRequest,
  output: SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateSecondaryZoneConfigurationRequest {
  zone_id: string;
  body: { auto_refresh_seconds: number; id: string; name: string; peers: string[] };
}

export const CreateSecondaryZoneConfigurationRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  auto_refresh_seconds: Schema.Number,
  id: Schema.String,
  name: Schema.String,
  peers: Schema.Array(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/secondary_dns/incoming" }),
).annotations({ identifier: "CreateSecondaryZoneConfigurationRequest" }) as unknown as Schema.Schema<CreateSecondaryZoneConfigurationRequest>;

export interface CreateSecondaryZoneConfigurationResponse {
  result: { auto_refresh_seconds?: number; checked_time?: string; created_time?: string; id?: string; modified_time?: string; name?: string; peers?: string[]; soa_serial?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateSecondaryZoneConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  auto_refresh_seconds: Schema.optional(Schema.Number),
  checked_time: Schema.optional(Schema.String),
  created_time: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_time: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  peers: Schema.optional(Schema.Array(Schema.String)),
  soa_serial: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateSecondaryZoneConfigurationResponse" }) as unknown as Schema.Schema<CreateSecondaryZoneConfigurationResponse>;

export const createSecondaryZoneConfiguration: (
  input: CreateSecondaryZoneConfigurationRequest
) => Effect.Effect<
  CreateSecondaryZoneConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateSecondaryZoneConfigurationRequest,
  output: CreateSecondaryZoneConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateSecondaryZoneConfigurationRequest {
  zone_id: string;
  body: { auto_refresh_seconds: number; id: string; name: string; peers: string[] };
}

export const UpdateSecondaryZoneConfigurationRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  auto_refresh_seconds: Schema.Number,
  id: Schema.String,
  name: Schema.String,
  peers: Schema.Array(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/secondary_dns/incoming" }),
).annotations({ identifier: "UpdateSecondaryZoneConfigurationRequest" }) as unknown as Schema.Schema<UpdateSecondaryZoneConfigurationRequest>;

export interface UpdateSecondaryZoneConfigurationResponse {
  result: { auto_refresh_seconds?: number; checked_time?: string; created_time?: string; id?: string; modified_time?: string; name?: string; peers?: string[]; soa_serial?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateSecondaryZoneConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  auto_refresh_seconds: Schema.optional(Schema.Number),
  checked_time: Schema.optional(Schema.String),
  created_time: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_time: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  peers: Schema.optional(Schema.Array(Schema.String)),
  soa_serial: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateSecondaryZoneConfigurationResponse" }) as unknown as Schema.Schema<UpdateSecondaryZoneConfigurationResponse>;

export const updateSecondaryZoneConfiguration: (
  input: UpdateSecondaryZoneConfigurationRequest
) => Effect.Effect<
  UpdateSecondaryZoneConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateSecondaryZoneConfigurationRequest,
  output: UpdateSecondaryZoneConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteSecondaryZoneConfigurationRequest {
  zone_id: string;
}

export const DeleteSecondaryZoneConfigurationRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/secondary_dns/incoming" }),
).annotations({ identifier: "DeleteSecondaryZoneConfigurationRequest" }) as unknown as Schema.Schema<DeleteSecondaryZoneConfigurationRequest>;

export interface DeleteSecondaryZoneConfigurationResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteSecondaryZoneConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteSecondaryZoneConfigurationResponse" }) as unknown as Schema.Schema<DeleteSecondaryZoneConfigurationResponse>;

export const deleteSecondaryZoneConfiguration: (
  input: DeleteSecondaryZoneConfigurationRequest
) => Effect.Effect<
  DeleteSecondaryZoneConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteSecondaryZoneConfigurationRequest,
  output: DeleteSecondaryZoneConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsRequest {
  zone_id: string;
}

export const SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/secondary_dns/outgoing" }),
).annotations({ identifier: "SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsRequest" }) as unknown as Schema.Schema<SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsRequest>;

export interface SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsResponse {
  result: { checked_time?: string; created_time?: string; id?: string; last_transferred_time?: string; name?: string; peers?: string[]; soa_serial?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  checked_time: Schema.optional(Schema.String),
  created_time: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  last_transferred_time: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  peers: Schema.optional(Schema.Array(Schema.String)),
  soa_serial: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsResponse" }) as unknown as Schema.Schema<SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsResponse>;

export const secondaryDnsPrimaryZonePrimaryZoneConfigurationDetails: (
  input: SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsRequest
) => Effect.Effect<
  SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsRequest,
  output: SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatePrimaryZoneConfigurationRequest {
  zone_id: string;
  body: unknown;
}

export const CreatePrimaryZoneConfigurationRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/secondary_dns/outgoing" }),
).annotations({ identifier: "CreatePrimaryZoneConfigurationRequest" }) as unknown as Schema.Schema<CreatePrimaryZoneConfigurationRequest>;

export interface CreatePrimaryZoneConfigurationResponse {
  result: { checked_time?: string; created_time?: string; id?: string; last_transferred_time?: string; name?: string; peers?: string[]; soa_serial?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatePrimaryZoneConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  checked_time: Schema.optional(Schema.String),
  created_time: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  last_transferred_time: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  peers: Schema.optional(Schema.Array(Schema.String)),
  soa_serial: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatePrimaryZoneConfigurationResponse" }) as unknown as Schema.Schema<CreatePrimaryZoneConfigurationResponse>;

export const createPrimaryZoneConfiguration: (
  input: CreatePrimaryZoneConfigurationRequest
) => Effect.Effect<
  CreatePrimaryZoneConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatePrimaryZoneConfigurationRequest,
  output: CreatePrimaryZoneConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatePrimaryZoneConfigurationRequest {
  zone_id: string;
  body: unknown;
}

export const UpdatePrimaryZoneConfigurationRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/secondary_dns/outgoing" }),
).annotations({ identifier: "UpdatePrimaryZoneConfigurationRequest" }) as unknown as Schema.Schema<UpdatePrimaryZoneConfigurationRequest>;

export interface UpdatePrimaryZoneConfigurationResponse {
  result: { checked_time?: string; created_time?: string; id?: string; last_transferred_time?: string; name?: string; peers?: string[]; soa_serial?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatePrimaryZoneConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  checked_time: Schema.optional(Schema.String),
  created_time: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  last_transferred_time: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  peers: Schema.optional(Schema.Array(Schema.String)),
  soa_serial: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatePrimaryZoneConfigurationResponse" }) as unknown as Schema.Schema<UpdatePrimaryZoneConfigurationResponse>;

export const updatePrimaryZoneConfiguration: (
  input: UpdatePrimaryZoneConfigurationRequest
) => Effect.Effect<
  UpdatePrimaryZoneConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatePrimaryZoneConfigurationRequest,
  output: UpdatePrimaryZoneConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletePrimaryZoneConfigurationRequest {
  zone_id: string;
}

export const DeletePrimaryZoneConfigurationRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/secondary_dns/outgoing" }),
).annotations({ identifier: "DeletePrimaryZoneConfigurationRequest" }) as unknown as Schema.Schema<DeletePrimaryZoneConfigurationRequest>;

export interface DeletePrimaryZoneConfigurationResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletePrimaryZoneConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletePrimaryZoneConfigurationResponse" }) as unknown as Schema.Schema<DeletePrimaryZoneConfigurationResponse>;

export const deletePrimaryZoneConfiguration: (
  input: DeletePrimaryZoneConfigurationRequest
) => Effect.Effect<
  DeletePrimaryZoneConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletePrimaryZoneConfigurationRequest,
  output: DeletePrimaryZoneConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersRequest {
  zone_id: string;
}

export const SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/secondary_dns/outgoing/disable" }),
).annotations({ identifier: "SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersRequest" }) as unknown as Schema.Schema<SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersRequest>;

export interface SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersResponse" }) as unknown as Schema.Schema<SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersResponse>;

export const secondaryDnsPrimaryZoneDisableOutgoingZoneTransfers: (
  input: SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersRequest
) => Effect.Effect<
  SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersRequest,
  output: SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersRequest {
  zone_id: string;
}

export const SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/secondary_dns/outgoing/enable" }),
).annotations({ identifier: "SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersRequest" }) as unknown as Schema.Schema<SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersRequest>;

export interface SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersResponse" }) as unknown as Schema.Schema<SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersResponse>;

export const secondaryDnsPrimaryZoneEnableOutgoingZoneTransfers: (
  input: SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersRequest
) => Effect.Effect<
  SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersRequest,
  output: SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SecondaryDnsPrimaryZoneForceDnsNotifyRequest {
  zone_id: string;
}

export const SecondaryDnsPrimaryZoneForceDnsNotifyRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/secondary_dns/outgoing/force_notify" }),
).annotations({ identifier: "SecondaryDnsPrimaryZoneForceDnsNotifyRequest" }) as unknown as Schema.Schema<SecondaryDnsPrimaryZoneForceDnsNotifyRequest>;

export interface SecondaryDnsPrimaryZoneForceDnsNotifyResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SecondaryDnsPrimaryZoneForceDnsNotifyResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SecondaryDnsPrimaryZoneForceDnsNotifyResponse" }) as unknown as Schema.Schema<SecondaryDnsPrimaryZoneForceDnsNotifyResponse>;

export const secondaryDnsPrimaryZoneForceDnsNotify: (
  input: SecondaryDnsPrimaryZoneForceDnsNotifyRequest
) => Effect.Effect<
  SecondaryDnsPrimaryZoneForceDnsNotifyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SecondaryDnsPrimaryZoneForceDnsNotifyRequest,
  output: SecondaryDnsPrimaryZoneForceDnsNotifyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetOutgoingZoneTransferStatusRequest {
  zone_id: string;
}

export const GetOutgoingZoneTransferStatusRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/secondary_dns/outgoing/status" }),
).annotations({ identifier: "GetOutgoingZoneTransferStatusRequest" }) as unknown as Schema.Schema<GetOutgoingZoneTransferStatusRequest>;

export interface GetOutgoingZoneTransferStatusResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetOutgoingZoneTransferStatusResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetOutgoingZoneTransferStatusResponse" }) as unknown as Schema.Schema<GetOutgoingZoneTransferStatusResponse>;

export const getOutgoingZoneTransferStatus: (
  input: GetOutgoingZoneTransferStatusRequest
) => Effect.Effect<
  GetOutgoingZoneTransferStatusResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetOutgoingZoneTransferStatusRequest,
  output: GetOutgoingZoneTransferStatusResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZoneSecurityCenterInsightsRequest {
  zone_id: string;
  dismissed?: boolean;
  issue_class?: string[];
  issue_type?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  product?: string[];
  severity?: "low" | "moderate" | "critical"[];
  subject?: string[];
  "issue_class~neq"?: string[];
  "issue_type~neq"?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  "product~neq"?: string[];
  "severity~neq"?: "low" | "moderate" | "critical"[];
  "subject~neq"?: string[];
  page?: unknown;
  per_page?: unknown;
}

export const GetZoneSecurityCenterInsightsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  dismissed: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("dismissed")),
  issue_class: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class")),
  issue_type: Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type")),
  product: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product")),
  severity: Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity")),
  subject: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject")),
  "issue_class~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class~neq")),
  "issue_type~neq": Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type~neq")),
  "product~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product~neq")),
  "severity~neq": Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity~neq")),
  "subject~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject~neq")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/security-center/insights" }),
).annotations({ identifier: "GetZoneSecurityCenterInsightsRequest" }) as unknown as Schema.Schema<GetZoneSecurityCenterInsightsRequest>;

export interface GetZoneSecurityCenterInsightsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZoneSecurityCenterInsightsResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  count: Schema.optional(Schema.Number),
  issues: Schema.optional(Schema.Array(Schema.Struct({
  dismissed: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  issue_class: Schema.optional(Schema.String),
  issue_type: Schema.optional(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion")),
  payload: Schema.optional(Schema.Struct({
  detection_method: Schema.optional(Schema.String),
  zone_tag: Schema.optional(Schema.String)
})),
  resolve_link: Schema.optional(Schema.String),
  resolve_text: Schema.optional(Schema.String),
  severity: Schema.optional(Schema.Literal("Low", "Moderate", "Critical")),
  since: Schema.optional(Schema.Date),
  subject: Schema.optional(Schema.String),
  timestamp: Schema.optional(Schema.Date)
}))),
  page: Schema.optional(Schema.Number),
  per_page: Schema.optional(Schema.Number)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZoneSecurityCenterInsightsResponse" }) as unknown as Schema.Schema<GetZoneSecurityCenterInsightsResponse>;

export const getZoneSecurityCenterInsights: (
  input: GetZoneSecurityCenterInsightsRequest
) => Effect.Effect<
  GetZoneSecurityCenterInsightsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZoneSecurityCenterInsightsRequest,
  output: GetZoneSecurityCenterInsightsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZoneSecurityCenterInsightCountsByClassRequest {
  zone_id: string;
  dismissed?: boolean;
  issue_class?: string[];
  issue_type?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  product?: string[];
  severity?: "low" | "moderate" | "critical"[];
  subject?: string[];
  "issue_class~neq"?: string[];
  "issue_type~neq"?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  "product~neq"?: string[];
  "severity~neq"?: "low" | "moderate" | "critical"[];
  "subject~neq"?: string[];
}

export const GetZoneSecurityCenterInsightCountsByClassRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  dismissed: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("dismissed")),
  issue_class: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class")),
  issue_type: Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type")),
  product: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product")),
  severity: Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity")),
  subject: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject")),
  "issue_class~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class~neq")),
  "issue_type~neq": Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type~neq")),
  "product~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product~neq")),
  "severity~neq": Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity~neq")),
  "subject~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject~neq"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/security-center/insights/class" }),
).annotations({ identifier: "GetZoneSecurityCenterInsightCountsByClassRequest" }) as unknown as Schema.Schema<GetZoneSecurityCenterInsightCountsByClassRequest>;

export interface GetZoneSecurityCenterInsightCountsByClassResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZoneSecurityCenterInsightCountsByClassResponse = Schema.Struct({
  result: Schema.Union(Schema.Array(Schema.Struct({
  count: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.String)
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZoneSecurityCenterInsightCountsByClassResponse" }) as unknown as Schema.Schema<GetZoneSecurityCenterInsightCountsByClassResponse>;

export const getZoneSecurityCenterInsightCountsByClass: (
  input: GetZoneSecurityCenterInsightCountsByClassRequest
) => Effect.Effect<
  GetZoneSecurityCenterInsightCountsByClassResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZoneSecurityCenterInsightCountsByClassRequest,
  output: GetZoneSecurityCenterInsightCountsByClassResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZoneSecurityCenterInsightCountsBySeverityRequest {
  zone_id: string;
  dismissed?: boolean;
  issue_class?: string[];
  issue_type?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  product?: string[];
  severity?: "low" | "moderate" | "critical"[];
  subject?: string[];
  "issue_class~neq"?: string[];
  "issue_type~neq"?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  "product~neq"?: string[];
  "severity~neq"?: "low" | "moderate" | "critical"[];
  "subject~neq"?: string[];
}

export const GetZoneSecurityCenterInsightCountsBySeverityRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  dismissed: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("dismissed")),
  issue_class: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class")),
  issue_type: Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type")),
  product: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product")),
  severity: Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity")),
  subject: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject")),
  "issue_class~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class~neq")),
  "issue_type~neq": Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type~neq")),
  "product~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product~neq")),
  "severity~neq": Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity~neq")),
  "subject~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject~neq"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/security-center/insights/severity" }),
).annotations({ identifier: "GetZoneSecurityCenterInsightCountsBySeverityRequest" }) as unknown as Schema.Schema<GetZoneSecurityCenterInsightCountsBySeverityRequest>;

export interface GetZoneSecurityCenterInsightCountsBySeverityResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZoneSecurityCenterInsightCountsBySeverityResponse = Schema.Struct({
  result: Schema.Union(Schema.Array(Schema.Struct({
  count: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.String)
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZoneSecurityCenterInsightCountsBySeverityResponse" }) as unknown as Schema.Schema<GetZoneSecurityCenterInsightCountsBySeverityResponse>;

export const getZoneSecurityCenterInsightCountsBySeverity: (
  input: GetZoneSecurityCenterInsightCountsBySeverityRequest
) => Effect.Effect<
  GetZoneSecurityCenterInsightCountsBySeverityResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZoneSecurityCenterInsightCountsBySeverityRequest,
  output: GetZoneSecurityCenterInsightCountsBySeverityResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZoneSecurityCenterInsightCountsByTypeRequest {
  zone_id: string;
  dismissed?: boolean;
  issue_class?: string[];
  issue_type?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  product?: string[];
  severity?: "low" | "moderate" | "critical"[];
  subject?: string[];
  "issue_class~neq"?: string[];
  "issue_type~neq"?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  "product~neq"?: string[];
  "severity~neq"?: "low" | "moderate" | "critical"[];
  "subject~neq"?: string[];
}

export const GetZoneSecurityCenterInsightCountsByTypeRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  dismissed: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("dismissed")),
  issue_class: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class")),
  issue_type: Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type")),
  product: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product")),
  severity: Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity")),
  subject: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject")),
  "issue_class~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class~neq")),
  "issue_type~neq": Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type~neq")),
  "product~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product~neq")),
  "severity~neq": Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity~neq")),
  "subject~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject~neq"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/security-center/insights/type" }),
).annotations({ identifier: "GetZoneSecurityCenterInsightCountsByTypeRequest" }) as unknown as Schema.Schema<GetZoneSecurityCenterInsightCountsByTypeRequest>;

export interface GetZoneSecurityCenterInsightCountsByTypeResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZoneSecurityCenterInsightCountsByTypeResponse = Schema.Struct({
  result: Schema.Union(Schema.Array(Schema.Struct({
  count: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.String)
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZoneSecurityCenterInsightCountsByTypeResponse" }) as unknown as Schema.Schema<GetZoneSecurityCenterInsightCountsByTypeResponse>;

export const getZoneSecurityCenterInsightCountsByType: (
  input: GetZoneSecurityCenterInsightCountsByTypeRequest
) => Effect.Effect<
  GetZoneSecurityCenterInsightCountsByTypeResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZoneSecurityCenterInsightCountsByTypeRequest,
  output: GetZoneSecurityCenterInsightCountsByTypeResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ArchiveZoneSecurityCenterInsightRequest {
  zone_id: string;
  issue_id: string;
  body: { dismiss?: boolean };
}

export const ArchiveZoneSecurityCenterInsightRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  issue_id: Schema.String.pipe(T.HttpPath("issue_id")),
  body: Schema.Struct({
  dismiss: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/security-center/insights/{issue_id}/dismiss" }),
).annotations({ identifier: "ArchiveZoneSecurityCenterInsightRequest" }) as unknown as Schema.Schema<ArchiveZoneSecurityCenterInsightRequest>;

export interface ArchiveZoneSecurityCenterInsightResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ArchiveZoneSecurityCenterInsightResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ArchiveZoneSecurityCenterInsightResponse" }) as unknown as Schema.Schema<ArchiveZoneSecurityCenterInsightResponse>;

export const archiveZoneSecurityCenterInsight: (
  input: ArchiveZoneSecurityCenterInsightRequest
) => Effect.Effect<
  ArchiveZoneSecurityCenterInsightResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ArchiveZoneSecurityCenterInsightRequest,
  output: ArchiveZoneSecurityCenterInsightResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSecurityTxtRequest {
  zone_id: string;
}

export const GetSecurityTxtRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/security-center/securitytxt" }),
).annotations({ identifier: "GetSecurityTxtRequest" }) as unknown as Schema.Schema<GetSecurityTxtRequest>;

export interface GetSecurityTxtResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSecurityTxtResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  acknowledgments: Schema.optional(Schema.Array(Schema.String)),
  canonical: Schema.optional(Schema.Array(Schema.String)),
  contact: Schema.optional(Schema.Array(Schema.String)),
  enabled: Schema.optional(Schema.Boolean),
  encryption: Schema.optional(Schema.Array(Schema.String)),
  expires: Schema.optional(Schema.Date),
  hiring: Schema.optional(Schema.Array(Schema.String)),
  policy: Schema.optional(Schema.Array(Schema.String)),
  preferredLanguages: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSecurityTxtResponse" }) as unknown as Schema.Schema<GetSecurityTxtResponse>;

export const getSecurityTxt: (
  input: GetSecurityTxtRequest
) => Effect.Effect<
  GetSecurityTxtResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSecurityTxtRequest,
  output: GetSecurityTxtResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateSecurityTxtRequest {
  zone_id: string;
  body: { acknowledgments?: string[]; canonical?: string[]; contact?: string[]; enabled?: boolean; encryption?: string[]; expires?: string; hiring?: string[]; policy?: string[]; preferredLanguages?: string };
}

export const UpdateSecurityTxtRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  acknowledgments: Schema.optional(Schema.Array(Schema.String)),
  canonical: Schema.optional(Schema.Array(Schema.String)),
  contact: Schema.optional(Schema.Array(Schema.String)),
  enabled: Schema.optional(Schema.Boolean),
  encryption: Schema.optional(Schema.Array(Schema.String)),
  expires: Schema.optional(Schema.Date),
  hiring: Schema.optional(Schema.Array(Schema.String)),
  policy: Schema.optional(Schema.Array(Schema.String)),
  preferredLanguages: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/security-center/securitytxt" }),
).annotations({ identifier: "UpdateSecurityTxtRequest" }) as unknown as Schema.Schema<UpdateSecurityTxtRequest>;

export interface UpdateSecurityTxtResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateSecurityTxtResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateSecurityTxtResponse" }) as unknown as Schema.Schema<UpdateSecurityTxtResponse>;

export const updateSecurityTxt: (
  input: UpdateSecurityTxtRequest
) => Effect.Effect<
  UpdateSecurityTxtResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateSecurityTxtRequest,
  output: UpdateSecurityTxtResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteSecurityTxtRequest {
  zone_id: string;
}

export const DeleteSecurityTxtRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/security-center/securitytxt" }),
).annotations({ identifier: "DeleteSecurityTxtRequest" }) as unknown as Schema.Schema<DeleteSecurityTxtRequest>;

export interface DeleteSecurityTxtResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteSecurityTxtResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteSecurityTxtResponse" }) as unknown as Schema.Schema<DeleteSecurityTxtResponse>;

export const deleteSecurityTxt: (
  input: DeleteSecurityTxtRequest
) => Effect.Effect<
  DeleteSecurityTxtResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteSecurityTxtRequest,
  output: DeleteSecurityTxtResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAllZoneSettingsRequest {
  zone_id: string;
}

export const GetAllZoneSettingsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/settings" }),
).annotations({ identifier: "GetAllZoneSettingsRequest" }) as unknown as Schema.Schema<GetAllZoneSettingsRequest>;

export interface GetAllZoneSettingsResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAllZoneSettingsResponse = Schema.Struct({
  result: Schema.Array(Schema.Union(Schema.Unknown, Schema.Unknown, Schema.Struct({}), Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Struct({}), Schema.Struct({}), Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown)),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAllZoneSettingsResponse" }) as unknown as Schema.Schema<GetAllZoneSettingsResponse>;

export const getAllZoneSettings: (
  input: GetAllZoneSettingsRequest
) => Effect.Effect<
  GetAllZoneSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAllZoneSettingsRequest,
  output: GetAllZoneSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneSettingsEditZoneSettingsInfoRequest {
  zone_id: string;
  body: unknown[];
}

export const ZoneSettingsEditZoneSettingsInfoRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Array(Schema.Union(Schema.Unknown, Schema.Unknown, Schema.Struct({}), Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Struct({}), Schema.Struct({}), Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown)).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/settings" }),
).annotations({ identifier: "ZoneSettingsEditZoneSettingsInfoRequest" }) as unknown as Schema.Schema<ZoneSettingsEditZoneSettingsInfoRequest>;

export interface ZoneSettingsEditZoneSettingsInfoResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneSettingsEditZoneSettingsInfoResponse = Schema.Struct({
  result: Schema.Array(Schema.Union(Schema.Unknown, Schema.Unknown, Schema.Struct({}), Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Struct({}), Schema.Struct({}), Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown, Schema.Unknown)),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneSettingsEditZoneSettingsInfoResponse" }) as unknown as Schema.Schema<ZoneSettingsEditZoneSettingsInfoResponse>;

export const zoneSettingsEditZoneSettingsInfo: (
  input: ZoneSettingsEditZoneSettingsInfoRequest
) => Effect.Effect<
  ZoneSettingsEditZoneSettingsInfoResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneSettingsEditZoneSettingsInfoRequest,
  output: ZoneSettingsEditZoneSettingsInfoResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAegisSettingRequest {
  zone_id: string;
}

export const GetAegisSettingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/settings/aegis" }),
).annotations({ identifier: "GetAegisSettingRequest" }) as unknown as Schema.Schema<GetAegisSettingRequest>;

export interface GetAegisSettingResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAegisSettingResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAegisSettingResponse" }) as unknown as Schema.Schema<GetAegisSettingResponse>;

export const getAegisSetting: (
  input: GetAegisSettingRequest
) => Effect.Effect<
  GetAegisSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAegisSettingRequest,
  output: GetAegisSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneCacheSettingsChangeAegisSettingRequest {
  zone_id: string;
  body: { value: { enabled?: boolean; pool_id?: string } };
}

export const ZoneCacheSettingsChangeAegisSettingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  value: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  pool_id: Schema.optional(Schema.String)
})
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/settings/aegis" }),
).annotations({ identifier: "ZoneCacheSettingsChangeAegisSettingRequest" }) as unknown as Schema.Schema<ZoneCacheSettingsChangeAegisSettingRequest>;

export interface ZoneCacheSettingsChangeAegisSettingResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneCacheSettingsChangeAegisSettingResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneCacheSettingsChangeAegisSettingResponse" }) as unknown as Schema.Schema<ZoneCacheSettingsChangeAegisSettingResponse>;

export const zoneCacheSettingsChangeAegisSetting: (
  input: ZoneCacheSettingsChangeAegisSettingRequest
) => Effect.Effect<
  ZoneCacheSettingsChangeAegisSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneCacheSettingsChangeAegisSettingRequest,
  output: ZoneCacheSettingsChangeAegisSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetFontsSettingRequest {
  zone_id: string;
}

export const GetFontsSettingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/settings/fonts" }),
).annotations({ identifier: "GetFontsSettingRequest" }) as unknown as Schema.Schema<GetFontsSettingRequest>;

export interface GetFontsSettingResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetFontsSettingResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.Literal("fonts")),
  value: Schema.optional(Schema.Literal("on", "off"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetFontsSettingResponse" }) as unknown as Schema.Schema<GetFontsSettingResponse>;

export const getFontsSetting: (
  input: GetFontsSettingRequest
) => Effect.Effect<
  GetFontsSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetFontsSettingRequest,
  output: GetFontsSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneSettingsChangeFontsSettingRequest {
  zone_id: string;
  body: { value: "on" | "off" };
}

export const ZoneSettingsChangeFontsSettingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  value: Schema.Literal("on", "off")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/settings/fonts" }),
).annotations({ identifier: "ZoneSettingsChangeFontsSettingRequest" }) as unknown as Schema.Schema<ZoneSettingsChangeFontsSettingRequest>;

export interface ZoneSettingsChangeFontsSettingResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneSettingsChangeFontsSettingResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.Literal("fonts")),
  value: Schema.optional(Schema.Literal("on", "off"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneSettingsChangeFontsSettingResponse" }) as unknown as Schema.Schema<ZoneSettingsChangeFontsSettingResponse>;

export const zoneSettingsChangeFontsSetting: (
  input: ZoneSettingsChangeFontsSettingRequest
) => Effect.Effect<
  ZoneSettingsChangeFontsSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneSettingsChangeFontsSettingRequest,
  output: ZoneSettingsChangeFontsSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetOriginH2MaxStreamsSettingRequest {
  zone_id: string;
}

export const GetOriginH2MaxStreamsSettingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/settings/origin_h2_max_streams" }),
).annotations({ identifier: "GetOriginH2MaxStreamsSettingRequest" }) as unknown as Schema.Schema<GetOriginH2MaxStreamsSettingRequest>;

export interface GetOriginH2MaxStreamsSettingResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetOriginH2MaxStreamsSettingResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetOriginH2MaxStreamsSettingResponse" }) as unknown as Schema.Schema<GetOriginH2MaxStreamsSettingResponse>;

export const getOriginH2MaxStreamsSetting: (
  input: GetOriginH2MaxStreamsSettingRequest
) => Effect.Effect<
  GetOriginH2MaxStreamsSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetOriginH2MaxStreamsSettingRequest,
  output: GetOriginH2MaxStreamsSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneCacheSettingsChangeOriginH2MaxStreamsSettingRequest {
  zone_id: string;
  body: { value: number };
}

export const ZoneCacheSettingsChangeOriginH2MaxStreamsSettingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  value: Schema.Number
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/settings/origin_h2_max_streams" }),
).annotations({ identifier: "ZoneCacheSettingsChangeOriginH2MaxStreamsSettingRequest" }) as unknown as Schema.Schema<ZoneCacheSettingsChangeOriginH2MaxStreamsSettingRequest>;

export interface ZoneCacheSettingsChangeOriginH2MaxStreamsSettingResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneCacheSettingsChangeOriginH2MaxStreamsSettingResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneCacheSettingsChangeOriginH2MaxStreamsSettingResponse" }) as unknown as Schema.Schema<ZoneCacheSettingsChangeOriginH2MaxStreamsSettingResponse>;

export const zoneCacheSettingsChangeOriginH2MaxStreamsSetting: (
  input: ZoneCacheSettingsChangeOriginH2MaxStreamsSettingRequest
) => Effect.Effect<
  ZoneCacheSettingsChangeOriginH2MaxStreamsSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneCacheSettingsChangeOriginH2MaxStreamsSettingRequest,
  output: ZoneCacheSettingsChangeOriginH2MaxStreamsSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetOriginMaxHttpVersionSettingRequest {
  zone_id: string;
}

export const GetOriginMaxHttpVersionSettingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/settings/origin_max_http_version" }),
).annotations({ identifier: "GetOriginMaxHttpVersionSettingRequest" }) as unknown as Schema.Schema<GetOriginMaxHttpVersionSettingRequest>;

export interface GetOriginMaxHttpVersionSettingResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetOriginMaxHttpVersionSettingResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetOriginMaxHttpVersionSettingResponse" }) as unknown as Schema.Schema<GetOriginMaxHttpVersionSettingResponse>;

export const getOriginMaxHttpVersionSetting: (
  input: GetOriginMaxHttpVersionSettingRequest
) => Effect.Effect<
  GetOriginMaxHttpVersionSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetOriginMaxHttpVersionSettingRequest,
  output: GetOriginMaxHttpVersionSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneCacheSettingsChangeOriginMaxHttpVersionSettingRequest {
  zone_id: string;
  body: { value: "2" | "1" };
}

export const ZoneCacheSettingsChangeOriginMaxHttpVersionSettingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  value: Schema.Literal("2", "1")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/settings/origin_max_http_version" }),
).annotations({ identifier: "ZoneCacheSettingsChangeOriginMaxHttpVersionSettingRequest" }) as unknown as Schema.Schema<ZoneCacheSettingsChangeOriginMaxHttpVersionSettingRequest>;

export interface ZoneCacheSettingsChangeOriginMaxHttpVersionSettingResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneCacheSettingsChangeOriginMaxHttpVersionSettingResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneCacheSettingsChangeOriginMaxHttpVersionSettingResponse" }) as unknown as Schema.Schema<ZoneCacheSettingsChangeOriginMaxHttpVersionSettingResponse>;

export const zoneCacheSettingsChangeOriginMaxHttpVersionSetting: (
  input: ZoneCacheSettingsChangeOriginMaxHttpVersionSettingRequest
) => Effect.Effect<
  ZoneCacheSettingsChangeOriginMaxHttpVersionSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneCacheSettingsChangeOriginMaxHttpVersionSettingRequest,
  output: ZoneCacheSettingsChangeOriginMaxHttpVersionSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetRumStatusRequest {
  zone_id: string;
}

export const GetRumStatusRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/settings/rum" }),
).annotations({ identifier: "GetRumStatusRequest" }) as unknown as Schema.Schema<GetRumStatusRequest>;

export interface GetRumStatusResponse {
  result: { editable?: boolean; id?: string; value?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetRumStatusResponse = Schema.Struct({
  result: Schema.Struct({
  editable: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetRumStatusResponse" }) as unknown as Schema.Schema<GetRumStatusResponse>;

export const getRumStatus: (
  input: GetRumStatusRequest
) => Effect.Effect<
  GetRumStatusResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRumStatusRequest,
  output: GetRumStatusResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface WebAnalyticsToggleRumRequest {
  zone_id: string;
  body: { value?: string };
}

export const WebAnalyticsToggleRumRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  value: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/settings/rum" }),
).annotations({ identifier: "WebAnalyticsToggleRumRequest" }) as unknown as Schema.Schema<WebAnalyticsToggleRumRequest>;

export interface WebAnalyticsToggleRumResponse {
  result: { editable?: boolean; id?: string; value?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const WebAnalyticsToggleRumResponse = Schema.Struct({
  result: Schema.Struct({
  editable: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "WebAnalyticsToggleRumResponse" }) as unknown as Schema.Schema<WebAnalyticsToggleRumResponse>;

export const webAnalyticsToggleRum: (
  input: WebAnalyticsToggleRumRequest
) => Effect.Effect<
  WebAnalyticsToggleRumResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: WebAnalyticsToggleRumRequest,
  output: WebAnalyticsToggleRumResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSpeedBrainSettingRequest {
  zone_id: string;
}

export const GetSpeedBrainSettingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/settings/speed_brain" }),
).annotations({ identifier: "GetSpeedBrainSettingRequest" }) as unknown as Schema.Schema<GetSpeedBrainSettingRequest>;

export interface GetSpeedBrainSettingResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSpeedBrainSettingResponse = Schema.Struct({
  result: Schema.Struct({
  value: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSpeedBrainSettingResponse" }) as unknown as Schema.Schema<GetSpeedBrainSettingResponse>;

export const getSpeedBrainSetting: (
  input: GetSpeedBrainSettingRequest
) => Effect.Effect<
  GetSpeedBrainSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSpeedBrainSettingRequest,
  output: GetSpeedBrainSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneSettingsChangeSpeedBrainSettingRequest {
  zone_id: string;
  body: { value: "on" | "off" };
}

export const ZoneSettingsChangeSpeedBrainSettingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  value: Schema.Literal("on", "off")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/settings/speed_brain" }),
).annotations({ identifier: "ZoneSettingsChangeSpeedBrainSettingRequest" }) as unknown as Schema.Schema<ZoneSettingsChangeSpeedBrainSettingRequest>;

export interface ZoneSettingsChangeSpeedBrainSettingResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneSettingsChangeSpeedBrainSettingResponse = Schema.Struct({
  result: Schema.Struct({
  value: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneSettingsChangeSpeedBrainSettingResponse" }) as unknown as Schema.Schema<ZoneSettingsChangeSpeedBrainSettingResponse>;

export const zoneSettingsChangeSpeedBrainSetting: (
  input: ZoneSettingsChangeSpeedBrainSettingRequest
) => Effect.Effect<
  ZoneSettingsChangeSpeedBrainSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneSettingsChangeSpeedBrainSettingRequest,
  output: ZoneSettingsChangeSpeedBrainSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetEnrollmentRequest {
  zone_id: string;
}

export const GetEnrollmentRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/settings/ssl_automatic_mode" }),
).annotations({ identifier: "GetEnrollmentRequest" }) as unknown as Schema.Schema<GetEnrollmentRequest>;

export interface GetEnrollmentResponse {
  result: { editable: boolean; id: string; modified_on: string; next_scheduled_scan?: string; value: "auto" | "custom" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetEnrollmentResponse = Schema.Struct({
  result: Schema.Struct({
  editable: Schema.Boolean,
  id: Schema.String,
  modified_on: Schema.Date,
  next_scheduled_scan: Schema.optional(Schema.Date),
  value: Schema.Literal("auto", "custom")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetEnrollmentResponse" }) as unknown as Schema.Schema<GetEnrollmentResponse>;

export const getEnrollment: (
  input: GetEnrollmentRequest
) => Effect.Effect<
  GetEnrollmentResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEnrollmentRequest,
  output: GetEnrollmentResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchEnrollmentRequest {
  zone_id: string;
  body: { value: "auto" | "custom" };
}

export const PatchEnrollmentRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  value: Schema.Literal("auto", "custom")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/settings/ssl_automatic_mode" }),
).annotations({ identifier: "PatchEnrollmentRequest" }) as unknown as Schema.Schema<PatchEnrollmentRequest>;

export interface PatchEnrollmentResponse {
  result: { editable: boolean; id: string; modified_on: string; next_scheduled_scan?: string; value: "auto" | "custom" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchEnrollmentResponse = Schema.Struct({
  result: Schema.Struct({
  editable: Schema.Boolean,
  id: Schema.String,
  modified_on: Schema.Date,
  next_scheduled_scan: Schema.optional(Schema.Date),
  value: Schema.Literal("auto", "custom")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchEnrollmentResponse" }) as unknown as Schema.Schema<PatchEnrollmentResponse>;

export const patchEnrollment: (
  input: PatchEnrollmentRequest
) => Effect.Effect<
  PatchEnrollmentResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchEnrollmentRequest,
  output: PatchEnrollmentResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZonesZoneIdentifierZarazConfigRequest {
  zone_id: string;
}

export const GetZonesZoneIdentifierZarazConfigRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/settings/zaraz/config" }),
).annotations({ identifier: "GetZonesZoneIdentifierZarazConfigRequest" }) as unknown as Schema.Schema<GetZonesZoneIdentifierZarazConfigRequest>;

export interface GetZonesZoneIdentifierZarazConfigResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZonesZoneIdentifierZarazConfigResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZonesZoneIdentifierZarazConfigResponse" }) as unknown as Schema.Schema<GetZonesZoneIdentifierZarazConfigResponse>;

export const getZonesZoneIdentifierZarazConfig: (
  input: GetZonesZoneIdentifierZarazConfigRequest
) => Effect.Effect<
  GetZonesZoneIdentifierZarazConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZonesZoneIdentifierZarazConfigRequest,
  output: GetZonesZoneIdentifierZarazConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PutZonesZoneIdentifierZarazConfigRequest {
  zone_id: string;
  body: unknown;
}

export const PutZonesZoneIdentifierZarazConfigRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/settings/zaraz/config" }),
).annotations({ identifier: "PutZonesZoneIdentifierZarazConfigRequest" }) as unknown as Schema.Schema<PutZonesZoneIdentifierZarazConfigRequest>;

export interface PutZonesZoneIdentifierZarazConfigResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PutZonesZoneIdentifierZarazConfigResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PutZonesZoneIdentifierZarazConfigResponse" }) as unknown as Schema.Schema<PutZonesZoneIdentifierZarazConfigResponse>;

export const putZonesZoneIdentifierZarazConfig: (
  input: PutZonesZoneIdentifierZarazConfigRequest
) => Effect.Effect<
  PutZonesZoneIdentifierZarazConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutZonesZoneIdentifierZarazConfigRequest,
  output: PutZonesZoneIdentifierZarazConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZonesZoneIdentifierZarazDefaultRequest {
  zone_id: string;
}

export const GetZonesZoneIdentifierZarazDefaultRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/settings/zaraz/default" }),
).annotations({ identifier: "GetZonesZoneIdentifierZarazDefaultRequest" }) as unknown as Schema.Schema<GetZonesZoneIdentifierZarazDefaultRequest>;

export interface GetZonesZoneIdentifierZarazDefaultResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZonesZoneIdentifierZarazDefaultResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZonesZoneIdentifierZarazDefaultResponse" }) as unknown as Schema.Schema<GetZonesZoneIdentifierZarazDefaultResponse>;

export const getZonesZoneIdentifierZarazDefault: (
  input: GetZonesZoneIdentifierZarazDefaultRequest
) => Effect.Effect<
  GetZonesZoneIdentifierZarazDefaultResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZonesZoneIdentifierZarazDefaultRequest,
  output: GetZonesZoneIdentifierZarazDefaultResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZonesZoneIdentifierZarazExportRequest {
  zone_id: string;
}

export const GetZonesZoneIdentifierZarazExportRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/settings/zaraz/export" }),
).annotations({ identifier: "GetZonesZoneIdentifierZarazExportRequest" }) as unknown as Schema.Schema<GetZonesZoneIdentifierZarazExportRequest>;

export interface GetZonesZoneIdentifierZarazExportResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZonesZoneIdentifierZarazExportResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZonesZoneIdentifierZarazExportResponse" }) as unknown as Schema.Schema<GetZonesZoneIdentifierZarazExportResponse>;

export const getZonesZoneIdentifierZarazExport: (
  input: GetZonesZoneIdentifierZarazExportRequest
) => Effect.Effect<
  GetZonesZoneIdentifierZarazExportResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZonesZoneIdentifierZarazExportRequest,
  output: GetZonesZoneIdentifierZarazExportResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZonesZoneIdentifierZarazHistoryRequest {
  zone_id: string;
  offset?: number;
  limit?: number;
  sortField?: "id" | "user_id" | "description" | "created_at" | "updated_at";
  sortOrder?: "DESC" | "ASC";
}

export const GetZonesZoneIdentifierZarazHistoryRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  sortField: Schema.optional(Schema.Literal("id", "user_id", "description", "created_at", "updated_at")).pipe(T.HttpQuery("sortField")),
  sortOrder: Schema.optional(Schema.Literal("DESC", "ASC")).pipe(T.HttpQuery("sortOrder"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/settings/zaraz/history" }),
).annotations({ identifier: "GetZonesZoneIdentifierZarazHistoryRequest" }) as unknown as Schema.Schema<GetZonesZoneIdentifierZarazHistoryRequest>;

export interface GetZonesZoneIdentifierZarazHistoryResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZonesZoneIdentifierZarazHistoryResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  description: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZonesZoneIdentifierZarazHistoryResponse" }) as unknown as Schema.Schema<GetZonesZoneIdentifierZarazHistoryResponse>;

export const getZonesZoneIdentifierZarazHistory: (
  input: GetZonesZoneIdentifierZarazHistoryRequest
) => Effect.Effect<
  GetZonesZoneIdentifierZarazHistoryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZonesZoneIdentifierZarazHistoryRequest,
  output: GetZonesZoneIdentifierZarazHistoryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PutZonesZoneIdentifierZarazHistoryRequest {
  zone_id: string;
  body: number;
}

export const PutZonesZoneIdentifierZarazHistoryRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Number.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/settings/zaraz/history" }),
).annotations({ identifier: "PutZonesZoneIdentifierZarazHistoryRequest" }) as unknown as Schema.Schema<PutZonesZoneIdentifierZarazHistoryRequest>;

export interface PutZonesZoneIdentifierZarazHistoryResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PutZonesZoneIdentifierZarazHistoryResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PutZonesZoneIdentifierZarazHistoryResponse" }) as unknown as Schema.Schema<PutZonesZoneIdentifierZarazHistoryResponse>;

export const putZonesZoneIdentifierZarazHistory: (
  input: PutZonesZoneIdentifierZarazHistoryRequest
) => Effect.Effect<
  PutZonesZoneIdentifierZarazHistoryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutZonesZoneIdentifierZarazHistoryRequest,
  output: PutZonesZoneIdentifierZarazHistoryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZonesZoneIdentifierZarazConfigHistoryRequest {
  zone_id: string;
  ids: number[];
}

export const GetZonesZoneIdentifierZarazConfigHistoryRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  ids: Schema.Array(Schema.Number).pipe(T.HttpQuery("ids"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/settings/zaraz/history/configs" }),
).annotations({ identifier: "GetZonesZoneIdentifierZarazConfigHistoryRequest" }) as unknown as Schema.Schema<GetZonesZoneIdentifierZarazConfigHistoryRequest>;

export interface GetZonesZoneIdentifierZarazConfigHistoryResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZonesZoneIdentifierZarazConfigHistoryResponse = Schema.Struct({
  result: Schema.Record({ key: Schema.String, value: Schema.Struct({
  config: Schema.Unknown
}) }),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZonesZoneIdentifierZarazConfigHistoryResponse" }) as unknown as Schema.Schema<GetZonesZoneIdentifierZarazConfigHistoryResponse>;

export const getZonesZoneIdentifierZarazConfigHistory: (
  input: GetZonesZoneIdentifierZarazConfigHistoryRequest
) => Effect.Effect<
  GetZonesZoneIdentifierZarazConfigHistoryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZonesZoneIdentifierZarazConfigHistoryRequest,
  output: GetZonesZoneIdentifierZarazConfigHistoryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostZonesZoneIdentifierZarazPublishRequest {
  zone_id: string;
  body: string;
}

export const PostZonesZoneIdentifierZarazPublishRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.String.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/settings/zaraz/publish" }),
).annotations({ identifier: "PostZonesZoneIdentifierZarazPublishRequest" }) as unknown as Schema.Schema<PostZonesZoneIdentifierZarazPublishRequest>;

export interface PostZonesZoneIdentifierZarazPublishResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostZonesZoneIdentifierZarazPublishResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostZonesZoneIdentifierZarazPublishResponse" }) as unknown as Schema.Schema<PostZonesZoneIdentifierZarazPublishResponse>;

export const postZonesZoneIdentifierZarazPublish: (
  input: PostZonesZoneIdentifierZarazPublishRequest
) => Effect.Effect<
  PostZonesZoneIdentifierZarazPublishResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostZonesZoneIdentifierZarazPublishRequest,
  output: PostZonesZoneIdentifierZarazPublishResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZonesZoneIdentifierZarazWorkflowRequest {
  zone_id: string;
}

export const GetZonesZoneIdentifierZarazWorkflowRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/settings/zaraz/workflow" }),
).annotations({ identifier: "GetZonesZoneIdentifierZarazWorkflowRequest" }) as unknown as Schema.Schema<GetZonesZoneIdentifierZarazWorkflowRequest>;

export interface GetZonesZoneIdentifierZarazWorkflowResponse {
  result: "realtime" | "preview";
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZonesZoneIdentifierZarazWorkflowResponse = Schema.Struct({
  result: Schema.Literal("realtime", "preview"),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZonesZoneIdentifierZarazWorkflowResponse" }) as unknown as Schema.Schema<GetZonesZoneIdentifierZarazWorkflowResponse>;

export const getZonesZoneIdentifierZarazWorkflow: (
  input: GetZonesZoneIdentifierZarazWorkflowRequest
) => Effect.Effect<
  GetZonesZoneIdentifierZarazWorkflowResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZonesZoneIdentifierZarazWorkflowRequest,
  output: GetZonesZoneIdentifierZarazWorkflowResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PutZonesZoneIdentifierZarazWorkflowRequest {
  zone_id: string;
  body: "realtime" | "preview";
}

export const PutZonesZoneIdentifierZarazWorkflowRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Literal("realtime", "preview").pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/settings/zaraz/workflow" }),
).annotations({ identifier: "PutZonesZoneIdentifierZarazWorkflowRequest" }) as unknown as Schema.Schema<PutZonesZoneIdentifierZarazWorkflowRequest>;

export interface PutZonesZoneIdentifierZarazWorkflowResponse {
  result: "realtime" | "preview";
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PutZonesZoneIdentifierZarazWorkflowResponse = Schema.Struct({
  result: Schema.Literal("realtime", "preview"),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PutZonesZoneIdentifierZarazWorkflowResponse" }) as unknown as Schema.Schema<PutZonesZoneIdentifierZarazWorkflowResponse>;

export const putZonesZoneIdentifierZarazWorkflow: (
  input: PutZonesZoneIdentifierZarazWorkflowRequest
) => Effect.Effect<
  PutZonesZoneIdentifierZarazWorkflowResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutZonesZoneIdentifierZarazWorkflowRequest,
  output: PutZonesZoneIdentifierZarazWorkflowResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSingleSettingRequest {
  zone_id: string;
  setting_id: string;
}

export const GetSingleSettingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  setting_id: Schema.String.pipe(T.HttpPath("setting_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/settings/{setting_id}" }),
).annotations({ identifier: "GetSingleSettingRequest" }) as unknown as Schema.Schema<GetSingleSettingRequest>;

export interface GetSingleSettingResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSingleSettingResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSingleSettingResponse" }) as unknown as Schema.Schema<GetSingleSettingResponse>;

export const getSingleSetting: (
  input: GetSingleSettingRequest
) => Effect.Effect<
  GetSingleSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSingleSettingRequest,
  output: GetSingleSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneSettingsEditSingleSettingRequest {
  zone_id: string;
  setting_id: string;
  body: unknown;
}

export const ZoneSettingsEditSingleSettingRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  setting_id: Schema.String.pipe(T.HttpPath("setting_id")),
  body: Schema.Union(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
}), Schema.Struct({
  value: Schema.optional(Schema.Union(Schema.Literal("on", "off"), Schema.Literal("on", "off"), Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  pool_id: Schema.optional(Schema.String)
}), Schema.Literal("on", "off"), Schema.Literal("on", "off"), Schema.Literal("on", "off"), Schema.Literal("off", "on"), Schema.Number, Schema.Literal("on", "off"), Schema.Literal("aggressive", "basic", "simplified"), Schema.Literal(300, 900, 1800, 2700, 3600, 7200, 10800, 14400, 28800, 57600, 86400, 604800, 2592000, 31536000), Schema.Literal("on", "off"), Schema.Array(Schema.String), Schema.Literal("flatten_at_root", "flatten_all"), Schema.Literal("on", "off"), Schema.Literal("on", "off"), Schema.Literal(30, 60, 300, 1200, 1800, 3600, 7200, 10800, 14400, 18000, 28800, 43200, 57600, 72000, 86400, 172800, 259200, 345600, 432000, 518400, 604800), Schema.Literal("on", "off"), Schema.Literal("on", "off", "custom"), Schema.Literal("on", "off"), Schema.Literal("on", "off"), Schema.Literal("on", "off"), Schema.Literal("on", "off", "open"), Schema.Literal("on", "off"), Schema.Literal("off", "on"), Schema.Literal(100, 125, 150, 175, 200, 225, 250, 275, 300, 325, 350, 375, 400, 425, 450, 475, 500, 1000), Schema.Literal("1.0", "1.1", "1.2", "1.3"), Schema.Literal("on", "off"), Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
}), Schema.Literal("on", "off"), Schema.Literal("on", "off"), Schema.Literal("on", "off"), Schema.Literal("on", "off"), Schema.Number, Schema.Literal("2", "1"), Schema.Literal("off", "lossless", "lossy"), Schema.Literal("on", "off"), Schema.Literal("on", "off"), Schema.Number, Schema.Literal("off", "add_header", "overwrite_header"), Schema.Literal("on", "off"), Schema.Literal("on", "off"), Schema.Literal("on", "off"), Schema.Struct({
  cache_by_device_type: Schema.Boolean,
  cf: Schema.Boolean,
  enabled: Schema.Boolean,
  hostnames: Schema.Array(Schema.String),
  wordpress: Schema.Boolean,
  wp_plugin: Schema.Boolean
}), Schema.Struct({
  strict_transport_security: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  include_subdomains: Schema.optional(Schema.Boolean),
  max_age: Schema.optional(Schema.Number),
  nosniff: Schema.optional(Schema.Boolean),
  preload: Schema.optional(Schema.Boolean)
}))
}), Schema.Literal("off", "essentially_off", "low", "medium", "high", "under_attack"), Schema.Literal("on", "off"), Schema.Literal("off", "on"), Schema.Literal("on", "off"), Schema.Literal("off", "flexible", "full", "strict"), Schema.Literal("off", "on"), Schema.Literal("on", "off", "zrt"), Schema.Literal("on", "off"), Schema.Literal("on", "off"), Schema.Literal("on", "off"), Schema.Literal("off", "on"), Schema.Literal("off", "on")))
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/settings/{setting_id}" }),
).annotations({ identifier: "ZoneSettingsEditSingleSettingRequest" }) as unknown as Schema.Schema<ZoneSettingsEditSingleSettingRequest>;

export interface ZoneSettingsEditSingleSettingResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneSettingsEditSingleSettingResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneSettingsEditSingleSettingResponse" }) as unknown as Schema.Schema<ZoneSettingsEditSingleSettingResponse>;

export const zoneSettingsEditSingleSetting: (
  input: ZoneSettingsEditSingleSettingRequest
) => Effect.Effect<
  ZoneSettingsEditSingleSettingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneSettingsEditSingleSettingRequest,
  output: ZoneSettingsEditSingleSettingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSettings2Request {
  zone_id: string;
}

export const GetSettings2Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/smart_shield" }),
).annotations({ identifier: "GetSettings2Request" }) as unknown as Schema.Schema<GetSettings2Request>;

export interface GetSettings2Response {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSettings2Response = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSettings2Response" }) as unknown as Schema.Schema<GetSettings2Response>;

export const getSettings2: (
  input: GetSettings2Request
) => Effect.Effect<
  GetSettings2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSettings2Request,
  output: GetSettings2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchSettingsRequest {
  zone_id: string;
  body: { cache_reserve?: { value?: "on" | "off" }; regional_tiered_cache?: { value?: "on" | "off" }; smart_routing?: { value?: "on" | "off" }; smart_tiered_cache?: { value?: "on" | "off" } };
}

export const PatchSettingsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  cache_reserve: Schema.optional(Schema.Struct({
  value: Schema.optional(Schema.Literal("on", "off"))
})),
  regional_tiered_cache: Schema.optional(Schema.Struct({
  value: Schema.optional(Schema.Literal("on", "off"))
})),
  smart_routing: Schema.optional(Schema.Struct({
  value: Schema.optional(Schema.Literal("on", "off"))
})),
  smart_tiered_cache: Schema.optional(Schema.Struct({
  value: Schema.optional(Schema.Literal("on", "off"))
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/smart_shield" }),
).annotations({ identifier: "PatchSettingsRequest" }) as unknown as Schema.Schema<PatchSettingsRequest>;

export interface PatchSettingsResponse {
  result: { smart_tiered_cache: { editable?: boolean; id?: string; modified_on?: string; value?: "on" | "off" } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchSettingsResponse = Schema.Struct({
  result: Schema.Struct({
  smart_tiered_cache: Schema.Struct({
  editable: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Literal("on", "off"))
})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchSettingsResponse" }) as unknown as Schema.Schema<PatchSettingsResponse>;

export const patchSettings: (
  input: PatchSettingsRequest
) => Effect.Effect<
  PatchSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchSettingsRequest,
  output: PatchSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetCacheReserveClearRequest {
  zone_id: string;
}

export const GetCacheReserveClearRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/smart_shield/cache_reserve_clear" }),
).annotations({ identifier: "GetCacheReserveClearRequest" }) as unknown as Schema.Schema<GetCacheReserveClearRequest>;

export interface GetCacheReserveClearResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetCacheReserveClearResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetCacheReserveClearResponse" }) as unknown as Schema.Schema<GetCacheReserveClearResponse>;

export const getCacheReserveClear: (
  input: GetCacheReserveClearRequest
) => Effect.Effect<
  GetCacheReserveClearResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCacheReserveClearRequest,
  output: GetCacheReserveClearResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SmartShieldSettingsStartCacheReserveClearRequest {
  zone_id: string;
}

export const SmartShieldSettingsStartCacheReserveClearRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/smart_shield/cache_reserve_clear" }),
).annotations({ identifier: "SmartShieldSettingsStartCacheReserveClearRequest" }) as unknown as Schema.Schema<SmartShieldSettingsStartCacheReserveClearRequest>;

export interface SmartShieldSettingsStartCacheReserveClearResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SmartShieldSettingsStartCacheReserveClearResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SmartShieldSettingsStartCacheReserveClearResponse" }) as unknown as Schema.Schema<SmartShieldSettingsStartCacheReserveClearResponse>;

export const smartShieldSettingsStartCacheReserveClear: (
  input: SmartShieldSettingsStartCacheReserveClearRequest
) => Effect.Effect<
  SmartShieldSettingsStartCacheReserveClearResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SmartShieldSettingsStartCacheReserveClearRequest,
  output: SmartShieldSettingsStartCacheReserveClearResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListHealthChecks1Request {
  zone_id: string;
}

export const ListHealthChecks1Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/smart_shield/healthchecks" }),
).annotations({ identifier: "ListHealthChecks1Request" }) as unknown as Schema.Schema<ListHealthChecks1Request>;

export interface ListHealthChecks1Response {
  result: { address?: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; created_on?: string; description?: string; failure_reason?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; id?: string; interval?: number; modified_on?: string; name?: string; retries?: number; status?: "unknown" | "healthy" | "unhealthy" | "suspended"; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListHealthChecks1Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  address: Schema.optional(Schema.String),
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  failure_reason: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("unknown", "healthy", "unhealthy", "suspended")),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListHealthChecks1Response" }) as unknown as Schema.Schema<ListHealthChecks1Response>;

export const listHealthChecks1: (
  input: ListHealthChecks1Request
) => Effect.Effect<
  ListHealthChecks1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListHealthChecks1Request,
  output: ListHealthChecks1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateHealthCheck1Request {
  zone_id: string;
  body: { address: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; description?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; interval?: number; name: string; retries?: number; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string };
}

export const CreateHealthCheck1Request = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  address: Schema.String,
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  description: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  interval: Schema.optional(Schema.Number),
  name: Schema.String,
  retries: Schema.optional(Schema.Number),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/smart_shield/healthchecks" }),
).annotations({ identifier: "CreateHealthCheck1Request" }) as unknown as Schema.Schema<CreateHealthCheck1Request>;

export interface CreateHealthCheck1Response {
  result: { address?: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; created_on?: string; description?: string; failure_reason?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; id?: string; interval?: number; modified_on?: string; name?: string; retries?: number; status?: "unknown" | "healthy" | "unhealthy" | "suspended"; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateHealthCheck1Response = Schema.Struct({
  result: Schema.Struct({
  address: Schema.optional(Schema.String),
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  failure_reason: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("unknown", "healthy", "unhealthy", "suspended")),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateHealthCheck1Response" }) as unknown as Schema.Schema<CreateHealthCheck1Response>;

export const createHealthCheck1: (
  input: CreateHealthCheck1Request
) => Effect.Effect<
  CreateHealthCheck1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateHealthCheck1Request,
  output: CreateHealthCheck1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SmartShieldHealthCheckDetailsRequest {
  healthcheck_id: string;
  zone_id: string;
}

export const SmartShieldHealthCheckDetailsRequest = Schema.Struct({
  healthcheck_id: Schema.String.pipe(T.HttpPath("healthcheck_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/smart_shield/healthchecks/{healthcheck_id}" }),
).annotations({ identifier: "SmartShieldHealthCheckDetailsRequest" }) as unknown as Schema.Schema<SmartShieldHealthCheckDetailsRequest>;

export interface SmartShieldHealthCheckDetailsResponse {
  result: { address?: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; created_on?: string; description?: string; failure_reason?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; id?: string; interval?: number; modified_on?: string; name?: string; retries?: number; status?: "unknown" | "healthy" | "unhealthy" | "suspended"; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SmartShieldHealthCheckDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  address: Schema.optional(Schema.String),
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  failure_reason: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("unknown", "healthy", "unhealthy", "suspended")),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SmartShieldHealthCheckDetailsResponse" }) as unknown as Schema.Schema<SmartShieldHealthCheckDetailsResponse>;

export const smartShieldHealthCheckDetails: (
  input: SmartShieldHealthCheckDetailsRequest
) => Effect.Effect<
  SmartShieldHealthCheckDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SmartShieldHealthCheckDetailsRequest,
  output: SmartShieldHealthCheckDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateHealthCheck1Request {
  healthcheck_id: string;
  zone_id: string;
  body: unknown;
}

export const UpdateHealthCheck1Request = Schema.Struct({
  healthcheck_id: Schema.String.pipe(T.HttpPath("healthcheck_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  result: Schema.optional(Schema.Struct({
  address: Schema.optional(Schema.String),
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  failure_reason: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("unknown", "healthy", "unhealthy", "suspended")),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/smart_shield/healthchecks/{healthcheck_id}" }),
).annotations({ identifier: "UpdateHealthCheck1Request" }) as unknown as Schema.Schema<UpdateHealthCheck1Request>;

export interface UpdateHealthCheck1Response {
  result: { address?: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; created_on?: string; description?: string; failure_reason?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; id?: string; interval?: number; modified_on?: string; name?: string; retries?: number; status?: "unknown" | "healthy" | "unhealthy" | "suspended"; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateHealthCheck1Response = Schema.Struct({
  result: Schema.Struct({
  address: Schema.optional(Schema.String),
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  failure_reason: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("unknown", "healthy", "unhealthy", "suspended")),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateHealthCheck1Response" }) as unknown as Schema.Schema<UpdateHealthCheck1Response>;

export const updateHealthCheck1: (
  input: UpdateHealthCheck1Request
) => Effect.Effect<
  UpdateHealthCheck1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateHealthCheck1Request,
  output: UpdateHealthCheck1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteHealthCheck1Request {
  healthcheck_id: string;
  zone_id: string;
}

export const DeleteHealthCheck1Request = Schema.Struct({
  healthcheck_id: Schema.String.pipe(T.HttpPath("healthcheck_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/smart_shield/healthchecks/{healthcheck_id}" }),
).annotations({ identifier: "DeleteHealthCheck1Request" }) as unknown as Schema.Schema<DeleteHealthCheck1Request>;

export interface DeleteHealthCheck1Response {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteHealthCheck1Response = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteHealthCheck1Response" }) as unknown as Schema.Schema<DeleteHealthCheck1Response>;

export const deleteHealthCheck1: (
  input: DeleteHealthCheck1Request
) => Effect.Effect<
  DeleteHealthCheck1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteHealthCheck1Request,
  output: DeleteHealthCheck1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchHealthCheck1Request {
  healthcheck_id: string;
  zone_id: string;
  body: { address: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; description?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; interval?: number; name: string; retries?: number; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string };
}

export const PatchHealthCheck1Request = Schema.Struct({
  healthcheck_id: Schema.String.pipe(T.HttpPath("healthcheck_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  address: Schema.String,
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  description: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  interval: Schema.optional(Schema.Number),
  name: Schema.String,
  retries: Schema.optional(Schema.Number),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/smart_shield/healthchecks/{healthcheck_id}" }),
).annotations({ identifier: "PatchHealthCheck1Request" }) as unknown as Schema.Schema<PatchHealthCheck1Request>;

export interface PatchHealthCheck1Response {
  result: { address?: string; check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; consecutive_fails?: number; consecutive_successes?: number; created_on?: string; description?: string; failure_reason?: string; http_config?: { allow_insecure?: boolean; expected_body?: string; expected_codes?: string[]; follow_redirects?: boolean; header?: Record<string, unknown>; method?: "GET" | "HEAD"; path?: string; port?: number }; id?: string; interval?: number; modified_on?: string; name?: string; retries?: number; status?: "unknown" | "healthy" | "unhealthy" | "suspended"; suspended?: boolean; tcp_config?: { method?: "connection_established"; port?: number }; timeout?: number; type?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchHealthCheck1Response = Schema.Struct({
  result: Schema.Struct({
  address: Schema.optional(Schema.String),
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"))),
  consecutive_fails: Schema.optional(Schema.Number),
  consecutive_successes: Schema.optional(Schema.Number),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  failure_reason: Schema.optional(Schema.String),
  http_config: Schema.optional(Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.Array(Schema.String)),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  method: Schema.optional(Schema.Literal("GET", "HEAD")),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("unknown", "healthy", "unhealthy", "suspended")),
  suspended: Schema.optional(Schema.Boolean),
  tcp_config: Schema.optional(Schema.Struct({
  method: Schema.optional(Schema.Literal("connection_established")),
  port: Schema.optional(Schema.Number)
})),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchHealthCheck1Response" }) as unknown as Schema.Schema<PatchHealthCheck1Response>;

export const patchHealthCheck1: (
  input: PatchHealthCheck1Request
) => Effect.Effect<
  PatchHealthCheck1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchHealthCheck1Request,
  output: PatchHealthCheck1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListzonesnippetsRequest {
  zone_id: string;
  page?: number;
  per_page?: number;
}

export const ListzonesnippetsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/snippets" }),
).annotations({ identifier: "ListzonesnippetsRequest" }) as unknown as Schema.Schema<ListzonesnippetsRequest>;

export interface ListzonesnippetsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListzonesnippetsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListzonesnippetsResponse" }) as unknown as Schema.Schema<ListzonesnippetsResponse>;

export const listzonesnippets: (
  input: ListzonesnippetsRequest
) => Effect.Effect<
  ListzonesnippetsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListzonesnippetsRequest,
  output: ListzonesnippetsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListzonesnippetrulesRequest {
  zone_id: string;
}

export const ListzonesnippetrulesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/snippets/snippet_rules" }),
).annotations({ identifier: "ListzonesnippetrulesRequest" }) as unknown as Schema.Schema<ListzonesnippetrulesRequest>;

export interface ListzonesnippetrulesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListzonesnippetrulesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListzonesnippetrulesResponse" }) as unknown as Schema.Schema<ListzonesnippetrulesResponse>;

export const listzonesnippetrules: (
  input: ListzonesnippetrulesRequest
) => Effect.Effect<
  ListzonesnippetrulesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListzonesnippetrulesRequest,
  output: ListzonesnippetrulesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatezonesnippetrulesRequest {
  zone_id: string;
  body: { rules: { description?: string; enabled?: boolean; expression: string; id: string; last_updated: string; snippet_name: string }[] };
}

export const UpdatezonesnippetrulesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  rules: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  expression: Schema.String,
  id: Schema.String,
  last_updated: Schema.Date,
  snippet_name: Schema.String
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/snippets/snippet_rules" }),
).annotations({ identifier: "UpdatezonesnippetrulesRequest" }) as unknown as Schema.Schema<UpdatezonesnippetrulesRequest>;

export interface UpdatezonesnippetrulesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatezonesnippetrulesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatezonesnippetrulesResponse" }) as unknown as Schema.Schema<UpdatezonesnippetrulesResponse>;

export const updatezonesnippetrules: (
  input: UpdatezonesnippetrulesRequest
) => Effect.Effect<
  UpdatezonesnippetrulesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatezonesnippetrulesRequest,
  output: UpdatezonesnippetrulesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletezonesnippetrulesRequest {
  zone_id: string;
}

export const DeletezonesnippetrulesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/snippets/snippet_rules" }),
).annotations({ identifier: "DeletezonesnippetrulesRequest" }) as unknown as Schema.Schema<DeletezonesnippetrulesRequest>;

export interface DeletezonesnippetrulesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletezonesnippetrulesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletezonesnippetrulesResponse" }) as unknown as Schema.Schema<DeletezonesnippetrulesResponse>;

export const deletezonesnippetrules: (
  input: DeletezonesnippetrulesRequest
) => Effect.Effect<
  DeletezonesnippetrulesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletezonesnippetrulesRequest,
  output: DeletezonesnippetrulesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetzonesnippetRequest {
  zone_id: string;
  snippet_name: string;
}

export const GetzonesnippetRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  snippet_name: Schema.String.pipe(T.HttpPath("snippet_name"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/snippets/{snippet_name}" }),
).annotations({ identifier: "GetzonesnippetRequest" }) as unknown as Schema.Schema<GetzonesnippetRequest>;

export interface GetzonesnippetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetzonesnippetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetzonesnippetResponse" }) as unknown as Schema.Schema<GetzonesnippetResponse>;

export const getzonesnippet: (
  input: GetzonesnippetRequest
) => Effect.Effect<
  GetzonesnippetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetzonesnippetRequest,
  output: GetzonesnippetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatezonesnippetRequest {
  zone_id: string;
  snippet_name: string;
  body: FormData;
}

export const UpdatezonesnippetRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  snippet_name: Schema.String.pipe(T.HttpPath("snippet_name")),
  body: Schema.instanceOf(FormData).pipe(T.HttpFormData())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/snippets/{snippet_name}" }),
).annotations({ identifier: "UpdatezonesnippetRequest" }) as unknown as Schema.Schema<UpdatezonesnippetRequest>;

export interface UpdatezonesnippetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatezonesnippetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatezonesnippetResponse" }) as unknown as Schema.Schema<UpdatezonesnippetResponse>;

export const updatezonesnippet: (
  input: UpdatezonesnippetRequest
) => Effect.Effect<
  UpdatezonesnippetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatezonesnippetRequest,
  output: UpdatezonesnippetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletezonesnippetRequest {
  zone_id: string;
  snippet_name: string;
}

export const DeletezonesnippetRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  snippet_name: Schema.String.pipe(T.HttpPath("snippet_name"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/snippets/{snippet_name}" }),
).annotations({ identifier: "DeletezonesnippetRequest" }) as unknown as Schema.Schema<DeletezonesnippetRequest>;

export interface DeletezonesnippetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletezonesnippetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletezonesnippetResponse" }) as unknown as Schema.Schema<DeletezonesnippetResponse>;

export const deletezonesnippet: (
  input: DeletezonesnippetRequest
) => Effect.Effect<
  DeletezonesnippetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletezonesnippetRequest,
  output: DeletezonesnippetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetzonesnippetcontentRequest {
  zone_id: string;
  snippet_name: string;
}

export const GetzonesnippetcontentRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  snippet_name: Schema.String.pipe(T.HttpPath("snippet_name"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/snippets/{snippet_name}/content" }),
).annotations({ identifier: "GetzonesnippetcontentRequest" }) as unknown as Schema.Schema<GetzonesnippetcontentRequest>;

export interface GetzonesnippetcontentResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetzonesnippetcontentResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetzonesnippetcontentResponse" }) as unknown as Schema.Schema<GetzonesnippetcontentResponse>;

export const getzonesnippetcontent: (
  input: GetzonesnippetcontentRequest
) => Effect.Effect<
  GetzonesnippetcontentResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetzonesnippetcontentRequest,
  output: GetzonesnippetcontentResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetCurrentAggregatedAnalyticsRequest {
  zone_id: string;
  appID?: string;
  colo_name?: string;
}

export const GetCurrentAggregatedAnalyticsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  appID: Schema.optional(Schema.String).pipe(T.HttpQuery("appID")),
  colo_name: Schema.optional(Schema.String).pipe(T.HttpQuery("colo_name"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/spectrum/analytics/aggregate/current" }),
).annotations({ identifier: "GetCurrentAggregatedAnalyticsRequest" }) as unknown as Schema.Schema<GetCurrentAggregatedAnalyticsRequest>;

export interface GetCurrentAggregatedAnalyticsResponse {
  result: { appID: unknown; bytesEgress: number; bytesIngress: number; connections: number; durationAvg: number }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetCurrentAggregatedAnalyticsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  appID: Schema.Unknown,
  bytesEgress: Schema.Number,
  bytesIngress: Schema.Number,
  connections: Schema.Number,
  durationAvg: Schema.Number
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetCurrentAggregatedAnalyticsResponse" }) as unknown as Schema.Schema<GetCurrentAggregatedAnalyticsResponse>;

export const getCurrentAggregatedAnalytics: (
  input: GetCurrentAggregatedAnalyticsRequest
) => Effect.Effect<
  GetCurrentAggregatedAnalyticsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCurrentAggregatedAnalyticsRequest,
  output: GetCurrentAggregatedAnalyticsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAnalyticsByTimeRequest {
  zone_id: string;
  dimensions?: "event" | "appID" | "coloName" | "ipVersion"[];
  sort?: string[];
  until?: unknown;
  metrics?: "count" | "bytesIngress" | "bytesEgress" | "durationAvg" | "durationMedian" | "duration90th" | "duration99th"[];
  filters?: string;
  since?: unknown;
  time_delta: "year" | "quarter" | "month" | "week" | "day" | "hour" | "dekaminute" | "minute";
}

export const GetAnalyticsByTimeRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  dimensions: Schema.optional(Schema.Array(Schema.Literal("event", "appID", "coloName", "ipVersion"))).pipe(T.HttpQuery("dimensions")),
  sort: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("sort")),
  until: Schema.optional(Schema.Unknown).pipe(T.HttpQuery("until")),
  metrics: Schema.optional(Schema.Array(Schema.Literal("count", "bytesIngress", "bytesEgress", "durationAvg", "durationMedian", "duration90th", "duration99th"))).pipe(T.HttpQuery("metrics")),
  filters: Schema.optional(Schema.String).pipe(T.HttpQuery("filters")),
  since: Schema.optional(Schema.Unknown).pipe(T.HttpQuery("since")),
  time_delta: Schema.Literal("year", "quarter", "month", "week", "day", "hour", "dekaminute", "minute").pipe(T.HttpQuery("time_delta"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/spectrum/analytics/events/bytime" }),
).annotations({ identifier: "GetAnalyticsByTimeRequest" }) as unknown as Schema.Schema<GetAnalyticsByTimeRequest>;

export interface GetAnalyticsByTimeResponse {
  result: { data: { dimensions?: string[]; metrics?: unknown }[]; data_lag: number; max: unknown; min: unknown; query: { dimensions?: "event" | "appID" | "coloName" | "ipVersion"[]; filters?: string; limit?: number; metrics?: "count" | "bytesIngress" | "bytesEgress" | "durationAvg" | "durationMedian" | "duration90th" | "duration99th"[]; since?: unknown; sort?: string[]; until?: unknown }; rows: number; time_intervals?: string[][]; totals: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAnalyticsByTimeResponse = Schema.Struct({
  result: Schema.Struct({
  data: Schema.Array(Schema.Struct({
  dimensions: Schema.optional(Schema.Array(Schema.String)),
  metrics: Schema.optional(Schema.Union(Schema.Array(Schema.Number), Schema.Array(Schema.Array(Schema.Number))))
})),
  data_lag: Schema.Number,
  max: Schema.Unknown,
  min: Schema.Unknown,
  query: Schema.Struct({
  dimensions: Schema.optional(Schema.Array(Schema.Literal("event", "appID", "coloName", "ipVersion"))),
  filters: Schema.optional(Schema.String),
  limit: Schema.optional(Schema.Number),
  metrics: Schema.optional(Schema.Array(Schema.Literal("count", "bytesIngress", "bytesEgress", "durationAvg", "durationMedian", "duration90th", "duration99th"))),
  since: Schema.optional(Schema.Unknown),
  sort: Schema.optional(Schema.Array(Schema.String)),
  until: Schema.optional(Schema.Unknown)
}),
  rows: Schema.Number,
  time_intervals: Schema.optional(Schema.Array(Schema.Array(Schema.Date))),
  totals: Schema.Unknown
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAnalyticsByTimeResponse" }) as unknown as Schema.Schema<GetAnalyticsByTimeResponse>;

export const getAnalyticsByTime: (
  input: GetAnalyticsByTimeRequest
) => Effect.Effect<
  GetAnalyticsByTimeResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAnalyticsByTimeRequest,
  output: GetAnalyticsByTimeResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAnalyticsSummaryRequest {
  zone_id: string;
  dimensions?: "event" | "appID" | "coloName" | "ipVersion"[];
  sort?: string[];
  until?: unknown;
  metrics?: "count" | "bytesIngress" | "bytesEgress" | "durationAvg" | "durationMedian" | "duration90th" | "duration99th"[];
  filters?: string;
  since?: unknown;
}

export const GetAnalyticsSummaryRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  dimensions: Schema.optional(Schema.Array(Schema.Literal("event", "appID", "coloName", "ipVersion"))).pipe(T.HttpQuery("dimensions")),
  sort: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("sort")),
  until: Schema.optional(Schema.Unknown).pipe(T.HttpQuery("until")),
  metrics: Schema.optional(Schema.Array(Schema.Literal("count", "bytesIngress", "bytesEgress", "durationAvg", "durationMedian", "duration90th", "duration99th"))).pipe(T.HttpQuery("metrics")),
  filters: Schema.optional(Schema.String).pipe(T.HttpQuery("filters")),
  since: Schema.optional(Schema.Unknown).pipe(T.HttpQuery("since"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/spectrum/analytics/events/summary" }),
).annotations({ identifier: "GetAnalyticsSummaryRequest" }) as unknown as Schema.Schema<GetAnalyticsSummaryRequest>;

export interface GetAnalyticsSummaryResponse {
  result: { data: { dimensions?: string[]; metrics?: unknown }[]; data_lag: number; max: unknown; min: unknown; query: { dimensions?: "event" | "appID" | "coloName" | "ipVersion"[]; filters?: string; limit?: number; metrics?: "count" | "bytesIngress" | "bytesEgress" | "durationAvg" | "durationMedian" | "duration90th" | "duration99th"[]; since?: unknown; sort?: string[]; until?: unknown }; rows: number; time_intervals?: string[][]; totals: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAnalyticsSummaryResponse = Schema.Struct({
  result: Schema.Struct({
  data: Schema.Array(Schema.Struct({
  dimensions: Schema.optional(Schema.Array(Schema.String)),
  metrics: Schema.optional(Schema.Union(Schema.Array(Schema.Number), Schema.Array(Schema.Array(Schema.Number))))
})),
  data_lag: Schema.Number,
  max: Schema.Unknown,
  min: Schema.Unknown,
  query: Schema.Struct({
  dimensions: Schema.optional(Schema.Array(Schema.Literal("event", "appID", "coloName", "ipVersion"))),
  filters: Schema.optional(Schema.String),
  limit: Schema.optional(Schema.Number),
  metrics: Schema.optional(Schema.Array(Schema.Literal("count", "bytesIngress", "bytesEgress", "durationAvg", "durationMedian", "duration90th", "duration99th"))),
  since: Schema.optional(Schema.Unknown),
  sort: Schema.optional(Schema.Array(Schema.String)),
  until: Schema.optional(Schema.Unknown)
}),
  rows: Schema.Number,
  time_intervals: Schema.optional(Schema.Array(Schema.Array(Schema.Date))),
  totals: Schema.Unknown
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAnalyticsSummaryResponse" }) as unknown as Schema.Schema<GetAnalyticsSummaryResponse>;

export const getAnalyticsSummary: (
  input: GetAnalyticsSummaryRequest
) => Effect.Effect<
  GetAnalyticsSummaryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAnalyticsSummaryRequest,
  output: GetAnalyticsSummaryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListSpectrumApplicationsRequest {
  zone_id: unknown;
  page?: number;
  per_page?: number;
  direction?: "asc" | "desc";
  order?: "protocol" | "app_id" | "created_on" | "modified_on" | "dns";
}

export const ListSpectrumApplicationsRequest = Schema.Struct({
  zone_id: Schema.Unknown.pipe(T.HttpPath("zone_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction")),
  order: Schema.optional(Schema.Literal("protocol", "app_id", "created_on", "modified_on", "dns")).pipe(T.HttpQuery("order"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/spectrum/apps" }),
).annotations({ identifier: "ListSpectrumApplicationsRequest" }) as unknown as Schema.Schema<ListSpectrumApplicationsRequest>;

export interface ListSpectrumApplicationsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListSpectrumApplicationsResponse = Schema.Struct({
  result: Schema.Union(Schema.Array(Schema.Struct({
  argo_smart_routing: Schema.optional(Schema.Boolean),
  dns: Schema.Struct({
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("CNAME", "ADDRESS"))
}),
  edge_ips: Schema.optional(Schema.Union(Schema.Struct({
  connectivity: Schema.optional(Schema.Literal("all", "ipv4", "ipv6")),
  type: Schema.optional(Schema.Literal("dynamic"))
}), Schema.Struct({
  ips: Schema.optional(Schema.Array(Schema.String)),
  type: Schema.optional(Schema.Literal("static"))
}))),
  ip_firewall: Schema.optional(Schema.Boolean),
  origin_direct: Schema.optional(Schema.Array(Schema.String)),
  origin_dns: Schema.optional(Schema.Struct({
  name: Schema.optional(Schema.String),
  ttl: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("", "A", "AAAA", "SRV"))
})),
  origin_port: Schema.optional(Schema.Union(Schema.Number, Schema.String)),
  protocol: Schema.String,
  proxy_protocol: Schema.optional(Schema.Literal("off", "v1", "v2", "simple")),
  tls: Schema.optional(Schema.Literal("off", "flexible", "full", "strict")),
  traffic_type: Schema.Literal("direct", "http", "https")
})), Schema.Array(Schema.Struct({
  dns: Schema.Struct({
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("CNAME", "ADDRESS"))
}),
  origin_direct: Schema.optional(Schema.Array(Schema.String)),
  protocol: Schema.String
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListSpectrumApplicationsResponse" }) as unknown as Schema.Schema<ListSpectrumApplicationsResponse>;

export const listSpectrumApplications: (
  input: ListSpectrumApplicationsRequest
) => Effect.Effect<
  ListSpectrumApplicationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListSpectrumApplicationsRequest,
  output: ListSpectrumApplicationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateSpectrumApplicationUsingANameForTheOriginRequest {
  zone_id: unknown;
  body: unknown;
}

export const CreateSpectrumApplicationUsingANameForTheOriginRequest = Schema.Struct({
  zone_id: Schema.Unknown.pipe(T.HttpPath("zone_id")),
  body: Schema.Union(Schema.Struct({
  argo_smart_routing: Schema.optional(Schema.Boolean),
  dns: Schema.Struct({
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("CNAME", "ADDRESS"))
}),
  edge_ips: Schema.optional(Schema.Union(Schema.Struct({
  connectivity: Schema.optional(Schema.Literal("all", "ipv4", "ipv6")),
  type: Schema.optional(Schema.Literal("dynamic"))
}), Schema.Struct({
  ips: Schema.optional(Schema.Array(Schema.String)),
  type: Schema.optional(Schema.Literal("static"))
}))),
  ip_firewall: Schema.optional(Schema.Boolean),
  origin_direct: Schema.optional(Schema.Array(Schema.String)),
  origin_dns: Schema.optional(Schema.Struct({
  name: Schema.optional(Schema.String),
  ttl: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("", "A", "AAAA", "SRV"))
})),
  origin_port: Schema.optional(Schema.Union(Schema.Number, Schema.String)),
  protocol: Schema.String,
  proxy_protocol: Schema.optional(Schema.Literal("off", "v1", "v2", "simple")),
  tls: Schema.optional(Schema.Literal("off", "flexible", "full", "strict")),
  traffic_type: Schema.Literal("direct", "http", "https")
}), Schema.Struct({
  dns: Schema.Struct({
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("CNAME", "ADDRESS"))
}),
  origin_direct: Schema.optional(Schema.Array(Schema.String)),
  protocol: Schema.String
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/spectrum/apps" }),
).annotations({ identifier: "CreateSpectrumApplicationUsingANameForTheOriginRequest" }) as unknown as Schema.Schema<CreateSpectrumApplicationUsingANameForTheOriginRequest>;

export interface CreateSpectrumApplicationUsingANameForTheOriginResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateSpectrumApplicationUsingANameForTheOriginResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  argo_smart_routing: Schema.optional(Schema.Boolean),
  dns: Schema.Struct({
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("CNAME", "ADDRESS"))
}),
  edge_ips: Schema.optional(Schema.Union(Schema.Struct({
  connectivity: Schema.optional(Schema.Literal("all", "ipv4", "ipv6")),
  type: Schema.optional(Schema.Literal("dynamic"))
}), Schema.Struct({
  ips: Schema.optional(Schema.Array(Schema.String)),
  type: Schema.optional(Schema.Literal("static"))
}))),
  ip_firewall: Schema.optional(Schema.Boolean),
  origin_direct: Schema.optional(Schema.Array(Schema.String)),
  origin_dns: Schema.optional(Schema.Struct({
  name: Schema.optional(Schema.String),
  ttl: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("", "A", "AAAA", "SRV"))
})),
  origin_port: Schema.optional(Schema.Union(Schema.Number, Schema.String)),
  protocol: Schema.String,
  proxy_protocol: Schema.optional(Schema.Literal("off", "v1", "v2", "simple")),
  tls: Schema.optional(Schema.Literal("off", "flexible", "full", "strict")),
  traffic_type: Schema.Literal("direct", "http", "https")
}), Schema.Struct({
  dns: Schema.Struct({
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("CNAME", "ADDRESS"))
}),
  origin_direct: Schema.optional(Schema.Array(Schema.String)),
  protocol: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateSpectrumApplicationUsingANameForTheOriginResponse" }) as unknown as Schema.Schema<CreateSpectrumApplicationUsingANameForTheOriginResponse>;

export const createSpectrumApplicationUsingANameForTheOrigin: (
  input: CreateSpectrumApplicationUsingANameForTheOriginRequest
) => Effect.Effect<
  CreateSpectrumApplicationUsingANameForTheOriginResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateSpectrumApplicationUsingANameForTheOriginRequest,
  output: CreateSpectrumApplicationUsingANameForTheOriginResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSpectrumApplicationConfigurationRequest {
  app_id: unknown;
  zone_id: unknown;
}

export const GetSpectrumApplicationConfigurationRequest = Schema.Struct({
  app_id: Schema.Unknown.pipe(T.HttpPath("app_id")),
  zone_id: Schema.Unknown.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/spectrum/apps/{app_id}" }),
).annotations({ identifier: "GetSpectrumApplicationConfigurationRequest" }) as unknown as Schema.Schema<GetSpectrumApplicationConfigurationRequest>;

export interface GetSpectrumApplicationConfigurationResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSpectrumApplicationConfigurationResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  argo_smart_routing: Schema.optional(Schema.Boolean),
  dns: Schema.Struct({
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("CNAME", "ADDRESS"))
}),
  edge_ips: Schema.optional(Schema.Union(Schema.Struct({
  connectivity: Schema.optional(Schema.Literal("all", "ipv4", "ipv6")),
  type: Schema.optional(Schema.Literal("dynamic"))
}), Schema.Struct({
  ips: Schema.optional(Schema.Array(Schema.String)),
  type: Schema.optional(Schema.Literal("static"))
}))),
  ip_firewall: Schema.optional(Schema.Boolean),
  origin_direct: Schema.optional(Schema.Array(Schema.String)),
  origin_dns: Schema.optional(Schema.Struct({
  name: Schema.optional(Schema.String),
  ttl: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("", "A", "AAAA", "SRV"))
})),
  origin_port: Schema.optional(Schema.Union(Schema.Number, Schema.String)),
  protocol: Schema.String,
  proxy_protocol: Schema.optional(Schema.Literal("off", "v1", "v2", "simple")),
  tls: Schema.optional(Schema.Literal("off", "flexible", "full", "strict")),
  traffic_type: Schema.Literal("direct", "http", "https")
}), Schema.Struct({
  dns: Schema.Struct({
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("CNAME", "ADDRESS"))
}),
  origin_direct: Schema.optional(Schema.Array(Schema.String)),
  protocol: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSpectrumApplicationConfigurationResponse" }) as unknown as Schema.Schema<GetSpectrumApplicationConfigurationResponse>;

export const getSpectrumApplicationConfiguration: (
  input: GetSpectrumApplicationConfigurationRequest
) => Effect.Effect<
  GetSpectrumApplicationConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSpectrumApplicationConfigurationRequest,
  output: GetSpectrumApplicationConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateSpectrumApplicationConfigurationUsingANameForTheOriginRequest {
  app_id: unknown;
  zone_id: unknown;
  body: unknown;
}

export const UpdateSpectrumApplicationConfigurationUsingANameForTheOriginRequest = Schema.Struct({
  app_id: Schema.Unknown.pipe(T.HttpPath("app_id")),
  zone_id: Schema.Unknown.pipe(T.HttpPath("zone_id")),
  body: Schema.Union(Schema.Struct({
  argo_smart_routing: Schema.optional(Schema.Boolean),
  dns: Schema.Struct({
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("CNAME", "ADDRESS"))
}),
  edge_ips: Schema.optional(Schema.Union(Schema.Struct({
  connectivity: Schema.optional(Schema.Literal("all", "ipv4", "ipv6")),
  type: Schema.optional(Schema.Literal("dynamic"))
}), Schema.Struct({
  ips: Schema.optional(Schema.Array(Schema.String)),
  type: Schema.optional(Schema.Literal("static"))
}))),
  ip_firewall: Schema.optional(Schema.Boolean),
  origin_direct: Schema.optional(Schema.Array(Schema.String)),
  origin_dns: Schema.optional(Schema.Struct({
  name: Schema.optional(Schema.String),
  ttl: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("", "A", "AAAA", "SRV"))
})),
  origin_port: Schema.optional(Schema.Union(Schema.Number, Schema.String)),
  protocol: Schema.String,
  proxy_protocol: Schema.optional(Schema.Literal("off", "v1", "v2", "simple")),
  tls: Schema.optional(Schema.Literal("off", "flexible", "full", "strict")),
  traffic_type: Schema.Literal("direct", "http", "https")
}), Schema.Struct({
  dns: Schema.Struct({
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("CNAME", "ADDRESS"))
}),
  origin_direct: Schema.optional(Schema.Array(Schema.String)),
  protocol: Schema.String
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/spectrum/apps/{app_id}" }),
).annotations({ identifier: "UpdateSpectrumApplicationConfigurationUsingANameForTheOriginRequest" }) as unknown as Schema.Schema<UpdateSpectrumApplicationConfigurationUsingANameForTheOriginRequest>;

export interface UpdateSpectrumApplicationConfigurationUsingANameForTheOriginResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateSpectrumApplicationConfigurationUsingANameForTheOriginResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  argo_smart_routing: Schema.optional(Schema.Boolean),
  dns: Schema.Struct({
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("CNAME", "ADDRESS"))
}),
  edge_ips: Schema.optional(Schema.Union(Schema.Struct({
  connectivity: Schema.optional(Schema.Literal("all", "ipv4", "ipv6")),
  type: Schema.optional(Schema.Literal("dynamic"))
}), Schema.Struct({
  ips: Schema.optional(Schema.Array(Schema.String)),
  type: Schema.optional(Schema.Literal("static"))
}))),
  ip_firewall: Schema.optional(Schema.Boolean),
  origin_direct: Schema.optional(Schema.Array(Schema.String)),
  origin_dns: Schema.optional(Schema.Struct({
  name: Schema.optional(Schema.String),
  ttl: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("", "A", "AAAA", "SRV"))
})),
  origin_port: Schema.optional(Schema.Union(Schema.Number, Schema.String)),
  protocol: Schema.String,
  proxy_protocol: Schema.optional(Schema.Literal("off", "v1", "v2", "simple")),
  tls: Schema.optional(Schema.Literal("off", "flexible", "full", "strict")),
  traffic_type: Schema.Literal("direct", "http", "https")
}), Schema.Struct({
  dns: Schema.Struct({
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("CNAME", "ADDRESS"))
}),
  origin_direct: Schema.optional(Schema.Array(Schema.String)),
  protocol: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateSpectrumApplicationConfigurationUsingANameForTheOriginResponse" }) as unknown as Schema.Schema<UpdateSpectrumApplicationConfigurationUsingANameForTheOriginResponse>;

export const updateSpectrumApplicationConfigurationUsingANameForTheOrigin: (
  input: UpdateSpectrumApplicationConfigurationUsingANameForTheOriginRequest
) => Effect.Effect<
  UpdateSpectrumApplicationConfigurationUsingANameForTheOriginResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateSpectrumApplicationConfigurationUsingANameForTheOriginRequest,
  output: UpdateSpectrumApplicationConfigurationUsingANameForTheOriginResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteSpectrumApplicationRequest {
  app_id: unknown;
  zone_id: unknown;
}

export const DeleteSpectrumApplicationRequest = Schema.Struct({
  app_id: Schema.Unknown.pipe(T.HttpPath("app_id")),
  zone_id: Schema.Unknown.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/spectrum/apps/{app_id}" }),
).annotations({ identifier: "DeleteSpectrumApplicationRequest" }) as unknown as Schema.Schema<DeleteSpectrumApplicationRequest>;

export interface DeleteSpectrumApplicationResponse {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteSpectrumApplicationResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteSpectrumApplicationResponse" }) as unknown as Schema.Schema<DeleteSpectrumApplicationResponse>;

export const deleteSpectrumApplication: (
  input: DeleteSpectrumApplicationRequest
) => Effect.Effect<
  DeleteSpectrumApplicationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteSpectrumApplicationRequest,
  output: DeleteSpectrumApplicationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAvailabilitiesRequest {
  zone_id: string;
}

export const GetAvailabilitiesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/speed_api/availabilities" }),
).annotations({ identifier: "GetAvailabilitiesRequest" }) as unknown as Schema.Schema<GetAvailabilitiesRequest>;

export interface GetAvailabilitiesResponse {
  result: { quota?: { plan?: string; quotasPerPlan?: { value?: { business?: number; enterprise?: number; free?: number; pro?: number } }; remainingSchedules?: number; remainingTests?: number; scheduleQuotasPerPlan?: { value?: { business?: number; enterprise?: number; free?: number; pro?: number } } }; regions?: { label?: string; value?: "asia-east1" | "asia-northeast1" | "asia-northeast2" | "asia-south1" | "asia-southeast1" | "australia-southeast1" | "europe-north1" | "europe-southwest1" | "europe-west1" | "europe-west2" | "europe-west3" | "europe-west4" | "europe-west8" | "europe-west9" | "me-west1" | "southamerica-east1" | "us-central1" | "us-east1" | "us-east4" | "us-south1" | "us-west1" }[]; regionsPerPlan?: { business?: { label?: string; value?: "asia-east1" | "asia-northeast1" | "asia-northeast2" | "asia-south1" | "asia-southeast1" | "australia-southeast1" | "europe-north1" | "europe-southwest1" | "europe-west1" | "europe-west2" | "europe-west3" | "europe-west4" | "europe-west8" | "europe-west9" | "me-west1" | "southamerica-east1" | "us-central1" | "us-east1" | "us-east4" | "us-south1" | "us-west1" }[]; enterprise?: { label?: string; value?: "asia-east1" | "asia-northeast1" | "asia-northeast2" | "asia-south1" | "asia-southeast1" | "australia-southeast1" | "europe-north1" | "europe-southwest1" | "europe-west1" | "europe-west2" | "europe-west3" | "europe-west4" | "europe-west8" | "europe-west9" | "me-west1" | "southamerica-east1" | "us-central1" | "us-east1" | "us-east4" | "us-south1" | "us-west1" }[]; free?: { label?: string; value?: "asia-east1" | "asia-northeast1" | "asia-northeast2" | "asia-south1" | "asia-southeast1" | "australia-southeast1" | "europe-north1" | "europe-southwest1" | "europe-west1" | "europe-west2" | "europe-west3" | "europe-west4" | "europe-west8" | "europe-west9" | "me-west1" | "southamerica-east1" | "us-central1" | "us-east1" | "us-east4" | "us-south1" | "us-west1" }[]; pro?: { label?: string; value?: "asia-east1" | "asia-northeast1" | "asia-northeast2" | "asia-south1" | "asia-southeast1" | "australia-southeast1" | "europe-north1" | "europe-southwest1" | "europe-west1" | "europe-west2" | "europe-west3" | "europe-west4" | "europe-west8" | "europe-west9" | "me-west1" | "southamerica-east1" | "us-central1" | "us-east1" | "us-east4" | "us-south1" | "us-west1" }[] } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAvailabilitiesResponse = Schema.Struct({
  result: Schema.Struct({
  quota: Schema.optional(Schema.Struct({
  plan: Schema.optional(Schema.String),
  quotasPerPlan: Schema.optional(Schema.Struct({
  value: Schema.optional(Schema.Struct({
  business: Schema.optional(Schema.Number),
  enterprise: Schema.optional(Schema.Number),
  free: Schema.optional(Schema.Number),
  pro: Schema.optional(Schema.Number)
}))
})),
  remainingSchedules: Schema.optional(Schema.Number),
  remainingTests: Schema.optional(Schema.Number),
  scheduleQuotasPerPlan: Schema.optional(Schema.Struct({
  value: Schema.optional(Schema.Struct({
  business: Schema.optional(Schema.Number),
  enterprise: Schema.optional(Schema.Number),
  free: Schema.optional(Schema.Number),
  pro: Schema.optional(Schema.Number)
}))
}))
})),
  regions: Schema.optional(Schema.Array(Schema.Struct({
  label: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Literal("asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"))
}))),
  regionsPerPlan: Schema.optional(Schema.Struct({
  business: Schema.optional(Schema.Array(Schema.Struct({
  label: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Literal("asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"))
}))),
  enterprise: Schema.optional(Schema.Array(Schema.Struct({
  label: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Literal("asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"))
}))),
  free: Schema.optional(Schema.Array(Schema.Struct({
  label: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Literal("asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"))
}))),
  pro: Schema.optional(Schema.Array(Schema.Struct({
  label: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Literal("asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"))
})))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAvailabilitiesResponse" }) as unknown as Schema.Schema<GetAvailabilitiesResponse>;

export const getAvailabilities: (
  input: GetAvailabilitiesRequest
) => Effect.Effect<
  GetAvailabilitiesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAvailabilitiesRequest,
  output: GetAvailabilitiesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListPagesRequest {
  zone_id: string;
}

export const ListPagesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/speed_api/pages" }),
).annotations({ identifier: "ListPagesRequest" }) as unknown as Schema.Schema<ListPagesRequest>;

export interface ListPagesResponse {
  result: { region?: { label?: string; value?: "asia-east1" | "asia-northeast1" | "asia-northeast2" | "asia-south1" | "asia-southeast1" | "australia-southeast1" | "europe-north1" | "europe-southwest1" | "europe-west1" | "europe-west2" | "europe-west3" | "europe-west4" | "europe-west8" | "europe-west9" | "me-west1" | "southamerica-east1" | "us-central1" | "us-east1" | "us-east4" | "us-south1" | "us-west1" }; scheduleFrequency?: "DAILY" | "WEEKLY"; tests?: { date?: string; desktopReport?: { cls?: number; deviceType?: "DESKTOP" | "MOBILE"; error?: { code?: "NOT_REACHABLE" | "DNS_FAILURE" | "NOT_HTML" | "LIGHTHOUSE_TIMEOUT" | "UNKNOWN"; detail?: string; finalDisplayedUrl?: string }; fcp?: number; jsonReportUrl?: string; lcp?: number; performanceScore?: number; si?: number; state?: "RUNNING" | "COMPLETE" | "FAILED"; tbt?: number; ttfb?: number; tti?: number }; id?: string; mobileReport?: { cls?: number; deviceType?: "DESKTOP" | "MOBILE"; error?: { code?: "NOT_REACHABLE" | "DNS_FAILURE" | "NOT_HTML" | "LIGHTHOUSE_TIMEOUT" | "UNKNOWN"; detail?: string; finalDisplayedUrl?: string }; fcp?: number; jsonReportUrl?: string; lcp?: number; performanceScore?: number; si?: number; state?: "RUNNING" | "COMPLETE" | "FAILED"; tbt?: number; ttfb?: number; tti?: number }; region?: { label?: string; value?: "asia-east1" | "asia-northeast1" | "asia-northeast2" | "asia-south1" | "asia-southeast1" | "australia-southeast1" | "europe-north1" | "europe-southwest1" | "europe-west1" | "europe-west2" | "europe-west3" | "europe-west4" | "europe-west8" | "europe-west9" | "me-west1" | "southamerica-east1" | "us-central1" | "us-east1" | "us-east4" | "us-south1" | "us-west1" }; scheduleFrequency?: "DAILY" | "WEEKLY"; url?: string }[]; url?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListPagesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  region: Schema.optional(Schema.Struct({
  label: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Literal("asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"))
})),
  scheduleFrequency: Schema.optional(Schema.Literal("DAILY", "WEEKLY")),
  tests: Schema.optional(Schema.Array(Schema.Struct({
  date: Schema.optional(Schema.Date),
  desktopReport: Schema.optional(Schema.Struct({
  cls: Schema.optional(Schema.Number),
  deviceType: Schema.optional(Schema.Literal("DESKTOP", "MOBILE")),
  error: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.Literal("NOT_REACHABLE", "DNS_FAILURE", "NOT_HTML", "LIGHTHOUSE_TIMEOUT", "UNKNOWN")),
  detail: Schema.optional(Schema.String),
  finalDisplayedUrl: Schema.optional(Schema.String)
})),
  fcp: Schema.optional(Schema.Number),
  jsonReportUrl: Schema.optional(Schema.String),
  lcp: Schema.optional(Schema.Number),
  performanceScore: Schema.optional(Schema.Number),
  si: Schema.optional(Schema.Number),
  state: Schema.optional(Schema.Literal("RUNNING", "COMPLETE", "FAILED")),
  tbt: Schema.optional(Schema.Number),
  ttfb: Schema.optional(Schema.Number),
  tti: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  mobileReport: Schema.optional(Schema.Struct({
  cls: Schema.optional(Schema.Number),
  deviceType: Schema.optional(Schema.Literal("DESKTOP", "MOBILE")),
  error: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.Literal("NOT_REACHABLE", "DNS_FAILURE", "NOT_HTML", "LIGHTHOUSE_TIMEOUT", "UNKNOWN")),
  detail: Schema.optional(Schema.String),
  finalDisplayedUrl: Schema.optional(Schema.String)
})),
  fcp: Schema.optional(Schema.Number),
  jsonReportUrl: Schema.optional(Schema.String),
  lcp: Schema.optional(Schema.Number),
  performanceScore: Schema.optional(Schema.Number),
  si: Schema.optional(Schema.Number),
  state: Schema.optional(Schema.Literal("RUNNING", "COMPLETE", "FAILED")),
  tbt: Schema.optional(Schema.Number),
  ttfb: Schema.optional(Schema.Number),
  tti: Schema.optional(Schema.Number)
})),
  region: Schema.optional(Schema.Struct({
  label: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Literal("asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"))
})),
  scheduleFrequency: Schema.optional(Schema.Literal("DAILY", "WEEKLY")),
  url: Schema.optional(Schema.String)
}))),
  url: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListPagesResponse" }) as unknown as Schema.Schema<ListPagesResponse>;

export const listPages: (
  input: ListPagesRequest
) => Effect.Effect<
  ListPagesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListPagesRequest,
  output: ListPagesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListTestHistoryRequest {
  zone_id: string;
  url: string;
  page?: number;
  per_page?: number;
  region?: unknown;
}

export const ListTestHistoryRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  url: Schema.String.pipe(T.HttpPath("url")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  region: Schema.optional(Schema.String).pipe(T.HttpQuery("region"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/speed_api/pages/{url}/tests" }),
).annotations({ identifier: "ListTestHistoryRequest" }) as unknown as Schema.Schema<ListTestHistoryRequest>;

export interface ListTestHistoryResponse {
  result: { date?: string; desktopReport?: { cls?: number; deviceType?: "DESKTOP" | "MOBILE"; error?: { code?: "NOT_REACHABLE" | "DNS_FAILURE" | "NOT_HTML" | "LIGHTHOUSE_TIMEOUT" | "UNKNOWN"; detail?: string; finalDisplayedUrl?: string }; fcp?: number; jsonReportUrl?: string; lcp?: number; performanceScore?: number; si?: number; state?: "RUNNING" | "COMPLETE" | "FAILED"; tbt?: number; ttfb?: number; tti?: number }; id?: string; mobileReport?: { cls?: number; deviceType?: "DESKTOP" | "MOBILE"; error?: { code?: "NOT_REACHABLE" | "DNS_FAILURE" | "NOT_HTML" | "LIGHTHOUSE_TIMEOUT" | "UNKNOWN"; detail?: string; finalDisplayedUrl?: string }; fcp?: number; jsonReportUrl?: string; lcp?: number; performanceScore?: number; si?: number; state?: "RUNNING" | "COMPLETE" | "FAILED"; tbt?: number; ttfb?: number; tti?: number }; region?: { label?: string; value?: "asia-east1" | "asia-northeast1" | "asia-northeast2" | "asia-south1" | "asia-southeast1" | "australia-southeast1" | "europe-north1" | "europe-southwest1" | "europe-west1" | "europe-west2" | "europe-west3" | "europe-west4" | "europe-west8" | "europe-west9" | "me-west1" | "southamerica-east1" | "us-central1" | "us-east1" | "us-east4" | "us-south1" | "us-west1" }; scheduleFrequency?: "DAILY" | "WEEKLY"; url?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListTestHistoryResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  date: Schema.optional(Schema.Date),
  desktopReport: Schema.optional(Schema.Struct({
  cls: Schema.optional(Schema.Number),
  deviceType: Schema.optional(Schema.Literal("DESKTOP", "MOBILE")),
  error: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.Literal("NOT_REACHABLE", "DNS_FAILURE", "NOT_HTML", "LIGHTHOUSE_TIMEOUT", "UNKNOWN")),
  detail: Schema.optional(Schema.String),
  finalDisplayedUrl: Schema.optional(Schema.String)
})),
  fcp: Schema.optional(Schema.Number),
  jsonReportUrl: Schema.optional(Schema.String),
  lcp: Schema.optional(Schema.Number),
  performanceScore: Schema.optional(Schema.Number),
  si: Schema.optional(Schema.Number),
  state: Schema.optional(Schema.Literal("RUNNING", "COMPLETE", "FAILED")),
  tbt: Schema.optional(Schema.Number),
  ttfb: Schema.optional(Schema.Number),
  tti: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  mobileReport: Schema.optional(Schema.Struct({
  cls: Schema.optional(Schema.Number),
  deviceType: Schema.optional(Schema.Literal("DESKTOP", "MOBILE")),
  error: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.Literal("NOT_REACHABLE", "DNS_FAILURE", "NOT_HTML", "LIGHTHOUSE_TIMEOUT", "UNKNOWN")),
  detail: Schema.optional(Schema.String),
  finalDisplayedUrl: Schema.optional(Schema.String)
})),
  fcp: Schema.optional(Schema.Number),
  jsonReportUrl: Schema.optional(Schema.String),
  lcp: Schema.optional(Schema.Number),
  performanceScore: Schema.optional(Schema.Number),
  si: Schema.optional(Schema.Number),
  state: Schema.optional(Schema.Literal("RUNNING", "COMPLETE", "FAILED")),
  tbt: Schema.optional(Schema.Number),
  ttfb: Schema.optional(Schema.Number),
  tti: Schema.optional(Schema.Number)
})),
  region: Schema.optional(Schema.Struct({
  label: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Literal("asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"))
})),
  scheduleFrequency: Schema.optional(Schema.Literal("DAILY", "WEEKLY")),
  url: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListTestHistoryResponse" }) as unknown as Schema.Schema<ListTestHistoryResponse>;

export const listTestHistory: (
  input: ListTestHistoryRequest
) => Effect.Effect<
  ListTestHistoryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListTestHistoryRequest,
  output: ListTestHistoryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateTestRequest {
  zone_id: string;
  url: string;
  body: { region?: unknown };
}

export const CreateTestRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  url: Schema.String.pipe(T.HttpPath("url")),
  body: Schema.Struct({
  region: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/speed_api/pages/{url}/tests" }),
).annotations({ identifier: "CreateTestRequest" }) as unknown as Schema.Schema<CreateTestRequest>;

export interface CreateTestResponse {
  result: { date?: string; desktopReport?: { cls?: number; deviceType?: "DESKTOP" | "MOBILE"; error?: { code?: "NOT_REACHABLE" | "DNS_FAILURE" | "NOT_HTML" | "LIGHTHOUSE_TIMEOUT" | "UNKNOWN"; detail?: string; finalDisplayedUrl?: string }; fcp?: number; jsonReportUrl?: string; lcp?: number; performanceScore?: number; si?: number; state?: "RUNNING" | "COMPLETE" | "FAILED"; tbt?: number; ttfb?: number; tti?: number }; id?: string; mobileReport?: { cls?: number; deviceType?: "DESKTOP" | "MOBILE"; error?: { code?: "NOT_REACHABLE" | "DNS_FAILURE" | "NOT_HTML" | "LIGHTHOUSE_TIMEOUT" | "UNKNOWN"; detail?: string; finalDisplayedUrl?: string }; fcp?: number; jsonReportUrl?: string; lcp?: number; performanceScore?: number; si?: number; state?: "RUNNING" | "COMPLETE" | "FAILED"; tbt?: number; ttfb?: number; tti?: number }; region?: { label?: string; value?: "asia-east1" | "asia-northeast1" | "asia-northeast2" | "asia-south1" | "asia-southeast1" | "australia-southeast1" | "europe-north1" | "europe-southwest1" | "europe-west1" | "europe-west2" | "europe-west3" | "europe-west4" | "europe-west8" | "europe-west9" | "me-west1" | "southamerica-east1" | "us-central1" | "us-east1" | "us-east4" | "us-south1" | "us-west1" }; scheduleFrequency?: "DAILY" | "WEEKLY"; url?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateTestResponse = Schema.Struct({
  result: Schema.Struct({
  date: Schema.optional(Schema.Date),
  desktopReport: Schema.optional(Schema.Struct({
  cls: Schema.optional(Schema.Number),
  deviceType: Schema.optional(Schema.Literal("DESKTOP", "MOBILE")),
  error: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.Literal("NOT_REACHABLE", "DNS_FAILURE", "NOT_HTML", "LIGHTHOUSE_TIMEOUT", "UNKNOWN")),
  detail: Schema.optional(Schema.String),
  finalDisplayedUrl: Schema.optional(Schema.String)
})),
  fcp: Schema.optional(Schema.Number),
  jsonReportUrl: Schema.optional(Schema.String),
  lcp: Schema.optional(Schema.Number),
  performanceScore: Schema.optional(Schema.Number),
  si: Schema.optional(Schema.Number),
  state: Schema.optional(Schema.Literal("RUNNING", "COMPLETE", "FAILED")),
  tbt: Schema.optional(Schema.Number),
  ttfb: Schema.optional(Schema.Number),
  tti: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  mobileReport: Schema.optional(Schema.Struct({
  cls: Schema.optional(Schema.Number),
  deviceType: Schema.optional(Schema.Literal("DESKTOP", "MOBILE")),
  error: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.Literal("NOT_REACHABLE", "DNS_FAILURE", "NOT_HTML", "LIGHTHOUSE_TIMEOUT", "UNKNOWN")),
  detail: Schema.optional(Schema.String),
  finalDisplayedUrl: Schema.optional(Schema.String)
})),
  fcp: Schema.optional(Schema.Number),
  jsonReportUrl: Schema.optional(Schema.String),
  lcp: Schema.optional(Schema.Number),
  performanceScore: Schema.optional(Schema.Number),
  si: Schema.optional(Schema.Number),
  state: Schema.optional(Schema.Literal("RUNNING", "COMPLETE", "FAILED")),
  tbt: Schema.optional(Schema.Number),
  ttfb: Schema.optional(Schema.Number),
  tti: Schema.optional(Schema.Number)
})),
  region: Schema.optional(Schema.Struct({
  label: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Literal("asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"))
})),
  scheduleFrequency: Schema.optional(Schema.Literal("DAILY", "WEEKLY")),
  url: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateTestResponse" }) as unknown as Schema.Schema<CreateTestResponse>;

export const createTest: (
  input: CreateTestRequest
) => Effect.Effect<
  CreateTestResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateTestRequest,
  output: CreateTestResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteTestsRequest {
  zone_id: string;
  url: string;
  region?: unknown;
}

export const DeleteTestsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  url: Schema.String.pipe(T.HttpPath("url")),
  region: Schema.optional(Schema.String).pipe(T.HttpQuery("region"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/speed_api/pages/{url}/tests" }),
).annotations({ identifier: "DeleteTestsRequest" }) as unknown as Schema.Schema<DeleteTestsRequest>;

export interface DeleteTestsResponse {
  result: { count?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteTestsResponse = Schema.Struct({
  result: Schema.Struct({
  count: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteTestsResponse" }) as unknown as Schema.Schema<DeleteTestsResponse>;

export const deleteTests: (
  input: DeleteTestsRequest
) => Effect.Effect<
  DeleteTestsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteTestsRequest,
  output: DeleteTestsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetTestRequest {
  zone_id: string;
  url: string;
  test_id: string;
}

export const GetTestRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  url: Schema.String.pipe(T.HttpPath("url")),
  test_id: Schema.String.pipe(T.HttpPath("test_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/speed_api/pages/{url}/tests/{test_id}" }),
).annotations({ identifier: "GetTestRequest" }) as unknown as Schema.Schema<GetTestRequest>;

export interface GetTestResponse {
  result: { date?: string; desktopReport?: { cls?: number; deviceType?: "DESKTOP" | "MOBILE"; error?: { code?: "NOT_REACHABLE" | "DNS_FAILURE" | "NOT_HTML" | "LIGHTHOUSE_TIMEOUT" | "UNKNOWN"; detail?: string; finalDisplayedUrl?: string }; fcp?: number; jsonReportUrl?: string; lcp?: number; performanceScore?: number; si?: number; state?: "RUNNING" | "COMPLETE" | "FAILED"; tbt?: number; ttfb?: number; tti?: number }; id?: string; mobileReport?: { cls?: number; deviceType?: "DESKTOP" | "MOBILE"; error?: { code?: "NOT_REACHABLE" | "DNS_FAILURE" | "NOT_HTML" | "LIGHTHOUSE_TIMEOUT" | "UNKNOWN"; detail?: string; finalDisplayedUrl?: string }; fcp?: number; jsonReportUrl?: string; lcp?: number; performanceScore?: number; si?: number; state?: "RUNNING" | "COMPLETE" | "FAILED"; tbt?: number; ttfb?: number; tti?: number }; region?: { label?: string; value?: "asia-east1" | "asia-northeast1" | "asia-northeast2" | "asia-south1" | "asia-southeast1" | "australia-southeast1" | "europe-north1" | "europe-southwest1" | "europe-west1" | "europe-west2" | "europe-west3" | "europe-west4" | "europe-west8" | "europe-west9" | "me-west1" | "southamerica-east1" | "us-central1" | "us-east1" | "us-east4" | "us-south1" | "us-west1" }; scheduleFrequency?: "DAILY" | "WEEKLY"; url?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetTestResponse = Schema.Struct({
  result: Schema.Struct({
  date: Schema.optional(Schema.Date),
  desktopReport: Schema.optional(Schema.Struct({
  cls: Schema.optional(Schema.Number),
  deviceType: Schema.optional(Schema.Literal("DESKTOP", "MOBILE")),
  error: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.Literal("NOT_REACHABLE", "DNS_FAILURE", "NOT_HTML", "LIGHTHOUSE_TIMEOUT", "UNKNOWN")),
  detail: Schema.optional(Schema.String),
  finalDisplayedUrl: Schema.optional(Schema.String)
})),
  fcp: Schema.optional(Schema.Number),
  jsonReportUrl: Schema.optional(Schema.String),
  lcp: Schema.optional(Schema.Number),
  performanceScore: Schema.optional(Schema.Number),
  si: Schema.optional(Schema.Number),
  state: Schema.optional(Schema.Literal("RUNNING", "COMPLETE", "FAILED")),
  tbt: Schema.optional(Schema.Number),
  ttfb: Schema.optional(Schema.Number),
  tti: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  mobileReport: Schema.optional(Schema.Struct({
  cls: Schema.optional(Schema.Number),
  deviceType: Schema.optional(Schema.Literal("DESKTOP", "MOBILE")),
  error: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.Literal("NOT_REACHABLE", "DNS_FAILURE", "NOT_HTML", "LIGHTHOUSE_TIMEOUT", "UNKNOWN")),
  detail: Schema.optional(Schema.String),
  finalDisplayedUrl: Schema.optional(Schema.String)
})),
  fcp: Schema.optional(Schema.Number),
  jsonReportUrl: Schema.optional(Schema.String),
  lcp: Schema.optional(Schema.Number),
  performanceScore: Schema.optional(Schema.Number),
  si: Schema.optional(Schema.Number),
  state: Schema.optional(Schema.Literal("RUNNING", "COMPLETE", "FAILED")),
  tbt: Schema.optional(Schema.Number),
  ttfb: Schema.optional(Schema.Number),
  tti: Schema.optional(Schema.Number)
})),
  region: Schema.optional(Schema.Struct({
  label: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Literal("asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"))
})),
  scheduleFrequency: Schema.optional(Schema.Literal("DAILY", "WEEKLY")),
  url: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetTestResponse" }) as unknown as Schema.Schema<GetTestResponse>;

export const getTest: (
  input: GetTestRequest
) => Effect.Effect<
  GetTestResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTestRequest,
  output: GetTestResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListPageTrendRequest {
  zone_id: string;
  url: string;
  region: "asia-east1" | "asia-northeast1" | "asia-northeast2" | "asia-south1" | "asia-southeast1" | "australia-southeast1" | "europe-north1" | "europe-southwest1" | "europe-west1" | "europe-west2" | "europe-west3" | "europe-west4" | "europe-west8" | "europe-west9" | "me-west1" | "southamerica-east1" | "us-central1" | "us-east1" | "us-east4" | "us-south1" | "us-west1";
  deviceType: "DESKTOP" | "MOBILE";
  start: string;
  end?: string;
  tz: string;
  metrics: string;
}

export const ListPageTrendRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  url: Schema.String.pipe(T.HttpPath("url")),
  region: Schema.Literal("asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1").pipe(T.HttpQuery("region")),
  deviceType: Schema.Literal("DESKTOP", "MOBILE").pipe(T.HttpQuery("deviceType")),
  start: Schema.Date.pipe(T.HttpQuery("start")),
  end: Schema.optional(Schema.Date).pipe(T.HttpQuery("end")),
  tz: Schema.String.pipe(T.HttpQuery("tz")),
  metrics: Schema.String.pipe(T.HttpQuery("metrics"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/speed_api/pages/{url}/trend" }),
).annotations({ identifier: "ListPageTrendRequest" }) as unknown as Schema.Schema<ListPageTrendRequest>;

export interface ListPageTrendResponse {
  result: { cls?: number[]; fcp?: number[]; lcp?: number[]; performanceScore?: number[]; si?: number[]; tbt?: number[]; ttfb?: number[]; tti?: number[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListPageTrendResponse = Schema.Struct({
  result: Schema.Struct({
  cls: Schema.optional(Schema.Array(Schema.Number)),
  fcp: Schema.optional(Schema.Array(Schema.Number)),
  lcp: Schema.optional(Schema.Array(Schema.Number)),
  performanceScore: Schema.optional(Schema.Array(Schema.Number)),
  si: Schema.optional(Schema.Array(Schema.Number)),
  tbt: Schema.optional(Schema.Array(Schema.Number)),
  ttfb: Schema.optional(Schema.Array(Schema.Number)),
  tti: Schema.optional(Schema.Array(Schema.Number))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListPageTrendResponse" }) as unknown as Schema.Schema<ListPageTrendResponse>;

export const listPageTrend: (
  input: ListPageTrendRequest
) => Effect.Effect<
  ListPageTrendResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListPageTrendRequest,
  output: ListPageTrendResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetScheduledTestRequest {
  zone_id: string;
  url: string;
  region?: unknown;
}

export const GetScheduledTestRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  url: Schema.String.pipe(T.HttpPath("url")),
  region: Schema.optional(Schema.String).pipe(T.HttpQuery("region"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/speed_api/schedule/{url}" }),
).annotations({ identifier: "GetScheduledTestRequest" }) as unknown as Schema.Schema<GetScheduledTestRequest>;

export interface GetScheduledTestResponse {
  result: { frequency?: "DAILY" | "WEEKLY"; region?: "asia-east1" | "asia-northeast1" | "asia-northeast2" | "asia-south1" | "asia-southeast1" | "australia-southeast1" | "europe-north1" | "europe-southwest1" | "europe-west1" | "europe-west2" | "europe-west3" | "europe-west4" | "europe-west8" | "europe-west9" | "me-west1" | "southamerica-east1" | "us-central1" | "us-east1" | "us-east4" | "us-south1" | "us-west1"; url?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetScheduledTestResponse = Schema.Struct({
  result: Schema.Struct({
  frequency: Schema.optional(Schema.Literal("DAILY", "WEEKLY")),
  region: Schema.optional(Schema.Literal("asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1")),
  url: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetScheduledTestResponse" }) as unknown as Schema.Schema<GetScheduledTestResponse>;

export const getScheduledTest: (
  input: GetScheduledTestRequest
) => Effect.Effect<
  GetScheduledTestResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetScheduledTestRequest,
  output: GetScheduledTestResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateScheduledTestRequest {
  zone_id: string;
  url: string;
  region?: unknown;
}

export const CreateScheduledTestRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  url: Schema.String.pipe(T.HttpPath("url")),
  region: Schema.optional(Schema.String).pipe(T.HttpQuery("region"))
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/speed_api/schedule/{url}" }),
).annotations({ identifier: "CreateScheduledTestRequest" }) as unknown as Schema.Schema<CreateScheduledTestRequest>;

export interface CreateScheduledTestResponse {
  result: { schedule?: { frequency?: "DAILY" | "WEEKLY"; region?: "asia-east1" | "asia-northeast1" | "asia-northeast2" | "asia-south1" | "asia-southeast1" | "australia-southeast1" | "europe-north1" | "europe-southwest1" | "europe-west1" | "europe-west2" | "europe-west3" | "europe-west4" | "europe-west8" | "europe-west9" | "me-west1" | "southamerica-east1" | "us-central1" | "us-east1" | "us-east4" | "us-south1" | "us-west1"; url?: string }; test?: { date?: string; desktopReport?: { cls?: number; deviceType?: "DESKTOP" | "MOBILE"; error?: { code?: "NOT_REACHABLE" | "DNS_FAILURE" | "NOT_HTML" | "LIGHTHOUSE_TIMEOUT" | "UNKNOWN"; detail?: string; finalDisplayedUrl?: string }; fcp?: number; jsonReportUrl?: string; lcp?: number; performanceScore?: number; si?: number; state?: "RUNNING" | "COMPLETE" | "FAILED"; tbt?: number; ttfb?: number; tti?: number }; id?: string; mobileReport?: { cls?: number; deviceType?: "DESKTOP" | "MOBILE"; error?: { code?: "NOT_REACHABLE" | "DNS_FAILURE" | "NOT_HTML" | "LIGHTHOUSE_TIMEOUT" | "UNKNOWN"; detail?: string; finalDisplayedUrl?: string }; fcp?: number; jsonReportUrl?: string; lcp?: number; performanceScore?: number; si?: number; state?: "RUNNING" | "COMPLETE" | "FAILED"; tbt?: number; ttfb?: number; tti?: number }; region?: { label?: string; value?: "asia-east1" | "asia-northeast1" | "asia-northeast2" | "asia-south1" | "asia-southeast1" | "australia-southeast1" | "europe-north1" | "europe-southwest1" | "europe-west1" | "europe-west2" | "europe-west3" | "europe-west4" | "europe-west8" | "europe-west9" | "me-west1" | "southamerica-east1" | "us-central1" | "us-east1" | "us-east4" | "us-south1" | "us-west1" }; scheduleFrequency?: "DAILY" | "WEEKLY"; url?: string } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateScheduledTestResponse = Schema.Struct({
  result: Schema.Struct({
  schedule: Schema.optional(Schema.Struct({
  frequency: Schema.optional(Schema.Literal("DAILY", "WEEKLY")),
  region: Schema.optional(Schema.Literal("asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1")),
  url: Schema.optional(Schema.String)
})),
  test: Schema.optional(Schema.Struct({
  date: Schema.optional(Schema.Date),
  desktopReport: Schema.optional(Schema.Struct({
  cls: Schema.optional(Schema.Number),
  deviceType: Schema.optional(Schema.Literal("DESKTOP", "MOBILE")),
  error: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.Literal("NOT_REACHABLE", "DNS_FAILURE", "NOT_HTML", "LIGHTHOUSE_TIMEOUT", "UNKNOWN")),
  detail: Schema.optional(Schema.String),
  finalDisplayedUrl: Schema.optional(Schema.String)
})),
  fcp: Schema.optional(Schema.Number),
  jsonReportUrl: Schema.optional(Schema.String),
  lcp: Schema.optional(Schema.Number),
  performanceScore: Schema.optional(Schema.Number),
  si: Schema.optional(Schema.Number),
  state: Schema.optional(Schema.Literal("RUNNING", "COMPLETE", "FAILED")),
  tbt: Schema.optional(Schema.Number),
  ttfb: Schema.optional(Schema.Number),
  tti: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  mobileReport: Schema.optional(Schema.Struct({
  cls: Schema.optional(Schema.Number),
  deviceType: Schema.optional(Schema.Literal("DESKTOP", "MOBILE")),
  error: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.Literal("NOT_REACHABLE", "DNS_FAILURE", "NOT_HTML", "LIGHTHOUSE_TIMEOUT", "UNKNOWN")),
  detail: Schema.optional(Schema.String),
  finalDisplayedUrl: Schema.optional(Schema.String)
})),
  fcp: Schema.optional(Schema.Number),
  jsonReportUrl: Schema.optional(Schema.String),
  lcp: Schema.optional(Schema.Number),
  performanceScore: Schema.optional(Schema.Number),
  si: Schema.optional(Schema.Number),
  state: Schema.optional(Schema.Literal("RUNNING", "COMPLETE", "FAILED")),
  tbt: Schema.optional(Schema.Number),
  ttfb: Schema.optional(Schema.Number),
  tti: Schema.optional(Schema.Number)
})),
  region: Schema.optional(Schema.Struct({
  label: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Literal("asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"))
})),
  scheduleFrequency: Schema.optional(Schema.Literal("DAILY", "WEEKLY")),
  url: Schema.optional(Schema.String)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateScheduledTestResponse" }) as unknown as Schema.Schema<CreateScheduledTestResponse>;

export const createScheduledTest: (
  input: CreateScheduledTestRequest
) => Effect.Effect<
  CreateScheduledTestResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateScheduledTestRequest,
  output: CreateScheduledTestResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteTestScheduleRequest {
  zone_id: string;
  url: string;
  region?: unknown;
}

export const DeleteTestScheduleRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  url: Schema.String.pipe(T.HttpPath("url")),
  region: Schema.optional(Schema.String).pipe(T.HttpQuery("region"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/speed_api/schedule/{url}" }),
).annotations({ identifier: "DeleteTestScheduleRequest" }) as unknown as Schema.Schema<DeleteTestScheduleRequest>;

export interface DeleteTestScheduleResponse {
  result: { count?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteTestScheduleResponse = Schema.Struct({
  result: Schema.Struct({
  count: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteTestScheduleResponse" }) as unknown as Schema.Schema<DeleteTestScheduleResponse>;

export const deleteTestSchedule: (
  input: DeleteTestScheduleRequest
) => Effect.Effect<
  DeleteTestScheduleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteTestScheduleRequest,
  output: DeleteTestScheduleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZoneSubscriptionZoneSubscriptionDetailsRequest {
  zone_id: string;
}

export const ZoneSubscriptionZoneSubscriptionDetailsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/subscription" }),
).annotations({ identifier: "ZoneSubscriptionZoneSubscriptionDetailsRequest" }) as unknown as Schema.Schema<ZoneSubscriptionZoneSubscriptionDetailsRequest>;

export interface ZoneSubscriptionZoneSubscriptionDetailsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZoneSubscriptionZoneSubscriptionDetailsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZoneSubscriptionZoneSubscriptionDetailsResponse" }) as unknown as Schema.Schema<ZoneSubscriptionZoneSubscriptionDetailsResponse>;

export const zoneSubscriptionZoneSubscriptionDetails: (
  input: ZoneSubscriptionZoneSubscriptionDetailsRequest
) => Effect.Effect<
  ZoneSubscriptionZoneSubscriptionDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZoneSubscriptionZoneSubscriptionDetailsRequest,
  output: ZoneSubscriptionZoneSubscriptionDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateZoneSubscriptionRequest {
  zone_id: string;
  body: { app?: unknown; component_values?: { default?: number; name?: string; price?: number; value?: number }[]; currency?: string; current_period_end?: string; current_period_start?: string; frequency?: "weekly" | "monthly" | "quarterly" | "yearly"; id?: string; price?: number; rate_plan?: { currency?: string; externally_managed?: boolean; id?: string; is_contract?: boolean; public_name?: string; scope?: string; sets?: string[] }; state?: "Trial" | "Provisioned" | "Paid" | "AwaitingPayment" | "Cancelled" | "Failed" | "Expired"; zone?: { id?: string; name?: string } };
}

export const CreateZoneSubscriptionRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  app: Schema.optional(Schema.Unknown),
  component_values: Schema.optional(Schema.Array(Schema.Struct({
  default: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  price: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.Number)
}))),
  currency: Schema.optional(Schema.String),
  current_period_end: Schema.optional(Schema.Date),
  current_period_start: Schema.optional(Schema.Date),
  frequency: Schema.optional(Schema.Literal("weekly", "monthly", "quarterly", "yearly")),
  id: Schema.optional(Schema.String),
  price: Schema.optional(Schema.Number),
  rate_plan: Schema.optional(Schema.Struct({
  currency: Schema.optional(Schema.String),
  externally_managed: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  is_contract: Schema.optional(Schema.Boolean),
  public_name: Schema.optional(Schema.String),
  scope: Schema.optional(Schema.String),
  sets: Schema.optional(Schema.Array(Schema.String))
})),
  state: Schema.optional(Schema.Literal("Trial", "Provisioned", "Paid", "AwaitingPayment", "Cancelled", "Failed", "Expired")),
  zone: Schema.optional(Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/subscription" }),
).annotations({ identifier: "CreateZoneSubscriptionRequest" }) as unknown as Schema.Schema<CreateZoneSubscriptionRequest>;

export interface CreateZoneSubscriptionResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateZoneSubscriptionResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateZoneSubscriptionResponse" }) as unknown as Schema.Schema<CreateZoneSubscriptionResponse>;

export const createZoneSubscription: (
  input: CreateZoneSubscriptionRequest
) => Effect.Effect<
  CreateZoneSubscriptionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateZoneSubscriptionRequest,
  output: CreateZoneSubscriptionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateZoneSubscriptionRequest {
  zone_id: string;
  body: { app?: unknown; component_values?: { default?: number; name?: string; price?: number; value?: number }[]; currency?: string; current_period_end?: string; current_period_start?: string; frequency?: "weekly" | "monthly" | "quarterly" | "yearly"; id?: string; price?: number; rate_plan?: { currency?: string; externally_managed?: boolean; id?: string; is_contract?: boolean; public_name?: string; scope?: string; sets?: string[] }; state?: "Trial" | "Provisioned" | "Paid" | "AwaitingPayment" | "Cancelled" | "Failed" | "Expired"; zone?: { id?: string; name?: string } };
}

export const UpdateZoneSubscriptionRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  app: Schema.optional(Schema.Unknown),
  component_values: Schema.optional(Schema.Array(Schema.Struct({
  default: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  price: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.Number)
}))),
  currency: Schema.optional(Schema.String),
  current_period_end: Schema.optional(Schema.Date),
  current_period_start: Schema.optional(Schema.Date),
  frequency: Schema.optional(Schema.Literal("weekly", "monthly", "quarterly", "yearly")),
  id: Schema.optional(Schema.String),
  price: Schema.optional(Schema.Number),
  rate_plan: Schema.optional(Schema.Struct({
  currency: Schema.optional(Schema.String),
  externally_managed: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  is_contract: Schema.optional(Schema.Boolean),
  public_name: Schema.optional(Schema.String),
  scope: Schema.optional(Schema.String),
  sets: Schema.optional(Schema.Array(Schema.String))
})),
  state: Schema.optional(Schema.Literal("Trial", "Provisioned", "Paid", "AwaitingPayment", "Cancelled", "Failed", "Expired")),
  zone: Schema.optional(Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/subscription" }),
).annotations({ identifier: "UpdateZoneSubscriptionRequest" }) as unknown as Schema.Schema<UpdateZoneSubscriptionRequest>;

export interface UpdateZoneSubscriptionResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateZoneSubscriptionResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateZoneSubscriptionResponse" }) as unknown as Schema.Schema<UpdateZoneSubscriptionResponse>;

export const updateZoneSubscription: (
  input: UpdateZoneSubscriptionRequest
) => Effect.Effect<
  UpdateZoneSubscriptionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateZoneSubscriptionRequest,
  output: UpdateZoneSubscriptionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List2Request {
}

export const List2Request = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/token_validation/config" }),
).annotations({ identifier: "List2Request" }) as unknown as Schema.Schema<List2Request>;

export interface List2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List2Response" }) as unknown as Schema.Schema<List2Response>;

export const list2: (
  input: List2Request
) => Effect.Effect<
  List2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List2Request,
  output: List2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create2Request {
  body: { credentials: { keys: Record<string, unknown>[] }; description: string; title: string; token_sources: unknown[]; token_type: "JWT" };
}

export const Create2Request = Schema.Struct({
  body: Schema.Struct({
  credentials: Schema.Struct({
  keys: Schema.Array(Schema.Struct({}))
}),
  description: Schema.String,
  title: Schema.String,
  token_sources: Schema.Array(Schema.Union(Schema.String, Schema.String)),
  token_type: Schema.Literal("JWT")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/token_validation/config" }),
).annotations({ identifier: "Create2Request" }) as unknown as Schema.Schema<Create2Request>;

export interface Create2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create2Response" }) as unknown as Schema.Schema<Create2Response>;

export const create2: (
  input: Create2Request
) => Effect.Effect<
  Create2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create2Request,
  output: Create2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_5Request {
}

export const Get_5Request = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/token_validation/config/{config_id}" }),
).annotations({ identifier: "Get_5Request" }) as unknown as Schema.Schema<Get_5Request>;

export interface Get_5Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_5Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_5Response" }) as unknown as Schema.Schema<Get_5Response>;

export const get_5: (
  input: Get_5Request
) => Effect.Effect<
  Get_5Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_5Request,
  output: Get_5Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_4Request {
}

export const Delete_4Request = Schema.Struct({

}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/token_validation/config/{config_id}" }),
).annotations({ identifier: "Delete_4Request" }) as unknown as Schema.Schema<Delete_4Request>;

export interface Delete_4Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_4Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_4Response" }) as unknown as Schema.Schema<Delete_4Response>;

export const delete_4: (
  input: Delete_4Request
) => Effect.Effect<
  Delete_4Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_4Request,
  output: Delete_4Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface TokenValidationConfigEditRequest {
  body: { description?: string; title?: string; token_sources?: unknown[] };
}

export const TokenValidationConfigEditRequest = Schema.Struct({
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  title: Schema.optional(Schema.String),
  token_sources: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/token_validation/config/{config_id}" }),
).annotations({ identifier: "TokenValidationConfigEditRequest" }) as unknown as Schema.Schema<TokenValidationConfigEditRequest>;

export interface TokenValidationConfigEditResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const TokenValidationConfigEditResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "TokenValidationConfigEditResponse" }) as unknown as Schema.Schema<TokenValidationConfigEditResponse>;

export const tokenValidationConfigEdit: (
  input: TokenValidationConfigEditRequest
) => Effect.Effect<
  TokenValidationConfigEditResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: TokenValidationConfigEditRequest,
  output: TokenValidationConfigEditResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateRequest {
  body: { keys: Record<string, unknown>[] };
}

export const UpdateRequest = Schema.Struct({
  body: Schema.Struct({
  keys: Schema.Array(Schema.Struct({}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/token_validation/config/{config_id}/credentials" }),
).annotations({ identifier: "UpdateRequest" }) as unknown as Schema.Schema<UpdateRequest>;

export interface UpdateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateResponse" }) as unknown as Schema.Schema<UpdateResponse>;

export const update: (
  input: UpdateRequest
) => Effect.Effect<
  UpdateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateRequest,
  output: UpdateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List3Request {
  token_configuration?: unknown[];
  action?: "log" | "block";
  enabled?: boolean;
  id?: unknown;
  rule_id?: unknown;
  host?: string;
  hostname?: string;
}

export const List3Request = Schema.Struct({
  token_configuration: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("token_configuration")),
  action: Schema.optional(Schema.Literal("log", "block")).pipe(T.HttpQuery("action")),
  enabled: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("enabled")),
  id: Schema.optional(Schema.String).pipe(T.HttpQuery("id")),
  rule_id: Schema.optional(Schema.String).pipe(T.HttpQuery("rule_id")),
  host: Schema.optional(Schema.String).pipe(T.HttpQuery("host")),
  hostname: Schema.optional(Schema.String).pipe(T.HttpQuery("hostname"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/token_validation/rules" }),
).annotations({ identifier: "List3Request" }) as unknown as Schema.Schema<List3Request>;

export interface List3Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List3Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List3Response" }) as unknown as Schema.Schema<List3Response>;

export const list3: (
  input: List3Request
) => Effect.Effect<
  List3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List3Request,
  output: List3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create3Request {
  body: unknown;
}

export const Create3Request = Schema.Struct({
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/token_validation/rules" }),
).annotations({ identifier: "Create3Request" }) as unknown as Schema.Schema<Create3Request>;

export interface Create3Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create3Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create3Response" }) as unknown as Schema.Schema<Create3Response>;

export const create3: (
  input: Create3Request
) => Effect.Effect<
  Create3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create3Request,
  output: Create3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create4Request {
  body: unknown[];
}

export const Create4Request = Schema.Struct({
  body: Schema.Array(Schema.Struct({})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/token_validation/rules/bulk" }),
).annotations({ identifier: "Create4Request" }) as unknown as Schema.Schema<Create4Request>;

export interface Create4Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create4Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create4Response" }) as unknown as Schema.Schema<Create4Response>;

export const create4: (
  input: Create4Request
) => Effect.Effect<
  Create4Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create4Request,
  output: Create4Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface TokenValidationRulesBulkEditRequest {
  body: unknown[];
}

export const TokenValidationRulesBulkEditRequest = Schema.Struct({
  body: Schema.Array(Schema.Struct({
  id: Schema.UUID
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/token_validation/rules/bulk" }),
).annotations({ identifier: "TokenValidationRulesBulkEditRequest" }) as unknown as Schema.Schema<TokenValidationRulesBulkEditRequest>;

export interface TokenValidationRulesBulkEditResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const TokenValidationRulesBulkEditResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "TokenValidationRulesBulkEditResponse" }) as unknown as Schema.Schema<TokenValidationRulesBulkEditResponse>;

export const tokenValidationRulesBulkEdit: (
  input: TokenValidationRulesBulkEditRequest
) => Effect.Effect<
  TokenValidationRulesBulkEditResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: TokenValidationRulesBulkEditRequest,
  output: TokenValidationRulesBulkEditResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface TokenValidationRulesPreviewRequest {
  state?: "included" | "excluded" | "ignored"[];
  host?: string[];
  hostname?: string[];
  method?: "GET" | "POST" | "HEAD" | "OPTIONS" | "PUT" | "DELETE" | "CONNECT" | "PATCH" | "TRACE"[];
  endpoint?: string[];
  body: { exclude?: { operation_ids?: unknown[] }[]; include?: { host?: string[] }[] };
}

export const TokenValidationRulesPreviewRequest = Schema.Struct({
  state: Schema.optional(Schema.Array(Schema.Literal("included", "excluded", "ignored"))).pipe(T.HttpQuery("state")),
  host: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("host")),
  hostname: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("hostname")),
  method: Schema.optional(Schema.Array(Schema.Literal("GET", "POST", "HEAD", "OPTIONS", "PUT", "DELETE", "CONNECT", "PATCH", "TRACE"))).pipe(T.HttpQuery("method")),
  endpoint: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("endpoint")),
  body: Schema.Struct({
  exclude: Schema.optional(Schema.Array(Schema.Struct({
  operation_ids: Schema.optional(Schema.Array(Schema.String))
}))),
  include: Schema.optional(Schema.Array(Schema.Struct({
  host: Schema.optional(Schema.Array(Schema.String))
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/token_validation/rules/preview" }),
).annotations({ identifier: "TokenValidationRulesPreviewRequest" }) as unknown as Schema.Schema<TokenValidationRulesPreviewRequest>;

export interface TokenValidationRulesPreviewResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const TokenValidationRulesPreviewResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "TokenValidationRulesPreviewResponse" }) as unknown as Schema.Schema<TokenValidationRulesPreviewResponse>;

export const tokenValidationRulesPreview: (
  input: TokenValidationRulesPreviewRequest
) => Effect.Effect<
  TokenValidationRulesPreviewResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: TokenValidationRulesPreviewRequest,
  output: TokenValidationRulesPreviewResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_6Request {
}

export const Get_6Request = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/token_validation/rules/{rule_id}" }),
).annotations({ identifier: "Get_6Request" }) as unknown as Schema.Schema<Get_6Request>;

export interface Get_6Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_6Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_6Response" }) as unknown as Schema.Schema<Get_6Response>;

export const get_6: (
  input: Get_6Request
) => Effect.Effect<
  Get_6Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_6Request,
  output: Get_6Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_5Request {
}

export const Delete_5Request = Schema.Struct({

}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/token_validation/rules/{rule_id}" }),
).annotations({ identifier: "Delete_5Request" }) as unknown as Schema.Schema<Delete_5Request>;

export interface Delete_5Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_5Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_5Response" }) as unknown as Schema.Schema<Delete_5Response>;

export const delete_5: (
  input: Delete_5Request
) => Effect.Effect<
  Delete_5Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_5Request,
  output: Delete_5Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface TokenValidationRulesEditRequest {
  body: unknown;
}

export const TokenValidationRulesEditRequest = Schema.Struct({
  body: Schema.Struct({
  position: Schema.optional(Schema.Struct({}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/token_validation/rules/{rule_id}" }),
).annotations({ identifier: "TokenValidationRulesEditRequest" }) as unknown as Schema.Schema<TokenValidationRulesEditRequest>;

export interface TokenValidationRulesEditResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const TokenValidationRulesEditResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "TokenValidationRulesEditResponse" }) as unknown as Schema.Schema<TokenValidationRulesEditResponse>;

export const tokenValidationRulesEdit: (
  input: TokenValidationRulesEditRequest
) => Effect.Effect<
  TokenValidationRulesEditResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: TokenValidationRulesEditRequest,
  output: TokenValidationRulesEditResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GeturlnormalizationRequest {
  zone_id: string;
}

export const GeturlnormalizationRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/url_normalization" }),
).annotations({ identifier: "GeturlnormalizationRequest" }) as unknown as Schema.Schema<GeturlnormalizationRequest>;

export interface GeturlnormalizationResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GeturlnormalizationResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GeturlnormalizationResponse" }) as unknown as Schema.Schema<GeturlnormalizationResponse>;

export const geturlnormalization: (
  input: GeturlnormalizationRequest
) => Effect.Effect<
  GeturlnormalizationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GeturlnormalizationRequest,
  output: GeturlnormalizationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateurlnormalizationRequest {
  zone_id: string;
  body: { scope: "incoming" | "both" | "none"; type: "cloudflare" | "rfc3986" };
}

export const UpdateurlnormalizationRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  scope: Schema.Literal("incoming", "both", "none"),
  type: Schema.Literal("cloudflare", "rfc3986")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/url_normalization" }),
).annotations({ identifier: "UpdateurlnormalizationRequest" }) as unknown as Schema.Schema<UpdateurlnormalizationRequest>;

export interface UpdateurlnormalizationResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateurlnormalizationResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateurlnormalizationResponse" }) as unknown as Schema.Schema<UpdateurlnormalizationResponse>;

export const updateurlnormalization: (
  input: UpdateurlnormalizationRequest
) => Effect.Effect<
  UpdateurlnormalizationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateurlnormalizationRequest,
  output: UpdateurlnormalizationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteurlnormalizationRequest {
  zone_id: string;
}

export const DeleteurlnormalizationRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/url_normalization" }),
).annotations({ identifier: "DeleteurlnormalizationRequest" }) as unknown as Schema.Schema<DeleteurlnormalizationRequest>;

export interface DeleteurlnormalizationResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteurlnormalizationResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteurlnormalizationResponse" }) as unknown as Schema.Schema<DeleteurlnormalizationResponse>;

export const deleteurlnormalization: (
  input: DeleteurlnormalizationRequest
) => Effect.Effect<
  DeleteurlnormalizationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteurlnormalizationRequest,
  output: DeleteurlnormalizationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListWaitingRoomsRequest {
  zone_id: string;
}

export const ListWaitingRoomsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/waiting_rooms" }),
).annotations({ identifier: "ListWaitingRoomsRequest" }) as unknown as Schema.Schema<ListWaitingRoomsRequest>;

export interface ListWaitingRoomsResponse {
  result: { additional_routes?: { host?: string; path?: string }[]; cookie_attributes?: { samesite?: "auto" | "lax" | "none" | "strict"; secure?: "auto" | "always" | "never" }; cookie_suffix?: string; created_on?: string; custom_page_html?: string; default_template_language?: "en-US" | "es-ES" | "de-DE" | "fr-FR" | "it-IT" | "ja-JP" | "ko-KR" | "pt-BR" | "zh-CN" | "zh-TW" | "nl-NL" | "pl-PL" | "id-ID" | "tr-TR" | "ar-EG" | "ru-RU" | "fa-IR" | "bg-BG" | "hr-HR" | "cs-CZ" | "da-DK" | "fi-FI" | "lt-LT" | "ms-MY" | "nb-NO" | "ro-RO" | "el-GR" | "he-IL" | "hi-IN" | "hu-HU" | "sr-BA" | "sk-SK" | "sl-SI" | "sv-SE" | "tl-PH" | "th-TH" | "uk-UA" | "vi-VN"; description?: string; disable_session_renewal?: boolean; enabled_origin_commands?: "revoke"[]; host?: string; id?: string; json_response_enabled?: boolean; modified_on?: string; name?: string; new_users_per_minute?: number; next_event_prequeue_start_time?: string; next_event_start_time?: string; path?: string; queue_all?: boolean; queueing_method?: "fifo" | "random" | "passthrough" | "reject"; queueing_status_code?: 200 | 202 | 429; session_duration?: number; suspended?: boolean; total_active_users?: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListWaitingRoomsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  additional_routes: Schema.optional(Schema.Array(Schema.Struct({
  host: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String)
}))),
  cookie_attributes: Schema.optional(Schema.Struct({
  samesite: Schema.optional(Schema.Literal("auto", "lax", "none", "strict")),
  secure: Schema.optional(Schema.Literal("auto", "always", "never"))
})),
  cookie_suffix: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  custom_page_html: Schema.optional(Schema.String),
  default_template_language: Schema.optional(Schema.Literal("en-US", "es-ES", "de-DE", "fr-FR", "it-IT", "ja-JP", "ko-KR", "pt-BR", "zh-CN", "zh-TW", "nl-NL", "pl-PL", "id-ID", "tr-TR", "ar-EG", "ru-RU", "fa-IR", "bg-BG", "hr-HR", "cs-CZ", "da-DK", "fi-FI", "lt-LT", "ms-MY", "nb-NO", "ro-RO", "el-GR", "he-IL", "hi-IN", "hu-HU", "sr-BA", "sk-SK", "sl-SI", "sv-SE", "tl-PH", "th-TH", "uk-UA", "vi-VN")),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  enabled_origin_commands: Schema.optional(Schema.Array(Schema.Literal("revoke"))),
  host: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  json_response_enabled: Schema.optional(Schema.Boolean),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  new_users_per_minute: Schema.optional(Schema.Number),
  next_event_prequeue_start_time: Schema.optional(Schema.String),
  next_event_start_time: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  queue_all: Schema.optional(Schema.Boolean),
  queueing_method: Schema.optional(Schema.Literal("fifo", "random", "passthrough", "reject")),
  queueing_status_code: Schema.optional(Schema.Literal(200, 202, 429)),
  session_duration: Schema.optional(Schema.Number),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.optional(Schema.Number),
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListWaitingRoomsResponse" }) as unknown as Schema.Schema<ListWaitingRoomsResponse>;

export const listWaitingRooms: (
  input: ListWaitingRoomsRequest
) => Effect.Effect<
  ListWaitingRoomsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListWaitingRoomsRequest,
  output: ListWaitingRoomsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateWaitingRoomRequest {
  zone_id: string;
  body: { additional_routes?: { host?: string; path?: string }[]; cookie_attributes?: { samesite?: "auto" | "lax" | "none" | "strict"; secure?: "auto" | "always" | "never" }; cookie_suffix?: string; custom_page_html?: string; default_template_language?: "en-US" | "es-ES" | "de-DE" | "fr-FR" | "it-IT" | "ja-JP" | "ko-KR" | "pt-BR" | "zh-CN" | "zh-TW" | "nl-NL" | "pl-PL" | "id-ID" | "tr-TR" | "ar-EG" | "ru-RU" | "fa-IR" | "bg-BG" | "hr-HR" | "cs-CZ" | "da-DK" | "fi-FI" | "lt-LT" | "ms-MY" | "nb-NO" | "ro-RO" | "el-GR" | "he-IL" | "hi-IN" | "hu-HU" | "sr-BA" | "sk-SK" | "sl-SI" | "sv-SE" | "tl-PH" | "th-TH" | "uk-UA" | "vi-VN"; description?: string; disable_session_renewal?: boolean; enabled_origin_commands?: "revoke"[]; host: string; json_response_enabled?: boolean; name: string; new_users_per_minute: number; path?: string; queue_all?: boolean; queueing_method?: "fifo" | "random" | "passthrough" | "reject"; queueing_status_code?: 200 | 202 | 429; session_duration?: number; suspended?: boolean; total_active_users: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" };
}

export const CreateWaitingRoomRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  additional_routes: Schema.optional(Schema.Array(Schema.Struct({
  host: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String)
}))),
  cookie_attributes: Schema.optional(Schema.Struct({
  samesite: Schema.optional(Schema.Literal("auto", "lax", "none", "strict")),
  secure: Schema.optional(Schema.Literal("auto", "always", "never"))
})),
  cookie_suffix: Schema.optional(Schema.String),
  custom_page_html: Schema.optional(Schema.String),
  default_template_language: Schema.optional(Schema.Literal("en-US", "es-ES", "de-DE", "fr-FR", "it-IT", "ja-JP", "ko-KR", "pt-BR", "zh-CN", "zh-TW", "nl-NL", "pl-PL", "id-ID", "tr-TR", "ar-EG", "ru-RU", "fa-IR", "bg-BG", "hr-HR", "cs-CZ", "da-DK", "fi-FI", "lt-LT", "ms-MY", "nb-NO", "ro-RO", "el-GR", "he-IL", "hi-IN", "hu-HU", "sr-BA", "sk-SK", "sl-SI", "sv-SE", "tl-PH", "th-TH", "uk-UA", "vi-VN")),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  enabled_origin_commands: Schema.optional(Schema.Array(Schema.Literal("revoke"))),
  host: Schema.String,
  json_response_enabled: Schema.optional(Schema.Boolean),
  name: Schema.String,
  new_users_per_minute: Schema.Number,
  path: Schema.optional(Schema.String),
  queue_all: Schema.optional(Schema.Boolean),
  queueing_method: Schema.optional(Schema.Literal("fifo", "random", "passthrough", "reject")),
  queueing_status_code: Schema.optional(Schema.Literal(200, 202, 429)),
  session_duration: Schema.optional(Schema.Number),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.Number,
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/waiting_rooms" }),
).annotations({ identifier: "CreateWaitingRoomRequest" }) as unknown as Schema.Schema<CreateWaitingRoomRequest>;

export interface CreateWaitingRoomResponse {
  result: { additional_routes?: { host?: string; path?: string }[]; cookie_attributes?: { samesite?: "auto" | "lax" | "none" | "strict"; secure?: "auto" | "always" | "never" }; cookie_suffix?: string; created_on?: string; custom_page_html?: string; default_template_language?: "en-US" | "es-ES" | "de-DE" | "fr-FR" | "it-IT" | "ja-JP" | "ko-KR" | "pt-BR" | "zh-CN" | "zh-TW" | "nl-NL" | "pl-PL" | "id-ID" | "tr-TR" | "ar-EG" | "ru-RU" | "fa-IR" | "bg-BG" | "hr-HR" | "cs-CZ" | "da-DK" | "fi-FI" | "lt-LT" | "ms-MY" | "nb-NO" | "ro-RO" | "el-GR" | "he-IL" | "hi-IN" | "hu-HU" | "sr-BA" | "sk-SK" | "sl-SI" | "sv-SE" | "tl-PH" | "th-TH" | "uk-UA" | "vi-VN"; description?: string; disable_session_renewal?: boolean; enabled_origin_commands?: "revoke"[]; host?: string; id?: string; json_response_enabled?: boolean; modified_on?: string; name?: string; new_users_per_minute?: number; next_event_prequeue_start_time?: string; next_event_start_time?: string; path?: string; queue_all?: boolean; queueing_method?: "fifo" | "random" | "passthrough" | "reject"; queueing_status_code?: 200 | 202 | 429; session_duration?: number; suspended?: boolean; total_active_users?: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateWaitingRoomResponse = Schema.Struct({
  result: Schema.Struct({
  additional_routes: Schema.optional(Schema.Array(Schema.Struct({
  host: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String)
}))),
  cookie_attributes: Schema.optional(Schema.Struct({
  samesite: Schema.optional(Schema.Literal("auto", "lax", "none", "strict")),
  secure: Schema.optional(Schema.Literal("auto", "always", "never"))
})),
  cookie_suffix: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  custom_page_html: Schema.optional(Schema.String),
  default_template_language: Schema.optional(Schema.Literal("en-US", "es-ES", "de-DE", "fr-FR", "it-IT", "ja-JP", "ko-KR", "pt-BR", "zh-CN", "zh-TW", "nl-NL", "pl-PL", "id-ID", "tr-TR", "ar-EG", "ru-RU", "fa-IR", "bg-BG", "hr-HR", "cs-CZ", "da-DK", "fi-FI", "lt-LT", "ms-MY", "nb-NO", "ro-RO", "el-GR", "he-IL", "hi-IN", "hu-HU", "sr-BA", "sk-SK", "sl-SI", "sv-SE", "tl-PH", "th-TH", "uk-UA", "vi-VN")),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  enabled_origin_commands: Schema.optional(Schema.Array(Schema.Literal("revoke"))),
  host: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  json_response_enabled: Schema.optional(Schema.Boolean),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  new_users_per_minute: Schema.optional(Schema.Number),
  next_event_prequeue_start_time: Schema.optional(Schema.String),
  next_event_start_time: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  queue_all: Schema.optional(Schema.Boolean),
  queueing_method: Schema.optional(Schema.Literal("fifo", "random", "passthrough", "reject")),
  queueing_status_code: Schema.optional(Schema.Literal(200, 202, 429)),
  session_duration: Schema.optional(Schema.Number),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.optional(Schema.Number),
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateWaitingRoomResponse" }) as unknown as Schema.Schema<CreateWaitingRoomResponse>;

export const createWaitingRoom: (
  input: CreateWaitingRoomRequest
) => Effect.Effect<
  CreateWaitingRoomResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateWaitingRoomRequest,
  output: CreateWaitingRoomResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateACustomWaitingRoomPagePreviewRequest {
  zone_id: string;
  body: { custom_html: string };
}

export const CreateACustomWaitingRoomPagePreviewRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  custom_html: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/waiting_rooms/preview" }),
).annotations({ identifier: "CreateACustomWaitingRoomPagePreviewRequest" }) as unknown as Schema.Schema<CreateACustomWaitingRoomPagePreviewRequest>;

export interface CreateACustomWaitingRoomPagePreviewResponse {
  result: { preview_url?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateACustomWaitingRoomPagePreviewResponse = Schema.Struct({
  result: Schema.Struct({
  preview_url: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateACustomWaitingRoomPagePreviewResponse" }) as unknown as Schema.Schema<CreateACustomWaitingRoomPagePreviewResponse>;

export const createACustomWaitingRoomPagePreview: (
  input: CreateACustomWaitingRoomPagePreviewRequest
) => Effect.Effect<
  CreateACustomWaitingRoomPagePreviewResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateACustomWaitingRoomPagePreviewRequest,
  output: CreateACustomWaitingRoomPagePreviewResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZoneSettingsRequest {
  zone_id: string;
}

export const GetZoneSettingsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/waiting_rooms/settings" }),
).annotations({ identifier: "GetZoneSettingsRequest" }) as unknown as Schema.Schema<GetZoneSettingsRequest>;

export interface GetZoneSettingsResponse {
  result: { search_engine_crawler_bypass: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZoneSettingsResponse = Schema.Struct({
  result: Schema.Struct({
  search_engine_crawler_bypass: Schema.Boolean
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZoneSettingsResponse" }) as unknown as Schema.Schema<GetZoneSettingsResponse>;

export const getZoneSettings: (
  input: GetZoneSettingsRequest
) => Effect.Effect<
  GetZoneSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZoneSettingsRequest,
  output: GetZoneSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateZoneSettingsRequest {
  zone_id: string;
  body: { search_engine_crawler_bypass?: boolean };
}

export const UpdateZoneSettingsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  search_engine_crawler_bypass: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/waiting_rooms/settings" }),
).annotations({ identifier: "UpdateZoneSettingsRequest" }) as unknown as Schema.Schema<UpdateZoneSettingsRequest>;

export interface UpdateZoneSettingsResponse {
  result: { search_engine_crawler_bypass: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateZoneSettingsResponse = Schema.Struct({
  result: Schema.Struct({
  search_engine_crawler_bypass: Schema.Boolean
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateZoneSettingsResponse" }) as unknown as Schema.Schema<UpdateZoneSettingsResponse>;

export const updateZoneSettings: (
  input: UpdateZoneSettingsRequest
) => Effect.Effect<
  UpdateZoneSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateZoneSettingsRequest,
  output: UpdateZoneSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchZoneSettingsRequest {
  zone_id: string;
  body: { search_engine_crawler_bypass?: boolean };
}

export const PatchZoneSettingsRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  search_engine_crawler_bypass: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/waiting_rooms/settings" }),
).annotations({ identifier: "PatchZoneSettingsRequest" }) as unknown as Schema.Schema<PatchZoneSettingsRequest>;

export interface PatchZoneSettingsResponse {
  result: { search_engine_crawler_bypass: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchZoneSettingsResponse = Schema.Struct({
  result: Schema.Struct({
  search_engine_crawler_bypass: Schema.Boolean
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchZoneSettingsResponse" }) as unknown as Schema.Schema<PatchZoneSettingsResponse>;

export const patchZoneSettings: (
  input: PatchZoneSettingsRequest
) => Effect.Effect<
  PatchZoneSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchZoneSettingsRequest,
  output: PatchZoneSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface WaitingRoomWaitingRoomDetailsRequest {
  waiting_room_id: string;
  zone_id: string;
}

export const WaitingRoomWaitingRoomDetailsRequest = Schema.Struct({
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}" }),
).annotations({ identifier: "WaitingRoomWaitingRoomDetailsRequest" }) as unknown as Schema.Schema<WaitingRoomWaitingRoomDetailsRequest>;

export interface WaitingRoomWaitingRoomDetailsResponse {
  result: { additional_routes?: { host?: string; path?: string }[]; cookie_attributes?: { samesite?: "auto" | "lax" | "none" | "strict"; secure?: "auto" | "always" | "never" }; cookie_suffix?: string; created_on?: string; custom_page_html?: string; default_template_language?: "en-US" | "es-ES" | "de-DE" | "fr-FR" | "it-IT" | "ja-JP" | "ko-KR" | "pt-BR" | "zh-CN" | "zh-TW" | "nl-NL" | "pl-PL" | "id-ID" | "tr-TR" | "ar-EG" | "ru-RU" | "fa-IR" | "bg-BG" | "hr-HR" | "cs-CZ" | "da-DK" | "fi-FI" | "lt-LT" | "ms-MY" | "nb-NO" | "ro-RO" | "el-GR" | "he-IL" | "hi-IN" | "hu-HU" | "sr-BA" | "sk-SK" | "sl-SI" | "sv-SE" | "tl-PH" | "th-TH" | "uk-UA" | "vi-VN"; description?: string; disable_session_renewal?: boolean; enabled_origin_commands?: "revoke"[]; host?: string; id?: string; json_response_enabled?: boolean; modified_on?: string; name?: string; new_users_per_minute?: number; next_event_prequeue_start_time?: string; next_event_start_time?: string; path?: string; queue_all?: boolean; queueing_method?: "fifo" | "random" | "passthrough" | "reject"; queueing_status_code?: 200 | 202 | 429; session_duration?: number; suspended?: boolean; total_active_users?: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const WaitingRoomWaitingRoomDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  additional_routes: Schema.optional(Schema.Array(Schema.Struct({
  host: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String)
}))),
  cookie_attributes: Schema.optional(Schema.Struct({
  samesite: Schema.optional(Schema.Literal("auto", "lax", "none", "strict")),
  secure: Schema.optional(Schema.Literal("auto", "always", "never"))
})),
  cookie_suffix: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  custom_page_html: Schema.optional(Schema.String),
  default_template_language: Schema.optional(Schema.Literal("en-US", "es-ES", "de-DE", "fr-FR", "it-IT", "ja-JP", "ko-KR", "pt-BR", "zh-CN", "zh-TW", "nl-NL", "pl-PL", "id-ID", "tr-TR", "ar-EG", "ru-RU", "fa-IR", "bg-BG", "hr-HR", "cs-CZ", "da-DK", "fi-FI", "lt-LT", "ms-MY", "nb-NO", "ro-RO", "el-GR", "he-IL", "hi-IN", "hu-HU", "sr-BA", "sk-SK", "sl-SI", "sv-SE", "tl-PH", "th-TH", "uk-UA", "vi-VN")),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  enabled_origin_commands: Schema.optional(Schema.Array(Schema.Literal("revoke"))),
  host: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  json_response_enabled: Schema.optional(Schema.Boolean),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  new_users_per_minute: Schema.optional(Schema.Number),
  next_event_prequeue_start_time: Schema.optional(Schema.String),
  next_event_start_time: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  queue_all: Schema.optional(Schema.Boolean),
  queueing_method: Schema.optional(Schema.Literal("fifo", "random", "passthrough", "reject")),
  queueing_status_code: Schema.optional(Schema.Literal(200, 202, 429)),
  session_duration: Schema.optional(Schema.Number),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.optional(Schema.Number),
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "WaitingRoomWaitingRoomDetailsResponse" }) as unknown as Schema.Schema<WaitingRoomWaitingRoomDetailsResponse>;

export const waitingRoomWaitingRoomDetails: (
  input: WaitingRoomWaitingRoomDetailsRequest
) => Effect.Effect<
  WaitingRoomWaitingRoomDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: WaitingRoomWaitingRoomDetailsRequest,
  output: WaitingRoomWaitingRoomDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateWaitingRoomRequest {
  waiting_room_id: string;
  zone_id: string;
  body: { additional_routes?: { host?: string; path?: string }[]; cookie_attributes?: { samesite?: "auto" | "lax" | "none" | "strict"; secure?: "auto" | "always" | "never" }; cookie_suffix?: string; custom_page_html?: string; default_template_language?: "en-US" | "es-ES" | "de-DE" | "fr-FR" | "it-IT" | "ja-JP" | "ko-KR" | "pt-BR" | "zh-CN" | "zh-TW" | "nl-NL" | "pl-PL" | "id-ID" | "tr-TR" | "ar-EG" | "ru-RU" | "fa-IR" | "bg-BG" | "hr-HR" | "cs-CZ" | "da-DK" | "fi-FI" | "lt-LT" | "ms-MY" | "nb-NO" | "ro-RO" | "el-GR" | "he-IL" | "hi-IN" | "hu-HU" | "sr-BA" | "sk-SK" | "sl-SI" | "sv-SE" | "tl-PH" | "th-TH" | "uk-UA" | "vi-VN"; description?: string; disable_session_renewal?: boolean; enabled_origin_commands?: "revoke"[]; host: string; json_response_enabled?: boolean; name: string; new_users_per_minute: number; path?: string; queue_all?: boolean; queueing_method?: "fifo" | "random" | "passthrough" | "reject"; queueing_status_code?: 200 | 202 | 429; session_duration?: number; suspended?: boolean; total_active_users: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" };
}

export const UpdateWaitingRoomRequest = Schema.Struct({
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  additional_routes: Schema.optional(Schema.Array(Schema.Struct({
  host: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String)
}))),
  cookie_attributes: Schema.optional(Schema.Struct({
  samesite: Schema.optional(Schema.Literal("auto", "lax", "none", "strict")),
  secure: Schema.optional(Schema.Literal("auto", "always", "never"))
})),
  cookie_suffix: Schema.optional(Schema.String),
  custom_page_html: Schema.optional(Schema.String),
  default_template_language: Schema.optional(Schema.Literal("en-US", "es-ES", "de-DE", "fr-FR", "it-IT", "ja-JP", "ko-KR", "pt-BR", "zh-CN", "zh-TW", "nl-NL", "pl-PL", "id-ID", "tr-TR", "ar-EG", "ru-RU", "fa-IR", "bg-BG", "hr-HR", "cs-CZ", "da-DK", "fi-FI", "lt-LT", "ms-MY", "nb-NO", "ro-RO", "el-GR", "he-IL", "hi-IN", "hu-HU", "sr-BA", "sk-SK", "sl-SI", "sv-SE", "tl-PH", "th-TH", "uk-UA", "vi-VN")),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  enabled_origin_commands: Schema.optional(Schema.Array(Schema.Literal("revoke"))),
  host: Schema.String,
  json_response_enabled: Schema.optional(Schema.Boolean),
  name: Schema.String,
  new_users_per_minute: Schema.Number,
  path: Schema.optional(Schema.String),
  queue_all: Schema.optional(Schema.Boolean),
  queueing_method: Schema.optional(Schema.Literal("fifo", "random", "passthrough", "reject")),
  queueing_status_code: Schema.optional(Schema.Literal(200, 202, 429)),
  session_duration: Schema.optional(Schema.Number),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.Number,
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}" }),
).annotations({ identifier: "UpdateWaitingRoomRequest" }) as unknown as Schema.Schema<UpdateWaitingRoomRequest>;

export interface UpdateWaitingRoomResponse {
  result: { additional_routes?: { host?: string; path?: string }[]; cookie_attributes?: { samesite?: "auto" | "lax" | "none" | "strict"; secure?: "auto" | "always" | "never" }; cookie_suffix?: string; created_on?: string; custom_page_html?: string; default_template_language?: "en-US" | "es-ES" | "de-DE" | "fr-FR" | "it-IT" | "ja-JP" | "ko-KR" | "pt-BR" | "zh-CN" | "zh-TW" | "nl-NL" | "pl-PL" | "id-ID" | "tr-TR" | "ar-EG" | "ru-RU" | "fa-IR" | "bg-BG" | "hr-HR" | "cs-CZ" | "da-DK" | "fi-FI" | "lt-LT" | "ms-MY" | "nb-NO" | "ro-RO" | "el-GR" | "he-IL" | "hi-IN" | "hu-HU" | "sr-BA" | "sk-SK" | "sl-SI" | "sv-SE" | "tl-PH" | "th-TH" | "uk-UA" | "vi-VN"; description?: string; disable_session_renewal?: boolean; enabled_origin_commands?: "revoke"[]; host?: string; id?: string; json_response_enabled?: boolean; modified_on?: string; name?: string; new_users_per_minute?: number; next_event_prequeue_start_time?: string; next_event_start_time?: string; path?: string; queue_all?: boolean; queueing_method?: "fifo" | "random" | "passthrough" | "reject"; queueing_status_code?: 200 | 202 | 429; session_duration?: number; suspended?: boolean; total_active_users?: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateWaitingRoomResponse = Schema.Struct({
  result: Schema.Struct({
  additional_routes: Schema.optional(Schema.Array(Schema.Struct({
  host: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String)
}))),
  cookie_attributes: Schema.optional(Schema.Struct({
  samesite: Schema.optional(Schema.Literal("auto", "lax", "none", "strict")),
  secure: Schema.optional(Schema.Literal("auto", "always", "never"))
})),
  cookie_suffix: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  custom_page_html: Schema.optional(Schema.String),
  default_template_language: Schema.optional(Schema.Literal("en-US", "es-ES", "de-DE", "fr-FR", "it-IT", "ja-JP", "ko-KR", "pt-BR", "zh-CN", "zh-TW", "nl-NL", "pl-PL", "id-ID", "tr-TR", "ar-EG", "ru-RU", "fa-IR", "bg-BG", "hr-HR", "cs-CZ", "da-DK", "fi-FI", "lt-LT", "ms-MY", "nb-NO", "ro-RO", "el-GR", "he-IL", "hi-IN", "hu-HU", "sr-BA", "sk-SK", "sl-SI", "sv-SE", "tl-PH", "th-TH", "uk-UA", "vi-VN")),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  enabled_origin_commands: Schema.optional(Schema.Array(Schema.Literal("revoke"))),
  host: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  json_response_enabled: Schema.optional(Schema.Boolean),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  new_users_per_minute: Schema.optional(Schema.Number),
  next_event_prequeue_start_time: Schema.optional(Schema.String),
  next_event_start_time: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  queue_all: Schema.optional(Schema.Boolean),
  queueing_method: Schema.optional(Schema.Literal("fifo", "random", "passthrough", "reject")),
  queueing_status_code: Schema.optional(Schema.Literal(200, 202, 429)),
  session_duration: Schema.optional(Schema.Number),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.optional(Schema.Number),
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateWaitingRoomResponse" }) as unknown as Schema.Schema<UpdateWaitingRoomResponse>;

export const updateWaitingRoom: (
  input: UpdateWaitingRoomRequest
) => Effect.Effect<
  UpdateWaitingRoomResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateWaitingRoomRequest,
  output: UpdateWaitingRoomResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteWaitingRoomRequest {
  waiting_room_id: string;
  zone_id: string;
}

export const DeleteWaitingRoomRequest = Schema.Struct({
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}" }),
).annotations({ identifier: "DeleteWaitingRoomRequest" }) as unknown as Schema.Schema<DeleteWaitingRoomRequest>;

export interface DeleteWaitingRoomResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteWaitingRoomResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteWaitingRoomResponse" }) as unknown as Schema.Schema<DeleteWaitingRoomResponse>;

export const deleteWaitingRoom: (
  input: DeleteWaitingRoomRequest
) => Effect.Effect<
  DeleteWaitingRoomResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteWaitingRoomRequest,
  output: DeleteWaitingRoomResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchWaitingRoomRequest {
  waiting_room_id: string;
  zone_id: string;
  body: { additional_routes?: { host?: string; path?: string }[]; cookie_attributes?: { samesite?: "auto" | "lax" | "none" | "strict"; secure?: "auto" | "always" | "never" }; cookie_suffix?: string; custom_page_html?: string; default_template_language?: "en-US" | "es-ES" | "de-DE" | "fr-FR" | "it-IT" | "ja-JP" | "ko-KR" | "pt-BR" | "zh-CN" | "zh-TW" | "nl-NL" | "pl-PL" | "id-ID" | "tr-TR" | "ar-EG" | "ru-RU" | "fa-IR" | "bg-BG" | "hr-HR" | "cs-CZ" | "da-DK" | "fi-FI" | "lt-LT" | "ms-MY" | "nb-NO" | "ro-RO" | "el-GR" | "he-IL" | "hi-IN" | "hu-HU" | "sr-BA" | "sk-SK" | "sl-SI" | "sv-SE" | "tl-PH" | "th-TH" | "uk-UA" | "vi-VN"; description?: string; disable_session_renewal?: boolean; enabled_origin_commands?: "revoke"[]; host: string; json_response_enabled?: boolean; name: string; new_users_per_minute: number; path?: string; queue_all?: boolean; queueing_method?: "fifo" | "random" | "passthrough" | "reject"; queueing_status_code?: 200 | 202 | 429; session_duration?: number; suspended?: boolean; total_active_users: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" };
}

export const PatchWaitingRoomRequest = Schema.Struct({
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  additional_routes: Schema.optional(Schema.Array(Schema.Struct({
  host: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String)
}))),
  cookie_attributes: Schema.optional(Schema.Struct({
  samesite: Schema.optional(Schema.Literal("auto", "lax", "none", "strict")),
  secure: Schema.optional(Schema.Literal("auto", "always", "never"))
})),
  cookie_suffix: Schema.optional(Schema.String),
  custom_page_html: Schema.optional(Schema.String),
  default_template_language: Schema.optional(Schema.Literal("en-US", "es-ES", "de-DE", "fr-FR", "it-IT", "ja-JP", "ko-KR", "pt-BR", "zh-CN", "zh-TW", "nl-NL", "pl-PL", "id-ID", "tr-TR", "ar-EG", "ru-RU", "fa-IR", "bg-BG", "hr-HR", "cs-CZ", "da-DK", "fi-FI", "lt-LT", "ms-MY", "nb-NO", "ro-RO", "el-GR", "he-IL", "hi-IN", "hu-HU", "sr-BA", "sk-SK", "sl-SI", "sv-SE", "tl-PH", "th-TH", "uk-UA", "vi-VN")),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  enabled_origin_commands: Schema.optional(Schema.Array(Schema.Literal("revoke"))),
  host: Schema.String,
  json_response_enabled: Schema.optional(Schema.Boolean),
  name: Schema.String,
  new_users_per_minute: Schema.Number,
  path: Schema.optional(Schema.String),
  queue_all: Schema.optional(Schema.Boolean),
  queueing_method: Schema.optional(Schema.Literal("fifo", "random", "passthrough", "reject")),
  queueing_status_code: Schema.optional(Schema.Literal(200, 202, 429)),
  session_duration: Schema.optional(Schema.Number),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.Number,
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}" }),
).annotations({ identifier: "PatchWaitingRoomRequest" }) as unknown as Schema.Schema<PatchWaitingRoomRequest>;

export interface PatchWaitingRoomResponse {
  result: { additional_routes?: { host?: string; path?: string }[]; cookie_attributes?: { samesite?: "auto" | "lax" | "none" | "strict"; secure?: "auto" | "always" | "never" }; cookie_suffix?: string; created_on?: string; custom_page_html?: string; default_template_language?: "en-US" | "es-ES" | "de-DE" | "fr-FR" | "it-IT" | "ja-JP" | "ko-KR" | "pt-BR" | "zh-CN" | "zh-TW" | "nl-NL" | "pl-PL" | "id-ID" | "tr-TR" | "ar-EG" | "ru-RU" | "fa-IR" | "bg-BG" | "hr-HR" | "cs-CZ" | "da-DK" | "fi-FI" | "lt-LT" | "ms-MY" | "nb-NO" | "ro-RO" | "el-GR" | "he-IL" | "hi-IN" | "hu-HU" | "sr-BA" | "sk-SK" | "sl-SI" | "sv-SE" | "tl-PH" | "th-TH" | "uk-UA" | "vi-VN"; description?: string; disable_session_renewal?: boolean; enabled_origin_commands?: "revoke"[]; host?: string; id?: string; json_response_enabled?: boolean; modified_on?: string; name?: string; new_users_per_minute?: number; next_event_prequeue_start_time?: string; next_event_start_time?: string; path?: string; queue_all?: boolean; queueing_method?: "fifo" | "random" | "passthrough" | "reject"; queueing_status_code?: 200 | 202 | 429; session_duration?: number; suspended?: boolean; total_active_users?: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchWaitingRoomResponse = Schema.Struct({
  result: Schema.Struct({
  additional_routes: Schema.optional(Schema.Array(Schema.Struct({
  host: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String)
}))),
  cookie_attributes: Schema.optional(Schema.Struct({
  samesite: Schema.optional(Schema.Literal("auto", "lax", "none", "strict")),
  secure: Schema.optional(Schema.Literal("auto", "always", "never"))
})),
  cookie_suffix: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  custom_page_html: Schema.optional(Schema.String),
  default_template_language: Schema.optional(Schema.Literal("en-US", "es-ES", "de-DE", "fr-FR", "it-IT", "ja-JP", "ko-KR", "pt-BR", "zh-CN", "zh-TW", "nl-NL", "pl-PL", "id-ID", "tr-TR", "ar-EG", "ru-RU", "fa-IR", "bg-BG", "hr-HR", "cs-CZ", "da-DK", "fi-FI", "lt-LT", "ms-MY", "nb-NO", "ro-RO", "el-GR", "he-IL", "hi-IN", "hu-HU", "sr-BA", "sk-SK", "sl-SI", "sv-SE", "tl-PH", "th-TH", "uk-UA", "vi-VN")),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  enabled_origin_commands: Schema.optional(Schema.Array(Schema.Literal("revoke"))),
  host: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  json_response_enabled: Schema.optional(Schema.Boolean),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  new_users_per_minute: Schema.optional(Schema.Number),
  next_event_prequeue_start_time: Schema.optional(Schema.String),
  next_event_start_time: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  queue_all: Schema.optional(Schema.Boolean),
  queueing_method: Schema.optional(Schema.Literal("fifo", "random", "passthrough", "reject")),
  queueing_status_code: Schema.optional(Schema.Literal(200, 202, 429)),
  session_duration: Schema.optional(Schema.Number),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.optional(Schema.Number),
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchWaitingRoomResponse" }) as unknown as Schema.Schema<PatchWaitingRoomResponse>;

export const patchWaitingRoom: (
  input: PatchWaitingRoomRequest
) => Effect.Effect<
  PatchWaitingRoomResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchWaitingRoomRequest,
  output: PatchWaitingRoomResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListEventsRequest {
  waiting_room_id: string;
  zone_id: string;
}

export const ListEventsRequest = Schema.Struct({
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}/events" }),
).annotations({ identifier: "ListEventsRequest" }) as unknown as Schema.Schema<ListEventsRequest>;

export interface ListEventsResponse {
  result: { created_on?: string; custom_page_html?: string; description?: string; disable_session_renewal?: boolean; event_end_time?: string; event_start_time?: string; id?: string; modified_on?: string; name?: string; new_users_per_minute?: number; prequeue_start_time?: string; queueing_method?: string; session_duration?: number; shuffle_at_event_start?: boolean; suspended?: boolean; total_active_users?: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListEventsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  custom_page_html: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  event_end_time: Schema.optional(Schema.String),
  event_start_time: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  new_users_per_minute: Schema.optional(Schema.Number),
  prequeue_start_time: Schema.optional(Schema.String),
  queueing_method: Schema.optional(Schema.String),
  session_duration: Schema.optional(Schema.Number),
  shuffle_at_event_start: Schema.optional(Schema.Boolean),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.optional(Schema.Number),
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListEventsResponse" }) as unknown as Schema.Schema<ListEventsResponse>;

export const listEvents: (
  input: ListEventsRequest
) => Effect.Effect<
  ListEventsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListEventsRequest,
  output: ListEventsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateEventRequest {
  waiting_room_id: string;
  zone_id: string;
  body: { custom_page_html?: string; description?: string; disable_session_renewal?: boolean; event_end_time: string; event_start_time: string; name: string; new_users_per_minute?: number; prequeue_start_time?: string; queueing_method?: string; session_duration?: number; shuffle_at_event_start?: boolean; suspended?: boolean; total_active_users?: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" };
}

export const CreateEventRequest = Schema.Struct({
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  custom_page_html: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  event_end_time: Schema.String,
  event_start_time: Schema.String,
  name: Schema.String,
  new_users_per_minute: Schema.optional(Schema.Number),
  prequeue_start_time: Schema.optional(Schema.String),
  queueing_method: Schema.optional(Schema.String),
  session_duration: Schema.optional(Schema.Number),
  shuffle_at_event_start: Schema.optional(Schema.Boolean),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.optional(Schema.Number),
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}/events" }),
).annotations({ identifier: "CreateEventRequest" }) as unknown as Schema.Schema<CreateEventRequest>;

export interface CreateEventResponse {
  result: { created_on?: string; custom_page_html?: string; description?: string; disable_session_renewal?: boolean; event_end_time?: string; event_start_time?: string; id?: string; modified_on?: string; name?: string; new_users_per_minute?: number; prequeue_start_time?: string; queueing_method?: string; session_duration?: number; shuffle_at_event_start?: boolean; suspended?: boolean; total_active_users?: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateEventResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  custom_page_html: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  event_end_time: Schema.optional(Schema.String),
  event_start_time: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  new_users_per_minute: Schema.optional(Schema.Number),
  prequeue_start_time: Schema.optional(Schema.String),
  queueing_method: Schema.optional(Schema.String),
  session_duration: Schema.optional(Schema.Number),
  shuffle_at_event_start: Schema.optional(Schema.Boolean),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.optional(Schema.Number),
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateEventResponse" }) as unknown as Schema.Schema<CreateEventResponse>;

export const createEvent: (
  input: CreateEventRequest
) => Effect.Effect<
  CreateEventResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateEventRequest,
  output: CreateEventResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface WaitingRoomEventDetailsRequest {
  event_id: string;
  waiting_room_id: string;
  zone_id: string;
}

export const WaitingRoomEventDetailsRequest = Schema.Struct({
  event_id: Schema.String.pipe(T.HttpPath("event_id")),
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}/events/{event_id}" }),
).annotations({ identifier: "WaitingRoomEventDetailsRequest" }) as unknown as Schema.Schema<WaitingRoomEventDetailsRequest>;

export interface WaitingRoomEventDetailsResponse {
  result: { created_on?: string; custom_page_html?: string; description?: string; disable_session_renewal?: boolean; event_end_time?: string; event_start_time?: string; id?: string; modified_on?: string; name?: string; new_users_per_minute?: number; prequeue_start_time?: string; queueing_method?: string; session_duration?: number; shuffle_at_event_start?: boolean; suspended?: boolean; total_active_users?: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const WaitingRoomEventDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  custom_page_html: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  event_end_time: Schema.optional(Schema.String),
  event_start_time: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  new_users_per_minute: Schema.optional(Schema.Number),
  prequeue_start_time: Schema.optional(Schema.String),
  queueing_method: Schema.optional(Schema.String),
  session_duration: Schema.optional(Schema.Number),
  shuffle_at_event_start: Schema.optional(Schema.Boolean),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.optional(Schema.Number),
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "WaitingRoomEventDetailsResponse" }) as unknown as Schema.Schema<WaitingRoomEventDetailsResponse>;

export const waitingRoomEventDetails: (
  input: WaitingRoomEventDetailsRequest
) => Effect.Effect<
  WaitingRoomEventDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: WaitingRoomEventDetailsRequest,
  output: WaitingRoomEventDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateEventRequest {
  event_id: string;
  waiting_room_id: string;
  zone_id: string;
  body: { custom_page_html?: string; description?: string; disable_session_renewal?: boolean; event_end_time: string; event_start_time: string; name: string; new_users_per_minute?: number; prequeue_start_time?: string; queueing_method?: string; session_duration?: number; shuffle_at_event_start?: boolean; suspended?: boolean; total_active_users?: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" };
}

export const UpdateEventRequest = Schema.Struct({
  event_id: Schema.String.pipe(T.HttpPath("event_id")),
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  custom_page_html: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  event_end_time: Schema.String,
  event_start_time: Schema.String,
  name: Schema.String,
  new_users_per_minute: Schema.optional(Schema.Number),
  prequeue_start_time: Schema.optional(Schema.String),
  queueing_method: Schema.optional(Schema.String),
  session_duration: Schema.optional(Schema.Number),
  shuffle_at_event_start: Schema.optional(Schema.Boolean),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.optional(Schema.Number),
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}/events/{event_id}" }),
).annotations({ identifier: "UpdateEventRequest" }) as unknown as Schema.Schema<UpdateEventRequest>;

export interface UpdateEventResponse {
  result: { created_on?: string; custom_page_html?: string; description?: string; disable_session_renewal?: boolean; event_end_time?: string; event_start_time?: string; id?: string; modified_on?: string; name?: string; new_users_per_minute?: number; prequeue_start_time?: string; queueing_method?: string; session_duration?: number; shuffle_at_event_start?: boolean; suspended?: boolean; total_active_users?: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateEventResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  custom_page_html: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  event_end_time: Schema.optional(Schema.String),
  event_start_time: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  new_users_per_minute: Schema.optional(Schema.Number),
  prequeue_start_time: Schema.optional(Schema.String),
  queueing_method: Schema.optional(Schema.String),
  session_duration: Schema.optional(Schema.Number),
  shuffle_at_event_start: Schema.optional(Schema.Boolean),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.optional(Schema.Number),
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateEventResponse" }) as unknown as Schema.Schema<UpdateEventResponse>;

export const updateEvent: (
  input: UpdateEventRequest
) => Effect.Effect<
  UpdateEventResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateEventRequest,
  output: UpdateEventResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteEventRequest {
  event_id: string;
  waiting_room_id: string;
  zone_id: string;
}

export const DeleteEventRequest = Schema.Struct({
  event_id: Schema.String.pipe(T.HttpPath("event_id")),
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}/events/{event_id}" }),
).annotations({ identifier: "DeleteEventRequest" }) as unknown as Schema.Schema<DeleteEventRequest>;

export interface DeleteEventResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteEventResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteEventResponse" }) as unknown as Schema.Schema<DeleteEventResponse>;

export const deleteEvent: (
  input: DeleteEventRequest
) => Effect.Effect<
  DeleteEventResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteEventRequest,
  output: DeleteEventResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchEventRequest {
  event_id: string;
  waiting_room_id: string;
  zone_id: string;
  body: { custom_page_html?: string; description?: string; disable_session_renewal?: boolean; event_end_time: string; event_start_time: string; name: string; new_users_per_minute?: number; prequeue_start_time?: string; queueing_method?: string; session_duration?: number; shuffle_at_event_start?: boolean; suspended?: boolean; total_active_users?: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" };
}

export const PatchEventRequest = Schema.Struct({
  event_id: Schema.String.pipe(T.HttpPath("event_id")),
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  custom_page_html: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  event_end_time: Schema.String,
  event_start_time: Schema.String,
  name: Schema.String,
  new_users_per_minute: Schema.optional(Schema.Number),
  prequeue_start_time: Schema.optional(Schema.String),
  queueing_method: Schema.optional(Schema.String),
  session_duration: Schema.optional(Schema.Number),
  shuffle_at_event_start: Schema.optional(Schema.Boolean),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.optional(Schema.Number),
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}/events/{event_id}" }),
).annotations({ identifier: "PatchEventRequest" }) as unknown as Schema.Schema<PatchEventRequest>;

export interface PatchEventResponse {
  result: { created_on?: string; custom_page_html?: string; description?: string; disable_session_renewal?: boolean; event_end_time?: string; event_start_time?: string; id?: string; modified_on?: string; name?: string; new_users_per_minute?: number; prequeue_start_time?: string; queueing_method?: string; session_duration?: number; shuffle_at_event_start?: boolean; suspended?: boolean; total_active_users?: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchEventResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  custom_page_html: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  event_end_time: Schema.optional(Schema.String),
  event_start_time: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  new_users_per_minute: Schema.optional(Schema.Number),
  prequeue_start_time: Schema.optional(Schema.String),
  queueing_method: Schema.optional(Schema.String),
  session_duration: Schema.optional(Schema.Number),
  shuffle_at_event_start: Schema.optional(Schema.Boolean),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.optional(Schema.Number),
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchEventResponse" }) as unknown as Schema.Schema<PatchEventResponse>;

export const patchEvent: (
  input: PatchEventRequest
) => Effect.Effect<
  PatchEventResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchEventRequest,
  output: PatchEventResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface WaitingRoomPreviewActiveEventDetailsRequest {
  event_id: string;
  waiting_room_id: string;
  zone_id: string;
}

export const WaitingRoomPreviewActiveEventDetailsRequest = Schema.Struct({
  event_id: Schema.String.pipe(T.HttpPath("event_id")),
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}/events/{event_id}/details" }),
).annotations({ identifier: "WaitingRoomPreviewActiveEventDetailsRequest" }) as unknown as Schema.Schema<WaitingRoomPreviewActiveEventDetailsRequest>;

export interface WaitingRoomPreviewActiveEventDetailsResponse {
  result: { created_on?: string; custom_page_html?: string; description?: string; disable_session_renewal?: boolean; event_end_time?: string; event_start_time?: string; id?: string; modified_on?: string; name?: string; new_users_per_minute?: number; prequeue_start_time?: string; queueing_method?: string; session_duration?: number; shuffle_at_event_start?: boolean; suspended?: boolean; total_active_users?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const WaitingRoomPreviewActiveEventDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  custom_page_html: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  event_end_time: Schema.optional(Schema.String),
  event_start_time: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  new_users_per_minute: Schema.optional(Schema.Number),
  prequeue_start_time: Schema.optional(Schema.String),
  queueing_method: Schema.optional(Schema.String),
  session_duration: Schema.optional(Schema.Number),
  shuffle_at_event_start: Schema.optional(Schema.Boolean),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "WaitingRoomPreviewActiveEventDetailsResponse" }) as unknown as Schema.Schema<WaitingRoomPreviewActiveEventDetailsResponse>;

export const waitingRoomPreviewActiveEventDetails: (
  input: WaitingRoomPreviewActiveEventDetailsRequest
) => Effect.Effect<
  WaitingRoomPreviewActiveEventDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: WaitingRoomPreviewActiveEventDetailsRequest,
  output: WaitingRoomPreviewActiveEventDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListWaitingRoomRulesRequest {
  waiting_room_id: string;
  zone_id: string;
}

export const ListWaitingRoomRulesRequest = Schema.Struct({
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}/rules" }),
).annotations({ identifier: "ListWaitingRoomRulesRequest" }) as unknown as Schema.Schema<ListWaitingRoomRulesRequest>;

export interface ListWaitingRoomRulesResponse {
  result: { action?: "bypass_waiting_room"; description?: string; enabled?: boolean; expression?: string; id?: string; last_updated?: string; version?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListWaitingRoomRulesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  action: Schema.optional(Schema.Literal("bypass_waiting_room")),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  expression: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  last_updated: Schema.optional(Schema.Date),
  version: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListWaitingRoomRulesResponse" }) as unknown as Schema.Schema<ListWaitingRoomRulesResponse>;

export const listWaitingRoomRules: (
  input: ListWaitingRoomRulesRequest
) => Effect.Effect<
  ListWaitingRoomRulesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListWaitingRoomRulesRequest,
  output: ListWaitingRoomRulesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateWaitingRoomRuleRequest {
  waiting_room_id: string;
  zone_id: string;
  body: { action: "bypass_waiting_room"; description?: string; enabled?: boolean; expression: string };
}

export const CreateWaitingRoomRuleRequest = Schema.Struct({
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  action: Schema.Literal("bypass_waiting_room"),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  expression: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}/rules" }),
).annotations({ identifier: "CreateWaitingRoomRuleRequest" }) as unknown as Schema.Schema<CreateWaitingRoomRuleRequest>;

export interface CreateWaitingRoomRuleResponse {
  result: { action?: "bypass_waiting_room"; description?: string; enabled?: boolean; expression?: string; id?: string; last_updated?: string; version?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateWaitingRoomRuleResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  action: Schema.optional(Schema.Literal("bypass_waiting_room")),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  expression: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  last_updated: Schema.optional(Schema.Date),
  version: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateWaitingRoomRuleResponse" }) as unknown as Schema.Schema<CreateWaitingRoomRuleResponse>;

export const createWaitingRoomRule: (
  input: CreateWaitingRoomRuleRequest
) => Effect.Effect<
  CreateWaitingRoomRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateWaitingRoomRuleRequest,
  output: CreateWaitingRoomRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface WaitingRoomReplaceWaitingRoomRulesRequest {
  waiting_room_id: string;
  zone_id: string;
  body: { action: "bypass_waiting_room"; description?: string; enabled?: boolean; expression: string }[];
}

export const WaitingRoomReplaceWaitingRoomRulesRequest = Schema.Struct({
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Array(Schema.Struct({
  action: Schema.Literal("bypass_waiting_room"),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  expression: Schema.String
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}/rules" }),
).annotations({ identifier: "WaitingRoomReplaceWaitingRoomRulesRequest" }) as unknown as Schema.Schema<WaitingRoomReplaceWaitingRoomRulesRequest>;

export interface WaitingRoomReplaceWaitingRoomRulesResponse {
  result: { action?: "bypass_waiting_room"; description?: string; enabled?: boolean; expression?: string; id?: string; last_updated?: string; version?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const WaitingRoomReplaceWaitingRoomRulesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  action: Schema.optional(Schema.Literal("bypass_waiting_room")),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  expression: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  last_updated: Schema.optional(Schema.Date),
  version: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "WaitingRoomReplaceWaitingRoomRulesResponse" }) as unknown as Schema.Schema<WaitingRoomReplaceWaitingRoomRulesResponse>;

export const waitingRoomReplaceWaitingRoomRules: (
  input: WaitingRoomReplaceWaitingRoomRulesRequest
) => Effect.Effect<
  WaitingRoomReplaceWaitingRoomRulesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: WaitingRoomReplaceWaitingRoomRulesRequest,
  output: WaitingRoomReplaceWaitingRoomRulesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteWaitingRoomRuleRequest {
  rule_id: string;
  waiting_room_id: string;
  zone_id: string;
}

export const DeleteWaitingRoomRuleRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}/rules/{rule_id}" }),
).annotations({ identifier: "DeleteWaitingRoomRuleRequest" }) as unknown as Schema.Schema<DeleteWaitingRoomRuleRequest>;

export interface DeleteWaitingRoomRuleResponse {
  result: { action?: "bypass_waiting_room"; description?: string; enabled?: boolean; expression?: string; id?: string; last_updated?: string; version?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteWaitingRoomRuleResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  action: Schema.optional(Schema.Literal("bypass_waiting_room")),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  expression: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  last_updated: Schema.optional(Schema.Date),
  version: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteWaitingRoomRuleResponse" }) as unknown as Schema.Schema<DeleteWaitingRoomRuleResponse>;

export const deleteWaitingRoomRule: (
  input: DeleteWaitingRoomRuleRequest
) => Effect.Effect<
  DeleteWaitingRoomRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteWaitingRoomRuleRequest,
  output: DeleteWaitingRoomRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchWaitingRoomRuleRequest {
  rule_id: string;
  waiting_room_id: string;
  zone_id: string;
  body: { action: "bypass_waiting_room"; description?: string; enabled?: boolean; expression: string; position?: Record<string, unknown> };
}

export const PatchWaitingRoomRuleRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  action: Schema.Literal("bypass_waiting_room"),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  expression: Schema.String,
  position: Schema.optional(Schema.Struct({}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}/rules/{rule_id}" }),
).annotations({ identifier: "PatchWaitingRoomRuleRequest" }) as unknown as Schema.Schema<PatchWaitingRoomRuleRequest>;

export interface PatchWaitingRoomRuleResponse {
  result: { action?: "bypass_waiting_room"; description?: string; enabled?: boolean; expression?: string; id?: string; last_updated?: string; version?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchWaitingRoomRuleResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  action: Schema.optional(Schema.Literal("bypass_waiting_room")),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  expression: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  last_updated: Schema.optional(Schema.Date),
  version: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchWaitingRoomRuleResponse" }) as unknown as Schema.Schema<PatchWaitingRoomRuleResponse>;

export const patchWaitingRoomRule: (
  input: PatchWaitingRoomRuleRequest
) => Effect.Effect<
  PatchWaitingRoomRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchWaitingRoomRuleRequest,
  output: PatchWaitingRoomRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetWaitingRoomStatusRequest {
  waiting_room_id: string;
  zone_id: string;
}

export const GetWaitingRoomStatusRequest = Schema.Struct({
  waiting_room_id: Schema.String.pipe(T.HttpPath("waiting_room_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/waiting_rooms/{waiting_room_id}/status" }),
).annotations({ identifier: "GetWaitingRoomStatusRequest" }) as unknown as Schema.Schema<GetWaitingRoomStatusRequest>;

export interface GetWaitingRoomStatusResponse {
  result: { estimated_queued_users?: number; estimated_total_active_users?: number; event_id?: string; max_estimated_time_minutes?: number; status?: "event_prequeueing" | "not_queueing" | "queueing" | "suspended" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetWaitingRoomStatusResponse = Schema.Struct({
  result: Schema.Struct({
  estimated_queued_users: Schema.optional(Schema.Number),
  estimated_total_active_users: Schema.optional(Schema.Number),
  event_id: Schema.optional(Schema.String),
  max_estimated_time_minutes: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("event_prequeueing", "not_queueing", "queueing", "suspended"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetWaitingRoomStatusResponse" }) as unknown as Schema.Schema<GetWaitingRoomStatusResponse>;

export const getWaitingRoomStatus: (
  input: GetWaitingRoomStatusRequest
) => Effect.Effect<
  GetWaitingRoomStatusResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetWaitingRoomStatusRequest,
  output: GetWaitingRoomStatusResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListWeb3HostnamesRequest {
  zone_id: string;
}

export const ListWeb3HostnamesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/web3/hostnames" }),
).annotations({ identifier: "ListWeb3HostnamesRequest" }) as unknown as Schema.Schema<ListWeb3HostnamesRequest>;

export interface ListWeb3HostnamesResponse {
  result: { created_on?: string; description?: string; dnslink?: string; id?: string; modified_on?: string; name?: string; status?: "active" | "pending" | "deleting" | "error"; target?: "ethereum" | "ipfs" | "ipfs_universal_path" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListWeb3HostnamesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  dnslink: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("active", "pending", "deleting", "error")),
  target: Schema.optional(Schema.Literal("ethereum", "ipfs", "ipfs_universal_path"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListWeb3HostnamesResponse" }) as unknown as Schema.Schema<ListWeb3HostnamesResponse>;

export const listWeb3Hostnames: (
  input: ListWeb3HostnamesRequest
) => Effect.Effect<
  ListWeb3HostnamesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListWeb3HostnamesRequest,
  output: ListWeb3HostnamesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateWeb3HostnameRequest {
  zone_id: string;
  body: { description?: string; dnslink?: string; name: string; target: "ethereum" | "ipfs" | "ipfs_universal_path" };
}

export const CreateWeb3HostnameRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  dnslink: Schema.optional(Schema.String),
  name: Schema.String,
  target: Schema.Literal("ethereum", "ipfs", "ipfs_universal_path")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/web3/hostnames" }),
).annotations({ identifier: "CreateWeb3HostnameRequest" }) as unknown as Schema.Schema<CreateWeb3HostnameRequest>;

export interface CreateWeb3HostnameResponse {
  result: { created_on?: string; description?: string; dnslink?: string; id?: string; modified_on?: string; name?: string; status?: "active" | "pending" | "deleting" | "error"; target?: "ethereum" | "ipfs" | "ipfs_universal_path" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateWeb3HostnameResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  dnslink: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("active", "pending", "deleting", "error")),
  target: Schema.optional(Schema.Literal("ethereum", "ipfs", "ipfs_universal_path"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateWeb3HostnameResponse" }) as unknown as Schema.Schema<CreateWeb3HostnameResponse>;

export const createWeb3Hostname: (
  input: CreateWeb3HostnameRequest
) => Effect.Effect<
  CreateWeb3HostnameResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateWeb3HostnameRequest,
  output: CreateWeb3HostnameResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Web3HostnameWeb3HostnameDetailsRequest {
  identifier: string;
  zone_id: string;
}

export const Web3HostnameWeb3HostnameDetailsRequest = Schema.Struct({
  identifier: Schema.String.pipe(T.HttpPath("identifier")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/web3/hostnames/{identifier}" }),
).annotations({ identifier: "Web3HostnameWeb3HostnameDetailsRequest" }) as unknown as Schema.Schema<Web3HostnameWeb3HostnameDetailsRequest>;

export interface Web3HostnameWeb3HostnameDetailsResponse {
  result: { created_on?: string; description?: string; dnslink?: string; id?: string; modified_on?: string; name?: string; status?: "active" | "pending" | "deleting" | "error"; target?: "ethereum" | "ipfs" | "ipfs_universal_path" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Web3HostnameWeb3HostnameDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  dnslink: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("active", "pending", "deleting", "error")),
  target: Schema.optional(Schema.Literal("ethereum", "ipfs", "ipfs_universal_path"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Web3HostnameWeb3HostnameDetailsResponse" }) as unknown as Schema.Schema<Web3HostnameWeb3HostnameDetailsResponse>;

export const web3HostnameWeb3HostnameDetails: (
  input: Web3HostnameWeb3HostnameDetailsRequest
) => Effect.Effect<
  Web3HostnameWeb3HostnameDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Web3HostnameWeb3HostnameDetailsRequest,
  output: Web3HostnameWeb3HostnameDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteWeb3HostnameRequest {
  identifier: string;
  zone_id: string;
}

export const DeleteWeb3HostnameRequest = Schema.Struct({
  identifier: Schema.String.pipe(T.HttpPath("identifier")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/web3/hostnames/{identifier}" }),
).annotations({ identifier: "DeleteWeb3HostnameRequest" }) as unknown as Schema.Schema<DeleteWeb3HostnameRequest>;

export interface DeleteWeb3HostnameResponse {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteWeb3HostnameResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteWeb3HostnameResponse" }) as unknown as Schema.Schema<DeleteWeb3HostnameResponse>;

export const deleteWeb3Hostname: (
  input: DeleteWeb3HostnameRequest
) => Effect.Effect<
  DeleteWeb3HostnameResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteWeb3HostnameRequest,
  output: DeleteWeb3HostnameResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Web3HostnameEditWeb3HostnameRequest {
  identifier: string;
  zone_id: string;
  body: { description?: string; dnslink?: string };
}

export const Web3HostnameEditWeb3HostnameRequest = Schema.Struct({
  identifier: Schema.String.pipe(T.HttpPath("identifier")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  dnslink: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/zones/{zone_id}/web3/hostnames/{identifier}" }),
).annotations({ identifier: "Web3HostnameEditWeb3HostnameRequest" }) as unknown as Schema.Schema<Web3HostnameEditWeb3HostnameRequest>;

export interface Web3HostnameEditWeb3HostnameResponse {
  result: { created_on?: string; description?: string; dnslink?: string; id?: string; modified_on?: string; name?: string; status?: "active" | "pending" | "deleting" | "error"; target?: "ethereum" | "ipfs" | "ipfs_universal_path" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Web3HostnameEditWeb3HostnameResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  dnslink: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("active", "pending", "deleting", "error")),
  target: Schema.optional(Schema.Literal("ethereum", "ipfs", "ipfs_universal_path"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Web3HostnameEditWeb3HostnameResponse" }) as unknown as Schema.Schema<Web3HostnameEditWeb3HostnameResponse>;

export const web3HostnameEditWeb3Hostname: (
  input: Web3HostnameEditWeb3HostnameRequest
) => Effect.Effect<
  Web3HostnameEditWeb3HostnameResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Web3HostnameEditWeb3HostnameRequest,
  output: Web3HostnameEditWeb3HostnameResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDetails1Request {
  identifier: string;
  zone_id: string;
}

export const ListDetails1Request = Schema.Struct({
  identifier: Schema.String.pipe(T.HttpPath("identifier")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/web3/hostnames/{identifier}/ipfs_universal_path/content_list" }),
).annotations({ identifier: "ListDetails1Request" }) as unknown as Schema.Schema<ListDetails1Request>;

export interface ListDetails1Response {
  result: { action?: "block" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDetails1Response = Schema.Struct({
  result: Schema.Struct({
  action: Schema.optional(Schema.Literal("block"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDetails1Response" }) as unknown as Schema.Schema<ListDetails1Response>;

export const listDetails1: (
  input: ListDetails1Request
) => Effect.Effect<
  ListDetails1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDetails1Request,
  output: ListDetails1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List4Request {
  identifier: string;
  zone_id: string;
  body: { action: "block"; entries: { content?: string; created_on?: string; description?: string; id?: string; modified_on?: string; type?: "cid" | "content_path" }[] };
}

export const List4Request = Schema.Struct({
  identifier: Schema.String.pipe(T.HttpPath("identifier")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  action: Schema.Literal("block"),
  entries: Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  type: Schema.optional(Schema.Literal("cid", "content_path"))
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/web3/hostnames/{identifier}/ipfs_universal_path/content_list" }),
).annotations({ identifier: "List4Request" }) as unknown as Schema.Schema<List4Request>;

export interface List4Response {
  result: { action?: "block" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List4Response = Schema.Struct({
  result: Schema.Struct({
  action: Schema.optional(Schema.Literal("block"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List4Response" }) as unknown as Schema.Schema<List4Response>;

export const list4: (
  input: List4Request
) => Effect.Effect<
  List4Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List4Request,
  output: List4Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListEntriesRequest {
  identifier: string;
  zone_id: string;
}

export const ListEntriesRequest = Schema.Struct({
  identifier: Schema.String.pipe(T.HttpPath("identifier")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/web3/hostnames/{identifier}/ipfs_universal_path/content_list/entries" }),
).annotations({ identifier: "ListEntriesRequest" }) as unknown as Schema.Schema<ListEntriesRequest>;

export interface ListEntriesResponse {
  result: { entries?: { content?: string; created_on?: string; description?: string; id?: string; modified_on?: string; type?: "cid" | "content_path" }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListEntriesResponse = Schema.Struct({
  result: Schema.Struct({
  entries: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  type: Schema.optional(Schema.Literal("cid", "content_path"))
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListEntriesResponse" }) as unknown as Schema.Schema<ListEntriesResponse>;

export const listEntries: (
  input: ListEntriesRequest
) => Effect.Effect<
  ListEntriesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListEntriesRequest,
  output: ListEntriesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListEntryRequest {
  identifier: string;
  zone_id: string;
  body: { content: string; description?: string; type: "cid" | "content_path" };
}

export const ListEntryRequest = Schema.Struct({
  identifier: Schema.String.pipe(T.HttpPath("identifier")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  content: Schema.String,
  description: Schema.optional(Schema.String),
  type: Schema.Literal("cid", "content_path")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/web3/hostnames/{identifier}/ipfs_universal_path/content_list/entries" }),
).annotations({ identifier: "ListEntryRequest" }) as unknown as Schema.Schema<ListEntryRequest>;

export interface ListEntryResponse {
  result: { content?: string; created_on?: string; description?: string; id?: string; modified_on?: string; type?: "cid" | "content_path" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListEntryResponse = Schema.Struct({
  result: Schema.Struct({
  content: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  type: Schema.optional(Schema.Literal("cid", "content_path"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListEntryResponse" }) as unknown as Schema.Schema<ListEntryResponse>;

export const listEntry: (
  input: ListEntryRequest
) => Effect.Effect<
  ListEntryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListEntryRequest,
  output: ListEntryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListEntryDetailsRequest {
  content_list_entry_identifier: string;
  identifier: string;
  zone_id: string;
}

export const ListEntryDetailsRequest = Schema.Struct({
  content_list_entry_identifier: Schema.String.pipe(T.HttpPath("content_list_entry_identifier")),
  identifier: Schema.String.pipe(T.HttpPath("identifier")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/web3/hostnames/{identifier}/ipfs_universal_path/content_list/entries/{content_list_entry_identifier}" }),
).annotations({ identifier: "ListEntryDetailsRequest" }) as unknown as Schema.Schema<ListEntryDetailsRequest>;

export interface ListEntryDetailsResponse {
  result: { content?: string; created_on?: string; description?: string; id?: string; modified_on?: string; type?: "cid" | "content_path" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListEntryDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  content: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  type: Schema.optional(Schema.Literal("cid", "content_path"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListEntryDetailsResponse" }) as unknown as Schema.Schema<ListEntryDetailsResponse>;

export const listEntryDetails: (
  input: ListEntryDetailsRequest
) => Effect.Effect<
  ListEntryDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListEntryDetailsRequest,
  output: ListEntryDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListEntry1Request {
  content_list_entry_identifier: string;
  identifier: string;
  zone_id: string;
  body: { content: string; description?: string; type: "cid" | "content_path" };
}

export const ListEntry1Request = Schema.Struct({
  content_list_entry_identifier: Schema.String.pipe(T.HttpPath("content_list_entry_identifier")),
  identifier: Schema.String.pipe(T.HttpPath("identifier")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  content: Schema.String,
  description: Schema.optional(Schema.String),
  type: Schema.Literal("cid", "content_path")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/web3/hostnames/{identifier}/ipfs_universal_path/content_list/entries/{content_list_entry_identifier}" }),
).annotations({ identifier: "ListEntry1Request" }) as unknown as Schema.Schema<ListEntry1Request>;

export interface ListEntry1Response {
  result: { content?: string; created_on?: string; description?: string; id?: string; modified_on?: string; type?: "cid" | "content_path" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListEntry1Response = Schema.Struct({
  result: Schema.Struct({
  content: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  type: Schema.optional(Schema.Literal("cid", "content_path"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListEntry1Response" }) as unknown as Schema.Schema<ListEntry1Response>;

export const listEntry1: (
  input: ListEntry1Request
) => Effect.Effect<
  ListEntry1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListEntry1Request,
  output: ListEntry1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListEntry2Request {
  content_list_entry_identifier: string;
  identifier: string;
  zone_id: string;
}

export const ListEntry2Request = Schema.Struct({
  content_list_entry_identifier: Schema.String.pipe(T.HttpPath("content_list_entry_identifier")),
  identifier: Schema.String.pipe(T.HttpPath("identifier")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/web3/hostnames/{identifier}/ipfs_universal_path/content_list/entries/{content_list_entry_identifier}" }),
).annotations({ identifier: "ListEntry2Request" }) as unknown as Schema.Schema<ListEntry2Request>;

export interface ListEntry2Response {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListEntry2Response = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListEntry2Response" }) as unknown as Schema.Schema<ListEntry2Response>;

export const listEntry2: (
  input: ListEntry2Request
) => Effect.Effect<
  ListEntry2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListEntry2Request,
  output: ListEntry2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListRoutesRequest {
  zone_id: string;
}

export const ListRoutesRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/workers/routes" }),
).annotations({ identifier: "ListRoutesRequest" }) as unknown as Schema.Schema<ListRoutesRequest>;

export interface ListRoutesResponse {
  result: { id: unknown; pattern: string; script?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListRoutesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  id: Schema.String,
  pattern: Schema.String,
  script: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListRoutesResponse" }) as unknown as Schema.Schema<ListRoutesResponse>;

export const listRoutes: (
  input: ListRoutesRequest
) => Effect.Effect<
  ListRoutesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListRoutesRequest,
  output: ListRoutesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateRouteRequest {
  zone_id: string;
  body: { id: unknown; pattern: string; script?: string };
}

export const CreateRouteRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  id: Schema.String,
  pattern: Schema.String,
  script: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/zones/{zone_id}/workers/routes" }),
).annotations({ identifier: "CreateRouteRequest" }) as unknown as Schema.Schema<CreateRouteRequest>;

export interface CreateRouteResponse {
  result: { id: unknown; pattern: string; script?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateRouteResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String,
  pattern: Schema.String,
  script: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateRouteResponse" }) as unknown as Schema.Schema<CreateRouteResponse>;

export const createRoute: (
  input: CreateRouteRequest
) => Effect.Effect<
  CreateRouteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateRouteRequest,
  output: CreateRouteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetRouteRequest {
  route_id: string;
  zone_id: string;
}

export const GetRouteRequest = Schema.Struct({
  route_id: Schema.String.pipe(T.HttpPath("route_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "GET", path: "/zones/{zone_id}/workers/routes/{route_id}" }),
).annotations({ identifier: "GetRouteRequest" }) as unknown as Schema.Schema<GetRouteRequest>;

export interface GetRouteResponse {
  result: { id: unknown; pattern: string; script?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetRouteResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String,
  pattern: Schema.String,
  script: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetRouteResponse" }) as unknown as Schema.Schema<GetRouteResponse>;

export const getRoute: (
  input: GetRouteRequest
) => Effect.Effect<
  GetRouteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRouteRequest,
  output: GetRouteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateRouteRequest {
  route_id: string;
  zone_id: string;
  body: { id: unknown; pattern: string; script?: string };
}

export const UpdateRouteRequest = Schema.Struct({
  route_id: Schema.String.pipe(T.HttpPath("route_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  body: Schema.Struct({
  id: Schema.String,
  pattern: Schema.String,
  script: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/zones/{zone_id}/workers/routes/{route_id}" }),
).annotations({ identifier: "UpdateRouteRequest" }) as unknown as Schema.Schema<UpdateRouteRequest>;

export interface UpdateRouteResponse {
  result: { id: unknown; pattern: string; script?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateRouteResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String,
  pattern: Schema.String,
  script: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateRouteResponse" }) as unknown as Schema.Schema<UpdateRouteResponse>;

export const updateRoute: (
  input: UpdateRouteRequest
) => Effect.Effect<
  UpdateRouteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateRouteRequest,
  output: UpdateRouteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteRouteRequest {
  route_id: string;
  zone_id: string;
}

export const DeleteRouteRequest = Schema.Struct({
  route_id: Schema.String.pipe(T.HttpPath("route_id")),
  zone_id: Schema.String.pipe(T.HttpPath("zone_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/zones/{zone_id}/workers/routes/{route_id}" }),
).annotations({ identifier: "DeleteRouteRequest" }) as unknown as Schema.Schema<DeleteRouteRequest>;

export interface DeleteRouteResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteRouteResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteRouteResponse" }) as unknown as Schema.Schema<DeleteRouteResponse>;

export const deleteRoute: (
  input: DeleteRouteRequest
) => Effect.Effect<
  DeleteRouteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteRouteRequest,
  output: DeleteRouteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));
