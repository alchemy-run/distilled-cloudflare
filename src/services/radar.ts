/**
 * Cloudflare RADAR API
 *
 * Generated from Cloudflare OpenAPI specification.
 * DO NOT EDIT - regenerate with: bun generate --service radar
 */

import * as Effect from "effect/Effect";
import * as Schema from "effect/Schema";
import type { HttpClient } from "@effect/platform";
import * as API from "../client/api.ts";
import * as T from "../traits.ts";
import type { ApiToken } from "../auth.ts";
import {
  CloudflareError,
  UnknownCloudflareError,
  CloudflareNetworkError,
  CloudflareHttpError,
} from "../errors.ts";

// =============================================================================
// Errors
// =============================================================================

export class AuthenticationError extends Schema.TaggedError<AuthenticationError>()(
  "AuthenticationError",
  {
    code: Schema.Number,
    message: Schema.String,
  },
) {
  static readonly _tag = "AuthenticationError";
}

export class InvalidToken extends Schema.TaggedError<InvalidToken>()("InvalidToken", {
  code: Schema.Number,
  message: Schema.String,
}) {
  static readonly _tag = "InvalidToken";
}

export class MissingToken extends Schema.TaggedError<MissingToken>()("MissingToken", {
  code: Schema.Number,
  message: Schema.String,
}) {
  static readonly _tag = "MissingToken";
}

export class RateLimited extends Schema.TaggedError<RateLimited>()("RateLimited", {
  code: Schema.Number,
  message: Schema.String,
}) {
  static readonly _tag = "RateLimited";
}

export class TokenExpired extends Schema.TaggedError<TokenExpired>()("TokenExpired", {
  code: Schema.Number,
  message: Schema.String,
}) {
  static readonly _tag = "TokenExpired";
}

export class TooManyRequests extends Schema.TaggedError<TooManyRequests>()("TooManyRequests", {
  code: Schema.Number,
  message: Schema.String,
}) {
  static readonly _tag = "TooManyRequests";
}

export class Unauthorized extends Schema.TaggedError<Unauthorized>()("Unauthorized", {
  code: Schema.Number,
  message: Schema.String,
}) {
  static readonly _tag = "Unauthorized";
}

export interface GetAiBotsSummaryByUserAgentRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAiBotsSummaryByUserAgentRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ai/bots/summary/user_agent" }))
  .annotations({
    identifier: "GetAiBotsSummaryByUserAgentRequest",
  }) as unknown as Schema.Schema<GetAiBotsSummaryByUserAgentRequest>;

export interface GetAiBotsSummaryByUserAgentResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAiBotsSummaryByUserAgentResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAiBotsSummaryByUserAgentResponse",
}) as unknown as Schema.Schema<GetAiBotsSummaryByUserAgentResponse>;

export const getAiBotsSummaryByUserAgent: (
  input: GetAiBotsSummaryByUserAgentRequest,
) => Effect.Effect<
  GetAiBotsSummaryByUserAgentResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAiBotsSummaryByUserAgentRequest,
  output: GetAiBotsSummaryByUserAgentResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAiBotsSummaryRequest {
  dimension: "USER_AGENT" | "CRAWL_PURPOSE" | "INDUSTRY" | "VERTICAL";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  crawlPurpose?: string[];
  vertical?: string[];
  industry?: string[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAiBotsSummaryRequest = Schema.Struct({
  dimension: Schema.Literal("USER_AGENT", "CRAWL_PURPOSE", "INDUSTRY", "VERTICAL").pipe(
    T.HttpPath("dimension"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  crawlPurpose: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("crawlPurpose")),
  vertical: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("vertical")),
  industry: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("industry")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ai/bots/summary/{dimension}" }))
  .annotations({
    identifier: "GetAiBotsSummaryRequest",
  }) as unknown as Schema.Schema<GetAiBotsSummaryRequest>;

export interface GetAiBotsSummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAiBotsSummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAiBotsSummaryResponse",
}) as unknown as Schema.Schema<GetAiBotsSummaryResponse>;

export const getAiBotsSummary: (
  input: GetAiBotsSummaryRequest,
) => Effect.Effect<
  GetAiBotsSummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAiBotsSummaryRequest,
  output: GetAiBotsSummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAiBotsTimeseriesRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  crawlPurpose?: string[];
  userAgent?: string[];
  industry?: string[];
  vertical?: string[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAiBotsTimeseriesRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  crawlPurpose: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("crawlPurpose")),
  userAgent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("userAgent")),
  industry: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("industry")),
  vertical: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("vertical")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ai/bots/timeseries" }))
  .annotations({
    identifier: "GetAiBotsTimeseriesRequest",
  }) as unknown as Schema.Schema<GetAiBotsTimeseriesRequest>;

export interface GetAiBotsTimeseriesResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAiBotsTimeseriesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAiBotsTimeseriesResponse",
}) as unknown as Schema.Schema<GetAiBotsTimeseriesResponse>;

export const getAiBotsTimeseries: (
  input: GetAiBotsTimeseriesRequest,
) => Effect.Effect<
  GetAiBotsTimeseriesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAiBotsTimeseriesRequest,
  output: GetAiBotsTimeseriesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAiBotsTimeseriesGroupByUserAgentRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAiBotsTimeseriesGroupByUserAgentRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ai/bots/timeseries_groups/user_agent" }))
  .annotations({
    identifier: "GetAiBotsTimeseriesGroupByUserAgentRequest",
  }) as unknown as Schema.Schema<GetAiBotsTimeseriesGroupByUserAgentRequest>;

export interface GetAiBotsTimeseriesGroupByUserAgentResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAiBotsTimeseriesGroupByUserAgentResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAiBotsTimeseriesGroupByUserAgentResponse",
}) as unknown as Schema.Schema<GetAiBotsTimeseriesGroupByUserAgentResponse>;

export const getAiBotsTimeseriesGroupByUserAgent: (
  input: GetAiBotsTimeseriesGroupByUserAgentRequest,
) => Effect.Effect<
  GetAiBotsTimeseriesGroupByUserAgentResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAiBotsTimeseriesGroupByUserAgentRequest,
  output: GetAiBotsTimeseriesGroupByUserAgentResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAiBotsTimeseriesGroupRequest {
  dimension: "USER_AGENT" | "CRAWL_PURPOSE" | "INDUSTRY" | "VERTICAL";
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  crawlPurpose?: string[];
  industry?: string[];
  vertical?: string[];
  limitPerGroup?: number;
  normalization?: "PERCENTAGE_CHANGE" | "MIN0_MAX";
  format?: "JSON" | "CSV";
}

export const GetAiBotsTimeseriesGroupRequest = Schema.Struct({
  dimension: Schema.Literal("USER_AGENT", "CRAWL_PURPOSE", "INDUSTRY", "VERTICAL").pipe(
    T.HttpPath("dimension"),
  ),
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  crawlPurpose: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("crawlPurpose")),
  industry: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("industry")),
  vertical: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("vertical")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE_CHANGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ai/bots/timeseries_groups/{dimension}" }))
  .annotations({
    identifier: "GetAiBotsTimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetAiBotsTimeseriesGroupRequest>;

export interface GetAiBotsTimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAiBotsTimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAiBotsTimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetAiBotsTimeseriesGroupResponse>;

export const getAiBotsTimeseriesGroup: (
  input: GetAiBotsTimeseriesGroupRequest,
) => Effect.Effect<
  GetAiBotsTimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAiBotsTimeseriesGroupRequest,
  output: GetAiBotsTimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAiInferenceSummaryByModelRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAiInferenceSummaryByModelRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ai/inference/summary/model" }))
  .annotations({
    identifier: "GetAiInferenceSummaryByModelRequest",
  }) as unknown as Schema.Schema<GetAiInferenceSummaryByModelRequest>;

export interface GetAiInferenceSummaryByModelResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAiInferenceSummaryByModelResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAiInferenceSummaryByModelResponse",
}) as unknown as Schema.Schema<GetAiInferenceSummaryByModelResponse>;

export const getAiInferenceSummaryByModel: (
  input: GetAiInferenceSummaryByModelRequest,
) => Effect.Effect<
  GetAiInferenceSummaryByModelResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAiInferenceSummaryByModelRequest,
  output: GetAiInferenceSummaryByModelResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAiInferenceSummaryByTaskRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAiInferenceSummaryByTaskRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ai/inference/summary/task" }))
  .annotations({
    identifier: "GetAiInferenceSummaryByTaskRequest",
  }) as unknown as Schema.Schema<GetAiInferenceSummaryByTaskRequest>;

export interface GetAiInferenceSummaryByTaskResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAiInferenceSummaryByTaskResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAiInferenceSummaryByTaskResponse",
}) as unknown as Schema.Schema<GetAiInferenceSummaryByTaskResponse>;

export const getAiInferenceSummaryByTask: (
  input: GetAiInferenceSummaryByTaskRequest,
) => Effect.Effect<
  GetAiInferenceSummaryByTaskResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAiInferenceSummaryByTaskRequest,
  output: GetAiInferenceSummaryByTaskResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAiInferenceSummaryRequest {
  dimension: "MODEL" | "TASK";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAiInferenceSummaryRequest = Schema.Struct({
  dimension: Schema.Literal("MODEL", "TASK").pipe(T.HttpPath("dimension")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ai/inference/summary/{dimension}" }))
  .annotations({
    identifier: "GetAiInferenceSummaryRequest",
  }) as unknown as Schema.Schema<GetAiInferenceSummaryRequest>;

export interface GetAiInferenceSummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAiInferenceSummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAiInferenceSummaryResponse",
}) as unknown as Schema.Schema<GetAiInferenceSummaryResponse>;

export const getAiInferenceSummary: (
  input: GetAiInferenceSummaryRequest,
) => Effect.Effect<
  GetAiInferenceSummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAiInferenceSummaryRequest,
  output: GetAiInferenceSummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAiInferenceTimeseriesGroupByModelRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAiInferenceTimeseriesGroupByModelRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ai/inference/timeseries_groups/model" }))
  .annotations({
    identifier: "GetAiInferenceTimeseriesGroupByModelRequest",
  }) as unknown as Schema.Schema<GetAiInferenceTimeseriesGroupByModelRequest>;

export interface GetAiInferenceTimeseriesGroupByModelResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAiInferenceTimeseriesGroupByModelResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAiInferenceTimeseriesGroupByModelResponse",
}) as unknown as Schema.Schema<GetAiInferenceTimeseriesGroupByModelResponse>;

export const getAiInferenceTimeseriesGroupByModel: (
  input: GetAiInferenceTimeseriesGroupByModelRequest,
) => Effect.Effect<
  GetAiInferenceTimeseriesGroupByModelResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAiInferenceTimeseriesGroupByModelRequest,
  output: GetAiInferenceTimeseriesGroupByModelResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAiInferenceTimeseriesGroupByTaskRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAiInferenceTimeseriesGroupByTaskRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ai/inference/timeseries_groups/task" }))
  .annotations({
    identifier: "GetAiInferenceTimeseriesGroupByTaskRequest",
  }) as unknown as Schema.Schema<GetAiInferenceTimeseriesGroupByTaskRequest>;

export interface GetAiInferenceTimeseriesGroupByTaskResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAiInferenceTimeseriesGroupByTaskResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAiInferenceTimeseriesGroupByTaskResponse",
}) as unknown as Schema.Schema<GetAiInferenceTimeseriesGroupByTaskResponse>;

export const getAiInferenceTimeseriesGroupByTask: (
  input: GetAiInferenceTimeseriesGroupByTaskRequest,
) => Effect.Effect<
  GetAiInferenceTimeseriesGroupByTaskResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAiInferenceTimeseriesGroupByTaskRequest,
  output: GetAiInferenceTimeseriesGroupByTaskResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAiInferenceTimeseriesGroupRequest {
  dimension: "MODEL" | "TASK";
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  limitPerGroup?: number;
  normalization?: "PERCENTAGE_CHANGE" | "MIN0_MAX";
  format?: "JSON" | "CSV";
}

export const GetAiInferenceTimeseriesGroupRequest = Schema.Struct({
  dimension: Schema.Literal("MODEL", "TASK").pipe(T.HttpPath("dimension")),
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE_CHANGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ai/inference/timeseries_groups/{dimension}" }))
  .annotations({
    identifier: "GetAiInferenceTimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetAiInferenceTimeseriesGroupRequest>;

export interface GetAiInferenceTimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAiInferenceTimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAiInferenceTimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetAiInferenceTimeseriesGroupResponse>;

export const getAiInferenceTimeseriesGroup: (
  input: GetAiInferenceTimeseriesGroupRequest,
) => Effect.Effect<
  GetAiInferenceTimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAiInferenceTimeseriesGroupRequest,
  output: GetAiInferenceTimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAnnotationsRequest {
  limit?: number;
  offset?: number;
  dateRange?: string;
  dateStart?: string;
  dateEnd?: string;
  dataSource?:
    | "ALL"
    | "AI_BOTS"
    | "AI_GATEWAY"
    | "BGP"
    | "BOTS"
    | "CONNECTION_ANOMALY"
    | "CT"
    | "DNS"
    | "DNS_MAGNITUDE"
    | "DNS_AS112"
    | "DOS"
    | "EMAIL_ROUTING"
    | "EMAIL_SECURITY"
    | "FW"
    | "FW_PG"
    | "HTTP"
    | "HTTP_CONTROL"
    | "HTTP_CRAWLER_REFERER"
    | "HTTP_ORIGINS"
    | "IQI"
    | "LEAKED_CREDENTIALS"
    | "NET"
    | "ROBOTS_TXT"
    | "SPEED"
    | "WORKERS_AI";
  eventType?:
    | "EVENT"
    | "GENERAL"
    | "OUTAGE"
    | "PARTIAL_PROJECTION"
    | "PIPELINE"
    | "TRAFFIC_ANOMALY";
  asn?: number;
  location?: string;
  origin?: string;
  format?: "JSON" | "CSV";
}

export const GetAnnotationsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset")),
  dateRange: Schema.optional(Schema.String).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Date).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Date).pipe(T.HttpQuery("dateEnd")),
  dataSource: Schema.optional(
    Schema.Literal(
      "ALL",
      "AI_BOTS",
      "AI_GATEWAY",
      "BGP",
      "BOTS",
      "CONNECTION_ANOMALY",
      "CT",
      "DNS",
      "DNS_MAGNITUDE",
      "DNS_AS112",
      "DOS",
      "EMAIL_ROUTING",
      "EMAIL_SECURITY",
      "FW",
      "FW_PG",
      "HTTP",
      "HTTP_CONTROL",
      "HTTP_CRAWLER_REFERER",
      "HTTP_ORIGINS",
      "IQI",
      "LEAKED_CREDENTIALS",
      "NET",
      "ROBOTS_TXT",
      "SPEED",
      "WORKERS_AI",
    ),
  ).pipe(T.HttpQuery("dataSource")),
  eventType: Schema.optional(
    Schema.Literal(
      "EVENT",
      "GENERAL",
      "OUTAGE",
      "PARTIAL_PROJECTION",
      "PIPELINE",
      "TRAFFIC_ANOMALY",
    ),
  ).pipe(T.HttpQuery("eventType")),
  asn: Schema.optional(Schema.Number).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.String).pipe(T.HttpQuery("location")),
  origin: Schema.optional(Schema.String).pipe(T.HttpQuery("origin")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/annotations" }))
  .annotations({
    identifier: "GetAnnotationsRequest",
  }) as unknown as Schema.Schema<GetAnnotationsRequest>;

export interface GetAnnotationsResponse {
  result: {
    annotations: {
      asns: number[];
      asnsDetails: { asn: string; locations?: { code: string; name: string }; name: string }[];
      dataSource: string;
      description?: string;
      endDate?: string;
      eventType: string;
      id: string;
      linkedUrl?: string;
      locations: string[];
      locationsDetails: { code: string; name: string }[];
      origins: string[];
      originsDetails: { name: string; origin: string }[];
      outage: { outageCause: string; outageType: string };
      scope?: string;
      startDate: string;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAnnotationsResponse = Schema.Struct({
  result: Schema.Struct({
    annotations: Schema.Array(
      Schema.Struct({
        asns: Schema.Array(Schema.Number),
        asnsDetails: Schema.Array(
          Schema.Struct({
            asn: Schema.String,
            locations: Schema.optional(
              Schema.NullOr(
                Schema.Struct({
                  code: Schema.String,
                  name: Schema.String,
                }),
              ),
            ),
            name: Schema.String,
          }),
        ),
        dataSource: Schema.String,
        description: Schema.optional(Schema.NullOr(Schema.String)),
        endDate: Schema.optional(Schema.NullOr(Schema.String)),
        eventType: Schema.String,
        id: Schema.String,
        linkedUrl: Schema.optional(Schema.NullOr(Schema.String)),
        locations: Schema.Array(Schema.String),
        locationsDetails: Schema.Array(
          Schema.Struct({
            code: Schema.String,
            name: Schema.String,
          }),
        ),
        origins: Schema.Array(Schema.String),
        originsDetails: Schema.Array(
          Schema.Struct({
            name: Schema.String,
            origin: Schema.String,
          }),
        ),
        outage: Schema.Struct({
          outageCause: Schema.String,
          outageType: Schema.String,
        }),
        scope: Schema.optional(Schema.NullOr(Schema.String)),
        startDate: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAnnotationsResponse",
}) as unknown as Schema.Schema<GetAnnotationsResponse>;

export const getAnnotations: (
  input: GetAnnotationsRequest,
) => Effect.Effect<
  GetAnnotationsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAnnotationsRequest,
  output: GetAnnotationsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAnnotationsOutagesRequest {
  limit?: number;
  offset?: number;
  dateRange?: string;
  dateStart?: string;
  dateEnd?: string;
  asn?: number;
  location?: string;
  origin?: string;
  format?: "JSON" | "CSV";
}

export const GetAnnotationsOutagesRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset")),
  dateRange: Schema.optional(Schema.String).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Date).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Date).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Number).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.String).pipe(T.HttpQuery("location")),
  origin: Schema.optional(Schema.String).pipe(T.HttpQuery("origin")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/annotations/outages" }))
  .annotations({
    identifier: "GetAnnotationsOutagesRequest",
  }) as unknown as Schema.Schema<GetAnnotationsOutagesRequest>;

export interface GetAnnotationsOutagesResponse {
  result: {
    annotations: {
      asns: number[];
      asnsDetails: { asn: string; locations?: { code: string; name: string }; name: string }[];
      dataSource: string;
      description?: string;
      endDate?: string;
      eventType: string;
      id: string;
      linkedUrl?: string;
      locations: string[];
      locationsDetails: { code: string; name: string }[];
      origins: string[];
      originsDetails: { name: string; origin: string }[];
      outage: { outageCause: string; outageType: string };
      scope?: string;
      startDate: string;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAnnotationsOutagesResponse = Schema.Struct({
  result: Schema.Struct({
    annotations: Schema.Array(
      Schema.Struct({
        asns: Schema.Array(Schema.Number),
        asnsDetails: Schema.Array(
          Schema.Struct({
            asn: Schema.String,
            locations: Schema.optional(
              Schema.NullOr(
                Schema.Struct({
                  code: Schema.String,
                  name: Schema.String,
                }),
              ),
            ),
            name: Schema.String,
          }),
        ),
        dataSource: Schema.String,
        description: Schema.optional(Schema.NullOr(Schema.String)),
        endDate: Schema.optional(Schema.NullOr(Schema.Date)),
        eventType: Schema.String,
        id: Schema.String,
        linkedUrl: Schema.optional(Schema.NullOr(Schema.String)),
        locations: Schema.Array(Schema.String),
        locationsDetails: Schema.Array(
          Schema.Struct({
            code: Schema.String,
            name: Schema.String,
          }),
        ),
        origins: Schema.Array(Schema.String),
        originsDetails: Schema.Array(
          Schema.Struct({
            name: Schema.String,
            origin: Schema.String,
          }),
        ),
        outage: Schema.Struct({
          outageCause: Schema.String,
          outageType: Schema.String,
        }),
        scope: Schema.optional(Schema.NullOr(Schema.String)),
        startDate: Schema.Date,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAnnotationsOutagesResponse",
}) as unknown as Schema.Schema<GetAnnotationsOutagesResponse>;

export const getAnnotationsOutages: (
  input: GetAnnotationsOutagesRequest,
) => Effect.Effect<
  GetAnnotationsOutagesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAnnotationsOutagesRequest,
  output: GetAnnotationsOutagesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAnnotationsOutagesTopRequest {
  limit?: number;
  dateRange?: string;
  dateStart?: string;
  dateEnd?: string;
  format?: "JSON" | "CSV";
}

export const GetAnnotationsOutagesTopRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  dateRange: Schema.optional(Schema.String).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Date).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Date).pipe(T.HttpQuery("dateEnd")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/annotations/outages/locations" }))
  .annotations({
    identifier: "GetAnnotationsOutagesTopRequest",
  }) as unknown as Schema.Schema<GetAnnotationsOutagesTopRequest>;

export interface GetAnnotationsOutagesTopResponse {
  result: {
    annotations: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAnnotationsOutagesTopResponse = Schema.Struct({
  result: Schema.Struct({
    annotations: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAnnotationsOutagesTopResponse",
}) as unknown as Schema.Schema<GetAnnotationsOutagesTopResponse>;

export const getAnnotationsOutagesTop: (
  input: GetAnnotationsOutagesTopRequest,
) => Effect.Effect<
  GetAnnotationsOutagesTopResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAnnotationsOutagesTopRequest,
  output: GetAnnotationsOutagesTopResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TimeseriesByDnssecRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TimeseriesByDnssecRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/summary/dnssec" }))
  .annotations({
    identifier: "GetDnsAs112TimeseriesByDnssecRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TimeseriesByDnssecRequest>;

export interface GetDnsAs112TimeseriesByDnssecResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { NOT_SUPPORTED: string; SUPPORTED: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TimeseriesByDnssecResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      NOT_SUPPORTED: Schema.String,
      SUPPORTED: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TimeseriesByDnssecResponse",
}) as unknown as Schema.Schema<GetDnsAs112TimeseriesByDnssecResponse>;

export const getDnsAs112TimeseriesByDnssec: (
  input: GetDnsAs112TimeseriesByDnssecRequest,
) => Effect.Effect<
  GetDnsAs112TimeseriesByDnssecResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TimeseriesByDnssecRequest,
  output: GetDnsAs112TimeseriesByDnssecResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TimeseriesByEdnsRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TimeseriesByEdnsRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/summary/edns" }))
  .annotations({
    identifier: "GetDnsAs112TimeseriesByEdnsRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TimeseriesByEdnsRequest>;

export interface GetDnsAs112TimeseriesByEdnsResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { NOT_SUPPORTED: string; SUPPORTED: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TimeseriesByEdnsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      NOT_SUPPORTED: Schema.String,
      SUPPORTED: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TimeseriesByEdnsResponse",
}) as unknown as Schema.Schema<GetDnsAs112TimeseriesByEdnsResponse>;

export const getDnsAs112TimeseriesByEdns: (
  input: GetDnsAs112TimeseriesByEdnsRequest,
) => Effect.Effect<
  GetDnsAs112TimeseriesByEdnsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TimeseriesByEdnsRequest,
  output: GetDnsAs112TimeseriesByEdnsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TimeseriesByIpVersionRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TimeseriesByIpVersionRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/summary/ip_version" }))
  .annotations({
    identifier: "GetDnsAs112TimeseriesByIpVersionRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TimeseriesByIpVersionRequest>;

export interface GetDnsAs112TimeseriesByIpVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { IPv4: string; IPv6: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TimeseriesByIpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      IPv4: Schema.String,
      IPv6: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TimeseriesByIpVersionResponse",
}) as unknown as Schema.Schema<GetDnsAs112TimeseriesByIpVersionResponse>;

export const getDnsAs112TimeseriesByIpVersion: (
  input: GetDnsAs112TimeseriesByIpVersionRequest,
) => Effect.Effect<
  GetDnsAs112TimeseriesByIpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TimeseriesByIpVersionRequest,
  output: GetDnsAs112TimeseriesByIpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TimeseriesByProtocolRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TimeseriesByProtocolRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/summary/protocol" }))
  .annotations({
    identifier: "GetDnsAs112TimeseriesByProtocolRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TimeseriesByProtocolRequest>;

export interface GetDnsAs112TimeseriesByProtocolResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { HTTPS: string; TCP: string; TLS: string; UDP: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TimeseriesByProtocolResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      HTTPS: Schema.String,
      TCP: Schema.String,
      TLS: Schema.String,
      UDP: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TimeseriesByProtocolResponse",
}) as unknown as Schema.Schema<GetDnsAs112TimeseriesByProtocolResponse>;

export const getDnsAs112TimeseriesByProtocol: (
  input: GetDnsAs112TimeseriesByProtocolRequest,
) => Effect.Effect<
  GetDnsAs112TimeseriesByProtocolResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TimeseriesByProtocolRequest,
  output: GetDnsAs112TimeseriesByProtocolResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TimeseriesByQueryTypeRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TimeseriesByQueryTypeRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/summary/query_type" }))
  .annotations({
    identifier: "GetDnsAs112TimeseriesByQueryTypeRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TimeseriesByQueryTypeRequest>;

export interface GetDnsAs112TimeseriesByQueryTypeResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TimeseriesByQueryTypeResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TimeseriesByQueryTypeResponse",
}) as unknown as Schema.Schema<GetDnsAs112TimeseriesByQueryTypeResponse>;

export const getDnsAs112TimeseriesByQueryType: (
  input: GetDnsAs112TimeseriesByQueryTypeRequest,
) => Effect.Effect<
  GetDnsAs112TimeseriesByQueryTypeResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TimeseriesByQueryTypeRequest,
  output: GetDnsAs112TimeseriesByQueryTypeResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TimeseriesByResponseCodesRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TimeseriesByResponseCodesRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/summary/response_codes" }))
  .annotations({
    identifier: "GetDnsAs112TimeseriesByResponseCodesRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TimeseriesByResponseCodesRequest>;

export interface GetDnsAs112TimeseriesByResponseCodesResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TimeseriesByResponseCodesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TimeseriesByResponseCodesResponse",
}) as unknown as Schema.Schema<GetDnsAs112TimeseriesByResponseCodesResponse>;

export const getDnsAs112TimeseriesByResponseCodes: (
  input: GetDnsAs112TimeseriesByResponseCodesRequest,
) => Effect.Effect<
  GetDnsAs112TimeseriesByResponseCodesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TimeseriesByResponseCodesRequest,
  output: GetDnsAs112TimeseriesByResponseCodesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112SummaryRequest {
  dimension: "DNSSEC" | "EDNS" | "IP_VERSION" | "PROTOCOL" | "QUERY_TYPE" | "RESPONSE_CODE";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetDnsAs112SummaryRequest = Schema.Struct({
  dimension: Schema.Literal(
    "DNSSEC",
    "EDNS",
    "IP_VERSION",
    "PROTOCOL",
    "QUERY_TYPE",
    "RESPONSE_CODE",
  ).pipe(T.HttpPath("dimension")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/summary/{dimension}" }))
  .annotations({
    identifier: "GetDnsAs112SummaryRequest",
  }) as unknown as Schema.Schema<GetDnsAs112SummaryRequest>;

export interface GetDnsAs112SummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112SummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112SummaryResponse",
}) as unknown as Schema.Schema<GetDnsAs112SummaryResponse>;

export const getDnsAs112Summary: (
  input: GetDnsAs112SummaryRequest,
) => Effect.Effect<
  GetDnsAs112SummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112SummaryRequest,
  output: GetDnsAs112SummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TimeseriesRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TimeseriesRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/timeseries" }))
  .annotations({
    identifier: "GetDnsAs112TimeseriesRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TimeseriesRequest>;

export interface GetDnsAs112TimeseriesResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TimeseriesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TimeseriesResponse",
}) as unknown as Schema.Schema<GetDnsAs112TimeseriesResponse>;

export const getDnsAs112Timeseries: (
  input: GetDnsAs112TimeseriesRequest,
) => Effect.Effect<
  GetDnsAs112TimeseriesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TimeseriesRequest,
  output: GetDnsAs112TimeseriesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TimeseriesGroupByDnssecRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TimeseriesGroupByDnssecRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/timeseries_groups/dnssec" }))
  .annotations({
    identifier: "GetDnsAs112TimeseriesGroupByDnssecRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TimeseriesGroupByDnssecRequest>;

export interface GetDnsAs112TimeseriesGroupByDnssecResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { NOT_SUPPORTED: string[]; SUPPORTED: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TimeseriesGroupByDnssecResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      NOT_SUPPORTED: Schema.Array(Schema.String),
      SUPPORTED: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TimeseriesGroupByDnssecResponse",
}) as unknown as Schema.Schema<GetDnsAs112TimeseriesGroupByDnssecResponse>;

export const getDnsAs112TimeseriesGroupByDnssec: (
  input: GetDnsAs112TimeseriesGroupByDnssecRequest,
) => Effect.Effect<
  GetDnsAs112TimeseriesGroupByDnssecResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TimeseriesGroupByDnssecRequest,
  output: GetDnsAs112TimeseriesGroupByDnssecResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TimeseriesGroupByEdnsRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TimeseriesGroupByEdnsRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/timeseries_groups/edns" }))
  .annotations({
    identifier: "GetDnsAs112TimeseriesGroupByEdnsRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TimeseriesGroupByEdnsRequest>;

export interface GetDnsAs112TimeseriesGroupByEdnsResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { NOT_SUPPORTED: string[]; SUPPORTED: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TimeseriesGroupByEdnsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      NOT_SUPPORTED: Schema.Array(Schema.String),
      SUPPORTED: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TimeseriesGroupByEdnsResponse",
}) as unknown as Schema.Schema<GetDnsAs112TimeseriesGroupByEdnsResponse>;

export const getDnsAs112TimeseriesGroupByEdns: (
  input: GetDnsAs112TimeseriesGroupByEdnsRequest,
) => Effect.Effect<
  GetDnsAs112TimeseriesGroupByEdnsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TimeseriesGroupByEdnsRequest,
  output: GetDnsAs112TimeseriesGroupByEdnsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TimeseriesGroupByIpVersionRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TimeseriesGroupByIpVersionRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/timeseries_groups/ip_version" }))
  .annotations({
    identifier: "GetDnsAs112TimeseriesGroupByIpVersionRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TimeseriesGroupByIpVersionRequest>;

export interface GetDnsAs112TimeseriesGroupByIpVersionResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { IPv4: string[]; IPv6: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TimeseriesGroupByIpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      IPv4: Schema.Array(Schema.String),
      IPv6: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TimeseriesGroupByIpVersionResponse",
}) as unknown as Schema.Schema<GetDnsAs112TimeseriesGroupByIpVersionResponse>;

export const getDnsAs112TimeseriesGroupByIpVersion: (
  input: GetDnsAs112TimeseriesGroupByIpVersionRequest,
) => Effect.Effect<
  GetDnsAs112TimeseriesGroupByIpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TimeseriesGroupByIpVersionRequest,
  output: GetDnsAs112TimeseriesGroupByIpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TimeseriesGroupByProtocolRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TimeseriesGroupByProtocolRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/timeseries_groups/protocol" }))
  .annotations({
    identifier: "GetDnsAs112TimeseriesGroupByProtocolRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TimeseriesGroupByProtocolRequest>;

export interface GetDnsAs112TimeseriesGroupByProtocolResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { HTTPS: string[]; TCP: string[]; TLS: string[]; UDP: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TimeseriesGroupByProtocolResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      HTTPS: Schema.Array(Schema.String),
      TCP: Schema.Array(Schema.String),
      TLS: Schema.Array(Schema.String),
      UDP: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TimeseriesGroupByProtocolResponse",
}) as unknown as Schema.Schema<GetDnsAs112TimeseriesGroupByProtocolResponse>;

export const getDnsAs112TimeseriesGroupByProtocol: (
  input: GetDnsAs112TimeseriesGroupByProtocolRequest,
) => Effect.Effect<
  GetDnsAs112TimeseriesGroupByProtocolResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TimeseriesGroupByProtocolRequest,
  output: GetDnsAs112TimeseriesGroupByProtocolResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TimeseriesGroupByQueryTypeRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TimeseriesGroupByQueryTypeRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/timeseries_groups/query_type" }))
  .annotations({
    identifier: "GetDnsAs112TimeseriesGroupByQueryTypeRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TimeseriesGroupByQueryTypeRequest>;

export interface GetDnsAs112TimeseriesGroupByQueryTypeResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TimeseriesGroupByQueryTypeResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TimeseriesGroupByQueryTypeResponse",
}) as unknown as Schema.Schema<GetDnsAs112TimeseriesGroupByQueryTypeResponse>;

export const getDnsAs112TimeseriesGroupByQueryType: (
  input: GetDnsAs112TimeseriesGroupByQueryTypeRequest,
) => Effect.Effect<
  GetDnsAs112TimeseriesGroupByQueryTypeResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TimeseriesGroupByQueryTypeRequest,
  output: GetDnsAs112TimeseriesGroupByQueryTypeResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TimeseriesGroupByResponseCodesRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TimeseriesGroupByResponseCodesRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/timeseries_groups/response_codes" }))
  .annotations({
    identifier: "GetDnsAs112TimeseriesGroupByResponseCodesRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TimeseriesGroupByResponseCodesRequest>;

export interface GetDnsAs112TimeseriesGroupByResponseCodesResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TimeseriesGroupByResponseCodesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TimeseriesGroupByResponseCodesResponse",
}) as unknown as Schema.Schema<GetDnsAs112TimeseriesGroupByResponseCodesResponse>;

export const getDnsAs112TimeseriesGroupByResponseCodes: (
  input: GetDnsAs112TimeseriesGroupByResponseCodesRequest,
) => Effect.Effect<
  GetDnsAs112TimeseriesGroupByResponseCodesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TimeseriesGroupByResponseCodesRequest,
  output: GetDnsAs112TimeseriesGroupByResponseCodesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TimeseriesGroupRequest {
  dimension: "DNSSEC" | "EDNS" | "IP_VERSION" | "PROTOCOL" | "QUERY_TYPE" | "RESPONSE_CODE";
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TimeseriesGroupRequest = Schema.Struct({
  dimension: Schema.Literal(
    "DNSSEC",
    "EDNS",
    "IP_VERSION",
    "PROTOCOL",
    "QUERY_TYPE",
    "RESPONSE_CODE",
  ).pipe(T.HttpPath("dimension")),
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/timeseries_groups/{dimension}" }))
  .annotations({
    identifier: "GetDnsAs112TimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TimeseriesGroupRequest>;

export interface GetDnsAs112TimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetDnsAs112TimeseriesGroupResponse>;

export const getDnsAs112TimeseriesGroup: (
  input: GetDnsAs112TimeseriesGroupRequest,
) => Effect.Effect<
  GetDnsAs112TimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TimeseriesGroupRequest,
  output: GetDnsAs112TimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TopLocationsRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TopLocationsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/top/locations" }))
  .annotations({
    identifier: "GetDnsAs112TopLocationsRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TopLocationsRequest>;

export interface GetDnsAs112TopLocationsResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TopLocationsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TopLocationsResponse",
}) as unknown as Schema.Schema<GetDnsAs112TopLocationsResponse>;

export const getDnsAs112TopLocations: (
  input: GetDnsAs112TopLocationsRequest,
) => Effect.Effect<
  GetDnsAs112TopLocationsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TopLocationsRequest,
  output: GetDnsAs112TopLocationsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TopLocationsByDnssecRequest {
  dnssec: "SUPPORTED" | "NOT_SUPPORTED";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TopLocationsByDnssecRequest = Schema.Struct({
  dnssec: Schema.Literal("SUPPORTED", "NOT_SUPPORTED").pipe(T.HttpPath("dnssec")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/top/locations/dnssec/{dnssec}" }))
  .annotations({
    identifier: "GetDnsAs112TopLocationsByDnssecRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TopLocationsByDnssecRequest>;

export interface GetDnsAs112TopLocationsByDnssecResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TopLocationsByDnssecResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TopLocationsByDnssecResponse",
}) as unknown as Schema.Schema<GetDnsAs112TopLocationsByDnssecResponse>;

export const getDnsAs112TopLocationsByDnssec: (
  input: GetDnsAs112TopLocationsByDnssecRequest,
) => Effect.Effect<
  GetDnsAs112TopLocationsByDnssecResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TopLocationsByDnssecRequest,
  output: GetDnsAs112TopLocationsByDnssecResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TopLocationsByEdnsRequest {
  edns: "SUPPORTED" | "NOT_SUPPORTED";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TopLocationsByEdnsRequest = Schema.Struct({
  edns: Schema.Literal("SUPPORTED", "NOT_SUPPORTED").pipe(T.HttpPath("edns")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/top/locations/edns/{edns}" }))
  .annotations({
    identifier: "GetDnsAs112TopLocationsByEdnsRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TopLocationsByEdnsRequest>;

export interface GetDnsAs112TopLocationsByEdnsResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TopLocationsByEdnsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TopLocationsByEdnsResponse",
}) as unknown as Schema.Schema<GetDnsAs112TopLocationsByEdnsResponse>;

export const getDnsAs112TopLocationsByEdns: (
  input: GetDnsAs112TopLocationsByEdnsRequest,
) => Effect.Effect<
  GetDnsAs112TopLocationsByEdnsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TopLocationsByEdnsRequest,
  output: GetDnsAs112TopLocationsByEdnsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsAs112TopLocationsByIpVersionRequest {
  ip_version: "IPv4" | "IPv6";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  format?: "JSON" | "CSV";
}

export const GetDnsAs112TopLocationsByIpVersionRequest = Schema.Struct({
  ip_version: Schema.Literal("IPv4", "IPv6").pipe(T.HttpPath("ip_version")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/as112/top/locations/ip_version/{ip_version}" }))
  .annotations({
    identifier: "GetDnsAs112TopLocationsByIpVersionRequest",
  }) as unknown as Schema.Schema<GetDnsAs112TopLocationsByIpVersionRequest>;

export interface GetDnsAs112TopLocationsByIpVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsAs112TopLocationsByIpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsAs112TopLocationsByIpVersionResponse",
}) as unknown as Schema.Schema<GetDnsAs112TopLocationsByIpVersionResponse>;

export const getDnsAs112TopLocationsByIpVersion: (
  input: GetDnsAs112TopLocationsByIpVersionRequest,
) => Effect.Effect<
  GetDnsAs112TopLocationsByIpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsAs112TopLocationsByIpVersionRequest,
  output: GetDnsAs112TopLocationsByIpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3SummaryByBitrateRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  direction?: "ORIGIN" | "TARGET";
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3SummaryByBitrateRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/summary/bitrate" }))
  .annotations({
    identifier: "GetAttacksLayer3SummaryByBitrateRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3SummaryByBitrateRequest>;

export interface GetAttacksLayer3SummaryByBitrateResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: {
      OVER_100_GBPS: string;
      UNDER_500_MBPS: string;
      _10_GBPS_TO_100_GBPS: string;
      _1_GBPS_TO_10_GBPS: string;
      _500_MBPS_TO_1_GBPS: string;
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3SummaryByBitrateResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      OVER_100_GBPS: Schema.String,
      UNDER_500_MBPS: Schema.String,
      _10_GBPS_TO_100_GBPS: Schema.String,
      _1_GBPS_TO_10_GBPS: Schema.String,
      _500_MBPS_TO_1_GBPS: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3SummaryByBitrateResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3SummaryByBitrateResponse>;

export const getAttacksLayer3SummaryByBitrate: (
  input: GetAttacksLayer3SummaryByBitrateRequest,
) => Effect.Effect<
  GetAttacksLayer3SummaryByBitrateResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3SummaryByBitrateRequest,
  output: GetAttacksLayer3SummaryByBitrateResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3SummaryByDurationRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  direction?: "ORIGIN" | "TARGET";
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3SummaryByDurationRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/summary/duration" }))
  .annotations({
    identifier: "GetAttacksLayer3SummaryByDurationRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3SummaryByDurationRequest>;

export interface GetAttacksLayer3SummaryByDurationResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: {
      OVER_3_HOURS: string;
      UNDER_10_MINS: string;
      _10_MINS_TO_20_MINS: string;
      _1_HOUR_TO_3_HOURS: string;
      _20_MINS_TO_40_MINS: string;
      _40_MINS_TO_1_HOUR: string;
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3SummaryByDurationResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      OVER_3_HOURS: Schema.String,
      UNDER_10_MINS: Schema.String,
      _10_MINS_TO_20_MINS: Schema.String,
      _1_HOUR_TO_3_HOURS: Schema.String,
      _20_MINS_TO_40_MINS: Schema.String,
      _40_MINS_TO_1_HOUR: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3SummaryByDurationResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3SummaryByDurationResponse>;

export const getAttacksLayer3SummaryByDuration: (
  input: GetAttacksLayer3SummaryByDurationRequest,
) => Effect.Effect<
  GetAttacksLayer3SummaryByDurationResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3SummaryByDurationRequest,
  output: GetAttacksLayer3SummaryByDurationResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3SummaryByIndustryRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  direction?: "ORIGIN" | "TARGET";
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3SummaryByIndustryRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/summary/industry" }))
  .annotations({
    identifier: "GetAttacksLayer3SummaryByIndustryRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3SummaryByIndustryRequest>;

export interface GetAttacksLayer3SummaryByIndustryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3SummaryByIndustryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3SummaryByIndustryResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3SummaryByIndustryResponse>;

export const getAttacksLayer3SummaryByIndustry: (
  input: GetAttacksLayer3SummaryByIndustryRequest,
) => Effect.Effect<
  GetAttacksLayer3SummaryByIndustryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3SummaryByIndustryRequest,
  output: GetAttacksLayer3SummaryByIndustryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3SummaryByIpVersionRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  direction?: "ORIGIN" | "TARGET";
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3SummaryByIpVersionRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/summary/ip_version" }))
  .annotations({
    identifier: "GetAttacksLayer3SummaryByIpVersionRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3SummaryByIpVersionRequest>;

export interface GetAttacksLayer3SummaryByIpVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { IPv4: string; IPv6: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3SummaryByIpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      IPv4: Schema.String,
      IPv6: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3SummaryByIpVersionResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3SummaryByIpVersionResponse>;

export const getAttacksLayer3SummaryByIpVersion: (
  input: GetAttacksLayer3SummaryByIpVersionRequest,
) => Effect.Effect<
  GetAttacksLayer3SummaryByIpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3SummaryByIpVersionRequest,
  output: GetAttacksLayer3SummaryByIpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3SummaryByProtocolRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  direction?: "ORIGIN" | "TARGET";
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3SummaryByProtocolRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/summary/protocol" }))
  .annotations({
    identifier: "GetAttacksLayer3SummaryByProtocolRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3SummaryByProtocolRequest>;

export interface GetAttacksLayer3SummaryByProtocolResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { GRE: string; ICMP: string; TCP: string; UDP: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3SummaryByProtocolResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      GRE: Schema.String,
      ICMP: Schema.String,
      TCP: Schema.String,
      UDP: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3SummaryByProtocolResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3SummaryByProtocolResponse>;

export const getAttacksLayer3SummaryByProtocol: (
  input: GetAttacksLayer3SummaryByProtocolRequest,
) => Effect.Effect<
  GetAttacksLayer3SummaryByProtocolResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3SummaryByProtocolRequest,
  output: GetAttacksLayer3SummaryByProtocolResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3SummaryByVectorRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  direction?: "ORIGIN" | "TARGET";
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3SummaryByVectorRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/summary/vector" }))
  .annotations({
    identifier: "GetAttacksLayer3SummaryByVectorRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3SummaryByVectorRequest>;

export interface GetAttacksLayer3SummaryByVectorResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3SummaryByVectorResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3SummaryByVectorResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3SummaryByVectorResponse>;

export const getAttacksLayer3SummaryByVector: (
  input: GetAttacksLayer3SummaryByVectorRequest,
) => Effect.Effect<
  GetAttacksLayer3SummaryByVectorResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3SummaryByVectorRequest,
  output: GetAttacksLayer3SummaryByVectorResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3SummaryByVerticalRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  direction?: "ORIGIN" | "TARGET";
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3SummaryByVerticalRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/summary/vertical" }))
  .annotations({
    identifier: "GetAttacksLayer3SummaryByVerticalRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3SummaryByVerticalRequest>;

export interface GetAttacksLayer3SummaryByVerticalResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3SummaryByVerticalResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3SummaryByVerticalResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3SummaryByVerticalResponse>;

export const getAttacksLayer3SummaryByVertical: (
  input: GetAttacksLayer3SummaryByVerticalRequest,
) => Effect.Effect<
  GetAttacksLayer3SummaryByVerticalResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3SummaryByVerticalRequest,
  output: GetAttacksLayer3SummaryByVerticalResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3SummaryRequest {
  dimension:
    | "PROTOCOL"
    | "IP_VERSION"
    | "VECTOR"
    | "DURATION"
    | "BITRATE"
    | "VERTICAL"
    | "INDUSTRY";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  direction?: "ORIGIN" | "TARGET";
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3SummaryRequest = Schema.Struct({
  dimension: Schema.Literal(
    "PROTOCOL",
    "IP_VERSION",
    "VECTOR",
    "DURATION",
    "BITRATE",
    "VERTICAL",
    "INDUSTRY",
  ).pipe(T.HttpPath("dimension")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/summary/{dimension}" }))
  .annotations({
    identifier: "GetAttacksLayer3SummaryRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3SummaryRequest>;

export interface GetAttacksLayer3SummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3SummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3SummaryResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3SummaryResponse>;

export const getAttacksLayer3Summary: (
  input: GetAttacksLayer3SummaryRequest,
) => Effect.Effect<
  GetAttacksLayer3SummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3SummaryRequest,
  output: GetAttacksLayer3SummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3TimeseriesByBytesRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  normalization?: "PERCENTAGE_CHANGE" | "MIN0_MAX";
  metric?: "BYTES" | "BYTES_OLD";
  direction?: "ORIGIN" | "TARGET";
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3TimeseriesByBytesRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE_CHANGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  metric: Schema.optional(Schema.Literal("BYTES", "BYTES_OLD")).pipe(T.HttpQuery("metric")),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/timeseries" }))
  .annotations({
    identifier: "GetAttacksLayer3TimeseriesByBytesRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesByBytesRequest>;

export interface GetAttacksLayer3TimeseriesByBytesResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3TimeseriesByBytesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3TimeseriesByBytesResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesByBytesResponse>;

export const getAttacksLayer3TimeseriesByBytes: (
  input: GetAttacksLayer3TimeseriesByBytesRequest,
) => Effect.Effect<
  GetAttacksLayer3TimeseriesByBytesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3TimeseriesByBytesRequest,
  output: GetAttacksLayer3TimeseriesByBytesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3TimeseriesGroupByBitrateRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  direction?: "ORIGIN" | "TARGET";
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3TimeseriesGroupByBitrateRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/timeseries_groups/bitrate" }))
  .annotations({
    identifier: "GetAttacksLayer3TimeseriesGroupByBitrateRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesGroupByBitrateRequest>;

export interface GetAttacksLayer3TimeseriesGroupByBitrateResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: {
      OVER_100_GBPS: string[];
      UNDER_500_MBPS: string[];
      _10_GBPS_TO_100_GBPS: string[];
      _1_GBPS_TO_10_GBPS: string[];
      _500_MBPS_TO_1_GBPS: string[];
      timestamps: string[];
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3TimeseriesGroupByBitrateResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      OVER_100_GBPS: Schema.Array(Schema.String),
      UNDER_500_MBPS: Schema.Array(Schema.String),
      _10_GBPS_TO_100_GBPS: Schema.Array(Schema.String),
      _1_GBPS_TO_10_GBPS: Schema.Array(Schema.String),
      _500_MBPS_TO_1_GBPS: Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3TimeseriesGroupByBitrateResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesGroupByBitrateResponse>;

export const getAttacksLayer3TimeseriesGroupByBitrate: (
  input: GetAttacksLayer3TimeseriesGroupByBitrateRequest,
) => Effect.Effect<
  GetAttacksLayer3TimeseriesGroupByBitrateResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3TimeseriesGroupByBitrateRequest,
  output: GetAttacksLayer3TimeseriesGroupByBitrateResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3TimeseriesGroupByDurationRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  direction?: "ORIGIN" | "TARGET";
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3TimeseriesGroupByDurationRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/timeseries_groups/duration" }))
  .annotations({
    identifier: "GetAttacksLayer3TimeseriesGroupByDurationRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesGroupByDurationRequest>;

export interface GetAttacksLayer3TimeseriesGroupByDurationResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: {
      OVER_3_HOURS: string[];
      UNDER_10_MINS: string[];
      _10_MINS_TO_20_MINS: string[];
      _1_HOUR_TO_3_HOURS: string[];
      _20_MINS_TO_40_MINS: string[];
      _40_MINS_TO_1_HOUR: string[];
      timestamps: string[];
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3TimeseriesGroupByDurationResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      OVER_3_HOURS: Schema.Array(Schema.String),
      UNDER_10_MINS: Schema.Array(Schema.String),
      _10_MINS_TO_20_MINS: Schema.Array(Schema.String),
      _1_HOUR_TO_3_HOURS: Schema.Array(Schema.String),
      _20_MINS_TO_40_MINS: Schema.Array(Schema.String),
      _40_MINS_TO_1_HOUR: Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3TimeseriesGroupByDurationResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesGroupByDurationResponse>;

export const getAttacksLayer3TimeseriesGroupByDuration: (
  input: GetAttacksLayer3TimeseriesGroupByDurationRequest,
) => Effect.Effect<
  GetAttacksLayer3TimeseriesGroupByDurationResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3TimeseriesGroupByDurationRequest,
  output: GetAttacksLayer3TimeseriesGroupByDurationResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3TimeseriesGroupByIndustryRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  direction?: "ORIGIN" | "TARGET";
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3TimeseriesGroupByIndustryRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/timeseries_groups/industry" }))
  .annotations({
    identifier: "GetAttacksLayer3TimeseriesGroupByIndustryRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesGroupByIndustryRequest>;

export interface GetAttacksLayer3TimeseriesGroupByIndustryResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3TimeseriesGroupByIndustryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3TimeseriesGroupByIndustryResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesGroupByIndustryResponse>;

export const getAttacksLayer3TimeseriesGroupByIndustry: (
  input: GetAttacksLayer3TimeseriesGroupByIndustryRequest,
) => Effect.Effect<
  GetAttacksLayer3TimeseriesGroupByIndustryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3TimeseriesGroupByIndustryRequest,
  output: GetAttacksLayer3TimeseriesGroupByIndustryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3TimeseriesGroupByIpVersionRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  direction?: "ORIGIN" | "TARGET";
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3TimeseriesGroupByIpVersionRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/timeseries_groups/ip_version" }))
  .annotations({
    identifier: "GetAttacksLayer3TimeseriesGroupByIpVersionRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesGroupByIpVersionRequest>;

export interface GetAttacksLayer3TimeseriesGroupByIpVersionResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { IPv4: string[]; IPv6: string[]; timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3TimeseriesGroupByIpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      IPv4: Schema.Array(Schema.String),
      IPv6: Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3TimeseriesGroupByIpVersionResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesGroupByIpVersionResponse>;

export const getAttacksLayer3TimeseriesGroupByIpVersion: (
  input: GetAttacksLayer3TimeseriesGroupByIpVersionRequest,
) => Effect.Effect<
  GetAttacksLayer3TimeseriesGroupByIpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3TimeseriesGroupByIpVersionRequest,
  output: GetAttacksLayer3TimeseriesGroupByIpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3TimeseriesGroupByProtocolRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  direction?: "ORIGIN" | "TARGET";
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3TimeseriesGroupByProtocolRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/timeseries_groups/protocol" }))
  .annotations({
    identifier: "GetAttacksLayer3TimeseriesGroupByProtocolRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesGroupByProtocolRequest>;

export interface GetAttacksLayer3TimeseriesGroupByProtocolResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { GRE: string[]; ICMP: string[]; TCP: string[]; UDP: string[]; timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3TimeseriesGroupByProtocolResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      GRE: Schema.Array(Schema.String),
      ICMP: Schema.Array(Schema.String),
      TCP: Schema.Array(Schema.String),
      UDP: Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3TimeseriesGroupByProtocolResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesGroupByProtocolResponse>;

export const getAttacksLayer3TimeseriesGroupByProtocol: (
  input: GetAttacksLayer3TimeseriesGroupByProtocolRequest,
) => Effect.Effect<
  GetAttacksLayer3TimeseriesGroupByProtocolResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3TimeseriesGroupByProtocolRequest,
  output: GetAttacksLayer3TimeseriesGroupByProtocolResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3TimeseriesGroupByVectorRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  direction?: "ORIGIN" | "TARGET";
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3TimeseriesGroupByVectorRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/timeseries_groups/vector" }))
  .annotations({
    identifier: "GetAttacksLayer3TimeseriesGroupByVectorRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesGroupByVectorRequest>;

export interface GetAttacksLayer3TimeseriesGroupByVectorResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3TimeseriesGroupByVectorResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3TimeseriesGroupByVectorResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesGroupByVectorResponse>;

export const getAttacksLayer3TimeseriesGroupByVector: (
  input: GetAttacksLayer3TimeseriesGroupByVectorRequest,
) => Effect.Effect<
  GetAttacksLayer3TimeseriesGroupByVectorResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3TimeseriesGroupByVectorRequest,
  output: GetAttacksLayer3TimeseriesGroupByVectorResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3TimeseriesGroupByVerticalRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  direction?: "ORIGIN" | "TARGET";
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3TimeseriesGroupByVerticalRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/timeseries_groups/vertical" }))
  .annotations({
    identifier: "GetAttacksLayer3TimeseriesGroupByVerticalRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesGroupByVerticalRequest>;

export interface GetAttacksLayer3TimeseriesGroupByVerticalResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3TimeseriesGroupByVerticalResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3TimeseriesGroupByVerticalResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesGroupByVerticalResponse>;

export const getAttacksLayer3TimeseriesGroupByVertical: (
  input: GetAttacksLayer3TimeseriesGroupByVerticalRequest,
) => Effect.Effect<
  GetAttacksLayer3TimeseriesGroupByVerticalResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3TimeseriesGroupByVerticalRequest,
  output: GetAttacksLayer3TimeseriesGroupByVerticalResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3TimeseriesGroupRequest {
  dimension:
    | "PROTOCOL"
    | "IP_VERSION"
    | "VECTOR"
    | "DURATION"
    | "BITRATE"
    | "VERTICAL"
    | "INDUSTRY";
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  direction?: "ORIGIN" | "TARGET";
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3TimeseriesGroupRequest = Schema.Struct({
  dimension: Schema.Literal(
    "PROTOCOL",
    "IP_VERSION",
    "VECTOR",
    "DURATION",
    "BITRATE",
    "VERTICAL",
    "INDUSTRY",
  ).pipe(T.HttpPath("dimension")),
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  direction: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(T.HttpQuery("direction")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/timeseries_groups/{dimension}" }))
  .annotations({
    identifier: "GetAttacksLayer3TimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesGroupRequest>;

export interface GetAttacksLayer3TimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3TimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3TimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3TimeseriesGroupResponse>;

export const getAttacksLayer3TimeseriesGroup: (
  input: GetAttacksLayer3TimeseriesGroupRequest,
) => Effect.Effect<
  GetAttacksLayer3TimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3TimeseriesGroupRequest,
  output: GetAttacksLayer3TimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3TopAttacksRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  limitDirection?: "ORIGIN" | "TARGET";
  limitPerLocation?: number;
  magnitude?: "MITIGATED_BYTES" | "MITIGATED_ATTACKS";
  normalization?: "PERCENTAGE" | "MIN_MAX";
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3TopAttacksRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  limitDirection: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(
    T.HttpQuery("limitDirection"),
  ),
  limitPerLocation: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerLocation")),
  magnitude: Schema.optional(Schema.Literal("MITIGATED_BYTES", "MITIGATED_ATTACKS")).pipe(
    T.HttpQuery("magnitude"),
  ),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/top/attacks" }))
  .annotations({
    identifier: "GetAttacksLayer3TopAttacksRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3TopAttacksRequest>;

export interface GetAttacksLayer3TopAttacksResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { originCountryAlpha2: string; originCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3TopAttacksResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        originCountryAlpha2: Schema.String,
        originCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3TopAttacksResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3TopAttacksResponse>;

export const getAttacksLayer3TopAttacks: (
  input: GetAttacksLayer3TopAttacksRequest,
) => Effect.Effect<
  GetAttacksLayer3TopAttacksResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3TopAttacksRequest,
  output: GetAttacksLayer3TopAttacksResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3TopIndustriesRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3TopIndustriesRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/top/industry" }))
  .annotations({
    identifier: "GetAttacksLayer3TopIndustriesRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3TopIndustriesRequest>;

export interface GetAttacksLayer3TopIndustriesResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { name: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3TopIndustriesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        name: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3TopIndustriesResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3TopIndustriesResponse>;

export const getAttacksLayer3TopIndustries: (
  input: GetAttacksLayer3TopIndustriesRequest,
) => Effect.Effect<
  GetAttacksLayer3TopIndustriesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3TopIndustriesRequest,
  output: GetAttacksLayer3TopIndustriesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3TopOriginLocationsRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3TopOriginLocationsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/top/locations/origin" }))
  .annotations({
    identifier: "GetAttacksLayer3TopOriginLocationsRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3TopOriginLocationsRequest>;

export interface GetAttacksLayer3TopOriginLocationsResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: {
      originCountryAlpha2: string;
      originCountryName: string;
      rank: number;
      value: string;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3TopOriginLocationsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        originCountryAlpha2: Schema.String,
        originCountryName: Schema.String,
        rank: Schema.Number,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3TopOriginLocationsResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3TopOriginLocationsResponse>;

export const getAttacksLayer3TopOriginLocations: (
  input: GetAttacksLayer3TopOriginLocationsRequest,
) => Effect.Effect<
  GetAttacksLayer3TopOriginLocationsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3TopOriginLocationsRequest,
  output: GetAttacksLayer3TopOriginLocationsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3TopTargetLocationsRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3TopTargetLocationsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/top/locations/target" }))
  .annotations({
    identifier: "GetAttacksLayer3TopTargetLocationsRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3TopTargetLocationsRequest>;

export interface GetAttacksLayer3TopTargetLocationsResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: {
      rank: number;
      targetCountryAlpha2: string;
      targetCountryName: string;
      value: string;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3TopTargetLocationsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        rank: Schema.Number,
        targetCountryAlpha2: Schema.String,
        targetCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3TopTargetLocationsResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3TopTargetLocationsResponse>;

export const getAttacksLayer3TopTargetLocations: (
  input: GetAttacksLayer3TopTargetLocationsRequest,
) => Effect.Effect<
  GetAttacksLayer3TopTargetLocationsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3TopTargetLocationsRequest,
  output: GetAttacksLayer3TopTargetLocationsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer3TopVerticalsRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  protocol?: "UDP" | "TCP" | "ICMP" | "GRE"[];
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer3TopVerticalsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "ICMP", "GRE"))).pipe(
    T.HttpQuery("protocol"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer3/top/vertical" }))
  .annotations({
    identifier: "GetAttacksLayer3TopVerticalsRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer3TopVerticalsRequest>;

export interface GetAttacksLayer3TopVerticalsResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { name: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer3TopVerticalsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        name: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer3TopVerticalsResponse",
}) as unknown as Schema.Schema<GetAttacksLayer3TopVerticalsResponse>;

export const getAttacksLayer3TopVerticals: (
  input: GetAttacksLayer3TopVerticalsRequest,
) => Effect.Effect<
  GetAttacksLayer3TopVerticalsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer3TopVerticalsRequest,
  output: GetAttacksLayer3TopVerticalsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7SummaryByHttpMethodRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7SummaryByHttpMethodRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/summary/http_method" }))
  .annotations({
    identifier: "GetAttacksLayer7SummaryByHttpMethodRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7SummaryByHttpMethodRequest>;

export interface GetAttacksLayer7SummaryByHttpMethodResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7SummaryByHttpMethodResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7SummaryByHttpMethodResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7SummaryByHttpMethodResponse>;

export const getAttacksLayer7SummaryByHttpMethod: (
  input: GetAttacksLayer7SummaryByHttpMethodRequest,
) => Effect.Effect<
  GetAttacksLayer7SummaryByHttpMethodResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7SummaryByHttpMethodRequest,
  output: GetAttacksLayer7SummaryByHttpMethodResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7SummaryByHttpVersionRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7SummaryByHttpVersionRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/summary/http_version" }))
  .annotations({
    identifier: "GetAttacksLayer7SummaryByHttpVersionRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7SummaryByHttpVersionRequest>;

export interface GetAttacksLayer7SummaryByHttpVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { "HTTP/1.x": string; "HTTP/2": string; "HTTP/3": string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7SummaryByHttpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      "HTTP/1.x": Schema.String,
      "HTTP/2": Schema.String,
      "HTTP/3": Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7SummaryByHttpVersionResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7SummaryByHttpVersionResponse>;

export const getAttacksLayer7SummaryByHttpVersion: (
  input: GetAttacksLayer7SummaryByHttpVersionRequest,
) => Effect.Effect<
  GetAttacksLayer7SummaryByHttpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7SummaryByHttpVersionRequest,
  output: GetAttacksLayer7SummaryByHttpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7SummaryByIndustryRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7SummaryByIndustryRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/summary/industry" }))
  .annotations({
    identifier: "GetAttacksLayer7SummaryByIndustryRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7SummaryByIndustryRequest>;

export interface GetAttacksLayer7SummaryByIndustryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7SummaryByIndustryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7SummaryByIndustryResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7SummaryByIndustryResponse>;

export const getAttacksLayer7SummaryByIndustry: (
  input: GetAttacksLayer7SummaryByIndustryRequest,
) => Effect.Effect<
  GetAttacksLayer7SummaryByIndustryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7SummaryByIndustryRequest,
  output: GetAttacksLayer7SummaryByIndustryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7SummaryByIpVersionRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7SummaryByIpVersionRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/summary/ip_version" }))
  .annotations({
    identifier: "GetAttacksLayer7SummaryByIpVersionRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7SummaryByIpVersionRequest>;

export interface GetAttacksLayer7SummaryByIpVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { IPv4: string; IPv6: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7SummaryByIpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      IPv4: Schema.String,
      IPv6: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7SummaryByIpVersionResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7SummaryByIpVersionResponse>;

export const getAttacksLayer7SummaryByIpVersion: (
  input: GetAttacksLayer7SummaryByIpVersionRequest,
) => Effect.Effect<
  GetAttacksLayer7SummaryByIpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7SummaryByIpVersionRequest,
  output: GetAttacksLayer7SummaryByIpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7SummaryByManagedRulesRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7SummaryByManagedRulesRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/summary/managed_rules" }))
  .annotations({
    identifier: "GetAttacksLayer7SummaryByManagedRulesRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7SummaryByManagedRulesRequest>;

export interface GetAttacksLayer7SummaryByManagedRulesResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7SummaryByManagedRulesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7SummaryByManagedRulesResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7SummaryByManagedRulesResponse>;

export const getAttacksLayer7SummaryByManagedRules: (
  input: GetAttacksLayer7SummaryByManagedRulesRequest,
) => Effect.Effect<
  GetAttacksLayer7SummaryByManagedRulesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7SummaryByManagedRulesRequest,
  output: GetAttacksLayer7SummaryByManagedRulesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7SummaryByMitigationProductRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7SummaryByMitigationProductRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/summary/mitigation_product" }))
  .annotations({
    identifier: "GetAttacksLayer7SummaryByMitigationProductRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7SummaryByMitigationProductRequest>;

export interface GetAttacksLayer7SummaryByMitigationProductResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7SummaryByMitigationProductResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7SummaryByMitigationProductResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7SummaryByMitigationProductResponse>;

export const getAttacksLayer7SummaryByMitigationProduct: (
  input: GetAttacksLayer7SummaryByMitigationProductRequest,
) => Effect.Effect<
  GetAttacksLayer7SummaryByMitigationProductResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7SummaryByMitigationProductRequest,
  output: GetAttacksLayer7SummaryByMitigationProductResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7SummaryByVerticalRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7SummaryByVerticalRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/summary/vertical" }))
  .annotations({
    identifier: "GetAttacksLayer7SummaryByVerticalRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7SummaryByVerticalRequest>;

export interface GetAttacksLayer7SummaryByVerticalResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7SummaryByVerticalResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7SummaryByVerticalResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7SummaryByVerticalResponse>;

export const getAttacksLayer7SummaryByVertical: (
  input: GetAttacksLayer7SummaryByVerticalRequest,
) => Effect.Effect<
  GetAttacksLayer7SummaryByVerticalResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7SummaryByVerticalRequest,
  output: GetAttacksLayer7SummaryByVerticalResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7SummaryRequest {
  dimension:
    | "HTTP_METHOD"
    | "HTTP_VERSION"
    | "IP_VERSION"
    | "MANAGED_RULES"
    | "MITIGATION_PRODUCT"
    | "VERTICAL"
    | "INDUSTRY";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7SummaryRequest = Schema.Struct({
  dimension: Schema.Literal(
    "HTTP_METHOD",
    "HTTP_VERSION",
    "IP_VERSION",
    "MANAGED_RULES",
    "MITIGATION_PRODUCT",
    "VERTICAL",
    "INDUSTRY",
  ).pipe(T.HttpPath("dimension")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/summary/{dimension}" }))
  .annotations({
    identifier: "GetAttacksLayer7SummaryRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7SummaryRequest>;

export interface GetAttacksLayer7SummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7SummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7SummaryResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7SummaryResponse>;

export const getAttacksLayer7Summary: (
  input: GetAttacksLayer7SummaryRequest,
) => Effect.Effect<
  GetAttacksLayer7SummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7SummaryRequest,
  output: GetAttacksLayer7SummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7TimeseriesRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  normalization?: "PERCENTAGE_CHANGE" | "MIN0_MAX";
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7TimeseriesRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE_CHANGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/timeseries" }))
  .annotations({
    identifier: "GetAttacksLayer7TimeseriesRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesRequest>;

export interface GetAttacksLayer7TimeseriesResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[]; values: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7TimeseriesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
      values: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7TimeseriesResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesResponse>;

export const getAttacksLayer7Timeseries: (
  input: GetAttacksLayer7TimeseriesRequest,
) => Effect.Effect<
  GetAttacksLayer7TimeseriesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7TimeseriesRequest,
  output: GetAttacksLayer7TimeseriesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7TimeseriesGroupByHttpMethodRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7TimeseriesGroupByHttpMethodRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/timeseries_groups/http_method" }))
  .annotations({
    identifier: "GetAttacksLayer7TimeseriesGroupByHttpMethodRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesGroupByHttpMethodRequest>;

export interface GetAttacksLayer7TimeseriesGroupByHttpMethodResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7TimeseriesGroupByHttpMethodResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7TimeseriesGroupByHttpMethodResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesGroupByHttpMethodResponse>;

export const getAttacksLayer7TimeseriesGroupByHttpMethod: (
  input: GetAttacksLayer7TimeseriesGroupByHttpMethodRequest,
) => Effect.Effect<
  GetAttacksLayer7TimeseriesGroupByHttpMethodResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7TimeseriesGroupByHttpMethodRequest,
  output: GetAttacksLayer7TimeseriesGroupByHttpMethodResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7TimeseriesGroupByHttpVersionRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7TimeseriesGroupByHttpVersionRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/timeseries_groups/http_version" }))
  .annotations({
    identifier: "GetAttacksLayer7TimeseriesGroupByHttpVersionRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesGroupByHttpVersionRequest>;

export interface GetAttacksLayer7TimeseriesGroupByHttpVersionResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { "HTTP/1.x": string[]; "HTTP/2": string[]; "HTTP/3": string[]; timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7TimeseriesGroupByHttpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      "HTTP/1.x": Schema.Array(Schema.String),
      "HTTP/2": Schema.Array(Schema.String),
      "HTTP/3": Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7TimeseriesGroupByHttpVersionResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesGroupByHttpVersionResponse>;

export const getAttacksLayer7TimeseriesGroupByHttpVersion: (
  input: GetAttacksLayer7TimeseriesGroupByHttpVersionRequest,
) => Effect.Effect<
  GetAttacksLayer7TimeseriesGroupByHttpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7TimeseriesGroupByHttpVersionRequest,
  output: GetAttacksLayer7TimeseriesGroupByHttpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7TimeseriesGroupByIndustryRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7TimeseriesGroupByIndustryRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/timeseries_groups/industry" }))
  .annotations({
    identifier: "GetAttacksLayer7TimeseriesGroupByIndustryRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesGroupByIndustryRequest>;

export interface GetAttacksLayer7TimeseriesGroupByIndustryResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7TimeseriesGroupByIndustryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7TimeseriesGroupByIndustryResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesGroupByIndustryResponse>;

export const getAttacksLayer7TimeseriesGroupByIndustry: (
  input: GetAttacksLayer7TimeseriesGroupByIndustryRequest,
) => Effect.Effect<
  GetAttacksLayer7TimeseriesGroupByIndustryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7TimeseriesGroupByIndustryRequest,
  output: GetAttacksLayer7TimeseriesGroupByIndustryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7TimeseriesGroupByIpVersionRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7TimeseriesGroupByIpVersionRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/timeseries_groups/ip_version" }))
  .annotations({
    identifier: "GetAttacksLayer7TimeseriesGroupByIpVersionRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesGroupByIpVersionRequest>;

export interface GetAttacksLayer7TimeseriesGroupByIpVersionResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { IPv4: string[]; IPv6: string[]; timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7TimeseriesGroupByIpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      IPv4: Schema.Array(Schema.String),
      IPv6: Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7TimeseriesGroupByIpVersionResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesGroupByIpVersionResponse>;

export const getAttacksLayer7TimeseriesGroupByIpVersion: (
  input: GetAttacksLayer7TimeseriesGroupByIpVersionRequest,
) => Effect.Effect<
  GetAttacksLayer7TimeseriesGroupByIpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7TimeseriesGroupByIpVersionRequest,
  output: GetAttacksLayer7TimeseriesGroupByIpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7TimeseriesGroupByManagedRulesRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7TimeseriesGroupByManagedRulesRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/timeseries_groups/managed_rules" }))
  .annotations({
    identifier: "GetAttacksLayer7TimeseriesGroupByManagedRulesRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesGroupByManagedRulesRequest>;

export interface GetAttacksLayer7TimeseriesGroupByManagedRulesResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7TimeseriesGroupByManagedRulesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7TimeseriesGroupByManagedRulesResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesGroupByManagedRulesResponse>;

export const getAttacksLayer7TimeseriesGroupByManagedRules: (
  input: GetAttacksLayer7TimeseriesGroupByManagedRulesRequest,
) => Effect.Effect<
  GetAttacksLayer7TimeseriesGroupByManagedRulesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7TimeseriesGroupByManagedRulesRequest,
  output: GetAttacksLayer7TimeseriesGroupByManagedRulesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7TimeseriesGroupByMitigationProductRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7TimeseriesGroupByMitigationProductRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(
    T.Http({ method: "GET", path: "/radar/attacks/layer7/timeseries_groups/mitigation_product" }),
  )
  .annotations({
    identifier: "GetAttacksLayer7TimeseriesGroupByMitigationProductRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesGroupByMitigationProductRequest>;

export interface GetAttacksLayer7TimeseriesGroupByMitigationProductResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7TimeseriesGroupByMitigationProductResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7TimeseriesGroupByMitigationProductResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesGroupByMitigationProductResponse>;

export const getAttacksLayer7TimeseriesGroupByMitigationProduct: (
  input: GetAttacksLayer7TimeseriesGroupByMitigationProductRequest,
) => Effect.Effect<
  GetAttacksLayer7TimeseriesGroupByMitigationProductResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7TimeseriesGroupByMitigationProductRequest,
  output: GetAttacksLayer7TimeseriesGroupByMitigationProductResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7TimeseriesGroupByVerticalRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7TimeseriesGroupByVerticalRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/timeseries_groups/vertical" }))
  .annotations({
    identifier: "GetAttacksLayer7TimeseriesGroupByVerticalRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesGroupByVerticalRequest>;

export interface GetAttacksLayer7TimeseriesGroupByVerticalResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7TimeseriesGroupByVerticalResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7TimeseriesGroupByVerticalResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesGroupByVerticalResponse>;

export const getAttacksLayer7TimeseriesGroupByVertical: (
  input: GetAttacksLayer7TimeseriesGroupByVerticalRequest,
) => Effect.Effect<
  GetAttacksLayer7TimeseriesGroupByVerticalResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7TimeseriesGroupByVerticalRequest,
  output: GetAttacksLayer7TimeseriesGroupByVerticalResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7TimeseriesGroupRequest {
  dimension:
    | "HTTP_METHOD"
    | "HTTP_VERSION"
    | "IP_VERSION"
    | "MANAGED_RULES"
    | "MITIGATION_PRODUCT"
    | "VERTICAL"
    | "INDUSTRY";
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7TimeseriesGroupRequest = Schema.Struct({
  dimension: Schema.Literal(
    "HTTP_METHOD",
    "HTTP_VERSION",
    "IP_VERSION",
    "MANAGED_RULES",
    "MITIGATION_PRODUCT",
    "VERTICAL",
    "INDUSTRY",
  ).pipe(T.HttpPath("dimension")),
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/timeseries_groups/{dimension}" }))
  .annotations({
    identifier: "GetAttacksLayer7TimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesGroupRequest>;

export interface GetAttacksLayer7TimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7TimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7TimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7TimeseriesGroupResponse>;

export const getAttacksLayer7TimeseriesGroup: (
  input: GetAttacksLayer7TimeseriesGroupRequest,
) => Effect.Effect<
  GetAttacksLayer7TimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7TimeseriesGroupRequest,
  output: GetAttacksLayer7TimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7TopOriginAsRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7TopOriginAsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/top/ases/origin" }))
  .annotations({
    identifier: "GetAttacksLayer7TopOriginAsRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7TopOriginAsRequest>;

export interface GetAttacksLayer7TopOriginAsResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { originAsn: string; originAsnName: string; rank: number; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7TopOriginAsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        originAsn: Schema.String,
        originAsnName: Schema.String,
        rank: Schema.Number,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7TopOriginAsResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7TopOriginAsResponse>;

export const getAttacksLayer7TopOriginAs: (
  input: GetAttacksLayer7TopOriginAsRequest,
) => Effect.Effect<
  GetAttacksLayer7TopOriginAsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7TopOriginAsRequest,
  output: GetAttacksLayer7TopOriginAsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7TopAttacksRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  limitDirection?: "ORIGIN" | "TARGET";
  limitPerLocation?: number;
  normalization?: "PERCENTAGE" | "MIN_MAX";
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7TopAttacksRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  limitDirection: Schema.optional(Schema.Literal("ORIGIN", "TARGET")).pipe(
    T.HttpQuery("limitDirection"),
  ),
  limitPerLocation: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerLocation")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/top/attacks" }))
  .annotations({
    identifier: "GetAttacksLayer7TopAttacksRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7TopAttacksRequest>;

export interface GetAttacksLayer7TopAttacksResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: {
      originCountryAlpha2: string;
      originCountryName: string;
      targetCountryAlpha2: string;
      targetCountryName: string;
      value: string;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7TopAttacksResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        originCountryAlpha2: Schema.String,
        originCountryName: Schema.String,
        targetCountryAlpha2: Schema.String,
        targetCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7TopAttacksResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7TopAttacksResponse>;

export const getAttacksLayer7TopAttacks: (
  input: GetAttacksLayer7TopAttacksRequest,
) => Effect.Effect<
  GetAttacksLayer7TopAttacksResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7TopAttacksRequest,
  output: GetAttacksLayer7TopAttacksResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7TopIndustriesRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7TopIndustriesRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/top/industry" }))
  .annotations({
    identifier: "GetAttacksLayer7TopIndustriesRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7TopIndustriesRequest>;

export interface GetAttacksLayer7TopIndustriesResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { name: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7TopIndustriesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        name: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7TopIndustriesResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7TopIndustriesResponse>;

export const getAttacksLayer7TopIndustries: (
  input: GetAttacksLayer7TopIndustriesRequest,
) => Effect.Effect<
  GetAttacksLayer7TopIndustriesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7TopIndustriesRequest,
  output: GetAttacksLayer7TopIndustriesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7TopOriginLocationRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7TopOriginLocationRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/top/locations/origin" }))
  .annotations({
    identifier: "GetAttacksLayer7TopOriginLocationRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7TopOriginLocationRequest>;

export interface GetAttacksLayer7TopOriginLocationResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: {
      originCountryAlpha2: string;
      originCountryName: string;
      rank: number;
      value: string;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7TopOriginLocationResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        originCountryAlpha2: Schema.String,
        originCountryName: Schema.String,
        rank: Schema.Number,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7TopOriginLocationResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7TopOriginLocationResponse>;

export const getAttacksLayer7TopOriginLocation: (
  input: GetAttacksLayer7TopOriginLocationRequest,
) => Effect.Effect<
  GetAttacksLayer7TopOriginLocationResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7TopOriginLocationRequest,
  output: GetAttacksLayer7TopOriginLocationResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7TopTargetLocationRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  continent?: string[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7TopTargetLocationRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/top/locations/target" }))
  .annotations({
    identifier: "GetAttacksLayer7TopTargetLocationRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7TopTargetLocationRequest>;

export interface GetAttacksLayer7TopTargetLocationResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: {
      rank: number;
      targetCountryAlpha2: string;
      targetCountryName: string;
      value: string;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7TopTargetLocationResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        rank: Schema.Number,
        targetCountryAlpha2: Schema.String,
        targetCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7TopTargetLocationResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7TopTargetLocationResponse>;

export const getAttacksLayer7TopTargetLocation: (
  input: GetAttacksLayer7TopTargetLocationRequest,
) => Effect.Effect<
  GetAttacksLayer7TopTargetLocationResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7TopTargetLocationRequest,
  output: GetAttacksLayer7TopTargetLocationResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAttacksLayer7TopVerticalsRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  httpMethod?:
    | "GET"
    | "POST"
    | "DELETE"
    | "PUT"
    | "HEAD"
    | "PURGE"
    | "OPTIONS"
    | "PROPFIND"
    | "MKCOL"
    | "PATCH"
    | "ACL"
    | "BCOPY"
    | "BDELETE"
    | "BMOVE"
    | "BPROPFIND"
    | "BPROPPATCH"
    | "CHECKIN"
    | "CHECKOUT"
    | "CONNECT"
    | "COPY"
    | "LABEL"
    | "LOCK"
    | "MERGE"
    | "MKACTIVITY"
    | "MKWORKSPACE"
    | "MOVE"
    | "NOTIFY"
    | "ORDERPATCH"
    | "POLL"
    | "PROPPATCH"
    | "REPORT"
    | "SEARCH"
    | "SUBSCRIBE"
    | "TRACE"
    | "UNCHECKOUT"
    | "UNLOCK"
    | "UNSUBSCRIBE"
    | "UPDATE"
    | "VERSIONCONTROL"
    | "BASELINECONTROL"
    | "XMSENUMATTS"
    | "RPC_OUT_DATA"
    | "RPC_IN_DATA"
    | "JSON"
    | "COOK"
    | "TRACK"[];
  mitigationProduct?:
    | "DDOS"
    | "WAF"
    | "BOT_MANAGEMENT"
    | "ACCESS_RULES"
    | "IP_REPUTATION"
    | "API_SHIELD"
    | "DATA_LOSS_PREVENTION"[];
  format?: "JSON" | "CSV";
}

export const GetAttacksLayer7TopVerticalsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  httpMethod: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "GET",
        "POST",
        "DELETE",
        "PUT",
        "HEAD",
        "PURGE",
        "OPTIONS",
        "PROPFIND",
        "MKCOL",
        "PATCH",
        "ACL",
        "BCOPY",
        "BDELETE",
        "BMOVE",
        "BPROPFIND",
        "BPROPPATCH",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKWORKSPACE",
        "MOVE",
        "NOTIFY",
        "ORDERPATCH",
        "POLL",
        "PROPPATCH",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UNSUBSCRIBE",
        "UPDATE",
        "VERSIONCONTROL",
        "BASELINECONTROL",
        "XMSENUMATTS",
        "RPC_OUT_DATA",
        "RPC_IN_DATA",
        "JSON",
        "COOK",
        "TRACK",
      ),
    ),
  ).pipe(T.HttpQuery("httpMethod")),
  mitigationProduct: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DDOS",
        "WAF",
        "BOT_MANAGEMENT",
        "ACCESS_RULES",
        "IP_REPUTATION",
        "API_SHIELD",
        "DATA_LOSS_PREVENTION",
      ),
    ),
  ).pipe(T.HttpQuery("mitigationProduct")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/attacks/layer7/top/vertical" }))
  .annotations({
    identifier: "GetAttacksLayer7TopVerticalsRequest",
  }) as unknown as Schema.Schema<GetAttacksLayer7TopVerticalsRequest>;

export interface GetAttacksLayer7TopVerticalsResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { name: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAttacksLayer7TopVerticalsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        name: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAttacksLayer7TopVerticalsResponse",
}) as unknown as Schema.Schema<GetAttacksLayer7TopVerticalsResponse>;

export const getAttacksLayer7TopVerticals: (
  input: GetAttacksLayer7TopVerticalsRequest,
) => Effect.Effect<
  GetAttacksLayer7TopVerticalsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttacksLayer7TopVerticalsRequest,
  output: GetAttacksLayer7TopVerticalsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBgpHijacksEventsRequest {
  page?: number;
  per_page?: number;
  eventId?: number;
  hijackerAsn?: number;
  victimAsn?: number;
  involvedAsn?: number;
  involvedCountry?: string;
  prefix?: string;
  minConfidence?: number;
  maxConfidence?: number;
  dateRange?: string;
  dateStart?: string;
  dateEnd?: string;
  sortBy?: "ID" | "TIME" | "CONFIDENCE";
  sortOrder?: "ASC" | "DESC";
  format?: "JSON" | "CSV";
}

export const GetBgpHijacksEventsRequest = Schema.Struct({
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  eventId: Schema.optional(Schema.Number).pipe(T.HttpQuery("eventId")),
  hijackerAsn: Schema.optional(Schema.Number).pipe(T.HttpQuery("hijackerAsn")),
  victimAsn: Schema.optional(Schema.Number).pipe(T.HttpQuery("victimAsn")),
  involvedAsn: Schema.optional(Schema.Number).pipe(T.HttpQuery("involvedAsn")),
  involvedCountry: Schema.optional(Schema.String).pipe(T.HttpQuery("involvedCountry")),
  prefix: Schema.optional(Schema.String).pipe(T.HttpQuery("prefix")),
  minConfidence: Schema.optional(Schema.Number).pipe(T.HttpQuery("minConfidence")),
  maxConfidence: Schema.optional(Schema.Number).pipe(T.HttpQuery("maxConfidence")),
  dateRange: Schema.optional(Schema.String).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Date).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Date).pipe(T.HttpQuery("dateEnd")),
  sortBy: Schema.optional(Schema.Literal("ID", "TIME", "CONFIDENCE")).pipe(T.HttpQuery("sortBy")),
  sortOrder: Schema.optional(Schema.Literal("ASC", "DESC")).pipe(T.HttpQuery("sortOrder")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bgp/hijacks/events" }))
  .annotations({
    identifier: "GetBgpHijacksEventsRequest",
  }) as unknown as Schema.Schema<GetBgpHijacksEventsRequest>;

export interface GetBgpHijacksEventsResponse {
  result: {
    asn_info: { asn: number; country_code: string; org_name: string }[];
    events: {
      confidence_score: number;
      duration: number;
      event_type: number;
      hijack_msgs_count: number;
      hijacker_asn: number;
      hijacker_country: string;
      id: number;
      is_stale: boolean;
      max_hijack_ts: string;
      max_msg_ts: string;
      min_hijack_ts: string;
      on_going_count: number;
      peer_asns: number[];
      peer_ip_count: number;
      prefixes: string[];
      tags: { name: string; score: number }[];
      victim_asns: number[];
      victim_countries: string[];
    }[];
    total_monitors: number;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBgpHijacksEventsResponse = Schema.Struct({
  result: Schema.Struct({
    asn_info: Schema.Array(
      Schema.Struct({
        asn: Schema.Number,
        country_code: Schema.String,
        org_name: Schema.String,
      }),
    ),
    events: Schema.Array(
      Schema.Struct({
        confidence_score: Schema.Number,
        duration: Schema.Number,
        event_type: Schema.Number,
        hijack_msgs_count: Schema.Number,
        hijacker_asn: Schema.Number,
        hijacker_country: Schema.String,
        id: Schema.Number,
        is_stale: Schema.Boolean,
        max_hijack_ts: Schema.String,
        max_msg_ts: Schema.String,
        min_hijack_ts: Schema.String,
        on_going_count: Schema.Number,
        peer_asns: Schema.Array(Schema.Number),
        peer_ip_count: Schema.Number,
        prefixes: Schema.Array(Schema.String),
        tags: Schema.Array(
          Schema.Struct({
            name: Schema.String,
            score: Schema.Number,
          }),
        ),
        victim_asns: Schema.Array(Schema.Number),
        victim_countries: Schema.Array(Schema.String),
      }),
    ),
    total_monitors: Schema.Number,
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetBgpHijacksEventsResponse",
}) as unknown as Schema.Schema<GetBgpHijacksEventsResponse>;

export const getBgpHijacksEvents: (
  input: GetBgpHijacksEventsRequest,
) => Effect.Effect<
  GetBgpHijacksEventsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBgpHijacksEventsRequest,
  output: GetBgpHijacksEventsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBgpIpsTimeseriesRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  ipVersion?: "IPv4" | "IPv6"[];
  includeDelay?: boolean;
  format?: "JSON" | "CSV";
}

export const GetBgpIpsTimeseriesRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  includeDelay: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("includeDelay")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bgp/ips/timeseries" }))
  .annotations({
    identifier: "GetBgpIpsTimeseriesRequest",
  }) as unknown as Schema.Schema<GetBgpIpsTimeseriesRequest>;

export interface GetBgpIpsTimeseriesResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      delay?: {
        asn_data: {
          delaySecs: number;
          delayStr: string;
          healthy: boolean;
          latest: { entries_count: number; path: string; timestamp: number };
        };
        country_data: {
          delaySecs: number;
          delayStr: string;
          healthy: boolean;
          latest: { count: number; timestamp: number };
        };
        healthy: boolean;
        nowTs: number;
      };
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { ipv4: string[]; ipv6: string[]; timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBgpIpsTimeseriesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      delay: Schema.optional(
        Schema.NullOr(
          Schema.Struct({
            asn_data: Schema.Struct({
              delaySecs: Schema.Number,
              delayStr: Schema.String,
              healthy: Schema.Boolean,
              latest: Schema.Struct({
                entries_count: Schema.Number,
                path: Schema.String,
                timestamp: Schema.Number,
              }),
            }),
            country_data: Schema.Struct({
              delaySecs: Schema.Number,
              delayStr: Schema.String,
              healthy: Schema.Boolean,
              latest: Schema.Struct({
                count: Schema.Number,
                timestamp: Schema.Number,
              }),
            }),
            healthy: Schema.Boolean,
            nowTs: Schema.Number,
          }),
        ),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      ipv4: Schema.Array(Schema.String),
      ipv6: Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetBgpIpsTimeseriesResponse",
}) as unknown as Schema.Schema<GetBgpIpsTimeseriesResponse>;

export const getBgpIpsTimeseries: (
  input: GetBgpIpsTimeseriesRequest,
) => Effect.Effect<
  GetBgpIpsTimeseriesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBgpIpsTimeseriesRequest,
  output: GetBgpIpsTimeseriesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBgpRouteLeakEventsRequest {
  page?: number;
  per_page?: number;
  eventId?: number;
  leakAsn?: number;
  involvedAsn?: number;
  involvedCountry?: string;
  dateRange?: string;
  dateStart?: string;
  dateEnd?: string;
  sortBy?: "ID" | "LEAKS" | "PEERS" | "PREFIXES" | "ORIGINS" | "TIME";
  sortOrder?: "ASC" | "DESC";
  format?: "JSON" | "CSV";
}

export const GetBgpRouteLeakEventsRequest = Schema.Struct({
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  eventId: Schema.optional(Schema.Number).pipe(T.HttpQuery("eventId")),
  leakAsn: Schema.optional(Schema.Number).pipe(T.HttpQuery("leakAsn")),
  involvedAsn: Schema.optional(Schema.Number).pipe(T.HttpQuery("involvedAsn")),
  involvedCountry: Schema.optional(Schema.String).pipe(T.HttpQuery("involvedCountry")),
  dateRange: Schema.optional(Schema.String).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Date).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Date).pipe(T.HttpQuery("dateEnd")),
  sortBy: Schema.optional(
    Schema.Literal("ID", "LEAKS", "PEERS", "PREFIXES", "ORIGINS", "TIME"),
  ).pipe(T.HttpQuery("sortBy")),
  sortOrder: Schema.optional(Schema.Literal("ASC", "DESC")).pipe(T.HttpQuery("sortOrder")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bgp/leaks/events" }))
  .annotations({
    identifier: "GetBgpRouteLeakEventsRequest",
  }) as unknown as Schema.Schema<GetBgpRouteLeakEventsRequest>;

export interface GetBgpRouteLeakEventsResponse {
  result: {
    asn_info: { asn: number; country_code: string; org_name: string }[];
    events: {
      countries: string[];
      detected_ts: string;
      finished: boolean;
      id: number;
      leak_asn: number;
      leak_count: number;
      leak_seg: number[];
      leak_type: number;
      max_ts: string;
      min_ts: string;
      origin_count: number;
      peer_count: number;
      prefix_count: number;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBgpRouteLeakEventsResponse = Schema.Struct({
  result: Schema.Struct({
    asn_info: Schema.Array(
      Schema.Struct({
        asn: Schema.Number,
        country_code: Schema.String,
        org_name: Schema.String,
      }),
    ),
    events: Schema.Array(
      Schema.Struct({
        countries: Schema.Array(Schema.String),
        detected_ts: Schema.String,
        finished: Schema.Boolean,
        id: Schema.Number,
        leak_asn: Schema.Number,
        leak_count: Schema.Number,
        leak_seg: Schema.Array(Schema.Number),
        leak_type: Schema.Number,
        max_ts: Schema.String,
        min_ts: Schema.String,
        origin_count: Schema.Number,
        peer_count: Schema.Number,
        prefix_count: Schema.Number,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetBgpRouteLeakEventsResponse",
}) as unknown as Schema.Schema<GetBgpRouteLeakEventsResponse>;

export const getBgpRouteLeakEvents: (
  input: GetBgpRouteLeakEventsRequest,
) => Effect.Effect<
  GetBgpRouteLeakEventsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBgpRouteLeakEventsRequest,
  output: GetBgpRouteLeakEventsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBgpRoutesAsnsRequest {
  location?: string;
  limit?: number;
  sortBy?: "cone" | "pfxs" | "ipv4" | "ipv6" | "rpki_valid" | "rpki_invalid" | "rpki_unknown";
  sortOrder?: "ASC" | "DESC";
  format?: "JSON" | "CSV";
}

export const GetBgpRoutesAsnsRequest = Schema.Struct({
  location: Schema.optional(Schema.String).pipe(T.HttpQuery("location")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  sortBy: Schema.optional(
    Schema.Literal("cone", "pfxs", "ipv4", "ipv6", "rpki_valid", "rpki_invalid", "rpki_unknown"),
  ).pipe(T.HttpQuery("sortBy")),
  sortOrder: Schema.optional(Schema.Literal("ASC", "DESC")).pipe(T.HttpQuery("sortOrder")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bgp/routes/ases" }))
  .annotations({
    identifier: "GetBgpRoutesAsnsRequest",
  }) as unknown as Schema.Schema<GetBgpRoutesAsnsRequest>;

export interface GetBgpRoutesAsnsResponse {
  result: {
    asns: {
      asn: number;
      coneSize: number;
      country: string;
      ipv4Count: number;
      ipv6Count: string;
      name: string;
      pfxsCount: number;
      rpkiInvalid: number;
      rpkiUnknown: number;
      rpkiValid: number;
    }[];
    meta: { dataTime: string; queryTime: string; totalPeers: number };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBgpRoutesAsnsResponse = Schema.Struct({
  result: Schema.Struct({
    asns: Schema.Array(
      Schema.Struct({
        asn: Schema.Number,
        coneSize: Schema.Number,
        country: Schema.String,
        ipv4Count: Schema.Number,
        ipv6Count: Schema.String,
        name: Schema.String,
        pfxsCount: Schema.Number,
        rpkiInvalid: Schema.Number,
        rpkiUnknown: Schema.Number,
        rpkiValid: Schema.Number,
      }),
    ),
    meta: Schema.Struct({
      dataTime: Schema.String,
      queryTime: Schema.String,
      totalPeers: Schema.Number,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetBgpRoutesAsnsResponse",
}) as unknown as Schema.Schema<GetBgpRoutesAsnsResponse>;

export const getBgpRoutesAsns: (
  input: GetBgpRoutesAsnsRequest,
) => Effect.Effect<
  GetBgpRoutesAsnsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBgpRoutesAsnsRequest,
  output: GetBgpRoutesAsnsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBgpPfx2asMoasRequest {
  origin?: number;
  prefix?: string;
  invalid_only?: boolean;
  format?: "JSON" | "CSV";
}

export const GetBgpPfx2asMoasRequest = Schema.Struct({
  origin: Schema.optional(Schema.Number).pipe(T.HttpQuery("origin")),
  prefix: Schema.optional(Schema.String).pipe(T.HttpQuery("prefix")),
  invalid_only: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("invalid_only")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bgp/routes/moas" }))
  .annotations({
    identifier: "GetBgpPfx2asMoasRequest",
  }) as unknown as Schema.Schema<GetBgpPfx2asMoasRequest>;

export interface GetBgpPfx2asMoasResponse {
  result: {
    meta: { data_time: string; query_time: string; total_peers: number };
    moas: {
      origins: { origin: number; peer_count: number; rpki_validation: string }[];
      prefix: string;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBgpPfx2asMoasResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      data_time: Schema.String,
      query_time: Schema.String,
      total_peers: Schema.Number,
    }),
    moas: Schema.Array(
      Schema.Struct({
        origins: Schema.Array(
          Schema.Struct({
            origin: Schema.Number,
            peer_count: Schema.Number,
            rpki_validation: Schema.String,
          }),
        ),
        prefix: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetBgpPfx2asMoasResponse",
}) as unknown as Schema.Schema<GetBgpPfx2asMoasResponse>;

export const getBgpPfx2asMoas: (
  input: GetBgpPfx2asMoasRequest,
) => Effect.Effect<
  GetBgpPfx2asMoasResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBgpPfx2asMoasRequest,
  output: GetBgpPfx2asMoasResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBgpPfx2asRequest {
  prefix?: string;
  origin?: number;
  rpkiStatus?: "VALID" | "INVALID" | "UNKNOWN";
  longestPrefixMatch?: boolean;
  format?: "JSON" | "CSV";
}

export const GetBgpPfx2asRequest = Schema.Struct({
  prefix: Schema.optional(Schema.String).pipe(T.HttpQuery("prefix")),
  origin: Schema.optional(Schema.Number).pipe(T.HttpQuery("origin")),
  rpkiStatus: Schema.optional(Schema.Literal("VALID", "INVALID", "UNKNOWN")).pipe(
    T.HttpQuery("rpkiStatus"),
  ),
  longestPrefixMatch: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("longestPrefixMatch")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bgp/routes/pfx2as" }))
  .annotations({
    identifier: "GetBgpPfx2asRequest",
  }) as unknown as Schema.Schema<GetBgpPfx2asRequest>;

export interface GetBgpPfx2asResponse {
  result: {
    meta: { data_time: string; query_time: string; total_peers: number };
    prefix_origins: {
      origin: number;
      peer_count: number;
      prefix: string;
      rpki_validation: string;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBgpPfx2asResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      data_time: Schema.String,
      query_time: Schema.String,
      total_peers: Schema.Number,
    }),
    prefix_origins: Schema.Array(
      Schema.Struct({
        origin: Schema.Number,
        peer_count: Schema.Number,
        prefix: Schema.String,
        rpki_validation: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetBgpPfx2asResponse",
}) as unknown as Schema.Schema<GetBgpPfx2asResponse>;

export const getBgpPfx2as: (
  input: GetBgpPfx2asRequest,
) => Effect.Effect<
  GetBgpPfx2asResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBgpPfx2asRequest,
  output: GetBgpPfx2asResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBgpRoutesRealtimeRequest {
  prefix?: string;
  format?: "JSON" | "CSV";
}

export const GetBgpRoutesRealtimeRequest = Schema.Struct({
  prefix: Schema.optional(Schema.String).pipe(T.HttpQuery("prefix")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bgp/routes/realtime" }))
  .annotations({
    identifier: "GetBgpRoutesRealtimeRequest",
  }) as unknown as Schema.Schema<GetBgpRoutesRealtimeRequest>;

export interface GetBgpRoutesRealtimeResponse {
  result: {
    meta: {
      asn_info: {
        as_name: string;
        asn: number;
        country_code: string;
        org_id: string;
        org_name: string;
      }[];
      collectors: {
        collector: string;
        latest_realtime_ts: string;
        latest_rib_ts: string;
        latest_updates_ts: string;
        peers_count: number;
        peers_v4_count: number;
        peers_v6_count: number;
      }[];
      data_time: string;
      prefix_origins: {
        origin: number;
        prefix: string;
        rpki_validation: string;
        total_peers: number;
        total_visible: number;
        visibility: number;
      }[];
      query_time: string;
    };
    routes: {
      as_path: number[];
      collector: string;
      communities: string[];
      prefix: string;
      timestamp: string;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBgpRoutesRealtimeResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      asn_info: Schema.Array(
        Schema.Struct({
          as_name: Schema.String,
          asn: Schema.Number,
          country_code: Schema.String,
          org_id: Schema.String,
          org_name: Schema.String,
        }),
      ),
      collectors: Schema.Array(
        Schema.Struct({
          collector: Schema.String,
          latest_realtime_ts: Schema.String,
          latest_rib_ts: Schema.String,
          latest_updates_ts: Schema.String,
          peers_count: Schema.Number,
          peers_v4_count: Schema.Number,
          peers_v6_count: Schema.Number,
        }),
      ),
      data_time: Schema.String,
      prefix_origins: Schema.Array(
        Schema.Struct({
          origin: Schema.Number,
          prefix: Schema.String,
          rpki_validation: Schema.String,
          total_peers: Schema.Number,
          total_visible: Schema.Number,
          visibility: Schema.Number,
        }),
      ),
      query_time: Schema.String,
    }),
    routes: Schema.Array(
      Schema.Struct({
        as_path: Schema.Array(Schema.Number),
        collector: Schema.String,
        communities: Schema.Array(Schema.String),
        prefix: Schema.String,
        timestamp: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetBgpRoutesRealtimeResponse",
}) as unknown as Schema.Schema<GetBgpRoutesRealtimeResponse>;

export const getBgpRoutesRealtime: (
  input: GetBgpRoutesRealtimeRequest,
) => Effect.Effect<
  GetBgpRoutesRealtimeResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBgpRoutesRealtimeRequest,
  output: GetBgpRoutesRealtimeResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBgpRoutesStatsRequest {
  asn?: number;
  location?: string;
  format?: "JSON" | "CSV";
}

export const GetBgpRoutesStatsRequest = Schema.Struct({
  asn: Schema.optional(Schema.Number).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.String).pipe(T.HttpQuery("location")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bgp/routes/stats" }))
  .annotations({
    identifier: "GetBgpRoutesStatsRequest",
  }) as unknown as Schema.Schema<GetBgpRoutesStatsRequest>;

export interface GetBgpRoutesStatsResponse {
  result: {
    meta: { data_time: string; query_time: string; total_peers: number };
    stats: {
      distinct_origins: number;
      distinct_origins_ipv4: number;
      distinct_origins_ipv6: number;
      distinct_prefixes: number;
      distinct_prefixes_ipv4: number;
      distinct_prefixes_ipv6: number;
      routes_invalid: number;
      routes_invalid_ipv4: number;
      routes_invalid_ipv6: number;
      routes_total: number;
      routes_total_ipv4: number;
      routes_total_ipv6: number;
      routes_unknown: number;
      routes_unknown_ipv4: number;
      routes_unknown_ipv6: number;
      routes_valid: number;
      routes_valid_ipv4: number;
      routes_valid_ipv6: number;
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBgpRoutesStatsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      data_time: Schema.String,
      query_time: Schema.String,
      total_peers: Schema.Number,
    }),
    stats: Schema.Struct({
      distinct_origins: Schema.Number,
      distinct_origins_ipv4: Schema.Number,
      distinct_origins_ipv6: Schema.Number,
      distinct_prefixes: Schema.Number,
      distinct_prefixes_ipv4: Schema.Number,
      distinct_prefixes_ipv6: Schema.Number,
      routes_invalid: Schema.Number,
      routes_invalid_ipv4: Schema.Number,
      routes_invalid_ipv6: Schema.Number,
      routes_total: Schema.Number,
      routes_total_ipv4: Schema.Number,
      routes_total_ipv6: Schema.Number,
      routes_unknown: Schema.Number,
      routes_unknown_ipv4: Schema.Number,
      routes_unknown_ipv6: Schema.Number,
      routes_valid: Schema.Number,
      routes_valid_ipv4: Schema.Number,
      routes_valid_ipv6: Schema.Number,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetBgpRoutesStatsResponse",
}) as unknown as Schema.Schema<GetBgpRoutesStatsResponse>;

export const getBgpRoutesStats: (
  input: GetBgpRoutesStatsRequest,
) => Effect.Effect<
  GetBgpRoutesStatsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBgpRoutesStatsRequest,
  output: GetBgpRoutesStatsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBgpTimeseriesRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  prefix?: string[];
  updateType?: "ANNOUNCEMENT" | "WITHDRAWAL"[];
  asn?: string[];
  format?: "JSON" | "CSV";
}

export const GetBgpTimeseriesRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  prefix: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("prefix")),
  updateType: Schema.optional(Schema.Array(Schema.Literal("ANNOUNCEMENT", "WITHDRAWAL"))).pipe(
    T.HttpQuery("updateType"),
  ),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bgp/timeseries" }))
  .annotations({
    identifier: "GetBgpTimeseriesRequest",
  }) as unknown as Schema.Schema<GetBgpTimeseriesRequest>;

export interface GetBgpTimeseriesResponse {
  result: {
    meta: {
      aggInterval: "15m" | "1h" | "1d" | "1w";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
    };
    serie_0: { timestamps: string[]; values: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBgpTimeseriesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal("15m", "1h", "1d", "1w"),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
      values: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetBgpTimeseriesResponse",
}) as unknown as Schema.Schema<GetBgpTimeseriesResponse>;

export const getBgpTimeseries: (
  input: GetBgpTimeseriesRequest,
) => Effect.Effect<
  GetBgpTimeseriesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBgpTimeseriesRequest,
  output: GetBgpTimeseriesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBgpTopAsesRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  prefix?: string[];
  updateType?: "ANNOUNCEMENT" | "WITHDRAWAL"[];
  format?: "JSON" | "CSV";
}

export const GetBgpTopAsesRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  prefix: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("prefix")),
  updateType: Schema.optional(Schema.Array(Schema.Literal("ANNOUNCEMENT", "WITHDRAWAL"))).pipe(
    T.HttpQuery("updateType"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bgp/top/ases" }))
  .annotations({
    identifier: "GetBgpTopAsesRequest",
  }) as unknown as Schema.Schema<GetBgpTopAsesRequest>;

export interface GetBgpTopAsesResponse {
  result: {
    meta: { dateRange: { endTime: string; startTime: string }[] };
    top_0: { ASName: string; asn: number; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBgpTopAsesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        ASName: Schema.String,
        asn: Schema.Number,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetBgpTopAsesResponse",
}) as unknown as Schema.Schema<GetBgpTopAsesResponse>;

export const getBgpTopAses: (
  input: GetBgpTopAsesRequest,
) => Effect.Effect<
  GetBgpTopAsesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBgpTopAsesRequest,
  output: GetBgpTopAsesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBgpTopAsnsByPrefixesRequest {
  country?: string;
  limit?: number;
  format?: "JSON" | "CSV";
}

export const GetBgpTopAsnsByPrefixesRequest = Schema.Struct({
  country: Schema.optional(Schema.String).pipe(T.HttpQuery("country")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bgp/top/ases/prefixes" }))
  .annotations({
    identifier: "GetBgpTopAsnsByPrefixesRequest",
  }) as unknown as Schema.Schema<GetBgpTopAsnsByPrefixesRequest>;

export interface GetBgpTopAsnsByPrefixesResponse {
  result: {
    asns: { asn: number; country: string; name: string; pfxs_count: number }[];
    meta: { data_time: string; query_time: string; total_peers: number };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBgpTopAsnsByPrefixesResponse = Schema.Struct({
  result: Schema.Struct({
    asns: Schema.Array(
      Schema.Struct({
        asn: Schema.Number,
        country: Schema.String,
        name: Schema.String,
        pfxs_count: Schema.Number,
      }),
    ),
    meta: Schema.Struct({
      data_time: Schema.String,
      query_time: Schema.String,
      total_peers: Schema.Number,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetBgpTopAsnsByPrefixesResponse",
}) as unknown as Schema.Schema<GetBgpTopAsnsByPrefixesResponse>;

export const getBgpTopAsnsByPrefixes: (
  input: GetBgpTopAsnsByPrefixesRequest,
) => Effect.Effect<
  GetBgpTopAsnsByPrefixesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBgpTopAsnsByPrefixesRequest,
  output: GetBgpTopAsnsByPrefixesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBgpTopPrefixesRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  updateType?: "ANNOUNCEMENT" | "WITHDRAWAL"[];
  format?: "JSON" | "CSV";
}

export const GetBgpTopPrefixesRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  updateType: Schema.optional(Schema.Array(Schema.Literal("ANNOUNCEMENT", "WITHDRAWAL"))).pipe(
    T.HttpQuery("updateType"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bgp/top/prefixes" }))
  .annotations({
    identifier: "GetBgpTopPrefixesRequest",
  }) as unknown as Schema.Schema<GetBgpTopPrefixesRequest>;

export interface GetBgpTopPrefixesResponse {
  result: {
    meta: { dateRange: { endTime: string; startTime: string }[] };
    top_0: { prefix: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBgpTopPrefixesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        prefix: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetBgpTopPrefixesResponse",
}) as unknown as Schema.Schema<GetBgpTopPrefixesResponse>;

export const getBgpTopPrefixes: (
  input: GetBgpTopPrefixesRequest,
) => Effect.Effect<
  GetBgpTopPrefixesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBgpTopPrefixesRequest,
  output: GetBgpTopPrefixesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBotsRequest {
  limit?: number;
  offset?: number;
  botCategory?:
    | "SEARCH_ENGINE_CRAWLER"
    | "SEARCH_ENGINE_OPTIMIZATION"
    | "MONITORING_AND_ANALYTICS"
    | "ADVERTISING_AND_MARKETING"
    | "SOCIAL_MEDIA_MARKETING"
    | "PAGE_PREVIEW"
    | "ACADEMIC_RESEARCH"
    | "SECURITY"
    | "ACCESSIBILITY"
    | "WEBHOOKS"
    | "FEED_FETCHER"
    | "AI_CRAWLER"
    | "AGGREGATOR"
    | "AI_ASSISTANT"
    | "AI_SEARCH"
    | "ARCHIVER";
  botOperator?: string;
  kind?: "AGENT" | "BOT";
  botVerificationStatus?: "VERIFIED";
  format?: "JSON" | "CSV";
}

export const GetBotsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset")),
  botCategory: Schema.optional(
    Schema.Literal(
      "SEARCH_ENGINE_CRAWLER",
      "SEARCH_ENGINE_OPTIMIZATION",
      "MONITORING_AND_ANALYTICS",
      "ADVERTISING_AND_MARKETING",
      "SOCIAL_MEDIA_MARKETING",
      "PAGE_PREVIEW",
      "ACADEMIC_RESEARCH",
      "SECURITY",
      "ACCESSIBILITY",
      "WEBHOOKS",
      "FEED_FETCHER",
      "AI_CRAWLER",
      "AGGREGATOR",
      "AI_ASSISTANT",
      "AI_SEARCH",
      "ARCHIVER",
    ),
  ).pipe(T.HttpQuery("botCategory")),
  botOperator: Schema.optional(Schema.String).pipe(T.HttpQuery("botOperator")),
  kind: Schema.optional(Schema.Literal("AGENT", "BOT")).pipe(T.HttpQuery("kind")),
  botVerificationStatus: Schema.optional(Schema.Literal("VERIFIED")).pipe(
    T.HttpQuery("botVerificationStatus"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bots" }))
  .annotations({ identifier: "GetBotsRequest" }) as unknown as Schema.Schema<GetBotsRequest>;

export interface GetBotsResponse {
  result: {
    bots: {
      category: string;
      description: string;
      kind: string;
      name: string;
      operator: string;
      slug: string;
      userAgentPatterns: string[];
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBotsResponse = Schema.Struct({
  result: Schema.Struct({
    bots: Schema.Array(
      Schema.Struct({
        category: Schema.String,
        description: Schema.String,
        kind: Schema.String,
        name: Schema.String,
        operator: Schema.String,
        slug: Schema.String,
        userAgentPatterns: Schema.Array(Schema.String),
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({ identifier: "GetBotsResponse" }) as unknown as Schema.Schema<GetBotsResponse>;

export const getBots: (
  input: GetBotsRequest,
) => Effect.Effect<
  GetBotsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBotsRequest,
  output: GetBotsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetCrawlersSummaryRequest {
  dimension:
    | "CLIENT_TYPE"
    | "USER_AGENT"
    | "REFERER"
    | "CRAWL_REFER_RATIO"
    | "VERTICAL"
    | "INDUSTRY";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  limitPerGroup?: number;
  botOperator?: string[];
  vertical?: string[];
  industry?: string[];
  clientType?: "HUMAN" | "NON_AI_BOT" | "AI_BOT" | "MIXED_PURPOSE"[];
  format?: "JSON" | "CSV";
}

export const GetCrawlersSummaryRequest = Schema.Struct({
  dimension: Schema.Literal(
    "CLIENT_TYPE",
    "USER_AGENT",
    "REFERER",
    "CRAWL_REFER_RATIO",
    "VERTICAL",
    "INDUSTRY",
  ).pipe(T.HttpPath("dimension")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  botOperator: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("botOperator")),
  vertical: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("vertical")),
  industry: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("industry")),
  clientType: Schema.optional(
    Schema.Array(Schema.Literal("HUMAN", "NON_AI_BOT", "AI_BOT", "MIXED_PURPOSE")),
  ).pipe(T.HttpQuery("clientType")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bots/crawlers/summary/{dimension}" }))
  .annotations({
    identifier: "GetCrawlersSummaryRequest",
  }) as unknown as Schema.Schema<GetCrawlersSummaryRequest>;

export interface GetCrawlersSummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetCrawlersSummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetCrawlersSummaryResponse",
}) as unknown as Schema.Schema<GetCrawlersSummaryResponse>;

export const getCrawlersSummary: (
  input: GetCrawlersSummaryRequest,
) => Effect.Effect<
  GetCrawlersSummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCrawlersSummaryRequest,
  output: GetCrawlersSummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetCrawlersTimeseriesGroupRequest {
  dimension:
    | "CLIENT_TYPE"
    | "USER_AGENT"
    | "REFERER"
    | "CRAWL_REFER_RATIO"
    | "VERTICAL"
    | "INDUSTRY";
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  limitPerGroup?: number;
  botOperator?: string[];
  vertical?: string[];
  industry?: string[];
  clientType?: "HUMAN" | "NON_AI_BOT" | "AI_BOT" | "MIXED_PURPOSE"[];
  format?: "JSON" | "CSV";
}

export const GetCrawlersTimeseriesGroupRequest = Schema.Struct({
  dimension: Schema.Literal(
    "CLIENT_TYPE",
    "USER_AGENT",
    "REFERER",
    "CRAWL_REFER_RATIO",
    "VERTICAL",
    "INDUSTRY",
  ).pipe(T.HttpPath("dimension")),
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  botOperator: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("botOperator")),
  vertical: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("vertical")),
  industry: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("industry")),
  clientType: Schema.optional(
    Schema.Array(Schema.Literal("HUMAN", "NON_AI_BOT", "AI_BOT", "MIXED_PURPOSE")),
  ).pipe(T.HttpQuery("clientType")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bots/crawlers/timeseries_groups/{dimension}" }))
  .annotations({
    identifier: "GetCrawlersTimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetCrawlersTimeseriesGroupRequest>;

export interface GetCrawlersTimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetCrawlersTimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetCrawlersTimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetCrawlersTimeseriesGroupResponse>;

export const getCrawlersTimeseriesGroup: (
  input: GetCrawlersTimeseriesGroupRequest,
) => Effect.Effect<
  GetCrawlersTimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCrawlersTimeseriesGroupRequest,
  output: GetCrawlersTimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBotsSummaryRequest {
  dimension: "BOT" | "BOT_KIND" | "BOT_OPERATOR" | "BOT_CATEGORY";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  limitPerGroup?: number;
  bot?: string[];
  botOperator?: string[];
  botCategory?:
    | "SEARCH_ENGINE_CRAWLER"
    | "SEARCH_ENGINE_OPTIMIZATION"
    | "MONITORING_AND_ANALYTICS"
    | "ADVERTISING_AND_MARKETING"
    | "SOCIAL_MEDIA_MARKETING"
    | "PAGE_PREVIEW"
    | "ACADEMIC_RESEARCH"
    | "SECURITY"
    | "ACCESSIBILITY"
    | "WEBHOOKS"
    | "FEED_FETCHER"
    | "AI_CRAWLER"
    | "AGGREGATOR"
    | "AI_ASSISTANT"
    | "AI_SEARCH"
    | "ARCHIVER"[];
  botKind?: "AGENT" | "BOT"[];
  botVerificationStatus?: "VERIFIED"[];
  format?: "JSON" | "CSV";
}

export const GetBotsSummaryRequest = Schema.Struct({
  dimension: Schema.Literal("BOT", "BOT_KIND", "BOT_OPERATOR", "BOT_CATEGORY").pipe(
    T.HttpPath("dimension"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  bot: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("bot")),
  botOperator: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("botOperator")),
  botCategory: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "SEARCH_ENGINE_CRAWLER",
        "SEARCH_ENGINE_OPTIMIZATION",
        "MONITORING_AND_ANALYTICS",
        "ADVERTISING_AND_MARKETING",
        "SOCIAL_MEDIA_MARKETING",
        "PAGE_PREVIEW",
        "ACADEMIC_RESEARCH",
        "SECURITY",
        "ACCESSIBILITY",
        "WEBHOOKS",
        "FEED_FETCHER",
        "AI_CRAWLER",
        "AGGREGATOR",
        "AI_ASSISTANT",
        "AI_SEARCH",
        "ARCHIVER",
      ),
    ),
  ).pipe(T.HttpQuery("botCategory")),
  botKind: Schema.optional(Schema.Array(Schema.Literal("AGENT", "BOT"))).pipe(
    T.HttpQuery("botKind"),
  ),
  botVerificationStatus: Schema.optional(Schema.Array(Schema.Literal("VERIFIED"))).pipe(
    T.HttpQuery("botVerificationStatus"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bots/summary/{dimension}" }))
  .annotations({
    identifier: "GetBotsSummaryRequest",
  }) as unknown as Schema.Schema<GetBotsSummaryRequest>;

export interface GetBotsSummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBotsSummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetBotsSummaryResponse",
}) as unknown as Schema.Schema<GetBotsSummaryResponse>;

export const getBotsSummary: (
  input: GetBotsSummaryRequest,
) => Effect.Effect<
  GetBotsSummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBotsSummaryRequest,
  output: GetBotsSummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBotsTimeseriesRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  bot?: string[];
  botOperator?: string[];
  botCategory?:
    | "SEARCH_ENGINE_CRAWLER"
    | "SEARCH_ENGINE_OPTIMIZATION"
    | "MONITORING_AND_ANALYTICS"
    | "ADVERTISING_AND_MARKETING"
    | "SOCIAL_MEDIA_MARKETING"
    | "PAGE_PREVIEW"
    | "ACADEMIC_RESEARCH"
    | "SECURITY"
    | "ACCESSIBILITY"
    | "WEBHOOKS"
    | "FEED_FETCHER"
    | "AI_CRAWLER"
    | "AGGREGATOR"
    | "AI_ASSISTANT"
    | "AI_SEARCH"
    | "ARCHIVER"[];
  botKind?: "AGENT" | "BOT"[];
  botVerificationStatus?: "VERIFIED"[];
  format?: "JSON" | "CSV";
}

export const GetBotsTimeseriesRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  bot: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("bot")),
  botOperator: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("botOperator")),
  botCategory: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "SEARCH_ENGINE_CRAWLER",
        "SEARCH_ENGINE_OPTIMIZATION",
        "MONITORING_AND_ANALYTICS",
        "ADVERTISING_AND_MARKETING",
        "SOCIAL_MEDIA_MARKETING",
        "PAGE_PREVIEW",
        "ACADEMIC_RESEARCH",
        "SECURITY",
        "ACCESSIBILITY",
        "WEBHOOKS",
        "FEED_FETCHER",
        "AI_CRAWLER",
        "AGGREGATOR",
        "AI_ASSISTANT",
        "AI_SEARCH",
        "ARCHIVER",
      ),
    ),
  ).pipe(T.HttpQuery("botCategory")),
  botKind: Schema.optional(Schema.Array(Schema.Literal("AGENT", "BOT"))).pipe(
    T.HttpQuery("botKind"),
  ),
  botVerificationStatus: Schema.optional(Schema.Array(Schema.Literal("VERIFIED"))).pipe(
    T.HttpQuery("botVerificationStatus"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bots/timeseries" }))
  .annotations({
    identifier: "GetBotsTimeseriesRequest",
  }) as unknown as Schema.Schema<GetBotsTimeseriesRequest>;

export interface GetBotsTimeseriesResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBotsTimeseriesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetBotsTimeseriesResponse",
}) as unknown as Schema.Schema<GetBotsTimeseriesResponse>;

export const getBotsTimeseries: (
  input: GetBotsTimeseriesRequest,
) => Effect.Effect<
  GetBotsTimeseriesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBotsTimeseriesRequest,
  output: GetBotsTimeseriesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBotsTimeseriesGroupRequest {
  dimension: "BOT" | "BOT_KIND" | "BOT_OPERATOR" | "BOT_CATEGORY";
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  limitPerGroup?: number;
  bot?: string[];
  botOperator?: string[];
  botCategory?:
    | "SEARCH_ENGINE_CRAWLER"
    | "SEARCH_ENGINE_OPTIMIZATION"
    | "MONITORING_AND_ANALYTICS"
    | "ADVERTISING_AND_MARKETING"
    | "SOCIAL_MEDIA_MARKETING"
    | "PAGE_PREVIEW"
    | "ACADEMIC_RESEARCH"
    | "SECURITY"
    | "ACCESSIBILITY"
    | "WEBHOOKS"
    | "FEED_FETCHER"
    | "AI_CRAWLER"
    | "AGGREGATOR"
    | "AI_ASSISTANT"
    | "AI_SEARCH"
    | "ARCHIVER"[];
  botKind?: "AGENT" | "BOT"[];
  botVerificationStatus?: "VERIFIED"[];
  format?: "JSON" | "CSV";
}

export const GetBotsTimeseriesGroupRequest = Schema.Struct({
  dimension: Schema.Literal("BOT", "BOT_KIND", "BOT_OPERATOR", "BOT_CATEGORY").pipe(
    T.HttpPath("dimension"),
  ),
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  bot: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("bot")),
  botOperator: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("botOperator")),
  botCategory: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "SEARCH_ENGINE_CRAWLER",
        "SEARCH_ENGINE_OPTIMIZATION",
        "MONITORING_AND_ANALYTICS",
        "ADVERTISING_AND_MARKETING",
        "SOCIAL_MEDIA_MARKETING",
        "PAGE_PREVIEW",
        "ACADEMIC_RESEARCH",
        "SECURITY",
        "ACCESSIBILITY",
        "WEBHOOKS",
        "FEED_FETCHER",
        "AI_CRAWLER",
        "AGGREGATOR",
        "AI_ASSISTANT",
        "AI_SEARCH",
        "ARCHIVER",
      ),
    ),
  ).pipe(T.HttpQuery("botCategory")),
  botKind: Schema.optional(Schema.Array(Schema.Literal("AGENT", "BOT"))).pipe(
    T.HttpQuery("botKind"),
  ),
  botVerificationStatus: Schema.optional(Schema.Array(Schema.Literal("VERIFIED"))).pipe(
    T.HttpQuery("botVerificationStatus"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bots/timeseries_groups/{dimension}" }))
  .annotations({
    identifier: "GetBotsTimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetBotsTimeseriesGroupRequest>;

export interface GetBotsTimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBotsTimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetBotsTimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetBotsTimeseriesGroupResponse>;

export const getBotsTimeseriesGroup: (
  input: GetBotsTimeseriesGroupRequest,
) => Effect.Effect<
  GetBotsTimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBotsTimeseriesGroupRequest,
  output: GetBotsTimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetBotDetailsRequest {
  bot_slug: string;
  format?: "JSON" | "CSV";
}

export const GetBotDetailsRequest = Schema.Struct({
  bot_slug: Schema.String.pipe(T.HttpPath("bot_slug")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/bots/{bot_slug}" }))
  .annotations({
    identifier: "GetBotDetailsRequest",
  }) as unknown as Schema.Schema<GetBotDetailsRequest>;

export interface GetBotDetailsResponse {
  result: {
    bot: {
      category: string;
      description: string;
      kind: string;
      name: string;
      operator: string;
      operatorUrl: string;
      slug: string;
      userAgentPatterns: string[];
      userAgents: string[];
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetBotDetailsResponse = Schema.Struct({
  result: Schema.Struct({
    bot: Schema.Struct({
      category: Schema.String,
      description: Schema.String,
      kind: Schema.String,
      name: Schema.String,
      operator: Schema.String,
      operatorUrl: Schema.String,
      slug: Schema.String,
      userAgentPatterns: Schema.Array(Schema.String),
      userAgents: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetBotDetailsResponse",
}) as unknown as Schema.Schema<GetBotDetailsResponse>;

export const getBotDetails: (
  input: GetBotDetailsRequest,
) => Effect.Effect<
  GetBotDetailsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBotDetailsRequest,
  output: GetBotDetailsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetCertificateAuthoritiesRequest {
  limit?: number;
  offset?: number;
  format?: "JSON" | "CSV";
}

export const GetCertificateAuthoritiesRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ct/authorities" }))
  .annotations({
    identifier: "GetCertificateAuthoritiesRequest",
  }) as unknown as Schema.Schema<GetCertificateAuthoritiesRequest>;

export interface GetCertificateAuthoritiesResponse {
  result: {
    certificateAuthorities: {
      certificateRecordType: "ROOT_CERTIFICATE" | "INTERMEDIATE_CERTIFICATE";
      country: string;
      countryName: string;
      name: string;
      owner: string;
      parentName: string;
      parentSha256Fingerprint: string;
      revocationStatus: "NOT_REVOKED" | "REVOKED" | "PARENT_CERT_REVOKED";
      sha256Fingerprint: string;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetCertificateAuthoritiesResponse = Schema.Struct({
  result: Schema.Struct({
    certificateAuthorities: Schema.Array(
      Schema.Struct({
        certificateRecordType: Schema.Literal("ROOT_CERTIFICATE", "INTERMEDIATE_CERTIFICATE"),
        country: Schema.String,
        countryName: Schema.String,
        name: Schema.String,
        owner: Schema.String,
        parentName: Schema.String,
        parentSha256Fingerprint: Schema.String,
        revocationStatus: Schema.Literal("NOT_REVOKED", "REVOKED", "PARENT_CERT_REVOKED"),
        sha256Fingerprint: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetCertificateAuthoritiesResponse",
}) as unknown as Schema.Schema<GetCertificateAuthoritiesResponse>;

export const getCertificateAuthorities: (
  input: GetCertificateAuthoritiesRequest,
) => Effect.Effect<
  GetCertificateAuthoritiesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCertificateAuthoritiesRequest,
  output: GetCertificateAuthoritiesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetCertificateAuthorityDetailsRequest {
  ca_slug: string;
  format?: "JSON" | "CSV";
}

export const GetCertificateAuthorityDetailsRequest = Schema.Struct({
  ca_slug: Schema.String.pipe(T.HttpPath("ca_slug")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ct/authorities/{ca_slug}" }))
  .annotations({
    identifier: "GetCertificateAuthorityDetailsRequest",
  }) as unknown as Schema.Schema<GetCertificateAuthorityDetailsRequest>;

export interface GetCertificateAuthorityDetailsResponse {
  result: {
    certificateAuthority: {
      appleStatus:
        | "INCLUDED"
        | "NOT_YET_INCLUDED"
        | "NOT_INCLUDED"
        | "NOT_BEFORE"
        | "REMOVED"
        | "DISABLED"
        | "BLOCKED";
      authorityKeyIdentifier: string;
      certificateRecordType: "ROOT_CERTIFICATE" | "INTERMEDIATE_CERTIFICATE";
      chromeStatus:
        | "INCLUDED"
        | "NOT_YET_INCLUDED"
        | "NOT_INCLUDED"
        | "NOT_BEFORE"
        | "REMOVED"
        | "DISABLED"
        | "BLOCKED";
      country: string;
      countryName: string;
      microsoftStatus:
        | "INCLUDED"
        | "NOT_YET_INCLUDED"
        | "NOT_INCLUDED"
        | "NOT_BEFORE"
        | "REMOVED"
        | "DISABLED"
        | "BLOCKED";
      mozillaStatus:
        | "INCLUDED"
        | "NOT_YET_INCLUDED"
        | "NOT_INCLUDED"
        | "NOT_BEFORE"
        | "REMOVED"
        | "DISABLED"
        | "BLOCKED";
      name: string;
      owner: string;
      parentName: string;
      parentSha256Fingerprint: string;
      related: {
        certificateRecordType: "ROOT_CERTIFICATE" | "INTERMEDIATE_CERTIFICATE";
        name: string;
        revocationStatus: "NOT_REVOKED" | "REVOKED" | "PARENT_CERT_REVOKED";
        sha256Fingerprint: string;
      }[];
      revocationStatus: "NOT_REVOKED" | "REVOKED" | "PARENT_CERT_REVOKED";
      sha256Fingerprint: string;
      subjectKeyIdentifier: string;
      validFrom: string;
      validTo: string;
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetCertificateAuthorityDetailsResponse = Schema.Struct({
  result: Schema.Struct({
    certificateAuthority: Schema.Struct({
      appleStatus: Schema.Literal(
        "INCLUDED",
        "NOT_YET_INCLUDED",
        "NOT_INCLUDED",
        "NOT_BEFORE",
        "REMOVED",
        "DISABLED",
        "BLOCKED",
      ),
      authorityKeyIdentifier: Schema.String,
      certificateRecordType: Schema.Literal("ROOT_CERTIFICATE", "INTERMEDIATE_CERTIFICATE"),
      chromeStatus: Schema.Literal(
        "INCLUDED",
        "NOT_YET_INCLUDED",
        "NOT_INCLUDED",
        "NOT_BEFORE",
        "REMOVED",
        "DISABLED",
        "BLOCKED",
      ),
      country: Schema.String,
      countryName: Schema.String,
      microsoftStatus: Schema.Literal(
        "INCLUDED",
        "NOT_YET_INCLUDED",
        "NOT_INCLUDED",
        "NOT_BEFORE",
        "REMOVED",
        "DISABLED",
        "BLOCKED",
      ),
      mozillaStatus: Schema.Literal(
        "INCLUDED",
        "NOT_YET_INCLUDED",
        "NOT_INCLUDED",
        "NOT_BEFORE",
        "REMOVED",
        "DISABLED",
        "BLOCKED",
      ),
      name: Schema.String,
      owner: Schema.String,
      parentName: Schema.String,
      parentSha256Fingerprint: Schema.String,
      related: Schema.Array(
        Schema.Struct({
          certificateRecordType: Schema.Literal("ROOT_CERTIFICATE", "INTERMEDIATE_CERTIFICATE"),
          name: Schema.String,
          revocationStatus: Schema.Literal("NOT_REVOKED", "REVOKED", "PARENT_CERT_REVOKED"),
          sha256Fingerprint: Schema.String,
        }),
      ),
      revocationStatus: Schema.Literal("NOT_REVOKED", "REVOKED", "PARENT_CERT_REVOKED"),
      sha256Fingerprint: Schema.String,
      subjectKeyIdentifier: Schema.String,
      validFrom: Schema.String,
      validTo: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetCertificateAuthorityDetailsResponse",
}) as unknown as Schema.Schema<GetCertificateAuthorityDetailsResponse>;

export const getCertificateAuthorityDetails: (
  input: GetCertificateAuthorityDetailsRequest,
) => Effect.Effect<
  GetCertificateAuthorityDetailsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCertificateAuthorityDetailsRequest,
  output: GetCertificateAuthorityDetailsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetCertificateLogsRequest {
  limit?: number;
  offset?: number;
  format?: "JSON" | "CSV";
}

export const GetCertificateLogsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ct/logs" }))
  .annotations({
    identifier: "GetCertificateLogsRequest",
  }) as unknown as Schema.Schema<GetCertificateLogsRequest>;

export interface GetCertificateLogsResponse {
  result: {
    certificateLogs: {
      api: "RFC6962" | "STATIC";
      description: string;
      endExclusive: string;
      operator: string;
      slug: string;
      startInclusive: string;
      state: "USABLE" | "PENDING" | "QUALIFIED" | "READ_ONLY" | "RETIRED" | "REJECTED";
      stateTimestamp: string;
      url: string;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetCertificateLogsResponse = Schema.Struct({
  result: Schema.Struct({
    certificateLogs: Schema.Array(
      Schema.Struct({
        api: Schema.Literal("RFC6962", "STATIC"),
        description: Schema.String,
        endExclusive: Schema.Date,
        operator: Schema.String,
        slug: Schema.String,
        startInclusive: Schema.Date,
        state: Schema.Literal("USABLE", "PENDING", "QUALIFIED", "READ_ONLY", "RETIRED", "REJECTED"),
        stateTimestamp: Schema.Date,
        url: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetCertificateLogsResponse",
}) as unknown as Schema.Schema<GetCertificateLogsResponse>;

export const getCertificateLogs: (
  input: GetCertificateLogsRequest,
) => Effect.Effect<
  GetCertificateLogsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCertificateLogsRequest,
  output: GetCertificateLogsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetCertificateLogDetailsRequest {
  log_slug: string;
  format?: "JSON" | "CSV";
}

export const GetCertificateLogDetailsRequest = Schema.Struct({
  log_slug: Schema.String.pipe(T.HttpPath("log_slug")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ct/logs/{log_slug}" }))
  .annotations({
    identifier: "GetCertificateLogDetailsRequest",
  }) as unknown as Schema.Schema<GetCertificateLogDetailsRequest>;

export interface GetCertificateLogDetailsResponse {
  result: {
    certificateLog: {
      api: "RFC6962" | "STATIC";
      avgThroughput: number;
      description: string;
      endExclusive: string;
      lastUpdate: string;
      operator: string;
      performance: {
        endpoints: {
          endpoint:
            | "add-chain (new)"
            | "add-chain (old)"
            | "add-pre-chain (new)"
            | "add-pre-chain (old)"
            | "get-entries"
            | "get-roots"
            | "get-sth";
          responseTime: number;
          uptime: number;
        }[];
        responseTime: number;
        uptime: number;
      };
      related: {
        description: string;
        endExclusive: string;
        slug: string;
        startInclusive: string;
        state: "USABLE" | "PENDING" | "QUALIFIED" | "READ_ONLY" | "RETIRED" | "REJECTED";
      }[];
      slug: string;
      startInclusive: string;
      state: "USABLE" | "PENDING" | "QUALIFIED" | "READ_ONLY" | "RETIRED" | "REJECTED";
      stateTimestamp: string;
      submittableCertCount: string;
      submittedCertCount: string;
      url: string;
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetCertificateLogDetailsResponse = Schema.Struct({
  result: Schema.Struct({
    certificateLog: Schema.Struct({
      api: Schema.Literal("RFC6962", "STATIC"),
      avgThroughput: Schema.Number,
      description: Schema.String,
      endExclusive: Schema.Date,
      lastUpdate: Schema.Date,
      operator: Schema.String,
      performance: Schema.NullOr(
        Schema.Struct({
          endpoints: Schema.Array(
            Schema.Struct({
              endpoint: Schema.Literal(
                "add-chain (new)",
                "add-chain (old)",
                "add-pre-chain (new)",
                "add-pre-chain (old)",
                "get-entries",
                "get-roots",
                "get-sth",
              ),
              responseTime: Schema.Number,
              uptime: Schema.Number,
            }),
          ),
          responseTime: Schema.Number,
          uptime: Schema.Number,
        }),
      ),
      related: Schema.Array(
        Schema.Struct({
          description: Schema.String,
          endExclusive: Schema.Date,
          slug: Schema.String,
          startInclusive: Schema.Date,
          state: Schema.Literal(
            "USABLE",
            "PENDING",
            "QUALIFIED",
            "READ_ONLY",
            "RETIRED",
            "REJECTED",
          ),
        }),
      ),
      slug: Schema.String,
      startInclusive: Schema.Date,
      state: Schema.Literal("USABLE", "PENDING", "QUALIFIED", "READ_ONLY", "RETIRED", "REJECTED"),
      stateTimestamp: Schema.Date,
      submittableCertCount: Schema.NullOr(Schema.String),
      submittedCertCount: Schema.NullOr(Schema.String),
      url: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetCertificateLogDetailsResponse",
}) as unknown as Schema.Schema<GetCertificateLogDetailsResponse>;

export const getCertificateLogDetails: (
  input: GetCertificateLogDetailsRequest,
) => Effect.Effect<
  GetCertificateLogDetailsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCertificateLogDetailsRequest,
  output: GetCertificateLogDetailsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetCtSummaryRequest {
  dimension:
    | "CA"
    | "CA_OWNER"
    | "DURATION"
    | "ENTRY_TYPE"
    | "EXPIRATION_STATUS"
    | "HAS_IPS"
    | "HAS_WILDCARDS"
    | "LOG"
    | "LOG_API"
    | "LOG_OPERATOR"
    | "PUBLIC_KEY_ALGORITHM"
    | "SIGNATURE_ALGORITHM"
    | "TLD"
    | "VALIDATION_LEVEL";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  limitPerGroup?: number;
  ca?: string[];
  caOwner?: string[];
  duration?:
    | "LTE_3D"
    | "GT_3D_LTE_7D"
    | "GT_7D_LTE_10D"
    | "GT_10D_LTE_47D"
    | "GT_47D_LTE_100D"
    | "GT_100D_LTE_200D"
    | "GT_200D"[];
  entryType?: "PRECERTIFICATE" | "CERTIFICATE"[];
  expirationStatus?: "EXPIRED" | "VALID"[];
  hasIps?: boolean[];
  hasWildcards?: boolean[];
  log?: string[];
  logApi?: "RFC6962" | "STATIC"[];
  logOperator?: string[];
  publicKeyAlgorithm?: "DSA" | "ECDSA" | "RSA"[];
  signatureAlgorithm?:
    | "DSA_SHA_1"
    | "DSA_SHA_256"
    | "ECDSA_SHA_1"
    | "ECDSA_SHA_256"
    | "ECDSA_SHA_384"
    | "ECDSA_SHA_512"
    | "PSS_SHA_256"
    | "PSS_SHA_384"
    | "PSS_SHA_512"
    | "RSA_MD2"
    | "RSA_MD5"
    | "RSA_SHA_1"
    | "RSA_SHA_256"
    | "RSA_SHA_384"
    | "RSA_SHA_512"[];
  tld?: string[];
  validationLevel?: "DOMAIN" | "ORGANIZATION" | "EXTENDED"[];
  uniqueEntries?: "true" | "false"[];
  normalization?: "RAW_VALUES" | "PERCENTAGE";
  format?: "JSON" | "CSV";
}

export const GetCtSummaryRequest = Schema.Struct({
  dimension: Schema.Literal(
    "CA",
    "CA_OWNER",
    "DURATION",
    "ENTRY_TYPE",
    "EXPIRATION_STATUS",
    "HAS_IPS",
    "HAS_WILDCARDS",
    "LOG",
    "LOG_API",
    "LOG_OPERATOR",
    "PUBLIC_KEY_ALGORITHM",
    "SIGNATURE_ALGORITHM",
    "TLD",
    "VALIDATION_LEVEL",
  ).pipe(T.HttpPath("dimension")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  ca: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("ca")),
  caOwner: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("caOwner")),
  duration: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "LTE_3D",
        "GT_3D_LTE_7D",
        "GT_7D_LTE_10D",
        "GT_10D_LTE_47D",
        "GT_47D_LTE_100D",
        "GT_100D_LTE_200D",
        "GT_200D",
      ),
    ),
  ).pipe(T.HttpQuery("duration")),
  entryType: Schema.optional(Schema.Array(Schema.Literal("PRECERTIFICATE", "CERTIFICATE"))).pipe(
    T.HttpQuery("entryType"),
  ),
  expirationStatus: Schema.optional(Schema.Array(Schema.Literal("EXPIRED", "VALID"))).pipe(
    T.HttpQuery("expirationStatus"),
  ),
  hasIps: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("hasIps")),
  hasWildcards: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("hasWildcards")),
  log: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("log")),
  logApi: Schema.optional(Schema.Array(Schema.Literal("RFC6962", "STATIC"))).pipe(
    T.HttpQuery("logApi"),
  ),
  logOperator: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("logOperator")),
  publicKeyAlgorithm: Schema.optional(Schema.Array(Schema.Literal("DSA", "ECDSA", "RSA"))).pipe(
    T.HttpQuery("publicKeyAlgorithm"),
  ),
  signatureAlgorithm: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DSA_SHA_1",
        "DSA_SHA_256",
        "ECDSA_SHA_1",
        "ECDSA_SHA_256",
        "ECDSA_SHA_384",
        "ECDSA_SHA_512",
        "PSS_SHA_256",
        "PSS_SHA_384",
        "PSS_SHA_512",
        "RSA_MD2",
        "RSA_MD5",
        "RSA_SHA_1",
        "RSA_SHA_256",
        "RSA_SHA_384",
        "RSA_SHA_512",
      ),
    ),
  ).pipe(T.HttpQuery("signatureAlgorithm")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  validationLevel: Schema.optional(
    Schema.Array(Schema.Literal("DOMAIN", "ORGANIZATION", "EXTENDED")),
  ).pipe(T.HttpQuery("validationLevel")),
  uniqueEntries: Schema.optional(Schema.Array(Schema.Literal("true", "false"))).pipe(
    T.HttpQuery("uniqueEntries"),
  ),
  normalization: Schema.optional(Schema.Literal("RAW_VALUES", "PERCENTAGE")).pipe(
    T.HttpQuery("normalization"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ct/summary/{dimension}" }))
  .annotations({
    identifier: "GetCtSummaryRequest",
  }) as unknown as Schema.Schema<GetCtSummaryRequest>;

export interface GetCtSummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: unknown;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetCtSummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Union(
      Schema.Record({ key: Schema.String, value: Schema.String }),
      Schema.Struct({
        rfc6962: Schema.String,
        static: Schema.String,
      }),
      Schema.Struct({
        gt_121d: Schema.String,
        gt_16d_lte_31d: Schema.String,
        gt_31d_lte_91d: Schema.String,
        gt_3d_lte_16d: Schema.String,
        gt_91d_lte_121d: Schema.String,
        lte_3d: Schema.String,
      }),
      Schema.Struct({
        CERTIFICATE: Schema.String,
        PRECERTIFICATE: Schema.String,
      }),
      Schema.Struct({
        EXPIRED: Schema.String,
        VALID: Schema.String,
      }),
      Schema.Struct({
        NEGATIVE: Schema.String,
        POSITIVE: Schema.String,
      }),
      Schema.Struct({
        DSA: Schema.String,
        ECDSA: Schema.String,
        RSA: Schema.String,
      }),
      Schema.Struct({
        domain: Schema.String,
        extended: Schema.String,
        organization: Schema.String,
        unknown: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetCtSummaryResponse",
}) as unknown as Schema.Schema<GetCtSummaryResponse>;

export const getCtSummary: (
  input: GetCtSummaryRequest,
) => Effect.Effect<
  GetCtSummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCtSummaryRequest,
  output: GetCtSummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetCtTimeseriesRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  ca?: string[];
  caOwner?: string[];
  duration?:
    | "LTE_3D"
    | "GT_3D_LTE_7D"
    | "GT_7D_LTE_10D"
    | "GT_10D_LTE_47D"
    | "GT_47D_LTE_100D"
    | "GT_100D_LTE_200D"
    | "GT_200D"[];
  entryType?: "PRECERTIFICATE" | "CERTIFICATE"[];
  expirationStatus?: "EXPIRED" | "VALID"[];
  hasIps?: boolean[];
  hasWildcards?: boolean[];
  log?: string[];
  logApi?: "RFC6962" | "STATIC"[];
  logOperator?: string[];
  publicKeyAlgorithm?: "DSA" | "ECDSA" | "RSA"[];
  signatureAlgorithm?:
    | "DSA_SHA_1"
    | "DSA_SHA_256"
    | "ECDSA_SHA_1"
    | "ECDSA_SHA_256"
    | "ECDSA_SHA_384"
    | "ECDSA_SHA_512"
    | "PSS_SHA_256"
    | "PSS_SHA_384"
    | "PSS_SHA_512"
    | "RSA_MD2"
    | "RSA_MD5"
    | "RSA_SHA_1"
    | "RSA_SHA_256"
    | "RSA_SHA_384"
    | "RSA_SHA_512"[];
  tld?: string[];
  validationLevel?: "DOMAIN" | "ORGANIZATION" | "EXTENDED"[];
  uniqueEntries?: "true" | "false"[];
  format?: "JSON" | "CSV";
}

export const GetCtTimeseriesRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  ca: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("ca")),
  caOwner: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("caOwner")),
  duration: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "LTE_3D",
        "GT_3D_LTE_7D",
        "GT_7D_LTE_10D",
        "GT_10D_LTE_47D",
        "GT_47D_LTE_100D",
        "GT_100D_LTE_200D",
        "GT_200D",
      ),
    ),
  ).pipe(T.HttpQuery("duration")),
  entryType: Schema.optional(Schema.Array(Schema.Literal("PRECERTIFICATE", "CERTIFICATE"))).pipe(
    T.HttpQuery("entryType"),
  ),
  expirationStatus: Schema.optional(Schema.Array(Schema.Literal("EXPIRED", "VALID"))).pipe(
    T.HttpQuery("expirationStatus"),
  ),
  hasIps: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("hasIps")),
  hasWildcards: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("hasWildcards")),
  log: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("log")),
  logApi: Schema.optional(Schema.Array(Schema.Literal("RFC6962", "STATIC"))).pipe(
    T.HttpQuery("logApi"),
  ),
  logOperator: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("logOperator")),
  publicKeyAlgorithm: Schema.optional(Schema.Array(Schema.Literal("DSA", "ECDSA", "RSA"))).pipe(
    T.HttpQuery("publicKeyAlgorithm"),
  ),
  signatureAlgorithm: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DSA_SHA_1",
        "DSA_SHA_256",
        "ECDSA_SHA_1",
        "ECDSA_SHA_256",
        "ECDSA_SHA_384",
        "ECDSA_SHA_512",
        "PSS_SHA_256",
        "PSS_SHA_384",
        "PSS_SHA_512",
        "RSA_MD2",
        "RSA_MD5",
        "RSA_SHA_1",
        "RSA_SHA_256",
        "RSA_SHA_384",
        "RSA_SHA_512",
      ),
    ),
  ).pipe(T.HttpQuery("signatureAlgorithm")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  validationLevel: Schema.optional(
    Schema.Array(Schema.Literal("DOMAIN", "ORGANIZATION", "EXTENDED")),
  ).pipe(T.HttpQuery("validationLevel")),
  uniqueEntries: Schema.optional(Schema.Array(Schema.Literal("true", "false"))).pipe(
    T.HttpQuery("uniqueEntries"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ct/timeseries" }))
  .annotations({
    identifier: "GetCtTimeseriesRequest",
  }) as unknown as Schema.Schema<GetCtTimeseriesRequest>;

export interface GetCtTimeseriesResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetCtTimeseriesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetCtTimeseriesResponse",
}) as unknown as Schema.Schema<GetCtTimeseriesResponse>;

export const getCtTimeseries: (
  input: GetCtTimeseriesRequest,
) => Effect.Effect<
  GetCtTimeseriesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCtTimeseriesRequest,
  output: GetCtTimeseriesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetCtTimeseriesGroupRequest {
  dimension:
    | "CA"
    | "CA_OWNER"
    | "DURATION"
    | "ENTRY_TYPE"
    | "EXPIRATION_STATUS"
    | "HAS_IPS"
    | "HAS_WILDCARDS"
    | "LOG"
    | "LOG_API"
    | "LOG_OPERATOR"
    | "PUBLIC_KEY_ALGORITHM"
    | "SIGNATURE_ALGORITHM"
    | "TLD"
    | "VALIDATION_LEVEL";
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  limitPerGroup?: number;
  ca?: string[];
  caOwner?: string[];
  duration?:
    | "LTE_3D"
    | "GT_3D_LTE_7D"
    | "GT_7D_LTE_10D"
    | "GT_10D_LTE_47D"
    | "GT_47D_LTE_100D"
    | "GT_100D_LTE_200D"
    | "GT_200D"[];
  entryType?: "PRECERTIFICATE" | "CERTIFICATE"[];
  expirationStatus?: "EXPIRED" | "VALID"[];
  hasIps?: boolean[];
  hasWildcards?: boolean[];
  log?: string[];
  logApi?: "RFC6962" | "STATIC"[];
  logOperator?: string[];
  publicKeyAlgorithm?: "DSA" | "ECDSA" | "RSA"[];
  signatureAlgorithm?:
    | "DSA_SHA_1"
    | "DSA_SHA_256"
    | "ECDSA_SHA_1"
    | "ECDSA_SHA_256"
    | "ECDSA_SHA_384"
    | "ECDSA_SHA_512"
    | "PSS_SHA_256"
    | "PSS_SHA_384"
    | "PSS_SHA_512"
    | "RSA_MD2"
    | "RSA_MD5"
    | "RSA_SHA_1"
    | "RSA_SHA_256"
    | "RSA_SHA_384"
    | "RSA_SHA_512"[];
  validationLevel?: "DOMAIN" | "ORGANIZATION" | "EXTENDED"[];
  tld?: string[];
  normalization?: "RAW_VALUES" | "PERCENTAGE";
  uniqueEntries?: "true" | "false"[];
  format?: "JSON" | "CSV";
}

export const GetCtTimeseriesGroupRequest = Schema.Struct({
  dimension: Schema.Literal(
    "CA",
    "CA_OWNER",
    "DURATION",
    "ENTRY_TYPE",
    "EXPIRATION_STATUS",
    "HAS_IPS",
    "HAS_WILDCARDS",
    "LOG",
    "LOG_API",
    "LOG_OPERATOR",
    "PUBLIC_KEY_ALGORITHM",
    "SIGNATURE_ALGORITHM",
    "TLD",
    "VALIDATION_LEVEL",
  ).pipe(T.HttpPath("dimension")),
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  ca: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("ca")),
  caOwner: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("caOwner")),
  duration: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "LTE_3D",
        "GT_3D_LTE_7D",
        "GT_7D_LTE_10D",
        "GT_10D_LTE_47D",
        "GT_47D_LTE_100D",
        "GT_100D_LTE_200D",
        "GT_200D",
      ),
    ),
  ).pipe(T.HttpQuery("duration")),
  entryType: Schema.optional(Schema.Array(Schema.Literal("PRECERTIFICATE", "CERTIFICATE"))).pipe(
    T.HttpQuery("entryType"),
  ),
  expirationStatus: Schema.optional(Schema.Array(Schema.Literal("EXPIRED", "VALID"))).pipe(
    T.HttpQuery("expirationStatus"),
  ),
  hasIps: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("hasIps")),
  hasWildcards: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("hasWildcards")),
  log: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("log")),
  logApi: Schema.optional(Schema.Array(Schema.Literal("RFC6962", "STATIC"))).pipe(
    T.HttpQuery("logApi"),
  ),
  logOperator: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("logOperator")),
  publicKeyAlgorithm: Schema.optional(Schema.Array(Schema.Literal("DSA", "ECDSA", "RSA"))).pipe(
    T.HttpQuery("publicKeyAlgorithm"),
  ),
  signatureAlgorithm: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "DSA_SHA_1",
        "DSA_SHA_256",
        "ECDSA_SHA_1",
        "ECDSA_SHA_256",
        "ECDSA_SHA_384",
        "ECDSA_SHA_512",
        "PSS_SHA_256",
        "PSS_SHA_384",
        "PSS_SHA_512",
        "RSA_MD2",
        "RSA_MD5",
        "RSA_SHA_1",
        "RSA_SHA_256",
        "RSA_SHA_384",
        "RSA_SHA_512",
      ),
    ),
  ).pipe(T.HttpQuery("signatureAlgorithm")),
  validationLevel: Schema.optional(
    Schema.Array(Schema.Literal("DOMAIN", "ORGANIZATION", "EXTENDED")),
  ).pipe(T.HttpQuery("validationLevel")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  normalization: Schema.optional(Schema.Literal("RAW_VALUES", "PERCENTAGE")).pipe(
    T.HttpQuery("normalization"),
  ),
  uniqueEntries: Schema.optional(Schema.Array(Schema.Literal("true", "false"))).pipe(
    T.HttpQuery("uniqueEntries"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ct/timeseries_groups/{dimension}" }))
  .annotations({
    identifier: "GetCtTimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetCtTimeseriesGroupRequest>;

export interface GetCtTimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: unknown;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetCtTimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Union(
      Schema.Struct({
        timestamps: Schema.Array(Schema.Date),
      }),
      Schema.Struct({
        rfc6962: Schema.Array(Schema.String),
        static: Schema.Array(Schema.String),
      }),
      Schema.Struct({
        gt_121d: Schema.Array(Schema.String),
        gt_16d_lte_31d: Schema.Array(Schema.String),
        gt_31d_lte_91d: Schema.Array(Schema.String),
        gt_3d_lte_16d: Schema.Array(Schema.String),
        gt_91d_lte_121d: Schema.Array(Schema.String),
        lte_3d: Schema.Array(Schema.String),
      }),
      Schema.Struct({
        CERTIFICATE: Schema.Array(Schema.String),
        PRECERTIFICATE: Schema.Array(Schema.String),
      }),
      Schema.Struct({
        EXPIRED: Schema.Array(Schema.String),
        VALID: Schema.Array(Schema.String),
      }),
      Schema.Struct({
        NEGATIVE: Schema.Array(Schema.String),
        POSITIVE: Schema.Array(Schema.String),
      }),
      Schema.Struct({
        DSA: Schema.Array(Schema.String),
        ECDSA: Schema.Array(Schema.String),
        RSA: Schema.Array(Schema.String),
      }),
      Schema.Struct({
        domain: Schema.Array(Schema.String),
        extended: Schema.Array(Schema.String),
        organization: Schema.Array(Schema.String),
        unknown: Schema.Array(Schema.String),
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetCtTimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetCtTimeseriesGroupResponse>;

export const getCtTimeseriesGroup: (
  input: GetCtTimeseriesGroupRequest,
) => Effect.Effect<
  GetCtTimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCtTimeseriesGroupRequest,
  output: GetCtTimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetReportsDatasetsRequest {
  limit?: number;
  offset?: number;
  datasetType?: "RANKING_BUCKET" | "REPORT";
  date?: string;
  format?: "JSON" | "CSV";
}

export const GetReportsDatasetsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset")),
  datasetType: Schema.optional(Schema.Literal("RANKING_BUCKET", "REPORT")).pipe(
    T.HttpQuery("datasetType"),
  ),
  date: Schema.optional(Schema.Date).pipe(T.HttpQuery("date")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/datasets" }))
  .annotations({
    identifier: "GetReportsDatasetsRequest",
  }) as unknown as Schema.Schema<GetReportsDatasetsRequest>;

export interface GetReportsDatasetsResponse {
  result: {
    datasets: {
      description: string;
      id: number;
      meta: Record<string, unknown>;
      tags: string[];
      title: string;
      type: string;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetReportsDatasetsResponse = Schema.Struct({
  result: Schema.Struct({
    datasets: Schema.Array(
      Schema.Struct({
        description: Schema.String,
        id: Schema.Number,
        meta: Schema.Struct({}),
        tags: Schema.Array(Schema.String),
        title: Schema.String,
        type: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetReportsDatasetsResponse",
}) as unknown as Schema.Schema<GetReportsDatasetsResponse>;

export const getReportsDatasets: (
  input: GetReportsDatasetsRequest,
) => Effect.Effect<
  GetReportsDatasetsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetReportsDatasetsRequest,
  output: GetReportsDatasetsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface PostReportsDatasetDownloadUrlRequest {
  format?: "JSON" | "CSV";
  body: { datasetId: number };
}

export const PostReportsDatasetDownloadUrlRequest = Schema.Struct({
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
  body: Schema.Struct({
    datasetId: Schema.Number,
  }).pipe(T.HttpBody()),
})
  .pipe(T.Http({ method: "POST", path: "/radar/datasets/download" }))
  .annotations({
    identifier: "PostReportsDatasetDownloadUrlRequest",
  }) as unknown as Schema.Schema<PostReportsDatasetDownloadUrlRequest>;

export interface PostReportsDatasetDownloadUrlResponse {
  result: { dataset: { url: string } };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const PostReportsDatasetDownloadUrlResponse = Schema.Struct({
  result: Schema.Struct({
    dataset: Schema.Struct({
      url: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "PostReportsDatasetDownloadUrlResponse",
}) as unknown as Schema.Schema<PostReportsDatasetDownloadUrlResponse>;

export const postReportsDatasetDownloadUrl: (
  input: PostReportsDatasetDownloadUrlRequest,
) => Effect.Effect<
  PostReportsDatasetDownloadUrlResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostReportsDatasetDownloadUrlRequest,
  output: PostReportsDatasetDownloadUrlResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetReportsDatasetDownloadRequest {
  alias: string;
}

export const GetReportsDatasetDownloadRequest = Schema.Struct({
  alias: Schema.String.pipe(T.HttpPath("alias")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/datasets/{alias}" }))
  .annotations({
    identifier: "GetReportsDatasetDownloadRequest",
  }) as unknown as Schema.Schema<GetReportsDatasetDownloadRequest>;

export interface GetReportsDatasetDownloadResponse {
  result: unknown | null;
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetReportsDatasetDownloadResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetReportsDatasetDownloadResponse",
}) as unknown as Schema.Schema<GetReportsDatasetDownloadResponse>;

export const getReportsDatasetDownload: (
  input: GetReportsDatasetDownloadRequest,
) => Effect.Effect<
  GetReportsDatasetDownloadResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetReportsDatasetDownloadRequest,
  output: GetReportsDatasetDownloadResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsSummaryByCacheHitStatusRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsSummaryByCacheHitStatusRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/summary/cache_hit" }))
  .annotations({
    identifier: "GetDnsSummaryByCacheHitStatusRequest",
  }) as unknown as Schema.Schema<GetDnsSummaryByCacheHitStatusRequest>;

export interface GetDnsSummaryByCacheHitStatusResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { NEGATIVE: string; POSITIVE: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsSummaryByCacheHitStatusResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      NEGATIVE: Schema.String,
      POSITIVE: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsSummaryByCacheHitStatusResponse",
}) as unknown as Schema.Schema<GetDnsSummaryByCacheHitStatusResponse>;

export const getDnsSummaryByCacheHitStatus: (
  input: GetDnsSummaryByCacheHitStatusRequest,
) => Effect.Effect<
  GetDnsSummaryByCacheHitStatusResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsSummaryByCacheHitStatusRequest,
  output: GetDnsSummaryByCacheHitStatusResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsSummaryByDnssecRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsSummaryByDnssecRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/summary/dnssec" }))
  .annotations({
    identifier: "GetDnsSummaryByDnssecRequest",
  }) as unknown as Schema.Schema<GetDnsSummaryByDnssecRequest>;

export interface GetDnsSummaryByDnssecResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { INSECURE: string; INVALID: string; OTHER: string; SECURE: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsSummaryByDnssecResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      INSECURE: Schema.String,
      INVALID: Schema.String,
      OTHER: Schema.String,
      SECURE: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsSummaryByDnssecResponse",
}) as unknown as Schema.Schema<GetDnsSummaryByDnssecResponse>;

export const getDnsSummaryByDnssec: (
  input: GetDnsSummaryByDnssecRequest,
) => Effect.Effect<
  GetDnsSummaryByDnssecResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsSummaryByDnssecRequest,
  output: GetDnsSummaryByDnssecResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsSummaryByDnssecAwarenessRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsSummaryByDnssecAwarenessRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/summary/dnssec_aware" }))
  .annotations({
    identifier: "GetDnsSummaryByDnssecAwarenessRequest",
  }) as unknown as Schema.Schema<GetDnsSummaryByDnssecAwarenessRequest>;

export interface GetDnsSummaryByDnssecAwarenessResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { NOT_SUPPORTED: string; SUPPORTED: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsSummaryByDnssecAwarenessResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      NOT_SUPPORTED: Schema.String,
      SUPPORTED: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsSummaryByDnssecAwarenessResponse",
}) as unknown as Schema.Schema<GetDnsSummaryByDnssecAwarenessResponse>;

export const getDnsSummaryByDnssecAwareness: (
  input: GetDnsSummaryByDnssecAwarenessRequest,
) => Effect.Effect<
  GetDnsSummaryByDnssecAwarenessResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsSummaryByDnssecAwarenessRequest,
  output: GetDnsSummaryByDnssecAwarenessResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsSummaryByDnssecE2eVersionRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsSummaryByDnssecE2eVersionRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/summary/dnssec_e2e" }))
  .annotations({
    identifier: "GetDnsSummaryByDnssecE2eVersionRequest",
  }) as unknown as Schema.Schema<GetDnsSummaryByDnssecE2eVersionRequest>;

export interface GetDnsSummaryByDnssecE2eVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { NEGATIVE: string; POSITIVE: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsSummaryByDnssecE2eVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      NEGATIVE: Schema.String,
      POSITIVE: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsSummaryByDnssecE2eVersionResponse",
}) as unknown as Schema.Schema<GetDnsSummaryByDnssecE2eVersionResponse>;

export const getDnsSummaryByDnssecE2eVersion: (
  input: GetDnsSummaryByDnssecE2eVersionRequest,
) => Effect.Effect<
  GetDnsSummaryByDnssecE2eVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsSummaryByDnssecE2eVersionRequest,
  output: GetDnsSummaryByDnssecE2eVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsSummaryByIpVersionRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsSummaryByIpVersionRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/summary/ip_version" }))
  .annotations({
    identifier: "GetDnsSummaryByIpVersionRequest",
  }) as unknown as Schema.Schema<GetDnsSummaryByIpVersionRequest>;

export interface GetDnsSummaryByIpVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { IPv4: string; IPv6: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsSummaryByIpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      IPv4: Schema.String,
      IPv6: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsSummaryByIpVersionResponse",
}) as unknown as Schema.Schema<GetDnsSummaryByIpVersionResponse>;

export const getDnsSummaryByIpVersion: (
  input: GetDnsSummaryByIpVersionRequest,
) => Effect.Effect<
  GetDnsSummaryByIpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsSummaryByIpVersionRequest,
  output: GetDnsSummaryByIpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsSummaryByMatchingAnswerStatusRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsSummaryByMatchingAnswerStatusRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/summary/matching_answer" }))
  .annotations({
    identifier: "GetDnsSummaryByMatchingAnswerStatusRequest",
  }) as unknown as Schema.Schema<GetDnsSummaryByMatchingAnswerStatusRequest>;

export interface GetDnsSummaryByMatchingAnswerStatusResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { NEGATIVE: string; POSITIVE: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsSummaryByMatchingAnswerStatusResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      NEGATIVE: Schema.String,
      POSITIVE: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsSummaryByMatchingAnswerStatusResponse",
}) as unknown as Schema.Schema<GetDnsSummaryByMatchingAnswerStatusResponse>;

export const getDnsSummaryByMatchingAnswerStatus: (
  input: GetDnsSummaryByMatchingAnswerStatusRequest,
) => Effect.Effect<
  GetDnsSummaryByMatchingAnswerStatusResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsSummaryByMatchingAnswerStatusRequest,
  output: GetDnsSummaryByMatchingAnswerStatusResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsSummaryByProtocolRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsSummaryByProtocolRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/summary/protocol" }))
  .annotations({
    identifier: "GetDnsSummaryByProtocolRequest",
  }) as unknown as Schema.Schema<GetDnsSummaryByProtocolRequest>;

export interface GetDnsSummaryByProtocolResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { HTTPS: string; TCP: string; TLS: string; UDP: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsSummaryByProtocolResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      HTTPS: Schema.String,
      TCP: Schema.String,
      TLS: Schema.String,
      UDP: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsSummaryByProtocolResponse",
}) as unknown as Schema.Schema<GetDnsSummaryByProtocolResponse>;

export const getDnsSummaryByProtocol: (
  input: GetDnsSummaryByProtocolRequest,
) => Effect.Effect<
  GetDnsSummaryByProtocolResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsSummaryByProtocolRequest,
  output: GetDnsSummaryByProtocolResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsSummaryByQueryTypeRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetDnsSummaryByQueryTypeRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/summary/query_type" }))
  .annotations({
    identifier: "GetDnsSummaryByQueryTypeRequest",
  }) as unknown as Schema.Schema<GetDnsSummaryByQueryTypeRequest>;

export interface GetDnsSummaryByQueryTypeResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsSummaryByQueryTypeResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsSummaryByQueryTypeResponse",
}) as unknown as Schema.Schema<GetDnsSummaryByQueryTypeResponse>;

export const getDnsSummaryByQueryType: (
  input: GetDnsSummaryByQueryTypeRequest,
) => Effect.Effect<
  GetDnsSummaryByQueryTypeResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsSummaryByQueryTypeRequest,
  output: GetDnsSummaryByQueryTypeResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsSummaryByResponseCodeRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  nodata?: boolean[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetDnsSummaryByResponseCodeRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/summary/response_code" }))
  .annotations({
    identifier: "GetDnsSummaryByResponseCodeRequest",
  }) as unknown as Schema.Schema<GetDnsSummaryByResponseCodeRequest>;

export interface GetDnsSummaryByResponseCodeResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsSummaryByResponseCodeResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsSummaryByResponseCodeResponse",
}) as unknown as Schema.Schema<GetDnsSummaryByResponseCodeResponse>;

export const getDnsSummaryByResponseCode: (
  input: GetDnsSummaryByResponseCodeRequest,
) => Effect.Effect<
  GetDnsSummaryByResponseCodeResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsSummaryByResponseCodeRequest,
  output: GetDnsSummaryByResponseCodeResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsSummaryByResponseTtlRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsSummaryByResponseTtlRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/summary/response_ttl" }))
  .annotations({
    identifier: "GetDnsSummaryByResponseTtlRequest",
  }) as unknown as Schema.Schema<GetDnsSummaryByResponseTtlRequest>;

export interface GetDnsSummaryByResponseTtlResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: {
      gt_15m_lte_1h: string;
      gt_1d_lte_1w: string;
      gt_1h_lte_1d: string;
      gt_1m_lte_5m: string;
      gt_1w: string;
      gt_5m_lte_15m: string;
      lte_1m: string;
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsSummaryByResponseTtlResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      gt_15m_lte_1h: Schema.String,
      gt_1d_lte_1w: Schema.String,
      gt_1h_lte_1d: Schema.String,
      gt_1m_lte_5m: Schema.String,
      gt_1w: Schema.String,
      gt_5m_lte_15m: Schema.String,
      lte_1m: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsSummaryByResponseTtlResponse",
}) as unknown as Schema.Schema<GetDnsSummaryByResponseTtlResponse>;

export const getDnsSummaryByResponseTtl: (
  input: GetDnsSummaryByResponseTtlRequest,
) => Effect.Effect<
  GetDnsSummaryByResponseTtlResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsSummaryByResponseTtlRequest,
  output: GetDnsSummaryByResponseTtlResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsSummaryRequest {
  dimension:
    | "IP_VERSION"
    | "CACHE_HIT"
    | "DNSSEC"
    | "DNSSEC_AWARE"
    | "DNSSEC_E2E"
    | "MATCHING_ANSWER"
    | "PROTOCOL"
    | "QUERY_TYPE"
    | "RESPONSE_CODE"
    | "RESPONSE_TTL"
    | "TLD"
    | "TLD_DNS_MAGNITUDE";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  cacheHit?: boolean[];
  nodata?: boolean[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  responseTtl?:
    | "LTE_1M"
    | "GT_1M_LTE_5M"
    | "GT_5M_LTE_15M"
    | "GT_15M_LTE_1H"
    | "GT_1H_LTE_1D"
    | "GT_1D_LTE_1W"
    | "GT_1W"[];
  dnssec?: "INVALID" | "INSECURE" | "SECURE" | "OTHER"[];
  dnssecAware?: "SUPPORTED" | "NOT_SUPPORTED"[];
  dnssecE2e?: boolean[];
  ipVersion?: "IPv4" | "IPv6"[];
  limitPerGroup?: number;
  matchingAnswer?: boolean[];
  tld?: string[];
  format?: "JSON" | "CSV";
}

export const GetDnsSummaryRequest = Schema.Struct({
  dimension: Schema.Literal(
    "IP_VERSION",
    "CACHE_HIT",
    "DNSSEC",
    "DNSSEC_AWARE",
    "DNSSEC_E2E",
    "MATCHING_ANSWER",
    "PROTOCOL",
    "QUERY_TYPE",
    "RESPONSE_CODE",
    "RESPONSE_TTL",
    "TLD",
    "TLD_DNS_MAGNITUDE",
  ).pipe(T.HttpPath("dimension")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  cacheHit: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("cacheHit")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  responseTtl: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "LTE_1M",
        "GT_1M_LTE_5M",
        "GT_5M_LTE_15M",
        "GT_15M_LTE_1H",
        "GT_1H_LTE_1D",
        "GT_1D_LTE_1W",
        "GT_1W",
      ),
    ),
  ).pipe(T.HttpQuery("responseTtl")),
  dnssec: Schema.optional(
    Schema.Array(Schema.Literal("INVALID", "INSECURE", "SECURE", "OTHER")),
  ).pipe(T.HttpQuery("dnssec")),
  dnssecAware: Schema.optional(Schema.Array(Schema.Literal("SUPPORTED", "NOT_SUPPORTED"))).pipe(
    T.HttpQuery("dnssecAware"),
  ),
  dnssecE2e: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("dnssecE2e")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  matchingAnswer: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("matchingAnswer")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/summary/{dimension}" }))
  .annotations({
    identifier: "GetDnsSummaryRequest",
  }) as unknown as Schema.Schema<GetDnsSummaryRequest>;

export interface GetDnsSummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsSummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsSummaryResponse",
}) as unknown as Schema.Schema<GetDnsSummaryResponse>;

export const getDnsSummary: (
  input: GetDnsSummaryRequest,
) => Effect.Effect<
  GetDnsSummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsSummaryRequest,
  output: GetDnsSummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsTimeseriesRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  cacheHit?: boolean[];
  nodata?: boolean[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  responseTtl?:
    | "LTE_1M"
    | "GT_1M_LTE_5M"
    | "GT_5M_LTE_15M"
    | "GT_15M_LTE_1H"
    | "GT_1H_LTE_1D"
    | "GT_1D_LTE_1W"
    | "GT_1W"[];
  dnssec?: "INVALID" | "INSECURE" | "SECURE" | "OTHER"[];
  dnssecAware?: "SUPPORTED" | "NOT_SUPPORTED"[];
  dnssecE2e?: boolean[];
  ipVersion?: "IPv4" | "IPv6"[];
  matchingAnswer?: boolean[];
  tld?: string[];
  format?: "JSON" | "CSV";
}

export const GetDnsTimeseriesRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  cacheHit: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("cacheHit")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  responseTtl: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "LTE_1M",
        "GT_1M_LTE_5M",
        "GT_5M_LTE_15M",
        "GT_15M_LTE_1H",
        "GT_1H_LTE_1D",
        "GT_1D_LTE_1W",
        "GT_1W",
      ),
    ),
  ).pipe(T.HttpQuery("responseTtl")),
  dnssec: Schema.optional(
    Schema.Array(Schema.Literal("INVALID", "INSECURE", "SECURE", "OTHER")),
  ).pipe(T.HttpQuery("dnssec")),
  dnssecAware: Schema.optional(Schema.Array(Schema.Literal("SUPPORTED", "NOT_SUPPORTED"))).pipe(
    T.HttpQuery("dnssecAware"),
  ),
  dnssecE2e: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("dnssecE2e")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  matchingAnswer: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("matchingAnswer")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/timeseries" }))
  .annotations({
    identifier: "GetDnsTimeseriesRequest",
  }) as unknown as Schema.Schema<GetDnsTimeseriesRequest>;

export interface GetDnsTimeseriesResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsTimeseriesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsTimeseriesResponse",
}) as unknown as Schema.Schema<GetDnsTimeseriesResponse>;

export const getDnsTimeseries: (
  input: GetDnsTimeseriesRequest,
) => Effect.Effect<
  GetDnsTimeseriesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsTimeseriesRequest,
  output: GetDnsTimeseriesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsTimeseriesGroupByCacheHitStatusRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsTimeseriesGroupByCacheHitStatusRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/timeseries_groups/cache_hit" }))
  .annotations({
    identifier: "GetDnsTimeseriesGroupByCacheHitStatusRequest",
  }) as unknown as Schema.Schema<GetDnsTimeseriesGroupByCacheHitStatusRequest>;

export interface GetDnsTimeseriesGroupByCacheHitStatusResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { NEGATIVE: string[]; POSITIVE: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsTimeseriesGroupByCacheHitStatusResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      NEGATIVE: Schema.Array(Schema.String),
      POSITIVE: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsTimeseriesGroupByCacheHitStatusResponse",
}) as unknown as Schema.Schema<GetDnsTimeseriesGroupByCacheHitStatusResponse>;

export const getDnsTimeseriesGroupByCacheHitStatus: (
  input: GetDnsTimeseriesGroupByCacheHitStatusRequest,
) => Effect.Effect<
  GetDnsTimeseriesGroupByCacheHitStatusResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsTimeseriesGroupByCacheHitStatusRequest,
  output: GetDnsTimeseriesGroupByCacheHitStatusResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsTimeseriesGroupByDnssecRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsTimeseriesGroupByDnssecRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/timeseries_groups/dnssec" }))
  .annotations({
    identifier: "GetDnsTimeseriesGroupByDnssecRequest",
  }) as unknown as Schema.Schema<GetDnsTimeseriesGroupByDnssecRequest>;

export interface GetDnsTimeseriesGroupByDnssecResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { INSECURE: string[]; INVALID: string[]; OTHER: string[]; SECURE: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsTimeseriesGroupByDnssecResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      INSECURE: Schema.Array(Schema.String),
      INVALID: Schema.Array(Schema.String),
      OTHER: Schema.Array(Schema.String),
      SECURE: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsTimeseriesGroupByDnssecResponse",
}) as unknown as Schema.Schema<GetDnsTimeseriesGroupByDnssecResponse>;

export const getDnsTimeseriesGroupByDnssec: (
  input: GetDnsTimeseriesGroupByDnssecRequest,
) => Effect.Effect<
  GetDnsTimeseriesGroupByDnssecResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsTimeseriesGroupByDnssecRequest,
  output: GetDnsTimeseriesGroupByDnssecResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsTimeseriesGroupByDnssecAwarenessRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsTimeseriesGroupByDnssecAwarenessRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/timeseries_groups/dnssec_aware" }))
  .annotations({
    identifier: "GetDnsTimeseriesGroupByDnssecAwarenessRequest",
  }) as unknown as Schema.Schema<GetDnsTimeseriesGroupByDnssecAwarenessRequest>;

export interface GetDnsTimeseriesGroupByDnssecAwarenessResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { NOT_SUPPORTED: string[]; SUPPORTED: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsTimeseriesGroupByDnssecAwarenessResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      NOT_SUPPORTED: Schema.Array(Schema.String),
      SUPPORTED: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsTimeseriesGroupByDnssecAwarenessResponse",
}) as unknown as Schema.Schema<GetDnsTimeseriesGroupByDnssecAwarenessResponse>;

export const getDnsTimeseriesGroupByDnssecAwareness: (
  input: GetDnsTimeseriesGroupByDnssecAwarenessRequest,
) => Effect.Effect<
  GetDnsTimeseriesGroupByDnssecAwarenessResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsTimeseriesGroupByDnssecAwarenessRequest,
  output: GetDnsTimeseriesGroupByDnssecAwarenessResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsTimeseriesGroupByDnssecE2eVersionRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsTimeseriesGroupByDnssecE2eVersionRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/timeseries_groups/dnssec_e2e" }))
  .annotations({
    identifier: "GetDnsTimeseriesGroupByDnssecE2eVersionRequest",
  }) as unknown as Schema.Schema<GetDnsTimeseriesGroupByDnssecE2eVersionRequest>;

export interface GetDnsTimeseriesGroupByDnssecE2eVersionResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { NEGATIVE: string[]; POSITIVE: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsTimeseriesGroupByDnssecE2eVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      NEGATIVE: Schema.Array(Schema.String),
      POSITIVE: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsTimeseriesGroupByDnssecE2eVersionResponse",
}) as unknown as Schema.Schema<GetDnsTimeseriesGroupByDnssecE2eVersionResponse>;

export const getDnsTimeseriesGroupByDnssecE2eVersion: (
  input: GetDnsTimeseriesGroupByDnssecE2eVersionRequest,
) => Effect.Effect<
  GetDnsTimeseriesGroupByDnssecE2eVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsTimeseriesGroupByDnssecE2eVersionRequest,
  output: GetDnsTimeseriesGroupByDnssecE2eVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsTimeseriesGroupByIpVersionRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsTimeseriesGroupByIpVersionRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/timeseries_groups/ip_version" }))
  .annotations({
    identifier: "GetDnsTimeseriesGroupByIpVersionRequest",
  }) as unknown as Schema.Schema<GetDnsTimeseriesGroupByIpVersionRequest>;

export interface GetDnsTimeseriesGroupByIpVersionResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { IPv4: string[]; IPv6: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsTimeseriesGroupByIpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      IPv4: Schema.Array(Schema.String),
      IPv6: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsTimeseriesGroupByIpVersionResponse",
}) as unknown as Schema.Schema<GetDnsTimeseriesGroupByIpVersionResponse>;

export const getDnsTimeseriesGroupByIpVersion: (
  input: GetDnsTimeseriesGroupByIpVersionRequest,
) => Effect.Effect<
  GetDnsTimeseriesGroupByIpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsTimeseriesGroupByIpVersionRequest,
  output: GetDnsTimeseriesGroupByIpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsTimeseriesGroupByMatchingAnswerStatusRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsTimeseriesGroupByMatchingAnswerStatusRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/timeseries_groups/matching_answer" }))
  .annotations({
    identifier: "GetDnsTimeseriesGroupByMatchingAnswerStatusRequest",
  }) as unknown as Schema.Schema<GetDnsTimeseriesGroupByMatchingAnswerStatusRequest>;

export interface GetDnsTimeseriesGroupByMatchingAnswerStatusResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { NEGATIVE: string[]; POSITIVE: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsTimeseriesGroupByMatchingAnswerStatusResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      NEGATIVE: Schema.Array(Schema.String),
      POSITIVE: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsTimeseriesGroupByMatchingAnswerStatusResponse",
}) as unknown as Schema.Schema<GetDnsTimeseriesGroupByMatchingAnswerStatusResponse>;

export const getDnsTimeseriesGroupByMatchingAnswerStatus: (
  input: GetDnsTimeseriesGroupByMatchingAnswerStatusRequest,
) => Effect.Effect<
  GetDnsTimeseriesGroupByMatchingAnswerStatusResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsTimeseriesGroupByMatchingAnswerStatusRequest,
  output: GetDnsTimeseriesGroupByMatchingAnswerStatusResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsTimeseriesGroupByProtocolRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsTimeseriesGroupByProtocolRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/timeseries_groups/protocol" }))
  .annotations({
    identifier: "GetDnsTimeseriesGroupByProtocolRequest",
  }) as unknown as Schema.Schema<GetDnsTimeseriesGroupByProtocolRequest>;

export interface GetDnsTimeseriesGroupByProtocolResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { HTTPS: string[]; TCP: string[]; TLS: string[]; UDP: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsTimeseriesGroupByProtocolResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      HTTPS: Schema.Array(Schema.String),
      TCP: Schema.Array(Schema.String),
      TLS: Schema.Array(Schema.String),
      UDP: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsTimeseriesGroupByProtocolResponse",
}) as unknown as Schema.Schema<GetDnsTimeseriesGroupByProtocolResponse>;

export const getDnsTimeseriesGroupByProtocol: (
  input: GetDnsTimeseriesGroupByProtocolRequest,
) => Effect.Effect<
  GetDnsTimeseriesGroupByProtocolResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsTimeseriesGroupByProtocolRequest,
  output: GetDnsTimeseriesGroupByProtocolResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsTimeseriesGroupByQueryTypeRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetDnsTimeseriesGroupByQueryTypeRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/timeseries_groups/query_type" }))
  .annotations({
    identifier: "GetDnsTimeseriesGroupByQueryTypeRequest",
  }) as unknown as Schema.Schema<GetDnsTimeseriesGroupByQueryTypeRequest>;

export interface GetDnsTimeseriesGroupByQueryTypeResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsTimeseriesGroupByQueryTypeResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsTimeseriesGroupByQueryTypeResponse",
}) as unknown as Schema.Schema<GetDnsTimeseriesGroupByQueryTypeResponse>;

export const getDnsTimeseriesGroupByQueryType: (
  input: GetDnsTimeseriesGroupByQueryTypeRequest,
) => Effect.Effect<
  GetDnsTimeseriesGroupByQueryTypeResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsTimeseriesGroupByQueryTypeRequest,
  output: GetDnsTimeseriesGroupByQueryTypeResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsTimeseriesGroupByResponseCodeRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  nodata?: boolean[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetDnsTimeseriesGroupByResponseCodeRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/timeseries_groups/response_code" }))
  .annotations({
    identifier: "GetDnsTimeseriesGroupByResponseCodeRequest",
  }) as unknown as Schema.Schema<GetDnsTimeseriesGroupByResponseCodeRequest>;

export interface GetDnsTimeseriesGroupByResponseCodeResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsTimeseriesGroupByResponseCodeResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsTimeseriesGroupByResponseCodeResponse",
}) as unknown as Schema.Schema<GetDnsTimeseriesGroupByResponseCodeResponse>;

export const getDnsTimeseriesGroupByResponseCode: (
  input: GetDnsTimeseriesGroupByResponseCodeRequest,
) => Effect.Effect<
  GetDnsTimeseriesGroupByResponseCodeResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsTimeseriesGroupByResponseCodeRequest,
  output: GetDnsTimeseriesGroupByResponseCodeResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsTimeseriesGroupByResponseTtlRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  tld?: string[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  nodata?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsTimeseriesGroupByResponseTtlRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/timeseries_groups/response_ttl" }))
  .annotations({
    identifier: "GetDnsTimeseriesGroupByResponseTtlRequest",
  }) as unknown as Schema.Schema<GetDnsTimeseriesGroupByResponseTtlRequest>;

export interface GetDnsTimeseriesGroupByResponseTtlResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: {
      gt_15m_lte_1h: string[];
      gt_1d_lte_1w: string[];
      gt_1h_lte_1d: string[];
      gt_1m_lte_5m: string[];
      gt_1w: string[];
      gt_5m_lte_15m: string[];
      lte_1m: string[];
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsTimeseriesGroupByResponseTtlResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      gt_15m_lte_1h: Schema.Array(Schema.String),
      gt_1d_lte_1w: Schema.Array(Schema.String),
      gt_1h_lte_1d: Schema.Array(Schema.String),
      gt_1m_lte_5m: Schema.Array(Schema.String),
      gt_1w: Schema.Array(Schema.String),
      gt_5m_lte_15m: Schema.Array(Schema.String),
      lte_1m: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsTimeseriesGroupByResponseTtlResponse",
}) as unknown as Schema.Schema<GetDnsTimeseriesGroupByResponseTtlResponse>;

export const getDnsTimeseriesGroupByResponseTtl: (
  input: GetDnsTimeseriesGroupByResponseTtlRequest,
) => Effect.Effect<
  GetDnsTimeseriesGroupByResponseTtlResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsTimeseriesGroupByResponseTtlRequest,
  output: GetDnsTimeseriesGroupByResponseTtlResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsTimeseriesGroupRequest {
  dimension:
    | "IP_VERSION"
    | "CACHE_HIT"
    | "DNSSEC"
    | "DNSSEC_AWARE"
    | "DNSSEC_E2E"
    | "MATCHING_ANSWER"
    | "PROTOCOL"
    | "QUERY_TYPE"
    | "RESPONSE_CODE"
    | "RESPONSE_TTL"
    | "TLD";
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  cacheHit?: boolean[];
  nodata?: boolean[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  responseTtl?:
    | "LTE_1M"
    | "GT_1M_LTE_5M"
    | "GT_5M_LTE_15M"
    | "GT_15M_LTE_1H"
    | "GT_1H_LTE_1D"
    | "GT_1D_LTE_1W"
    | "GT_1W"[];
  dnssec?: "INVALID" | "INSECURE" | "SECURE" | "OTHER"[];
  dnssecAware?: "SUPPORTED" | "NOT_SUPPORTED"[];
  dnssecE2e?: boolean[];
  ipVersion?: "IPv4" | "IPv6"[];
  limitPerGroup?: number;
  matchingAnswer?: boolean[];
  tld?: string[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  format?: "JSON" | "CSV";
}

export const GetDnsTimeseriesGroupRequest = Schema.Struct({
  dimension: Schema.Literal(
    "IP_VERSION",
    "CACHE_HIT",
    "DNSSEC",
    "DNSSEC_AWARE",
    "DNSSEC_E2E",
    "MATCHING_ANSWER",
    "PROTOCOL",
    "QUERY_TYPE",
    "RESPONSE_CODE",
    "RESPONSE_TTL",
    "TLD",
  ).pipe(T.HttpPath("dimension")),
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  cacheHit: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("cacheHit")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  responseTtl: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "LTE_1M",
        "GT_1M_LTE_5M",
        "GT_5M_LTE_15M",
        "GT_15M_LTE_1H",
        "GT_1H_LTE_1D",
        "GT_1D_LTE_1W",
        "GT_1W",
      ),
    ),
  ).pipe(T.HttpQuery("responseTtl")),
  dnssec: Schema.optional(
    Schema.Array(Schema.Literal("INVALID", "INSECURE", "SECURE", "OTHER")),
  ).pipe(T.HttpQuery("dnssec")),
  dnssecAware: Schema.optional(Schema.Array(Schema.Literal("SUPPORTED", "NOT_SUPPORTED"))).pipe(
    T.HttpQuery("dnssecAware"),
  ),
  dnssecE2e: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("dnssecE2e")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  matchingAnswer: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("matchingAnswer")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/timeseries_groups/{dimension}" }))
  .annotations({
    identifier: "GetDnsTimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetDnsTimeseriesGroupRequest>;

export interface GetDnsTimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsTimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsTimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetDnsTimeseriesGroupResponse>;

export const getDnsTimeseriesGroup: (
  input: GetDnsTimeseriesGroupRequest,
) => Effect.Effect<
  GetDnsTimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsTimeseriesGroupRequest,
  output: GetDnsTimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsTopAsesRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  domain?: string[];
  cacheHit?: boolean[];
  nodata?: boolean[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  responseTtl?:
    | "LTE_1M"
    | "GT_1M_LTE_5M"
    | "GT_5M_LTE_15M"
    | "GT_15M_LTE_1H"
    | "GT_1H_LTE_1D"
    | "GT_1D_LTE_1W"
    | "GT_1W"[];
  dnssec?: "INVALID" | "INSECURE" | "SECURE" | "OTHER"[];
  dnssecAware?: "SUPPORTED" | "NOT_SUPPORTED"[];
  dnssecE2e?: boolean[];
  ipVersion?: "IPv4" | "IPv6"[];
  matchingAnswer?: boolean[];
  format?: "JSON" | "CSV";
}

export const GetDnsTopAsesRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  domain: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("domain")),
  cacheHit: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("cacheHit")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  responseTtl: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "LTE_1M",
        "GT_1M_LTE_5M",
        "GT_5M_LTE_15M",
        "GT_15M_LTE_1H",
        "GT_1H_LTE_1D",
        "GT_1D_LTE_1W",
        "GT_1W",
      ),
    ),
  ).pipe(T.HttpQuery("responseTtl")),
  dnssec: Schema.optional(
    Schema.Array(Schema.Literal("INVALID", "INSECURE", "SECURE", "OTHER")),
  ).pipe(T.HttpQuery("dnssec")),
  dnssecAware: Schema.optional(Schema.Array(Schema.Literal("SUPPORTED", "NOT_SUPPORTED"))).pipe(
    T.HttpQuery("dnssecAware"),
  ),
  dnssecE2e: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("dnssecE2e")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  matchingAnswer: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("matchingAnswer")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/top/ases" }))
  .annotations({
    identifier: "GetDnsTopAsesRequest",
  }) as unknown as Schema.Schema<GetDnsTopAsesRequest>;

export interface GetDnsTopAsesResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientASN: number; clientASName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsTopAsesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientASN: Schema.Number,
        clientASName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsTopAsesResponse",
}) as unknown as Schema.Schema<GetDnsTopAsesResponse>;

export const getDnsTopAses: (
  input: GetDnsTopAsesRequest,
) => Effect.Effect<
  GetDnsTopAsesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsTopAsesRequest,
  output: GetDnsTopAsesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetDnsTopLocationsRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  domain?: string[];
  cacheHit?: boolean[];
  nodata?: boolean[];
  protocol?: "UDP" | "TCP" | "HTTPS" | "TLS"[];
  queryType?:
    | "A"
    | "AAAA"
    | "A6"
    | "AFSDB"
    | "ANY"
    | "APL"
    | "ATMA"
    | "AXFR"
    | "CAA"
    | "CDNSKEY"
    | "CDS"
    | "CERT"
    | "CNAME"
    | "CSYNC"
    | "DHCID"
    | "DLV"
    | "DNAME"
    | "DNSKEY"
    | "DOA"
    | "DS"
    | "EID"
    | "EUI48"
    | "EUI64"
    | "GPOS"
    | "GID"
    | "HINFO"
    | "HIP"
    | "HTTPS"
    | "IPSECKEY"
    | "ISDN"
    | "IXFR"
    | "KEY"
    | "KX"
    | "L32"
    | "L64"
    | "LOC"
    | "LP"
    | "MAILA"
    | "MAILB"
    | "MB"
    | "MD"
    | "MF"
    | "MG"
    | "MINFO"
    | "MR"
    | "MX"
    | "NAPTR"
    | "NB"
    | "NBSTAT"
    | "NID"
    | "NIMLOC"
    | "NINFO"
    | "NS"
    | "NSAP"
    | "NSEC"
    | "NSEC3"
    | "NSEC3PARAM"
    | "NULL"
    | "NXT"
    | "OPENPGPKEY"
    | "OPT"
    | "PTR"
    | "PX"
    | "RKEY"
    | "RP"
    | "RRSIG"
    | "RT"
    | "SIG"
    | "SINK"
    | "SMIMEA"
    | "SOA"
    | "SPF"
    | "SRV"
    | "SSHFP"
    | "SVCB"
    | "TA"
    | "TALINK"
    | "TKEY"
    | "TLSA"
    | "TSIG"
    | "TXT"
    | "UINFO"
    | "UID"
    | "UNSPEC"
    | "URI"
    | "WKS"
    | "X25"
    | "ZONEMD"[];
  responseCode?:
    | "NOERROR"
    | "FORMERR"
    | "SERVFAIL"
    | "NXDOMAIN"
    | "NOTIMP"
    | "REFUSED"
    | "YXDOMAIN"
    | "YXRRSET"
    | "NXRRSET"
    | "NOTAUTH"
    | "NOTZONE"
    | "BADSIG"
    | "BADKEY"
    | "BADTIME"
    | "BADMODE"
    | "BADNAME"
    | "BADALG"
    | "BADTRUNC"
    | "BADCOOKIE"[];
  responseTtl?:
    | "LTE_1M"
    | "GT_1M_LTE_5M"
    | "GT_5M_LTE_15M"
    | "GT_15M_LTE_1H"
    | "GT_1H_LTE_1D"
    | "GT_1D_LTE_1W"
    | "GT_1W"[];
  dnssec?: "INVALID" | "INSECURE" | "SECURE" | "OTHER"[];
  dnssecAware?: "SUPPORTED" | "NOT_SUPPORTED"[];
  dnssecE2e?: boolean[];
  ipVersion?: "IPv4" | "IPv6"[];
  matchingAnswer?: boolean[];
  tld?: string[];
  format?: "JSON" | "CSV";
}

export const GetDnsTopLocationsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  domain: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("domain")),
  cacheHit: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("cacheHit")),
  nodata: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("nodata")),
  protocol: Schema.optional(Schema.Array(Schema.Literal("UDP", "TCP", "HTTPS", "TLS"))).pipe(
    T.HttpQuery("protocol"),
  ),
  queryType: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "A",
        "AAAA",
        "A6",
        "AFSDB",
        "ANY",
        "APL",
        "ATMA",
        "AXFR",
        "CAA",
        "CDNSKEY",
        "CDS",
        "CERT",
        "CNAME",
        "CSYNC",
        "DHCID",
        "DLV",
        "DNAME",
        "DNSKEY",
        "DOA",
        "DS",
        "EID",
        "EUI48",
        "EUI64",
        "GPOS",
        "GID",
        "HINFO",
        "HIP",
        "HTTPS",
        "IPSECKEY",
        "ISDN",
        "IXFR",
        "KEY",
        "KX",
        "L32",
        "L64",
        "LOC",
        "LP",
        "MAILA",
        "MAILB",
        "MB",
        "MD",
        "MF",
        "MG",
        "MINFO",
        "MR",
        "MX",
        "NAPTR",
        "NB",
        "NBSTAT",
        "NID",
        "NIMLOC",
        "NINFO",
        "NS",
        "NSAP",
        "NSEC",
        "NSEC3",
        "NSEC3PARAM",
        "NULL",
        "NXT",
        "OPENPGPKEY",
        "OPT",
        "PTR",
        "PX",
        "RKEY",
        "RP",
        "RRSIG",
        "RT",
        "SIG",
        "SINK",
        "SMIMEA",
        "SOA",
        "SPF",
        "SRV",
        "SSHFP",
        "SVCB",
        "TA",
        "TALINK",
        "TKEY",
        "TLSA",
        "TSIG",
        "TXT",
        "UINFO",
        "UID",
        "UNSPEC",
        "URI",
        "WKS",
        "X25",
        "ZONEMD",
      ),
    ),
  ).pipe(T.HttpQuery("queryType")),
  responseCode: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "NOERROR",
        "FORMERR",
        "SERVFAIL",
        "NXDOMAIN",
        "NOTIMP",
        "REFUSED",
        "YXDOMAIN",
        "YXRRSET",
        "NXRRSET",
        "NOTAUTH",
        "NOTZONE",
        "BADSIG",
        "BADKEY",
        "BADTIME",
        "BADMODE",
        "BADNAME",
        "BADALG",
        "BADTRUNC",
        "BADCOOKIE",
      ),
    ),
  ).pipe(T.HttpQuery("responseCode")),
  responseTtl: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "LTE_1M",
        "GT_1M_LTE_5M",
        "GT_5M_LTE_15M",
        "GT_15M_LTE_1H",
        "GT_1H_LTE_1D",
        "GT_1D_LTE_1W",
        "GT_1W",
      ),
    ),
  ).pipe(T.HttpQuery("responseTtl")),
  dnssec: Schema.optional(
    Schema.Array(Schema.Literal("INVALID", "INSECURE", "SECURE", "OTHER")),
  ).pipe(T.HttpQuery("dnssec")),
  dnssecAware: Schema.optional(Schema.Array(Schema.Literal("SUPPORTED", "NOT_SUPPORTED"))).pipe(
    T.HttpQuery("dnssecAware"),
  ),
  dnssecE2e: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("dnssecE2e")),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  matchingAnswer: Schema.optional(Schema.Array(Schema.Boolean)).pipe(T.HttpQuery("matchingAnswer")),
  tld: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tld")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/dns/top/locations" }))
  .annotations({
    identifier: "GetDnsTopLocationsRequest",
  }) as unknown as Schema.Schema<GetDnsTopLocationsRequest>;

export interface GetDnsTopLocationsResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetDnsTopLocationsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetDnsTopLocationsResponse",
}) as unknown as Schema.Schema<GetDnsTopLocationsResponse>;

export const getDnsTopLocations: (
  input: GetDnsTopLocationsRequest,
) => Effect.Effect<
  GetDnsTopLocationsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDnsTopLocationsRequest,
  output: GetDnsTopLocationsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailRoutingSummaryByArcRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  ipVersion?: "IPv4" | "IPv6"[];
  encrypted?: "ENCRYPTED" | "NOT_ENCRYPTED"[];
  format?: "JSON" | "CSV";
}

export const GetEmailRoutingSummaryByArcRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  encrypted: Schema.optional(Schema.Array(Schema.Literal("ENCRYPTED", "NOT_ENCRYPTED"))).pipe(
    T.HttpQuery("encrypted"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/routing/summary/arc" }))
  .annotations({
    identifier: "GetEmailRoutingSummaryByArcRequest",
  }) as unknown as Schema.Schema<GetEmailRoutingSummaryByArcRequest>;

export interface GetEmailRoutingSummaryByArcResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { FAIL: string; NONE: string; PASS: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailRoutingSummaryByArcResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      FAIL: Schema.String,
      NONE: Schema.String,
      PASS: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailRoutingSummaryByArcResponse",
}) as unknown as Schema.Schema<GetEmailRoutingSummaryByArcResponse>;

export const getEmailRoutingSummaryByArc: (
  input: GetEmailRoutingSummaryByArcRequest,
) => Effect.Effect<
  GetEmailRoutingSummaryByArcResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailRoutingSummaryByArcRequest,
  output: GetEmailRoutingSummaryByArcResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailRoutingSummaryByDkimRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  ipVersion?: "IPv4" | "IPv6"[];
  encrypted?: "ENCRYPTED" | "NOT_ENCRYPTED"[];
  format?: "JSON" | "CSV";
}

export const GetEmailRoutingSummaryByDkimRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  encrypted: Schema.optional(Schema.Array(Schema.Literal("ENCRYPTED", "NOT_ENCRYPTED"))).pipe(
    T.HttpQuery("encrypted"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/routing/summary/dkim" }))
  .annotations({
    identifier: "GetEmailRoutingSummaryByDkimRequest",
  }) as unknown as Schema.Schema<GetEmailRoutingSummaryByDkimRequest>;

export interface GetEmailRoutingSummaryByDkimResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { FAIL: string; NONE: string; PASS: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailRoutingSummaryByDkimResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      FAIL: Schema.String,
      NONE: Schema.String,
      PASS: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailRoutingSummaryByDkimResponse",
}) as unknown as Schema.Schema<GetEmailRoutingSummaryByDkimResponse>;

export const getEmailRoutingSummaryByDkim: (
  input: GetEmailRoutingSummaryByDkimRequest,
) => Effect.Effect<
  GetEmailRoutingSummaryByDkimResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailRoutingSummaryByDkimRequest,
  output: GetEmailRoutingSummaryByDkimResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailRoutingSummaryByDmarcRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  ipVersion?: "IPv4" | "IPv6"[];
  encrypted?: "ENCRYPTED" | "NOT_ENCRYPTED"[];
  format?: "JSON" | "CSV";
}

export const GetEmailRoutingSummaryByDmarcRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  encrypted: Schema.optional(Schema.Array(Schema.Literal("ENCRYPTED", "NOT_ENCRYPTED"))).pipe(
    T.HttpQuery("encrypted"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/routing/summary/dmarc" }))
  .annotations({
    identifier: "GetEmailRoutingSummaryByDmarcRequest",
  }) as unknown as Schema.Schema<GetEmailRoutingSummaryByDmarcRequest>;

export interface GetEmailRoutingSummaryByDmarcResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { FAIL: string; NONE: string; PASS: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailRoutingSummaryByDmarcResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      FAIL: Schema.String,
      NONE: Schema.String,
      PASS: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailRoutingSummaryByDmarcResponse",
}) as unknown as Schema.Schema<GetEmailRoutingSummaryByDmarcResponse>;

export const getEmailRoutingSummaryByDmarc: (
  input: GetEmailRoutingSummaryByDmarcRequest,
) => Effect.Effect<
  GetEmailRoutingSummaryByDmarcResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailRoutingSummaryByDmarcRequest,
  output: GetEmailRoutingSummaryByDmarcResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailRoutingSummaryByEncryptedRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  ipVersion?: "IPv4" | "IPv6"[];
  format?: "JSON" | "CSV";
}

export const GetEmailRoutingSummaryByEncryptedRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/routing/summary/encrypted" }))
  .annotations({
    identifier: "GetEmailRoutingSummaryByEncryptedRequest",
  }) as unknown as Schema.Schema<GetEmailRoutingSummaryByEncryptedRequest>;

export interface GetEmailRoutingSummaryByEncryptedResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { ENCRYPTED: string; NOT_ENCRYPTED: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailRoutingSummaryByEncryptedResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      ENCRYPTED: Schema.String,
      NOT_ENCRYPTED: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailRoutingSummaryByEncryptedResponse",
}) as unknown as Schema.Schema<GetEmailRoutingSummaryByEncryptedResponse>;

export const getEmailRoutingSummaryByEncrypted: (
  input: GetEmailRoutingSummaryByEncryptedRequest,
) => Effect.Effect<
  GetEmailRoutingSummaryByEncryptedResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailRoutingSummaryByEncryptedRequest,
  output: GetEmailRoutingSummaryByEncryptedResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailRoutingSummaryByIpVersionRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  encrypted?: "ENCRYPTED" | "NOT_ENCRYPTED"[];
  format?: "JSON" | "CSV";
}

export const GetEmailRoutingSummaryByIpVersionRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  encrypted: Schema.optional(Schema.Array(Schema.Literal("ENCRYPTED", "NOT_ENCRYPTED"))).pipe(
    T.HttpQuery("encrypted"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/routing/summary/ip_version" }))
  .annotations({
    identifier: "GetEmailRoutingSummaryByIpVersionRequest",
  }) as unknown as Schema.Schema<GetEmailRoutingSummaryByIpVersionRequest>;

export interface GetEmailRoutingSummaryByIpVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { IPv4: string; IPv6: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailRoutingSummaryByIpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      IPv4: Schema.String,
      IPv6: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailRoutingSummaryByIpVersionResponse",
}) as unknown as Schema.Schema<GetEmailRoutingSummaryByIpVersionResponse>;

export const getEmailRoutingSummaryByIpVersion: (
  input: GetEmailRoutingSummaryByIpVersionRequest,
) => Effect.Effect<
  GetEmailRoutingSummaryByIpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailRoutingSummaryByIpVersionRequest,
  output: GetEmailRoutingSummaryByIpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailRoutingSummaryBySpfRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  ipVersion?: "IPv4" | "IPv6"[];
  encrypted?: "ENCRYPTED" | "NOT_ENCRYPTED"[];
  format?: "JSON" | "CSV";
}

export const GetEmailRoutingSummaryBySpfRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  encrypted: Schema.optional(Schema.Array(Schema.Literal("ENCRYPTED", "NOT_ENCRYPTED"))).pipe(
    T.HttpQuery("encrypted"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/routing/summary/spf" }))
  .annotations({
    identifier: "GetEmailRoutingSummaryBySpfRequest",
  }) as unknown as Schema.Schema<GetEmailRoutingSummaryBySpfRequest>;

export interface GetEmailRoutingSummaryBySpfResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { FAIL: string; NONE: string; PASS: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailRoutingSummaryBySpfResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      FAIL: Schema.String,
      NONE: Schema.String,
      PASS: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailRoutingSummaryBySpfResponse",
}) as unknown as Schema.Schema<GetEmailRoutingSummaryBySpfResponse>;

export const getEmailRoutingSummaryBySpf: (
  input: GetEmailRoutingSummaryBySpfRequest,
) => Effect.Effect<
  GetEmailRoutingSummaryBySpfResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailRoutingSummaryBySpfRequest,
  output: GetEmailRoutingSummaryBySpfResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailRoutingSummaryRequest {
  dimension: "IP_VERSION" | "ENCRYPTED" | "ARC" | "DKIM" | "DMARC" | "SPF";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  ipVersion?: "IPv4" | "IPv6"[];
  encrypted?: "ENCRYPTED" | "NOT_ENCRYPTED"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetEmailRoutingSummaryRequest = Schema.Struct({
  dimension: Schema.Literal("IP_VERSION", "ENCRYPTED", "ARC", "DKIM", "DMARC", "SPF").pipe(
    T.HttpPath("dimension"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  encrypted: Schema.optional(Schema.Array(Schema.Literal("ENCRYPTED", "NOT_ENCRYPTED"))).pipe(
    T.HttpQuery("encrypted"),
  ),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/routing/summary/{dimension}" }))
  .annotations({
    identifier: "GetEmailRoutingSummaryRequest",
  }) as unknown as Schema.Schema<GetEmailRoutingSummaryRequest>;

export interface GetEmailRoutingSummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailRoutingSummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailRoutingSummaryResponse",
}) as unknown as Schema.Schema<GetEmailRoutingSummaryResponse>;

export const getEmailRoutingSummary: (
  input: GetEmailRoutingSummaryRequest,
) => Effect.Effect<
  GetEmailRoutingSummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailRoutingSummaryRequest,
  output: GetEmailRoutingSummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailRoutingTimeseriesGroupByArcRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  ipVersion?: "IPv4" | "IPv6"[];
  encrypted?: "ENCRYPTED" | "NOT_ENCRYPTED"[];
  format?: "JSON" | "CSV";
}

export const GetEmailRoutingTimeseriesGroupByArcRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  encrypted: Schema.optional(Schema.Array(Schema.Literal("ENCRYPTED", "NOT_ENCRYPTED"))).pipe(
    T.HttpQuery("encrypted"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/routing/timeseries_groups/arc" }))
  .annotations({
    identifier: "GetEmailRoutingTimeseriesGroupByArcRequest",
  }) as unknown as Schema.Schema<GetEmailRoutingTimeseriesGroupByArcRequest>;

export interface GetEmailRoutingTimeseriesGroupByArcResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { FAIL: string[]; NONE: string[]; PASS: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailRoutingTimeseriesGroupByArcResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      FAIL: Schema.Array(Schema.String),
      NONE: Schema.Array(Schema.String),
      PASS: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailRoutingTimeseriesGroupByArcResponse",
}) as unknown as Schema.Schema<GetEmailRoutingTimeseriesGroupByArcResponse>;

export const getEmailRoutingTimeseriesGroupByArc: (
  input: GetEmailRoutingTimeseriesGroupByArcRequest,
) => Effect.Effect<
  GetEmailRoutingTimeseriesGroupByArcResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailRoutingTimeseriesGroupByArcRequest,
  output: GetEmailRoutingTimeseriesGroupByArcResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailRoutingTimeseriesGroupByDkimRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  ipVersion?: "IPv4" | "IPv6"[];
  encrypted?: "ENCRYPTED" | "NOT_ENCRYPTED"[];
  format?: "JSON" | "CSV";
}

export const GetEmailRoutingTimeseriesGroupByDkimRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  encrypted: Schema.optional(Schema.Array(Schema.Literal("ENCRYPTED", "NOT_ENCRYPTED"))).pipe(
    T.HttpQuery("encrypted"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/routing/timeseries_groups/dkim" }))
  .annotations({
    identifier: "GetEmailRoutingTimeseriesGroupByDkimRequest",
  }) as unknown as Schema.Schema<GetEmailRoutingTimeseriesGroupByDkimRequest>;

export interface GetEmailRoutingTimeseriesGroupByDkimResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { FAIL: string[]; NONE: string[]; PASS: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailRoutingTimeseriesGroupByDkimResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      FAIL: Schema.Array(Schema.String),
      NONE: Schema.Array(Schema.String),
      PASS: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailRoutingTimeseriesGroupByDkimResponse",
}) as unknown as Schema.Schema<GetEmailRoutingTimeseriesGroupByDkimResponse>;

export const getEmailRoutingTimeseriesGroupByDkim: (
  input: GetEmailRoutingTimeseriesGroupByDkimRequest,
) => Effect.Effect<
  GetEmailRoutingTimeseriesGroupByDkimResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailRoutingTimeseriesGroupByDkimRequest,
  output: GetEmailRoutingTimeseriesGroupByDkimResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailRoutingTimeseriesGroupByDmarcRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  ipVersion?: "IPv4" | "IPv6"[];
  encrypted?: "ENCRYPTED" | "NOT_ENCRYPTED"[];
  format?: "JSON" | "CSV";
}

export const GetEmailRoutingTimeseriesGroupByDmarcRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  encrypted: Schema.optional(Schema.Array(Schema.Literal("ENCRYPTED", "NOT_ENCRYPTED"))).pipe(
    T.HttpQuery("encrypted"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/routing/timeseries_groups/dmarc" }))
  .annotations({
    identifier: "GetEmailRoutingTimeseriesGroupByDmarcRequest",
  }) as unknown as Schema.Schema<GetEmailRoutingTimeseriesGroupByDmarcRequest>;

export interface GetEmailRoutingTimeseriesGroupByDmarcResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { FAIL: string[]; NONE: string[]; PASS: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailRoutingTimeseriesGroupByDmarcResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      FAIL: Schema.Array(Schema.String),
      NONE: Schema.Array(Schema.String),
      PASS: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailRoutingTimeseriesGroupByDmarcResponse",
}) as unknown as Schema.Schema<GetEmailRoutingTimeseriesGroupByDmarcResponse>;

export const getEmailRoutingTimeseriesGroupByDmarc: (
  input: GetEmailRoutingTimeseriesGroupByDmarcRequest,
) => Effect.Effect<
  GetEmailRoutingTimeseriesGroupByDmarcResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailRoutingTimeseriesGroupByDmarcRequest,
  output: GetEmailRoutingTimeseriesGroupByDmarcResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailRoutingTimeseriesGroupByEncryptedRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  ipVersion?: "IPv4" | "IPv6"[];
  format?: "JSON" | "CSV";
}

export const GetEmailRoutingTimeseriesGroupByEncryptedRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/routing/timeseries_groups/encrypted" }))
  .annotations({
    identifier: "GetEmailRoutingTimeseriesGroupByEncryptedRequest",
  }) as unknown as Schema.Schema<GetEmailRoutingTimeseriesGroupByEncryptedRequest>;

export interface GetEmailRoutingTimeseriesGroupByEncryptedResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { ENCRYPTED: string[]; NOT_ENCRYPTED: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailRoutingTimeseriesGroupByEncryptedResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      ENCRYPTED: Schema.Array(Schema.String),
      NOT_ENCRYPTED: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailRoutingTimeseriesGroupByEncryptedResponse",
}) as unknown as Schema.Schema<GetEmailRoutingTimeseriesGroupByEncryptedResponse>;

export const getEmailRoutingTimeseriesGroupByEncrypted: (
  input: GetEmailRoutingTimeseriesGroupByEncryptedRequest,
) => Effect.Effect<
  GetEmailRoutingTimeseriesGroupByEncryptedResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailRoutingTimeseriesGroupByEncryptedRequest,
  output: GetEmailRoutingTimeseriesGroupByEncryptedResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailRoutingTimeseriesGroupByIpVersionRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  encrypted?: "ENCRYPTED" | "NOT_ENCRYPTED"[];
  format?: "JSON" | "CSV";
}

export const GetEmailRoutingTimeseriesGroupByIpVersionRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  encrypted: Schema.optional(Schema.Array(Schema.Literal("ENCRYPTED", "NOT_ENCRYPTED"))).pipe(
    T.HttpQuery("encrypted"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/routing/timeseries_groups/ip_version" }))
  .annotations({
    identifier: "GetEmailRoutingTimeseriesGroupByIpVersionRequest",
  }) as unknown as Schema.Schema<GetEmailRoutingTimeseriesGroupByIpVersionRequest>;

export interface GetEmailRoutingTimeseriesGroupByIpVersionResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { IPv4: string[]; IPv6: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailRoutingTimeseriesGroupByIpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      IPv4: Schema.Array(Schema.String),
      IPv6: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailRoutingTimeseriesGroupByIpVersionResponse",
}) as unknown as Schema.Schema<GetEmailRoutingTimeseriesGroupByIpVersionResponse>;

export const getEmailRoutingTimeseriesGroupByIpVersion: (
  input: GetEmailRoutingTimeseriesGroupByIpVersionRequest,
) => Effect.Effect<
  GetEmailRoutingTimeseriesGroupByIpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailRoutingTimeseriesGroupByIpVersionRequest,
  output: GetEmailRoutingTimeseriesGroupByIpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailRoutingTimeseriesGroupBySpfRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  ipVersion?: "IPv4" | "IPv6"[];
  encrypted?: "ENCRYPTED" | "NOT_ENCRYPTED"[];
  format?: "JSON" | "CSV";
}

export const GetEmailRoutingTimeseriesGroupBySpfRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  encrypted: Schema.optional(Schema.Array(Schema.Literal("ENCRYPTED", "NOT_ENCRYPTED"))).pipe(
    T.HttpQuery("encrypted"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/routing/timeseries_groups/spf" }))
  .annotations({
    identifier: "GetEmailRoutingTimeseriesGroupBySpfRequest",
  }) as unknown as Schema.Schema<GetEmailRoutingTimeseriesGroupBySpfRequest>;

export interface GetEmailRoutingTimeseriesGroupBySpfResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { FAIL: string[]; NONE: string[]; PASS: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailRoutingTimeseriesGroupBySpfResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      FAIL: Schema.Array(Schema.String),
      NONE: Schema.Array(Schema.String),
      PASS: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailRoutingTimeseriesGroupBySpfResponse",
}) as unknown as Schema.Schema<GetEmailRoutingTimeseriesGroupBySpfResponse>;

export const getEmailRoutingTimeseriesGroupBySpf: (
  input: GetEmailRoutingTimeseriesGroupBySpfRequest,
) => Effect.Effect<
  GetEmailRoutingTimeseriesGroupBySpfResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailRoutingTimeseriesGroupBySpfRequest,
  output: GetEmailRoutingTimeseriesGroupBySpfResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailRoutingTimeseriesGroupRequest {
  dimension: "IP_VERSION" | "ENCRYPTED" | "ARC" | "DKIM" | "DMARC" | "SPF";
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  ipVersion?: "IPv4" | "IPv6"[];
  encrypted?: "ENCRYPTED" | "NOT_ENCRYPTED"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetEmailRoutingTimeseriesGroupRequest = Schema.Struct({
  dimension: Schema.Literal("IP_VERSION", "ENCRYPTED", "ARC", "DKIM", "DMARC", "SPF").pipe(
    T.HttpPath("dimension"),
  ),
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  encrypted: Schema.optional(Schema.Array(Schema.Literal("ENCRYPTED", "NOT_ENCRYPTED"))).pipe(
    T.HttpQuery("encrypted"),
  ),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/routing/timeseries_groups/{dimension}" }))
  .annotations({
    identifier: "GetEmailRoutingTimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetEmailRoutingTimeseriesGroupRequest>;

export interface GetEmailRoutingTimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailRoutingTimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailRoutingTimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetEmailRoutingTimeseriesGroupResponse>;

export const getEmailRoutingTimeseriesGroup: (
  input: GetEmailRoutingTimeseriesGroupRequest,
) => Effect.Effect<
  GetEmailRoutingTimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailRoutingTimeseriesGroupRequest,
  output: GetEmailRoutingTimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecuritySummaryByArcRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecuritySummaryByArcRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/summary/arc" }))
  .annotations({
    identifier: "GetEmailSecuritySummaryByArcRequest",
  }) as unknown as Schema.Schema<GetEmailSecuritySummaryByArcRequest>;

export interface GetEmailSecuritySummaryByArcResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { FAIL: string; NONE: string; PASS: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecuritySummaryByArcResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      FAIL: Schema.String,
      NONE: Schema.String,
      PASS: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecuritySummaryByArcResponse",
}) as unknown as Schema.Schema<GetEmailSecuritySummaryByArcResponse>;

export const getEmailSecuritySummaryByArc: (
  input: GetEmailSecuritySummaryByArcRequest,
) => Effect.Effect<
  GetEmailSecuritySummaryByArcResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecuritySummaryByArcRequest,
  output: GetEmailSecuritySummaryByArcResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecuritySummaryByDkimRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecuritySummaryByDkimRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/summary/dkim" }))
  .annotations({
    identifier: "GetEmailSecuritySummaryByDkimRequest",
  }) as unknown as Schema.Schema<GetEmailSecuritySummaryByDkimRequest>;

export interface GetEmailSecuritySummaryByDkimResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { FAIL: string; NONE: string; PASS: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecuritySummaryByDkimResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      FAIL: Schema.String,
      NONE: Schema.String,
      PASS: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecuritySummaryByDkimResponse",
}) as unknown as Schema.Schema<GetEmailSecuritySummaryByDkimResponse>;

export const getEmailSecuritySummaryByDkim: (
  input: GetEmailSecuritySummaryByDkimRequest,
) => Effect.Effect<
  GetEmailSecuritySummaryByDkimResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecuritySummaryByDkimRequest,
  output: GetEmailSecuritySummaryByDkimResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecuritySummaryByDmarcRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecuritySummaryByDmarcRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/summary/dmarc" }))
  .annotations({
    identifier: "GetEmailSecuritySummaryByDmarcRequest",
  }) as unknown as Schema.Schema<GetEmailSecuritySummaryByDmarcRequest>;

export interface GetEmailSecuritySummaryByDmarcResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { FAIL: string; NONE: string; PASS: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecuritySummaryByDmarcResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      FAIL: Schema.String,
      NONE: Schema.String,
      PASS: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecuritySummaryByDmarcResponse",
}) as unknown as Schema.Schema<GetEmailSecuritySummaryByDmarcResponse>;

export const getEmailSecuritySummaryByDmarc: (
  input: GetEmailSecuritySummaryByDmarcRequest,
) => Effect.Effect<
  GetEmailSecuritySummaryByDmarcResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecuritySummaryByDmarcRequest,
  output: GetEmailSecuritySummaryByDmarcResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecuritySummaryByMaliciousRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecuritySummaryByMaliciousRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/summary/malicious" }))
  .annotations({
    identifier: "GetEmailSecuritySummaryByMaliciousRequest",
  }) as unknown as Schema.Schema<GetEmailSecuritySummaryByMaliciousRequest>;

export interface GetEmailSecuritySummaryByMaliciousResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { MALICIOUS: string; NOT_MALICIOUS: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecuritySummaryByMaliciousResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      MALICIOUS: Schema.String,
      NOT_MALICIOUS: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecuritySummaryByMaliciousResponse",
}) as unknown as Schema.Schema<GetEmailSecuritySummaryByMaliciousResponse>;

export const getEmailSecuritySummaryByMalicious: (
  input: GetEmailSecuritySummaryByMaliciousRequest,
) => Effect.Effect<
  GetEmailSecuritySummaryByMaliciousResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecuritySummaryByMaliciousRequest,
  output: GetEmailSecuritySummaryByMaliciousResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecuritySummaryBySpamRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecuritySummaryBySpamRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/summary/spam" }))
  .annotations({
    identifier: "GetEmailSecuritySummaryBySpamRequest",
  }) as unknown as Schema.Schema<GetEmailSecuritySummaryBySpamRequest>;

export interface GetEmailSecuritySummaryBySpamResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { NOT_SPAM: string; SPAM: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecuritySummaryBySpamResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      NOT_SPAM: Schema.String,
      SPAM: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecuritySummaryBySpamResponse",
}) as unknown as Schema.Schema<GetEmailSecuritySummaryBySpamResponse>;

export const getEmailSecuritySummaryBySpam: (
  input: GetEmailSecuritySummaryBySpamRequest,
) => Effect.Effect<
  GetEmailSecuritySummaryBySpamResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecuritySummaryBySpamRequest,
  output: GetEmailSecuritySummaryBySpamResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecuritySummaryBySpfRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecuritySummaryBySpfRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/summary/spf" }))
  .annotations({
    identifier: "GetEmailSecuritySummaryBySpfRequest",
  }) as unknown as Schema.Schema<GetEmailSecuritySummaryBySpfRequest>;

export interface GetEmailSecuritySummaryBySpfResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { FAIL: string; NONE: string; PASS: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecuritySummaryBySpfResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      FAIL: Schema.String,
      NONE: Schema.String,
      PASS: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecuritySummaryBySpfResponse",
}) as unknown as Schema.Schema<GetEmailSecuritySummaryBySpfResponse>;

export const getEmailSecuritySummaryBySpf: (
  input: GetEmailSecuritySummaryBySpfRequest,
) => Effect.Effect<
  GetEmailSecuritySummaryBySpfResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecuritySummaryBySpfRequest,
  output: GetEmailSecuritySummaryBySpfResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecuritySummaryBySpoofRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecuritySummaryBySpoofRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/summary/spoof" }))
  .annotations({
    identifier: "GetEmailSecuritySummaryBySpoofRequest",
  }) as unknown as Schema.Schema<GetEmailSecuritySummaryBySpoofRequest>;

export interface GetEmailSecuritySummaryBySpoofResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { NOT_SPOOF: string; SPOOF: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecuritySummaryBySpoofResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      NOT_SPOOF: Schema.String,
      SPOOF: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecuritySummaryBySpoofResponse",
}) as unknown as Schema.Schema<GetEmailSecuritySummaryBySpoofResponse>;

export const getEmailSecuritySummaryBySpoof: (
  input: GetEmailSecuritySummaryBySpoofRequest,
) => Effect.Effect<
  GetEmailSecuritySummaryBySpoofResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecuritySummaryBySpoofRequest,
  output: GetEmailSecuritySummaryBySpoofResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecuritySummaryByThreatCategoryRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecuritySummaryByThreatCategoryRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/summary/threat_category" }))
  .annotations({
    identifier: "GetEmailSecuritySummaryByThreatCategoryRequest",
  }) as unknown as Schema.Schema<GetEmailSecuritySummaryByThreatCategoryRequest>;

export interface GetEmailSecuritySummaryByThreatCategoryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: {
      BrandImpersonation: string;
      CredentialHarvester: string;
      IdentityDeception: string;
      Link: string;
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecuritySummaryByThreatCategoryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      BrandImpersonation: Schema.String,
      CredentialHarvester: Schema.String,
      IdentityDeception: Schema.String,
      Link: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecuritySummaryByThreatCategoryResponse",
}) as unknown as Schema.Schema<GetEmailSecuritySummaryByThreatCategoryResponse>;

export const getEmailSecuritySummaryByThreatCategory: (
  input: GetEmailSecuritySummaryByThreatCategoryRequest,
) => Effect.Effect<
  GetEmailSecuritySummaryByThreatCategoryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecuritySummaryByThreatCategoryRequest,
  output: GetEmailSecuritySummaryByThreatCategoryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecuritySummaryByTlsVersionRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecuritySummaryByTlsVersionRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/summary/tls_version" }))
  .annotations({
    identifier: "GetEmailSecuritySummaryByTlsVersionRequest",
  }) as unknown as Schema.Schema<GetEmailSecuritySummaryByTlsVersionRequest>;

export interface GetEmailSecuritySummaryByTlsVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { "TLS 1.0": string; "TLS 1.1": string; "TLS 1.2": string; "TLS 1.3": string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecuritySummaryByTlsVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      "TLS 1.0": Schema.String,
      "TLS 1.1": Schema.String,
      "TLS 1.2": Schema.String,
      "TLS 1.3": Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecuritySummaryByTlsVersionResponse",
}) as unknown as Schema.Schema<GetEmailSecuritySummaryByTlsVersionResponse>;

export const getEmailSecuritySummaryByTlsVersion: (
  input: GetEmailSecuritySummaryByTlsVersionRequest,
) => Effect.Effect<
  GetEmailSecuritySummaryByTlsVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecuritySummaryByTlsVersionRequest,
  output: GetEmailSecuritySummaryByTlsVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecuritySummaryRequest {
  dimension:
    | "SPAM"
    | "MALICIOUS"
    | "SPOOF"
    | "THREAT_CATEGORY"
    | "ARC"
    | "DKIM"
    | "DMARC"
    | "SPF"
    | "TLS_VERSION";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetEmailSecuritySummaryRequest = Schema.Struct({
  dimension: Schema.Literal(
    "SPAM",
    "MALICIOUS",
    "SPOOF",
    "THREAT_CATEGORY",
    "ARC",
    "DKIM",
    "DMARC",
    "SPF",
    "TLS_VERSION",
  ).pipe(T.HttpPath("dimension")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/summary/{dimension}" }))
  .annotations({
    identifier: "GetEmailSecuritySummaryRequest",
  }) as unknown as Schema.Schema<GetEmailSecuritySummaryRequest>;

export interface GetEmailSecuritySummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecuritySummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecuritySummaryResponse",
}) as unknown as Schema.Schema<GetEmailSecuritySummaryResponse>;

export const getEmailSecuritySummary: (
  input: GetEmailSecuritySummaryRequest,
) => Effect.Effect<
  GetEmailSecuritySummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecuritySummaryRequest,
  output: GetEmailSecuritySummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecurityTimeseriesGroupByArcRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecurityTimeseriesGroupByArcRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/timeseries_groups/arc" }))
  .annotations({
    identifier: "GetEmailSecurityTimeseriesGroupByArcRequest",
  }) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupByArcRequest>;

export interface GetEmailSecurityTimeseriesGroupByArcResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { FAIL: string[]; NONE: string[]; PASS: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecurityTimeseriesGroupByArcResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      FAIL: Schema.Array(Schema.String),
      NONE: Schema.Array(Schema.String),
      PASS: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecurityTimeseriesGroupByArcResponse",
}) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupByArcResponse>;

export const getEmailSecurityTimeseriesGroupByArc: (
  input: GetEmailSecurityTimeseriesGroupByArcRequest,
) => Effect.Effect<
  GetEmailSecurityTimeseriesGroupByArcResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecurityTimeseriesGroupByArcRequest,
  output: GetEmailSecurityTimeseriesGroupByArcResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecurityTimeseriesGroupByDkimRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecurityTimeseriesGroupByDkimRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/timeseries_groups/dkim" }))
  .annotations({
    identifier: "GetEmailSecurityTimeseriesGroupByDkimRequest",
  }) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupByDkimRequest>;

export interface GetEmailSecurityTimeseriesGroupByDkimResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { FAIL: string[]; NONE: string[]; PASS: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecurityTimeseriesGroupByDkimResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      FAIL: Schema.Array(Schema.String),
      NONE: Schema.Array(Schema.String),
      PASS: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecurityTimeseriesGroupByDkimResponse",
}) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupByDkimResponse>;

export const getEmailSecurityTimeseriesGroupByDkim: (
  input: GetEmailSecurityTimeseriesGroupByDkimRequest,
) => Effect.Effect<
  GetEmailSecurityTimeseriesGroupByDkimResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecurityTimeseriesGroupByDkimRequest,
  output: GetEmailSecurityTimeseriesGroupByDkimResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecurityTimeseriesGroupByDmarcRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecurityTimeseriesGroupByDmarcRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/timeseries_groups/dmarc" }))
  .annotations({
    identifier: "GetEmailSecurityTimeseriesGroupByDmarcRequest",
  }) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupByDmarcRequest>;

export interface GetEmailSecurityTimeseriesGroupByDmarcResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { FAIL: string[]; NONE: string[]; PASS: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecurityTimeseriesGroupByDmarcResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      FAIL: Schema.Array(Schema.String),
      NONE: Schema.Array(Schema.String),
      PASS: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecurityTimeseriesGroupByDmarcResponse",
}) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupByDmarcResponse>;

export const getEmailSecurityTimeseriesGroupByDmarc: (
  input: GetEmailSecurityTimeseriesGroupByDmarcRequest,
) => Effect.Effect<
  GetEmailSecurityTimeseriesGroupByDmarcResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecurityTimeseriesGroupByDmarcRequest,
  output: GetEmailSecurityTimeseriesGroupByDmarcResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecurityTimeseriesGroupByMaliciousRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecurityTimeseriesGroupByMaliciousRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/timeseries_groups/malicious" }))
  .annotations({
    identifier: "GetEmailSecurityTimeseriesGroupByMaliciousRequest",
  }) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupByMaliciousRequest>;

export interface GetEmailSecurityTimeseriesGroupByMaliciousResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { MALICIOUS: string[]; NOT_MALICIOUS: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecurityTimeseriesGroupByMaliciousResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      MALICIOUS: Schema.Array(Schema.String),
      NOT_MALICIOUS: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecurityTimeseriesGroupByMaliciousResponse",
}) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupByMaliciousResponse>;

export const getEmailSecurityTimeseriesGroupByMalicious: (
  input: GetEmailSecurityTimeseriesGroupByMaliciousRequest,
) => Effect.Effect<
  GetEmailSecurityTimeseriesGroupByMaliciousResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecurityTimeseriesGroupByMaliciousRequest,
  output: GetEmailSecurityTimeseriesGroupByMaliciousResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecurityTimeseriesGroupBySpamRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecurityTimeseriesGroupBySpamRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/timeseries_groups/spam" }))
  .annotations({
    identifier: "GetEmailSecurityTimeseriesGroupBySpamRequest",
  }) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupBySpamRequest>;

export interface GetEmailSecurityTimeseriesGroupBySpamResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { NOT_SPAM: string[]; SPAM: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecurityTimeseriesGroupBySpamResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      NOT_SPAM: Schema.Array(Schema.String),
      SPAM: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecurityTimeseriesGroupBySpamResponse",
}) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupBySpamResponse>;

export const getEmailSecurityTimeseriesGroupBySpam: (
  input: GetEmailSecurityTimeseriesGroupBySpamRequest,
) => Effect.Effect<
  GetEmailSecurityTimeseriesGroupBySpamResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecurityTimeseriesGroupBySpamRequest,
  output: GetEmailSecurityTimeseriesGroupBySpamResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecurityTimeseriesGroupBySpfRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecurityTimeseriesGroupBySpfRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/timeseries_groups/spf" }))
  .annotations({
    identifier: "GetEmailSecurityTimeseriesGroupBySpfRequest",
  }) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupBySpfRequest>;

export interface GetEmailSecurityTimeseriesGroupBySpfResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { FAIL: string[]; NONE: string[]; PASS: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecurityTimeseriesGroupBySpfResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      FAIL: Schema.Array(Schema.String),
      NONE: Schema.Array(Schema.String),
      PASS: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecurityTimeseriesGroupBySpfResponse",
}) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupBySpfResponse>;

export const getEmailSecurityTimeseriesGroupBySpf: (
  input: GetEmailSecurityTimeseriesGroupBySpfRequest,
) => Effect.Effect<
  GetEmailSecurityTimeseriesGroupBySpfResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecurityTimeseriesGroupBySpfRequest,
  output: GetEmailSecurityTimeseriesGroupBySpfResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecurityTimeseriesGroupBySpoofRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecurityTimeseriesGroupBySpoofRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/timeseries_groups/spoof" }))
  .annotations({
    identifier: "GetEmailSecurityTimeseriesGroupBySpoofRequest",
  }) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupBySpoofRequest>;

export interface GetEmailSecurityTimeseriesGroupBySpoofResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { NOT_SPOOF: string[]; SPOOF: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecurityTimeseriesGroupBySpoofResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      NOT_SPOOF: Schema.Array(Schema.String),
      SPOOF: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecurityTimeseriesGroupBySpoofResponse",
}) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupBySpoofResponse>;

export const getEmailSecurityTimeseriesGroupBySpoof: (
  input: GetEmailSecurityTimeseriesGroupBySpoofRequest,
) => Effect.Effect<
  GetEmailSecurityTimeseriesGroupBySpoofResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecurityTimeseriesGroupBySpoofRequest,
  output: GetEmailSecurityTimeseriesGroupBySpoofResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecurityTimeseriesGroupByThreatCategoryRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecurityTimeseriesGroupByThreatCategoryRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/timeseries_groups/threat_category" }))
  .annotations({
    identifier: "GetEmailSecurityTimeseriesGroupByThreatCategoryRequest",
  }) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupByThreatCategoryRequest>;

export interface GetEmailSecurityTimeseriesGroupByThreatCategoryResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: {
      BrandImpersonation: string[];
      CredentialHarvester: string[];
      IdentityDeception: string[];
      Link: string[];
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecurityTimeseriesGroupByThreatCategoryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      BrandImpersonation: Schema.Array(Schema.String),
      CredentialHarvester: Schema.Array(Schema.String),
      IdentityDeception: Schema.Array(Schema.String),
      Link: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecurityTimeseriesGroupByThreatCategoryResponse",
}) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupByThreatCategoryResponse>;

export const getEmailSecurityTimeseriesGroupByThreatCategory: (
  input: GetEmailSecurityTimeseriesGroupByThreatCategoryRequest,
) => Effect.Effect<
  GetEmailSecurityTimeseriesGroupByThreatCategoryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecurityTimeseriesGroupByThreatCategoryRequest,
  output: GetEmailSecurityTimeseriesGroupByThreatCategoryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecurityTimeseriesGroupByTlsVersionRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  format?: "JSON" | "CSV";
}

export const GetEmailSecurityTimeseriesGroupByTlsVersionRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/timeseries_groups/tls_version" }))
  .annotations({
    identifier: "GetEmailSecurityTimeseriesGroupByTlsVersionRequest",
  }) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupByTlsVersionRequest>;

export interface GetEmailSecurityTimeseriesGroupByTlsVersionResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { "TLS 1.0": string[]; "TLS 1.1": string[]; "TLS 1.2": string[]; "TLS 1.3": string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecurityTimeseriesGroupByTlsVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      "TLS 1.0": Schema.Array(Schema.String),
      "TLS 1.1": Schema.Array(Schema.String),
      "TLS 1.2": Schema.Array(Schema.String),
      "TLS 1.3": Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecurityTimeseriesGroupByTlsVersionResponse",
}) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupByTlsVersionResponse>;

export const getEmailSecurityTimeseriesGroupByTlsVersion: (
  input: GetEmailSecurityTimeseriesGroupByTlsVersionRequest,
) => Effect.Effect<
  GetEmailSecurityTimeseriesGroupByTlsVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecurityTimeseriesGroupByTlsVersionRequest,
  output: GetEmailSecurityTimeseriesGroupByTlsVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecurityTimeseriesGroupRequest {
  dimension:
    | "SPAM"
    | "MALICIOUS"
    | "SPOOF"
    | "THREAT_CATEGORY"
    | "ARC"
    | "DKIM"
    | "DMARC"
    | "SPF"
    | "TLS_VERSION";
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetEmailSecurityTimeseriesGroupRequest = Schema.Struct({
  dimension: Schema.Literal(
    "SPAM",
    "MALICIOUS",
    "SPOOF",
    "THREAT_CATEGORY",
    "ARC",
    "DKIM",
    "DMARC",
    "SPF",
    "TLS_VERSION",
  ).pipe(T.HttpPath("dimension")),
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/timeseries_groups/{dimension}" }))
  .annotations({
    identifier: "GetEmailSecurityTimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupRequest>;

export interface GetEmailSecurityTimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecurityTimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecurityTimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetEmailSecurityTimeseriesGroupResponse>;

export const getEmailSecurityTimeseriesGroup: (
  input: GetEmailSecurityTimeseriesGroupRequest,
) => Effect.Effect<
  GetEmailSecurityTimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecurityTimeseriesGroupRequest,
  output: GetEmailSecurityTimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecurityTopTldsByMessagesRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  tldCategory?: "CLASSIC" | "COUNTRY";
  format?: "JSON" | "CSV";
}

export const GetEmailSecurityTopTldsByMessagesRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  tldCategory: Schema.optional(Schema.Literal("CLASSIC", "COUNTRY")).pipe(
    T.HttpQuery("tldCategory"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/top/tlds" }))
  .annotations({
    identifier: "GetEmailSecurityTopTldsByMessagesRequest",
  }) as unknown as Schema.Schema<GetEmailSecurityTopTldsByMessagesRequest>;

export interface GetEmailSecurityTopTldsByMessagesResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { name: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecurityTopTldsByMessagesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        name: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecurityTopTldsByMessagesResponse",
}) as unknown as Schema.Schema<GetEmailSecurityTopTldsByMessagesResponse>;

export const getEmailSecurityTopTldsByMessages: (
  input: GetEmailSecurityTopTldsByMessagesRequest,
) => Effect.Effect<
  GetEmailSecurityTopTldsByMessagesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecurityTopTldsByMessagesRequest,
  output: GetEmailSecurityTopTldsByMessagesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecurityTopTldsByMaliciousRequest {
  malicious: "MALICIOUS" | "NOT_MALICIOUS";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  tldCategory?: "CLASSIC" | "COUNTRY";
  format?: "JSON" | "CSV";
}

export const GetEmailSecurityTopTldsByMaliciousRequest = Schema.Struct({
  malicious: Schema.Literal("MALICIOUS", "NOT_MALICIOUS").pipe(T.HttpPath("malicious")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  tldCategory: Schema.optional(Schema.Literal("CLASSIC", "COUNTRY")).pipe(
    T.HttpQuery("tldCategory"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/top/tlds/malicious/{malicious}" }))
  .annotations({
    identifier: "GetEmailSecurityTopTldsByMaliciousRequest",
  }) as unknown as Schema.Schema<GetEmailSecurityTopTldsByMaliciousRequest>;

export interface GetEmailSecurityTopTldsByMaliciousResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { name: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecurityTopTldsByMaliciousResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        name: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecurityTopTldsByMaliciousResponse",
}) as unknown as Schema.Schema<GetEmailSecurityTopTldsByMaliciousResponse>;

export const getEmailSecurityTopTldsByMalicious: (
  input: GetEmailSecurityTopTldsByMaliciousRequest,
) => Effect.Effect<
  GetEmailSecurityTopTldsByMaliciousResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecurityTopTldsByMaliciousRequest,
  output: GetEmailSecurityTopTldsByMaliciousResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecurityTopTldsBySpamRequest {
  spam: "SPAM" | "NOT_SPAM";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  tldCategory?: "CLASSIC" | "COUNTRY";
  format?: "JSON" | "CSV";
}

export const GetEmailSecurityTopTldsBySpamRequest = Schema.Struct({
  spam: Schema.Literal("SPAM", "NOT_SPAM").pipe(T.HttpPath("spam")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  tldCategory: Schema.optional(Schema.Literal("CLASSIC", "COUNTRY")).pipe(
    T.HttpQuery("tldCategory"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/top/tlds/spam/{spam}" }))
  .annotations({
    identifier: "GetEmailSecurityTopTldsBySpamRequest",
  }) as unknown as Schema.Schema<GetEmailSecurityTopTldsBySpamRequest>;

export interface GetEmailSecurityTopTldsBySpamResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { name: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecurityTopTldsBySpamResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        name: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecurityTopTldsBySpamResponse",
}) as unknown as Schema.Schema<GetEmailSecurityTopTldsBySpamResponse>;

export const getEmailSecurityTopTldsBySpam: (
  input: GetEmailSecurityTopTldsBySpamRequest,
) => Effect.Effect<
  GetEmailSecurityTopTldsBySpamResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecurityTopTldsBySpamRequest,
  output: GetEmailSecurityTopTldsBySpamResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEmailSecurityTopTldsBySpoofRequest {
  spoof: "SPOOF" | "NOT_SPOOF";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  arc?: "PASS" | "NONE" | "FAIL"[];
  dkim?: "PASS" | "NONE" | "FAIL"[];
  dmarc?: "PASS" | "NONE" | "FAIL"[];
  spf?: "PASS" | "NONE" | "FAIL"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3"[];
  tldCategory?: "CLASSIC" | "COUNTRY";
  format?: "JSON" | "CSV";
}

export const GetEmailSecurityTopTldsBySpoofRequest = Schema.Struct({
  spoof: Schema.Literal("SPOOF", "NOT_SPOOF").pipe(T.HttpPath("spoof")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  arc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("arc"),
  ),
  dkim: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dkim"),
  ),
  dmarc: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("dmarc"),
  ),
  spf: Schema.optional(Schema.Array(Schema.Literal("PASS", "NONE", "FAIL"))).pipe(
    T.HttpQuery("spf"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3")),
  ).pipe(T.HttpQuery("tlsVersion")),
  tldCategory: Schema.optional(Schema.Literal("CLASSIC", "COUNTRY")).pipe(
    T.HttpQuery("tldCategory"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/email/security/top/tlds/spoof/{spoof}" }))
  .annotations({
    identifier: "GetEmailSecurityTopTldsBySpoofRequest",
  }) as unknown as Schema.Schema<GetEmailSecurityTopTldsBySpoofRequest>;

export interface GetEmailSecurityTopTldsBySpoofResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { name: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEmailSecurityTopTldsBySpoofResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        name: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEmailSecurityTopTldsBySpoofResponse",
}) as unknown as Schema.Schema<GetEmailSecurityTopTldsBySpoofResponse>;

export const getEmailSecurityTopTldsBySpoof: (
  input: GetEmailSecurityTopTldsBySpoofRequest,
) => Effect.Effect<
  GetEmailSecurityTopTldsBySpoofResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEmailSecurityTopTldsBySpoofRequest,
  output: GetEmailSecurityTopTldsBySpoofResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface ListRequest {
  limit?: number;
  offset?: number;
  asn?: string;
  location?: string;
  orderBy?: "ASN" | "POPULATION";
  format?: "JSON" | "CSV";
}

export const ListRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset")),
  asn: Schema.optional(Schema.String).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.String).pipe(T.HttpQuery("location")),
  orderBy: Schema.optional(Schema.Literal("ASN", "POPULATION")).pipe(T.HttpQuery("orderBy")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/entities/asns" }))
  .annotations({ identifier: "ListRequest" }) as unknown as Schema.Schema<ListRequest>;

export interface ListResponse {
  result: {
    asns: {
      aka?: string;
      asn: number;
      country: string;
      countryName: string;
      name: string;
      orgName?: string;
      website?: string;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const ListResponse = Schema.Struct({
  result: Schema.Struct({
    asns: Schema.Array(
      Schema.Struct({
        aka: Schema.optional(Schema.NullOr(Schema.String)),
        asn: Schema.Number,
        country: Schema.String,
        countryName: Schema.String,
        name: Schema.String,
        orgName: Schema.optional(Schema.NullOr(Schema.String)),
        website: Schema.optional(Schema.NullOr(Schema.String)),
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({ identifier: "ListResponse" }) as unknown as Schema.Schema<ListResponse>;

export const list: (
  input: ListRequest,
) => Effect.Effect<
  ListResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListRequest,
  output: ListResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEntitiesAsnByIpRequest {
  ip: string;
  format?: "JSON" | "CSV";
}

export const GetEntitiesAsnByIpRequest = Schema.Struct({
  ip: Schema.String.pipe(T.HttpQuery("ip")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/entities/asns/ip" }))
  .annotations({
    identifier: "GetEntitiesAsnByIpRequest",
  }) as unknown as Schema.Schema<GetEntitiesAsnByIpRequest>;

export interface GetEntitiesAsnByIpResponse {
  result: {
    asn: {
      aka?: string;
      asn: number;
      country: string;
      countryName: string;
      estimatedUsers: {
        estimatedUsers?: number;
        locations: { estimatedUsers?: number; locationAlpha2: string; locationName: string }[];
      };
      name: string;
      orgName: string;
      related: { aka?: string; asn: number; estimatedUsers?: number; name: string }[];
      source: string;
      website: string;
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEntitiesAsnByIpResponse = Schema.Struct({
  result: Schema.Struct({
    asn: Schema.Struct({
      aka: Schema.optional(Schema.NullOr(Schema.String)),
      asn: Schema.Number,
      country: Schema.String,
      countryName: Schema.String,
      estimatedUsers: Schema.Struct({
        estimatedUsers: Schema.optional(Schema.NullOr(Schema.Number)),
        locations: Schema.Array(
          Schema.Struct({
            estimatedUsers: Schema.optional(Schema.NullOr(Schema.Number)),
            locationAlpha2: Schema.String,
            locationName: Schema.String,
          }),
        ),
      }),
      name: Schema.String,
      orgName: Schema.String,
      related: Schema.Array(
        Schema.Struct({
          aka: Schema.optional(Schema.NullOr(Schema.String)),
          asn: Schema.Number,
          estimatedUsers: Schema.optional(Schema.NullOr(Schema.Number)),
          name: Schema.String,
        }),
      ),
      source: Schema.String,
      website: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEntitiesAsnByIpResponse",
}) as unknown as Schema.Schema<GetEntitiesAsnByIpResponse>;

export const getEntitiesAsnByIp: (
  input: GetEntitiesAsnByIpRequest,
) => Effect.Effect<
  GetEntitiesAsnByIpResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEntitiesAsnByIpRequest,
  output: GetEntitiesAsnByIpResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEntitiesAsnByIdRequest {
  asn: number;
  format?: "JSON" | "CSV";
}

export const GetEntitiesAsnByIdRequest = Schema.Struct({
  asn: Schema.Number.pipe(T.HttpPath("asn")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/entities/asns/{asn}" }))
  .annotations({
    identifier: "GetEntitiesAsnByIdRequest",
  }) as unknown as Schema.Schema<GetEntitiesAsnByIdRequest>;

export interface GetEntitiesAsnByIdResponse {
  result: {
    asn: {
      aka?: string;
      asn: number;
      confidenceLevel: number;
      country: string;
      countryName: string;
      estimatedUsers: {
        estimatedUsers?: number;
        locations: { estimatedUsers?: number; locationAlpha2: string; locationName: string }[];
      };
      name: string;
      orgName: string;
      related: { aka?: string; asn: number; estimatedUsers?: number; name: string }[];
      source: string;
      website: string;
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEntitiesAsnByIdResponse = Schema.Struct({
  result: Schema.Struct({
    asn: Schema.Struct({
      aka: Schema.optional(Schema.NullOr(Schema.String)),
      asn: Schema.Number,
      confidenceLevel: Schema.Number,
      country: Schema.String,
      countryName: Schema.String,
      estimatedUsers: Schema.Struct({
        estimatedUsers: Schema.optional(Schema.NullOr(Schema.Number)),
        locations: Schema.Array(
          Schema.Struct({
            estimatedUsers: Schema.optional(Schema.NullOr(Schema.Number)),
            locationAlpha2: Schema.String,
            locationName: Schema.String,
          }),
        ),
      }),
      name: Schema.String,
      orgName: Schema.String,
      related: Schema.Array(
        Schema.Struct({
          aka: Schema.optional(Schema.NullOr(Schema.String)),
          asn: Schema.Number,
          estimatedUsers: Schema.optional(Schema.NullOr(Schema.Number)),
          name: Schema.String,
        }),
      ),
      source: Schema.String,
      website: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEntitiesAsnByIdResponse",
}) as unknown as Schema.Schema<GetEntitiesAsnByIdResponse>;

export const getEntitiesAsnById: (
  input: GetEntitiesAsnByIdRequest,
) => Effect.Effect<
  GetEntitiesAsnByIdResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEntitiesAsnByIdRequest,
  output: GetEntitiesAsnByIdResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAsnsAsSetRequest {
  asn: number;
  format?: "JSON" | "CSV";
}

export const GetAsnsAsSetRequest = Schema.Struct({
  asn: Schema.Number.pipe(T.HttpPath("asn")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/entities/asns/{asn}/as_set" }))
  .annotations({
    identifier: "GetAsnsAsSetRequest",
  }) as unknown as Schema.Schema<GetAsnsAsSetRequest>;

export interface GetAsnsAsSetResponse {
  result: {
    as_sets: {
      as_members_count: number;
      as_set_members_count: number;
      as_set_upstreams_count: number;
      asn_cone_size: number;
      hierarchical_asn?: number;
      inferred_asn?: number;
      irr_sources: string[];
      name: string;
      peeringdb_asn?: number;
    }[];
    paths: string[][];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAsnsAsSetResponse = Schema.Struct({
  result: Schema.Struct({
    as_sets: Schema.Array(
      Schema.Struct({
        as_members_count: Schema.Number,
        as_set_members_count: Schema.Number,
        as_set_upstreams_count: Schema.Number,
        asn_cone_size: Schema.Number,
        hierarchical_asn: Schema.optional(Schema.NullOr(Schema.Number)),
        inferred_asn: Schema.optional(Schema.NullOr(Schema.Number)),
        irr_sources: Schema.Array(Schema.String),
        name: Schema.String,
        peeringdb_asn: Schema.optional(Schema.NullOr(Schema.Number)),
      }),
    ),
    paths: Schema.Array(Schema.Array(Schema.String)),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAsnsAsSetResponse",
}) as unknown as Schema.Schema<GetAsnsAsSetResponse>;

export const getAsnsAsSet: (
  input: GetAsnsAsSetRequest,
) => Effect.Effect<
  GetAsnsAsSetResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAsnsAsSetRequest,
  output: GetAsnsAsSetResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetAsnsRelRequest {
  asn: number;
  asn2?: number;
  format?: "JSON" | "CSV";
}

export const GetAsnsRelRequest = Schema.Struct({
  asn: Schema.Number.pipe(T.HttpPath("asn")),
  asn2: Schema.optional(Schema.Number).pipe(T.HttpQuery("asn2")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/entities/asns/{asn}/rel" }))
  .annotations({ identifier: "GetAsnsRelRequest" }) as unknown as Schema.Schema<GetAsnsRelRequest>;

export interface GetAsnsRelResponse {
  result: {
    meta: { data_time: string; query_time: string; total_peers: number };
    rels: {
      asn1: number;
      asn1_country: string;
      asn1_name: string;
      asn2: number;
      asn2_country: string;
      asn2_name: string;
      rel: string;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetAsnsRelResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      data_time: Schema.String,
      query_time: Schema.String,
      total_peers: Schema.Number,
    }),
    rels: Schema.Array(
      Schema.Struct({
        asn1: Schema.Number,
        asn1_country: Schema.String,
        asn1_name: Schema.String,
        asn2: Schema.Number,
        asn2_country: Schema.String,
        asn2_name: Schema.String,
        rel: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetAsnsRelResponse",
}) as unknown as Schema.Schema<GetAsnsRelResponse>;

export const getAsnsRel: (
  input: GetAsnsRelRequest,
) => Effect.Effect<
  GetAsnsRelResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAsnsRelRequest,
  output: GetAsnsRelResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEntitiesIpRequest {
  ip: string;
  format?: "JSON" | "CSV";
}

export const GetEntitiesIpRequest = Schema.Struct({
  ip: Schema.String.pipe(T.HttpQuery("ip")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/entities/ip" }))
  .annotations({
    identifier: "GetEntitiesIpRequest",
  }) as unknown as Schema.Schema<GetEntitiesIpRequest>;

export interface GetEntitiesIpResponse {
  result: {
    ip: {
      asn: string;
      asnLocation: string;
      asnName: string;
      asnOrgName: string;
      ip: string;
      ipVersion: string;
      location: string;
      locationName: string;
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEntitiesIpResponse = Schema.Struct({
  result: Schema.Struct({
    ip: Schema.Struct({
      asn: Schema.String,
      asnLocation: Schema.String,
      asnName: Schema.String,
      asnOrgName: Schema.String,
      ip: Schema.String,
      ipVersion: Schema.String,
      location: Schema.String,
      locationName: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEntitiesIpResponse",
}) as unknown as Schema.Schema<GetEntitiesIpResponse>;

export const getEntitiesIp: (
  input: GetEntitiesIpRequest,
) => Effect.Effect<
  GetEntitiesIpResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEntitiesIpRequest,
  output: GetEntitiesIpResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEntitiesLocationsRequest {
  limit?: number;
  offset?: number;
  location?: string;
  format?: "JSON" | "CSV";
}

export const GetEntitiesLocationsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset")),
  location: Schema.optional(Schema.String).pipe(T.HttpQuery("location")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/entities/locations" }))
  .annotations({
    identifier: "GetEntitiesLocationsRequest",
  }) as unknown as Schema.Schema<GetEntitiesLocationsRequest>;

export interface GetEntitiesLocationsResponse {
  result: { locations: { alpha2: string; latitude: string; longitude: string; name: string }[] };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEntitiesLocationsResponse = Schema.Struct({
  result: Schema.Struct({
    locations: Schema.Array(
      Schema.Struct({
        alpha2: Schema.String,
        latitude: Schema.String,
        longitude: Schema.String,
        name: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEntitiesLocationsResponse",
}) as unknown as Schema.Schema<GetEntitiesLocationsResponse>;

export const getEntitiesLocations: (
  input: GetEntitiesLocationsRequest,
) => Effect.Effect<
  GetEntitiesLocationsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEntitiesLocationsRequest,
  output: GetEntitiesLocationsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetEntitiesLocationByAlpha2Request {
  location: string;
  format?: "JSON" | "CSV";
}

export const GetEntitiesLocationByAlpha2Request = Schema.Struct({
  location: Schema.String.pipe(T.HttpPath("location")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/entities/locations/{location}" }))
  .annotations({
    identifier: "GetEntitiesLocationByAlpha2Request",
  }) as unknown as Schema.Schema<GetEntitiesLocationByAlpha2Request>;

export interface GetEntitiesLocationByAlpha2Response {
  result: {
    location: {
      alpha2: string;
      confidenceLevel: number;
      latitude: string;
      longitude: string;
      name: string;
      region: string;
      subregion: string;
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetEntitiesLocationByAlpha2Response = Schema.Struct({
  result: Schema.Struct({
    location: Schema.Struct({
      alpha2: Schema.String,
      confidenceLevel: Schema.Number,
      latitude: Schema.String,
      longitude: Schema.String,
      name: Schema.String,
      region: Schema.String,
      subregion: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetEntitiesLocationByAlpha2Response",
}) as unknown as Schema.Schema<GetEntitiesLocationByAlpha2Response>;

export const getEntitiesLocationByAlpha2: (
  input: GetEntitiesLocationByAlpha2Request,
) => Effect.Effect<
  GetEntitiesLocationByAlpha2Response,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEntitiesLocationByAlpha2Request,
  output: GetEntitiesLocationByAlpha2Response,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetGeolocationsRequest {
  limit?: number;
  offset?: number;
  geoId?: string;
  location?: string;
  format?: "JSON" | "CSV";
}

export const GetGeolocationsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset")),
  geoId: Schema.optional(Schema.String).pipe(T.HttpQuery("geoId")),
  location: Schema.optional(Schema.String).pipe(T.HttpQuery("location")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/geolocations" }))
  .annotations({
    identifier: "GetGeolocationsRequest",
  }) as unknown as Schema.Schema<GetGeolocationsRequest>;

export interface GetGeolocationsResponse {
  result: {
    geolocations: {
      geoId: string;
      latitude: string;
      longitude: string;
      name: string;
      parent: {
        geoId: string;
        latitude: string;
        longitude: string;
        name: string;
        parent: {
          geoId: string;
          latitude: string;
          longitude: string;
          name: string;
          type: "CONTINENT" | "COUNTRY" | "ADM1";
        };
        type: "CONTINENT" | "COUNTRY" | "ADM1";
      };
      type: "CONTINENT" | "COUNTRY" | "ADM1";
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetGeolocationsResponse = Schema.Struct({
  result: Schema.Struct({
    geolocations: Schema.Array(
      Schema.Struct({
        geoId: Schema.String,
        latitude: Schema.String,
        longitude: Schema.String,
        name: Schema.String,
        parent: Schema.Struct({
          geoId: Schema.String,
          latitude: Schema.String,
          longitude: Schema.String,
          name: Schema.String,
          parent: Schema.Struct({
            geoId: Schema.String,
            latitude: Schema.String,
            longitude: Schema.String,
            name: Schema.String,
            type: Schema.Literal("CONTINENT", "COUNTRY", "ADM1"),
          }),
          type: Schema.Literal("CONTINENT", "COUNTRY", "ADM1"),
        }),
        type: Schema.Literal("CONTINENT", "COUNTRY", "ADM1"),
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetGeolocationsResponse",
}) as unknown as Schema.Schema<GetGeolocationsResponse>;

export const getGeolocations: (
  input: GetGeolocationsRequest,
) => Effect.Effect<
  GetGeolocationsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGeolocationsRequest,
  output: GetGeolocationsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetGeolocationDetailsRequest {
  geo_id: string;
  format?: "JSON" | "CSV";
}

export const GetGeolocationDetailsRequest = Schema.Struct({
  geo_id: Schema.String.pipe(T.HttpPath("geo_id")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/geolocations/{geo_id}" }))
  .annotations({
    identifier: "GetGeolocationDetailsRequest",
  }) as unknown as Schema.Schema<GetGeolocationDetailsRequest>;

export interface GetGeolocationDetailsResponse {
  result: {
    geolocation: {
      geoId: string;
      latitude: string;
      longitude: string;
      name: string;
      parent: {
        geoId: string;
        latitude: string;
        longitude: string;
        name: string;
        parent: {
          geoId: string;
          latitude: string;
          longitude: string;
          name: string;
          type: "CONTINENT" | "COUNTRY" | "ADM1";
        };
        type: "CONTINENT" | "COUNTRY" | "ADM1";
      };
      type: "CONTINENT" | "COUNTRY" | "ADM1";
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetGeolocationDetailsResponse = Schema.Struct({
  result: Schema.Struct({
    geolocation: Schema.Struct({
      geoId: Schema.String,
      latitude: Schema.String,
      longitude: Schema.String,
      name: Schema.String,
      parent: Schema.Struct({
        geoId: Schema.String,
        latitude: Schema.String,
        longitude: Schema.String,
        name: Schema.String,
        parent: Schema.Struct({
          geoId: Schema.String,
          latitude: Schema.String,
          longitude: Schema.String,
          name: Schema.String,
          type: Schema.Literal("CONTINENT", "COUNTRY", "ADM1"),
        }),
        type: Schema.Literal("CONTINENT", "COUNTRY", "ADM1"),
      }),
      type: Schema.Literal("CONTINENT", "COUNTRY", "ADM1"),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetGeolocationDetailsResponse",
}) as unknown as Schema.Schema<GetGeolocationDetailsResponse>;

export const getGeolocationDetails: (
  input: GetGeolocationDetailsRequest,
) => Effect.Effect<
  GetGeolocationDetailsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGeolocationDetailsRequest,
  output: GetGeolocationDetailsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpSummaryByBotClassRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpSummaryByBotClassRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/summary/bot_class" }))
  .annotations({
    identifier: "GetHttpSummaryByBotClassRequest",
  }) as unknown as Schema.Schema<GetHttpSummaryByBotClassRequest>;

export interface GetHttpSummaryByBotClassResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { bot: string; human: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpSummaryByBotClassResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      bot: Schema.String,
      human: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpSummaryByBotClassResponse",
}) as unknown as Schema.Schema<GetHttpSummaryByBotClassResponse>;

export const getHttpSummaryByBotClass: (
  input: GetHttpSummaryByBotClassRequest,
) => Effect.Effect<
  GetHttpSummaryByBotClassResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpSummaryByBotClassRequest,
  output: GetHttpSummaryByBotClassResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpSummaryByDeviceTypeRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpSummaryByDeviceTypeRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/summary/device_type" }))
  .annotations({
    identifier: "GetHttpSummaryByDeviceTypeRequest",
  }) as unknown as Schema.Schema<GetHttpSummaryByDeviceTypeRequest>;

export interface GetHttpSummaryByDeviceTypeResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { desktop: string; mobile: string; other: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpSummaryByDeviceTypeResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      desktop: Schema.String,
      mobile: Schema.String,
      other: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpSummaryByDeviceTypeResponse",
}) as unknown as Schema.Schema<GetHttpSummaryByDeviceTypeResponse>;

export const getHttpSummaryByDeviceType: (
  input: GetHttpSummaryByDeviceTypeRequest,
) => Effect.Effect<
  GetHttpSummaryByDeviceTypeResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpSummaryByDeviceTypeRequest,
  output: GetHttpSummaryByDeviceTypeResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpSummaryByHttpProtocolRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpSummaryByHttpProtocolRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/summary/http_protocol" }))
  .annotations({
    identifier: "GetHttpSummaryByHttpProtocolRequest",
  }) as unknown as Schema.Schema<GetHttpSummaryByHttpProtocolRequest>;

export interface GetHttpSummaryByHttpProtocolResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { http: string; https: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpSummaryByHttpProtocolResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      http: Schema.String,
      https: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpSummaryByHttpProtocolResponse",
}) as unknown as Schema.Schema<GetHttpSummaryByHttpProtocolResponse>;

export const getHttpSummaryByHttpProtocol: (
  input: GetHttpSummaryByHttpProtocolRequest,
) => Effect.Effect<
  GetHttpSummaryByHttpProtocolResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpSummaryByHttpProtocolRequest,
  output: GetHttpSummaryByHttpProtocolResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpSummaryByHttpVersionRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpSummaryByHttpVersionRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/summary/http_version" }))
  .annotations({
    identifier: "GetHttpSummaryByHttpVersionRequest",
  }) as unknown as Schema.Schema<GetHttpSummaryByHttpVersionRequest>;

export interface GetHttpSummaryByHttpVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { "HTTP/1.x": string; "HTTP/2": string; "HTTP/3": string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpSummaryByHttpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      "HTTP/1.x": Schema.String,
      "HTTP/2": Schema.String,
      "HTTP/3": Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpSummaryByHttpVersionResponse",
}) as unknown as Schema.Schema<GetHttpSummaryByHttpVersionResponse>;

export const getHttpSummaryByHttpVersion: (
  input: GetHttpSummaryByHttpVersionRequest,
) => Effect.Effect<
  GetHttpSummaryByHttpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpSummaryByHttpVersionRequest,
  output: GetHttpSummaryByHttpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpSummaryByIpVersionRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpSummaryByIpVersionRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/summary/ip_version" }))
  .annotations({
    identifier: "GetHttpSummaryByIpVersionRequest",
  }) as unknown as Schema.Schema<GetHttpSummaryByIpVersionRequest>;

export interface GetHttpSummaryByIpVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { IPv4: string; IPv6: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpSummaryByIpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      IPv4: Schema.String,
      IPv6: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpSummaryByIpVersionResponse",
}) as unknown as Schema.Schema<GetHttpSummaryByIpVersionResponse>;

export const getHttpSummaryByIpVersion: (
  input: GetHttpSummaryByIpVersionRequest,
) => Effect.Effect<
  GetHttpSummaryByIpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpSummaryByIpVersionRequest,
  output: GetHttpSummaryByIpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpSummaryByOperatingSystemRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpSummaryByOperatingSystemRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/summary/os" }))
  .annotations({
    identifier: "GetHttpSummaryByOperatingSystemRequest",
  }) as unknown as Schema.Schema<GetHttpSummaryByOperatingSystemRequest>;

export interface GetHttpSummaryByOperatingSystemResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { ANDROID: string; IOS: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpSummaryByOperatingSystemResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      ANDROID: Schema.String,
      IOS: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpSummaryByOperatingSystemResponse",
}) as unknown as Schema.Schema<GetHttpSummaryByOperatingSystemResponse>;

export const getHttpSummaryByOperatingSystem: (
  input: GetHttpSummaryByOperatingSystemRequest,
) => Effect.Effect<
  GetHttpSummaryByOperatingSystemResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpSummaryByOperatingSystemRequest,
  output: GetHttpSummaryByOperatingSystemResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface PostQuantumRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const PostQuantumRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/summary/post_quantum" }))
  .annotations({
    identifier: "PostQuantumRequest",
  }) as unknown as Schema.Schema<PostQuantumRequest>;

export interface PostQuantumResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { NOT_SUPPORTED: string; SUPPORTED: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const PostQuantumResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      NOT_SUPPORTED: Schema.String,
      SUPPORTED: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "PostQuantumResponse",
}) as unknown as Schema.Schema<PostQuantumResponse>;

export const postQuantum: (
  input: PostQuantumRequest,
) => Effect.Effect<
  PostQuantumResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostQuantumRequest,
  output: PostQuantumResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpSummaryByTlsVersionRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpSummaryByTlsVersionRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/summary/tls_version" }))
  .annotations({
    identifier: "GetHttpSummaryByTlsVersionRequest",
  }) as unknown as Schema.Schema<GetHttpSummaryByTlsVersionRequest>;

export interface GetHttpSummaryByTlsVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: {
      "TLS 1.0": string;
      "TLS 1.1": string;
      "TLS 1.2": string;
      "TLS 1.3": string;
      "TLS QUIC": string;
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpSummaryByTlsVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      "TLS 1.0": Schema.String,
      "TLS 1.1": Schema.String,
      "TLS 1.2": Schema.String,
      "TLS 1.3": Schema.String,
      "TLS QUIC": Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpSummaryByTlsVersionResponse",
}) as unknown as Schema.Schema<GetHttpSummaryByTlsVersionResponse>;

export const getHttpSummaryByTlsVersion: (
  input: GetHttpSummaryByTlsVersionRequest,
) => Effect.Effect<
  GetHttpSummaryByTlsVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpSummaryByTlsVersionRequest,
  output: GetHttpSummaryByTlsVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpSummaryRequest {
  dimension:
    | "ADM1"
    | "BOT_CLASS"
    | "BROWSER"
    | "BROWSER_FAMILY"
    | "DEVICE_TYPE"
    | "HTTP_PROTOCOL"
    | "HTTP_VERSION"
    | "IP_VERSION"
    | "OS"
    | "POST_QUANTUM"
    | "TLS_VERSION";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetHttpSummaryRequest = Schema.Struct({
  dimension: Schema.Literal(
    "ADM1",
    "BOT_CLASS",
    "BROWSER",
    "BROWSER_FAMILY",
    "DEVICE_TYPE",
    "HTTP_PROTOCOL",
    "HTTP_VERSION",
    "IP_VERSION",
    "OS",
    "POST_QUANTUM",
    "TLS_VERSION",
  ).pipe(T.HttpPath("dimension")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/summary/{dimension}" }))
  .annotations({
    identifier: "GetHttpSummaryRequest",
  }) as unknown as Schema.Schema<GetHttpSummaryRequest>;

export interface GetHttpSummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpSummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpSummaryResponse",
}) as unknown as Schema.Schema<GetHttpSummaryResponse>;

export const getHttpSummary: (
  input: GetHttpSummaryRequest,
) => Effect.Effect<
  GetHttpSummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpSummaryRequest,
  output: GetHttpSummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTimeseriesRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  normalization?: "PERCENTAGE_CHANGE" | "MIN0_MAX";
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTimeseriesRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE_CHANGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/timeseries" }))
  .annotations({
    identifier: "GetHttpTimeseriesRequest",
  }) as unknown as Schema.Schema<GetHttpTimeseriesRequest>;

export interface GetHttpTimeseriesResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTimeseriesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTimeseriesResponse",
}) as unknown as Schema.Schema<GetHttpTimeseriesResponse>;

export const getHttpTimeseries: (
  input: GetHttpTimeseriesRequest,
) => Effect.Effect<
  GetHttpTimeseriesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTimeseriesRequest,
  output: GetHttpTimeseriesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTimeseriesGroupByBotClassRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTimeseriesGroupByBotClassRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/timeseries_groups/bot_class" }))
  .annotations({
    identifier: "GetHttpTimeseriesGroupByBotClassRequest",
  }) as unknown as Schema.Schema<GetHttpTimeseriesGroupByBotClassRequest>;

export interface GetHttpTimeseriesGroupByBotClassResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { bot: string[]; human: string[]; timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTimeseriesGroupByBotClassResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      bot: Schema.Array(Schema.String),
      human: Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTimeseriesGroupByBotClassResponse",
}) as unknown as Schema.Schema<GetHttpTimeseriesGroupByBotClassResponse>;

export const getHttpTimeseriesGroupByBotClass: (
  input: GetHttpTimeseriesGroupByBotClassRequest,
) => Effect.Effect<
  GetHttpTimeseriesGroupByBotClassResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTimeseriesGroupByBotClassRequest,
  output: GetHttpTimeseriesGroupByBotClassResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTimeseriesGroupByBrowsersRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetHttpTimeseriesGroupByBrowsersRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/timeseries_groups/browser" }))
  .annotations({
    identifier: "GetHttpTimeseriesGroupByBrowsersRequest",
  }) as unknown as Schema.Schema<GetHttpTimeseriesGroupByBrowsersRequest>;

export interface GetHttpTimeseriesGroupByBrowsersResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTimeseriesGroupByBrowsersResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTimeseriesGroupByBrowsersResponse",
}) as unknown as Schema.Schema<GetHttpTimeseriesGroupByBrowsersResponse>;

export const getHttpTimeseriesGroupByBrowsers: (
  input: GetHttpTimeseriesGroupByBrowsersRequest,
) => Effect.Effect<
  GetHttpTimeseriesGroupByBrowsersResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTimeseriesGroupByBrowsersRequest,
  output: GetHttpTimeseriesGroupByBrowsersResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTimeseriesGroupByBrowserFamiliesRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetHttpTimeseriesGroupByBrowserFamiliesRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/timeseries_groups/browser_family" }))
  .annotations({
    identifier: "GetHttpTimeseriesGroupByBrowserFamiliesRequest",
  }) as unknown as Schema.Schema<GetHttpTimeseriesGroupByBrowserFamiliesRequest>;

export interface GetHttpTimeseriesGroupByBrowserFamiliesResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTimeseriesGroupByBrowserFamiliesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTimeseriesGroupByBrowserFamiliesResponse",
}) as unknown as Schema.Schema<GetHttpTimeseriesGroupByBrowserFamiliesResponse>;

export const getHttpTimeseriesGroupByBrowserFamilies: (
  input: GetHttpTimeseriesGroupByBrowserFamiliesRequest,
) => Effect.Effect<
  GetHttpTimeseriesGroupByBrowserFamiliesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTimeseriesGroupByBrowserFamiliesRequest,
  output: GetHttpTimeseriesGroupByBrowserFamiliesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTimeseriesGroupByDeviceTypeRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTimeseriesGroupByDeviceTypeRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/timeseries_groups/device_type" }))
  .annotations({
    identifier: "GetHttpTimeseriesGroupByDeviceTypeRequest",
  }) as unknown as Schema.Schema<GetHttpTimeseriesGroupByDeviceTypeRequest>;

export interface GetHttpTimeseriesGroupByDeviceTypeResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { desktop: string[]; mobile: string[]; other: string[]; timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTimeseriesGroupByDeviceTypeResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      desktop: Schema.Array(Schema.String),
      mobile: Schema.Array(Schema.String),
      other: Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTimeseriesGroupByDeviceTypeResponse",
}) as unknown as Schema.Schema<GetHttpTimeseriesGroupByDeviceTypeResponse>;

export const getHttpTimeseriesGroupByDeviceType: (
  input: GetHttpTimeseriesGroupByDeviceTypeRequest,
) => Effect.Effect<
  GetHttpTimeseriesGroupByDeviceTypeResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTimeseriesGroupByDeviceTypeRequest,
  output: GetHttpTimeseriesGroupByDeviceTypeResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTimeseriesGroupByHttpProtocolRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTimeseriesGroupByHttpProtocolRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/timeseries_groups/http_protocol" }))
  .annotations({
    identifier: "GetHttpTimeseriesGroupByHttpProtocolRequest",
  }) as unknown as Schema.Schema<GetHttpTimeseriesGroupByHttpProtocolRequest>;

export interface GetHttpTimeseriesGroupByHttpProtocolResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { http: string[]; https: string[]; timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTimeseriesGroupByHttpProtocolResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      http: Schema.Array(Schema.String),
      https: Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTimeseriesGroupByHttpProtocolResponse",
}) as unknown as Schema.Schema<GetHttpTimeseriesGroupByHttpProtocolResponse>;

export const getHttpTimeseriesGroupByHttpProtocol: (
  input: GetHttpTimeseriesGroupByHttpProtocolRequest,
) => Effect.Effect<
  GetHttpTimeseriesGroupByHttpProtocolResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTimeseriesGroupByHttpProtocolRequest,
  output: GetHttpTimeseriesGroupByHttpProtocolResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTimeseriesGroupByHttpVersionRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTimeseriesGroupByHttpVersionRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/timeseries_groups/http_version" }))
  .annotations({
    identifier: "GetHttpTimeseriesGroupByHttpVersionRequest",
  }) as unknown as Schema.Schema<GetHttpTimeseriesGroupByHttpVersionRequest>;

export interface GetHttpTimeseriesGroupByHttpVersionResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { "HTTP/1.x": string[]; "HTTP/2": string[]; "HTTP/3": string[]; timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTimeseriesGroupByHttpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      "HTTP/1.x": Schema.Array(Schema.String),
      "HTTP/2": Schema.Array(Schema.String),
      "HTTP/3": Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTimeseriesGroupByHttpVersionResponse",
}) as unknown as Schema.Schema<GetHttpTimeseriesGroupByHttpVersionResponse>;

export const getHttpTimeseriesGroupByHttpVersion: (
  input: GetHttpTimeseriesGroupByHttpVersionRequest,
) => Effect.Effect<
  GetHttpTimeseriesGroupByHttpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTimeseriesGroupByHttpVersionRequest,
  output: GetHttpTimeseriesGroupByHttpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTimeseriesGroupByIpVersionRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTimeseriesGroupByIpVersionRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/timeseries_groups/ip_version" }))
  .annotations({
    identifier: "GetHttpTimeseriesGroupByIpVersionRequest",
  }) as unknown as Schema.Schema<GetHttpTimeseriesGroupByIpVersionRequest>;

export interface GetHttpTimeseriesGroupByIpVersionResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { IPv4: string[]; IPv6: string[]; timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTimeseriesGroupByIpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      IPv4: Schema.Array(Schema.String),
      IPv6: Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTimeseriesGroupByIpVersionResponse",
}) as unknown as Schema.Schema<GetHttpTimeseriesGroupByIpVersionResponse>;

export const getHttpTimeseriesGroupByIpVersion: (
  input: GetHttpTimeseriesGroupByIpVersionRequest,
) => Effect.Effect<
  GetHttpTimeseriesGroupByIpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTimeseriesGroupByIpVersionRequest,
  output: GetHttpTimeseriesGroupByIpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTimeseriesGroupByOperatingSystemRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTimeseriesGroupByOperatingSystemRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/timeseries_groups/os" }))
  .annotations({
    identifier: "GetHttpTimeseriesGroupByOperatingSystemRequest",
  }) as unknown as Schema.Schema<GetHttpTimeseriesGroupByOperatingSystemRequest>;

export interface GetHttpTimeseriesGroupByOperatingSystemResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTimeseriesGroupByOperatingSystemResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTimeseriesGroupByOperatingSystemResponse",
}) as unknown as Schema.Schema<GetHttpTimeseriesGroupByOperatingSystemResponse>;

export const getHttpTimeseriesGroupByOperatingSystem: (
  input: GetHttpTimeseriesGroupByOperatingSystemRequest,
) => Effect.Effect<
  GetHttpTimeseriesGroupByOperatingSystemResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTimeseriesGroupByOperatingSystemRequest,
  output: GetHttpTimeseriesGroupByOperatingSystemResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface PostQuantum1Request {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const PostQuantum1Request = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/timeseries_groups/post_quantum" }))
  .annotations({
    identifier: "PostQuantum1Request",
  }) as unknown as Schema.Schema<PostQuantum1Request>;

export interface PostQuantum1Response {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { NOT_SUPPORTED: string[]; SUPPORTED: string[]; timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const PostQuantum1Response = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      NOT_SUPPORTED: Schema.Array(Schema.String),
      SUPPORTED: Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "PostQuantum1Response",
}) as unknown as Schema.Schema<PostQuantum1Response>;

export const postQuantum1: (
  input: PostQuantum1Request,
) => Effect.Effect<
  PostQuantum1Response,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostQuantum1Request,
  output: PostQuantum1Response,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTimeseriesGroupByTlsVersionRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTimeseriesGroupByTlsVersionRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/timeseries_groups/tls_version" }))
  .annotations({
    identifier: "GetHttpTimeseriesGroupByTlsVersionRequest",
  }) as unknown as Schema.Schema<GetHttpTimeseriesGroupByTlsVersionRequest>;

export interface GetHttpTimeseriesGroupByTlsVersionResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: {
      "TLS 1.0": string[];
      "TLS 1.1": string[];
      "TLS 1.2": string[];
      "TLS 1.3": string[];
      "TLS QUIC": string[];
      timestamps: string[];
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTimeseriesGroupByTlsVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      "TLS 1.0": Schema.Array(Schema.String),
      "TLS 1.1": Schema.Array(Schema.String),
      "TLS 1.2": Schema.Array(Schema.String),
      "TLS 1.3": Schema.Array(Schema.String),
      "TLS QUIC": Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTimeseriesGroupByTlsVersionResponse",
}) as unknown as Schema.Schema<GetHttpTimeseriesGroupByTlsVersionResponse>;

export const getHttpTimeseriesGroupByTlsVersion: (
  input: GetHttpTimeseriesGroupByTlsVersionRequest,
) => Effect.Effect<
  GetHttpTimeseriesGroupByTlsVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTimeseriesGroupByTlsVersionRequest,
  output: GetHttpTimeseriesGroupByTlsVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTimeseriesGroupRequest {
  dimension:
    | "ADM1"
    | "BOT_CLASS"
    | "BROWSER"
    | "BROWSER_FAMILY"
    | "DEVICE_TYPE"
    | "HTTP_PROTOCOL"
    | "HTTP_VERSION"
    | "IP_VERSION"
    | "OS"
    | "POST_QUANTUM"
    | "TLS_VERSION";
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  limitPerGroup?: number;
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTimeseriesGroupRequest = Schema.Struct({
  dimension: Schema.Literal(
    "ADM1",
    "BOT_CLASS",
    "BROWSER",
    "BROWSER_FAMILY",
    "DEVICE_TYPE",
    "HTTP_PROTOCOL",
    "HTTP_VERSION",
    "IP_VERSION",
    "OS",
    "POST_QUANTUM",
    "TLS_VERSION",
  ).pipe(T.HttpPath("dimension")),
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/timeseries_groups/{dimension}" }))
  .annotations({
    identifier: "GetHttpTimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetHttpTimeseriesGroupRequest>;

export interface GetHttpTimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetHttpTimeseriesGroupResponse>;

export const getHttpTimeseriesGroup: (
  input: GetHttpTimeseriesGroupRequest,
) => Effect.Effect<
  GetHttpTimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTimeseriesGroupRequest,
  output: GetHttpTimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopAsesByHttpRequestsRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopAsesByHttpRequestsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/ases" }))
  .annotations({
    identifier: "GetHttpTopAsesByHttpRequestsRequest",
  }) as unknown as Schema.Schema<GetHttpTopAsesByHttpRequestsRequest>;

export interface GetHttpTopAsesByHttpRequestsResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientASN: number; clientASName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopAsesByHttpRequestsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientASN: Schema.Number,
        clientASName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopAsesByHttpRequestsResponse",
}) as unknown as Schema.Schema<GetHttpTopAsesByHttpRequestsResponse>;

export const getHttpTopAsesByHttpRequests: (
  input: GetHttpTopAsesByHttpRequestsRequest,
) => Effect.Effect<
  GetHttpTopAsesByHttpRequestsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopAsesByHttpRequestsRequest,
  output: GetHttpTopAsesByHttpRequestsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopAsesByBotClassRequest {
  bot_class: "LIKELY_AUTOMATED" | "LIKELY_HUMAN";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopAsesByBotClassRequest = Schema.Struct({
  bot_class: Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN").pipe(T.HttpPath("bot_class")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/ases/bot_class/{bot_class}" }))
  .annotations({
    identifier: "GetHttpTopAsesByBotClassRequest",
  }) as unknown as Schema.Schema<GetHttpTopAsesByBotClassRequest>;

export interface GetHttpTopAsesByBotClassResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientASN: number; clientASName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopAsesByBotClassResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientASN: Schema.Number,
        clientASName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopAsesByBotClassResponse",
}) as unknown as Schema.Schema<GetHttpTopAsesByBotClassResponse>;

export const getHttpTopAsesByBotClass: (
  input: GetHttpTopAsesByBotClassRequest,
) => Effect.Effect<
  GetHttpTopAsesByBotClassResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopAsesByBotClassRequest,
  output: GetHttpTopAsesByBotClassResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopAsesByBrowserFamilyRequest {
  browser_family: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopAsesByBrowserFamilyRequest = Schema.Struct({
  browser_family: Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI").pipe(
    T.HttpPath("browser_family"),
  ),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/ases/browser_family/{browser_family}" }))
  .annotations({
    identifier: "GetHttpTopAsesByBrowserFamilyRequest",
  }) as unknown as Schema.Schema<GetHttpTopAsesByBrowserFamilyRequest>;

export interface GetHttpTopAsesByBrowserFamilyResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientASN: number; clientASName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopAsesByBrowserFamilyResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientASN: Schema.Number,
        clientASName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopAsesByBrowserFamilyResponse",
}) as unknown as Schema.Schema<GetHttpTopAsesByBrowserFamilyResponse>;

export const getHttpTopAsesByBrowserFamily: (
  input: GetHttpTopAsesByBrowserFamilyRequest,
) => Effect.Effect<
  GetHttpTopAsesByBrowserFamilyResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopAsesByBrowserFamilyRequest,
  output: GetHttpTopAsesByBrowserFamilyResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopAsesByDeviceTypeRequest {
  device_type: "DESKTOP" | "MOBILE" | "OTHER";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopAsesByDeviceTypeRequest = Schema.Struct({
  device_type: Schema.Literal("DESKTOP", "MOBILE", "OTHER").pipe(T.HttpPath("device_type")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/ases/device_type/{device_type}" }))
  .annotations({
    identifier: "GetHttpTopAsesByDeviceTypeRequest",
  }) as unknown as Schema.Schema<GetHttpTopAsesByDeviceTypeRequest>;

export interface GetHttpTopAsesByDeviceTypeResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientASN: number; clientASName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopAsesByDeviceTypeResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientASN: Schema.Number,
        clientASName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopAsesByDeviceTypeResponse",
}) as unknown as Schema.Schema<GetHttpTopAsesByDeviceTypeResponse>;

export const getHttpTopAsesByDeviceType: (
  input: GetHttpTopAsesByDeviceTypeRequest,
) => Effect.Effect<
  GetHttpTopAsesByDeviceTypeResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopAsesByDeviceTypeRequest,
  output: GetHttpTopAsesByDeviceTypeResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopAsesByHttpProtocolRequest {
  http_protocol: "HTTP" | "HTTPS";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopAsesByHttpProtocolRequest = Schema.Struct({
  http_protocol: Schema.Literal("HTTP", "HTTPS").pipe(T.HttpPath("http_protocol")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/ases/http_protocol/{http_protocol}" }))
  .annotations({
    identifier: "GetHttpTopAsesByHttpProtocolRequest",
  }) as unknown as Schema.Schema<GetHttpTopAsesByHttpProtocolRequest>;

export interface GetHttpTopAsesByHttpProtocolResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientASN: number; clientASName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopAsesByHttpProtocolResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientASN: Schema.Number,
        clientASName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopAsesByHttpProtocolResponse",
}) as unknown as Schema.Schema<GetHttpTopAsesByHttpProtocolResponse>;

export const getHttpTopAsesByHttpProtocol: (
  input: GetHttpTopAsesByHttpProtocolRequest,
) => Effect.Effect<
  GetHttpTopAsesByHttpProtocolResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopAsesByHttpProtocolRequest,
  output: GetHttpTopAsesByHttpProtocolResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopAsesByHttpVersionRequest {
  http_version: "HTTPv1" | "HTTPv2" | "HTTPv3";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopAsesByHttpVersionRequest = Schema.Struct({
  http_version: Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3").pipe(T.HttpPath("http_version")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/ases/http_version/{http_version}" }))
  .annotations({
    identifier: "GetHttpTopAsesByHttpVersionRequest",
  }) as unknown as Schema.Schema<GetHttpTopAsesByHttpVersionRequest>;

export interface GetHttpTopAsesByHttpVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientASN: number; clientASName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopAsesByHttpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientASN: Schema.Number,
        clientASName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopAsesByHttpVersionResponse",
}) as unknown as Schema.Schema<GetHttpTopAsesByHttpVersionResponse>;

export const getHttpTopAsesByHttpVersion: (
  input: GetHttpTopAsesByHttpVersionRequest,
) => Effect.Effect<
  GetHttpTopAsesByHttpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopAsesByHttpVersionRequest,
  output: GetHttpTopAsesByHttpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopAsesByIpVersionRequest {
  ip_version: "IPv4" | "IPv6";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopAsesByIpVersionRequest = Schema.Struct({
  ip_version: Schema.Literal("IPv4", "IPv6").pipe(T.HttpPath("ip_version")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/ases/ip_version/{ip_version}" }))
  .annotations({
    identifier: "GetHttpTopAsesByIpVersionRequest",
  }) as unknown as Schema.Schema<GetHttpTopAsesByIpVersionRequest>;

export interface GetHttpTopAsesByIpVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientASN: number; clientASName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopAsesByIpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientASN: Schema.Number,
        clientASName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopAsesByIpVersionResponse",
}) as unknown as Schema.Schema<GetHttpTopAsesByIpVersionResponse>;

export const getHttpTopAsesByIpVersion: (
  input: GetHttpTopAsesByIpVersionRequest,
) => Effect.Effect<
  GetHttpTopAsesByIpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopAsesByIpVersionRequest,
  output: GetHttpTopAsesByIpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopAsesByOperatingSystemRequest {
  os: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopAsesByOperatingSystemRequest = Schema.Struct({
  os: Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV").pipe(
    T.HttpPath("os"),
  ),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/ases/os/{os}" }))
  .annotations({
    identifier: "GetHttpTopAsesByOperatingSystemRequest",
  }) as unknown as Schema.Schema<GetHttpTopAsesByOperatingSystemRequest>;

export interface GetHttpTopAsesByOperatingSystemResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientASN: number; clientASName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopAsesByOperatingSystemResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientASN: Schema.Number,
        clientASName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopAsesByOperatingSystemResponse",
}) as unknown as Schema.Schema<GetHttpTopAsesByOperatingSystemResponse>;

export const getHttpTopAsesByOperatingSystem: (
  input: GetHttpTopAsesByOperatingSystemRequest,
) => Effect.Effect<
  GetHttpTopAsesByOperatingSystemResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopAsesByOperatingSystemRequest,
  output: GetHttpTopAsesByOperatingSystemResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopAsesByTlsVersionRequest {
  tls_version: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopAsesByTlsVersionRequest = Schema.Struct({
  tls_version: Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC").pipe(
    T.HttpPath("tls_version"),
  ),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/ases/tls_version/{tls_version}" }))
  .annotations({
    identifier: "GetHttpTopAsesByTlsVersionRequest",
  }) as unknown as Schema.Schema<GetHttpTopAsesByTlsVersionRequest>;

export interface GetHttpTopAsesByTlsVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientASN: number; clientASName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopAsesByTlsVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientASN: Schema.Number,
        clientASName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopAsesByTlsVersionResponse",
}) as unknown as Schema.Schema<GetHttpTopAsesByTlsVersionResponse>;

export const getHttpTopAsesByTlsVersion: (
  input: GetHttpTopAsesByTlsVersionRequest,
) => Effect.Effect<
  GetHttpTopAsesByTlsVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopAsesByTlsVersionRequest,
  output: GetHttpTopAsesByTlsVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopBrowsersRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopBrowsersRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/browser" }))
  .annotations({
    identifier: "GetHttpTopBrowsersRequest",
  }) as unknown as Schema.Schema<GetHttpTopBrowsersRequest>;

export interface GetHttpTopBrowsersResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { name: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopBrowsersResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        name: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopBrowsersResponse",
}) as unknown as Schema.Schema<GetHttpTopBrowsersResponse>;

export const getHttpTopBrowsers: (
  input: GetHttpTopBrowsersRequest,
) => Effect.Effect<
  GetHttpTopBrowsersResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopBrowsersRequest,
  output: GetHttpTopBrowsersResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopBrowserFamiliesRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopBrowserFamiliesRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/browser_family" }))
  .annotations({
    identifier: "GetHttpTopBrowserFamiliesRequest",
  }) as unknown as Schema.Schema<GetHttpTopBrowserFamiliesRequest>;

export interface GetHttpTopBrowserFamiliesResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { name: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopBrowserFamiliesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        name: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopBrowserFamiliesResponse",
}) as unknown as Schema.Schema<GetHttpTopBrowserFamiliesResponse>;

export const getHttpTopBrowserFamilies: (
  input: GetHttpTopBrowserFamiliesRequest,
) => Effect.Effect<
  GetHttpTopBrowserFamiliesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopBrowserFamiliesRequest,
  output: GetHttpTopBrowserFamiliesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopLocationsByHttpRequestsRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopLocationsByHttpRequestsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/locations" }))
  .annotations({
    identifier: "GetHttpTopLocationsByHttpRequestsRequest",
  }) as unknown as Schema.Schema<GetHttpTopLocationsByHttpRequestsRequest>;

export interface GetHttpTopLocationsByHttpRequestsResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopLocationsByHttpRequestsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopLocationsByHttpRequestsResponse",
}) as unknown as Schema.Schema<GetHttpTopLocationsByHttpRequestsResponse>;

export const getHttpTopLocationsByHttpRequests: (
  input: GetHttpTopLocationsByHttpRequestsRequest,
) => Effect.Effect<
  GetHttpTopLocationsByHttpRequestsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopLocationsByHttpRequestsRequest,
  output: GetHttpTopLocationsByHttpRequestsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopLocationsByBotClassRequest {
  bot_class: "LIKELY_AUTOMATED" | "LIKELY_HUMAN";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopLocationsByBotClassRequest = Schema.Struct({
  bot_class: Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN").pipe(T.HttpPath("bot_class")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/locations/bot_class/{bot_class}" }))
  .annotations({
    identifier: "GetHttpTopLocationsByBotClassRequest",
  }) as unknown as Schema.Schema<GetHttpTopLocationsByBotClassRequest>;

export interface GetHttpTopLocationsByBotClassResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopLocationsByBotClassResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopLocationsByBotClassResponse",
}) as unknown as Schema.Schema<GetHttpTopLocationsByBotClassResponse>;

export const getHttpTopLocationsByBotClass: (
  input: GetHttpTopLocationsByBotClassRequest,
) => Effect.Effect<
  GetHttpTopLocationsByBotClassResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopLocationsByBotClassRequest,
  output: GetHttpTopLocationsByBotClassResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopLocationsByBrowserFamilyRequest {
  browser_family: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopLocationsByBrowserFamilyRequest = Schema.Struct({
  browser_family: Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI").pipe(
    T.HttpPath("browser_family"),
  ),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(
    T.Http({ method: "GET", path: "/radar/http/top/locations/browser_family/{browser_family}" }),
  )
  .annotations({
    identifier: "GetHttpTopLocationsByBrowserFamilyRequest",
  }) as unknown as Schema.Schema<GetHttpTopLocationsByBrowserFamilyRequest>;

export interface GetHttpTopLocationsByBrowserFamilyResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopLocationsByBrowserFamilyResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopLocationsByBrowserFamilyResponse",
}) as unknown as Schema.Schema<GetHttpTopLocationsByBrowserFamilyResponse>;

export const getHttpTopLocationsByBrowserFamily: (
  input: GetHttpTopLocationsByBrowserFamilyRequest,
) => Effect.Effect<
  GetHttpTopLocationsByBrowserFamilyResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopLocationsByBrowserFamilyRequest,
  output: GetHttpTopLocationsByBrowserFamilyResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopLocationsByDeviceTypeRequest {
  device_type: "DESKTOP" | "MOBILE" | "OTHER";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopLocationsByDeviceTypeRequest = Schema.Struct({
  device_type: Schema.Literal("DESKTOP", "MOBILE", "OTHER").pipe(T.HttpPath("device_type")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/locations/device_type/{device_type}" }))
  .annotations({
    identifier: "GetHttpTopLocationsByDeviceTypeRequest",
  }) as unknown as Schema.Schema<GetHttpTopLocationsByDeviceTypeRequest>;

export interface GetHttpTopLocationsByDeviceTypeResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopLocationsByDeviceTypeResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopLocationsByDeviceTypeResponse",
}) as unknown as Schema.Schema<GetHttpTopLocationsByDeviceTypeResponse>;

export const getHttpTopLocationsByDeviceType: (
  input: GetHttpTopLocationsByDeviceTypeRequest,
) => Effect.Effect<
  GetHttpTopLocationsByDeviceTypeResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopLocationsByDeviceTypeRequest,
  output: GetHttpTopLocationsByDeviceTypeResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopLocationsByHttpProtocolRequest {
  http_protocol: "HTTP" | "HTTPS";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopLocationsByHttpProtocolRequest = Schema.Struct({
  http_protocol: Schema.Literal("HTTP", "HTTPS").pipe(T.HttpPath("http_protocol")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/locations/http_protocol/{http_protocol}" }))
  .annotations({
    identifier: "GetHttpTopLocationsByHttpProtocolRequest",
  }) as unknown as Schema.Schema<GetHttpTopLocationsByHttpProtocolRequest>;

export interface GetHttpTopLocationsByHttpProtocolResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopLocationsByHttpProtocolResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopLocationsByHttpProtocolResponse",
}) as unknown as Schema.Schema<GetHttpTopLocationsByHttpProtocolResponse>;

export const getHttpTopLocationsByHttpProtocol: (
  input: GetHttpTopLocationsByHttpProtocolRequest,
) => Effect.Effect<
  GetHttpTopLocationsByHttpProtocolResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopLocationsByHttpProtocolRequest,
  output: GetHttpTopLocationsByHttpProtocolResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopLocationsByHttpVersionRequest {
  http_version: "HTTPv1" | "HTTPv2" | "HTTPv3";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopLocationsByHttpVersionRequest = Schema.Struct({
  http_version: Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3").pipe(T.HttpPath("http_version")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/locations/http_version/{http_version}" }))
  .annotations({
    identifier: "GetHttpTopLocationsByHttpVersionRequest",
  }) as unknown as Schema.Schema<GetHttpTopLocationsByHttpVersionRequest>;

export interface GetHttpTopLocationsByHttpVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopLocationsByHttpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopLocationsByHttpVersionResponse",
}) as unknown as Schema.Schema<GetHttpTopLocationsByHttpVersionResponse>;

export const getHttpTopLocationsByHttpVersion: (
  input: GetHttpTopLocationsByHttpVersionRequest,
) => Effect.Effect<
  GetHttpTopLocationsByHttpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopLocationsByHttpVersionRequest,
  output: GetHttpTopLocationsByHttpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopLocationsByIpVersionRequest {
  ip_version: "IPv4" | "IPv6";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopLocationsByIpVersionRequest = Schema.Struct({
  ip_version: Schema.Literal("IPv4", "IPv6").pipe(T.HttpPath("ip_version")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/locations/ip_version/{ip_version}" }))
  .annotations({
    identifier: "GetHttpTopLocationsByIpVersionRequest",
  }) as unknown as Schema.Schema<GetHttpTopLocationsByIpVersionRequest>;

export interface GetHttpTopLocationsByIpVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopLocationsByIpVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopLocationsByIpVersionResponse",
}) as unknown as Schema.Schema<GetHttpTopLocationsByIpVersionResponse>;

export const getHttpTopLocationsByIpVersion: (
  input: GetHttpTopLocationsByIpVersionRequest,
) => Effect.Effect<
  GetHttpTopLocationsByIpVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopLocationsByIpVersionRequest,
  output: GetHttpTopLocationsByIpVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopLocationsByOperatingSystemRequest {
  os: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  tlsVersion?: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopLocationsByOperatingSystemRequest = Schema.Struct({
  os: Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV").pipe(
    T.HttpPath("os"),
  ),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  tlsVersion: Schema.optional(
    Schema.Array(Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC")),
  ).pipe(T.HttpQuery("tlsVersion")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/locations/os/{os}" }))
  .annotations({
    identifier: "GetHttpTopLocationsByOperatingSystemRequest",
  }) as unknown as Schema.Schema<GetHttpTopLocationsByOperatingSystemRequest>;

export interface GetHttpTopLocationsByOperatingSystemResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopLocationsByOperatingSystemResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopLocationsByOperatingSystemResponse",
}) as unknown as Schema.Schema<GetHttpTopLocationsByOperatingSystemResponse>;

export const getHttpTopLocationsByOperatingSystem: (
  input: GetHttpTopLocationsByOperatingSystemRequest,
) => Effect.Effect<
  GetHttpTopLocationsByOperatingSystemResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopLocationsByOperatingSystemRequest,
  output: GetHttpTopLocationsByOperatingSystemResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetHttpTopLocationsByTlsVersionRequest {
  tls_version: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC";
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  deviceType?: "DESKTOP" | "MOBILE" | "OTHER"[];
  httpProtocol?: "HTTP" | "HTTPS"[];
  httpVersion?: "HTTPv1" | "HTTPv2" | "HTTPv3"[];
  ipVersion?: "IPv4" | "IPv6"[];
  os?: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV"[];
  browserFamily?: "CHROME" | "EDGE" | "FIREFOX" | "SAFARI"[];
  format?: "JSON" | "CSV";
}

export const GetHttpTopLocationsByTlsVersionRequest = Schema.Struct({
  tls_version: Schema.Literal("TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC").pipe(
    T.HttpPath("tls_version"),
  ),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  deviceType: Schema.optional(Schema.Array(Schema.Literal("DESKTOP", "MOBILE", "OTHER"))).pipe(
    T.HttpQuery("deviceType"),
  ),
  httpProtocol: Schema.optional(Schema.Array(Schema.Literal("HTTP", "HTTPS"))).pipe(
    T.HttpQuery("httpProtocol"),
  ),
  httpVersion: Schema.optional(Schema.Array(Schema.Literal("HTTPv1", "HTTPv2", "HTTPv3"))).pipe(
    T.HttpQuery("httpVersion"),
  ),
  ipVersion: Schema.optional(Schema.Array(Schema.Literal("IPv4", "IPv6"))).pipe(
    T.HttpQuery("ipVersion"),
  ),
  os: Schema.optional(
    Schema.Array(
      Schema.Literal("WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"),
    ),
  ).pipe(T.HttpQuery("os")),
  browserFamily: Schema.optional(
    Schema.Array(Schema.Literal("CHROME", "EDGE", "FIREFOX", "SAFARI")),
  ).pipe(T.HttpQuery("browserFamily")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/http/top/locations/tls_version/{tls_version}" }))
  .annotations({
    identifier: "GetHttpTopLocationsByTlsVersionRequest",
  }) as unknown as Schema.Schema<GetHttpTopLocationsByTlsVersionRequest>;

export interface GetHttpTopLocationsByTlsVersionResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetHttpTopLocationsByTlsVersionResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetHttpTopLocationsByTlsVersionResponse",
}) as unknown as Schema.Schema<GetHttpTopLocationsByTlsVersionResponse>;

export const getHttpTopLocationsByTlsVersion: (
  input: GetHttpTopLocationsByTlsVersionRequest,
) => Effect.Effect<
  GetHttpTopLocationsByTlsVersionResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetHttpTopLocationsByTlsVersionRequest,
  output: GetHttpTopLocationsByTlsVersionResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetLeakedCredentialChecksSummaryByBotClassRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  compromised?: "CLEAN" | "COMPROMISED"[];
  format?: "JSON" | "CSV";
}

export const GetLeakedCredentialChecksSummaryByBotClassRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  compromised: Schema.optional(Schema.Array(Schema.Literal("CLEAN", "COMPROMISED"))).pipe(
    T.HttpQuery("compromised"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/leaked_credential_checks/summary/bot_class" }))
  .annotations({
    identifier: "GetLeakedCredentialChecksSummaryByBotClassRequest",
  }) as unknown as Schema.Schema<GetLeakedCredentialChecksSummaryByBotClassRequest>;

export interface GetLeakedCredentialChecksSummaryByBotClassResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { bot: string; human: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetLeakedCredentialChecksSummaryByBotClassResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      bot: Schema.String,
      human: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetLeakedCredentialChecksSummaryByBotClassResponse",
}) as unknown as Schema.Schema<GetLeakedCredentialChecksSummaryByBotClassResponse>;

export const getLeakedCredentialChecksSummaryByBotClass: (
  input: GetLeakedCredentialChecksSummaryByBotClassRequest,
) => Effect.Effect<
  GetLeakedCredentialChecksSummaryByBotClassResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetLeakedCredentialChecksSummaryByBotClassRequest,
  output: GetLeakedCredentialChecksSummaryByBotClassResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetLeakedCredentialChecksSummaryByCompromisedRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  format?: "JSON" | "CSV";
}

export const GetLeakedCredentialChecksSummaryByCompromisedRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/leaked_credential_checks/summary/compromised" }))
  .annotations({
    identifier: "GetLeakedCredentialChecksSummaryByCompromisedRequest",
  }) as unknown as Schema.Schema<GetLeakedCredentialChecksSummaryByCompromisedRequest>;

export interface GetLeakedCredentialChecksSummaryByCompromisedResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { CLEAN: string; COMPROMISED: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetLeakedCredentialChecksSummaryByCompromisedResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      CLEAN: Schema.String,
      COMPROMISED: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetLeakedCredentialChecksSummaryByCompromisedResponse",
}) as unknown as Schema.Schema<GetLeakedCredentialChecksSummaryByCompromisedResponse>;

export const getLeakedCredentialChecksSummaryByCompromised: (
  input: GetLeakedCredentialChecksSummaryByCompromisedRequest,
) => Effect.Effect<
  GetLeakedCredentialChecksSummaryByCompromisedResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetLeakedCredentialChecksSummaryByCompromisedRequest,
  output: GetLeakedCredentialChecksSummaryByCompromisedResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetLeakedCredentialChecksSummaryRequest {
  dimension: "COMPROMISED" | "BOT_CLASS";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  compromised?: "CLEAN" | "COMPROMISED"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetLeakedCredentialChecksSummaryRequest = Schema.Struct({
  dimension: Schema.Literal("COMPROMISED", "BOT_CLASS").pipe(T.HttpPath("dimension")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  compromised: Schema.optional(Schema.Array(Schema.Literal("CLEAN", "COMPROMISED"))).pipe(
    T.HttpQuery("compromised"),
  ),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/leaked_credential_checks/summary/{dimension}" }))
  .annotations({
    identifier: "GetLeakedCredentialChecksSummaryRequest",
  }) as unknown as Schema.Schema<GetLeakedCredentialChecksSummaryRequest>;

export interface GetLeakedCredentialChecksSummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetLeakedCredentialChecksSummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetLeakedCredentialChecksSummaryResponse",
}) as unknown as Schema.Schema<GetLeakedCredentialChecksSummaryResponse>;

export const getLeakedCredentialChecksSummary: (
  input: GetLeakedCredentialChecksSummaryRequest,
) => Effect.Effect<
  GetLeakedCredentialChecksSummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetLeakedCredentialChecksSummaryRequest,
  output: GetLeakedCredentialChecksSummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetLeakedCredentialChecksTimeseriesGroupByBotClassRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  compromised?: "CLEAN" | "COMPROMISED"[];
  format?: "JSON" | "CSV";
}

export const GetLeakedCredentialChecksTimeseriesGroupByBotClassRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  compromised: Schema.optional(Schema.Array(Schema.Literal("CLEAN", "COMPROMISED"))).pipe(
    T.HttpQuery("compromised"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(
    T.Http({ method: "GET", path: "/radar/leaked_credential_checks/timeseries_groups/bot_class" }),
  )
  .annotations({
    identifier: "GetLeakedCredentialChecksTimeseriesGroupByBotClassRequest",
  }) as unknown as Schema.Schema<GetLeakedCredentialChecksTimeseriesGroupByBotClassRequest>;

export interface GetLeakedCredentialChecksTimeseriesGroupByBotClassResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { bot: string[]; human: string[]; timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetLeakedCredentialChecksTimeseriesGroupByBotClassResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      bot: Schema.Array(Schema.String),
      human: Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetLeakedCredentialChecksTimeseriesGroupByBotClassResponse",
}) as unknown as Schema.Schema<GetLeakedCredentialChecksTimeseriesGroupByBotClassResponse>;

export const getLeakedCredentialChecksTimeseriesGroupByBotClass: (
  input: GetLeakedCredentialChecksTimeseriesGroupByBotClassRequest,
) => Effect.Effect<
  GetLeakedCredentialChecksTimeseriesGroupByBotClassResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetLeakedCredentialChecksTimeseriesGroupByBotClassRequest,
  output: GetLeakedCredentialChecksTimeseriesGroupByBotClassResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetLeakedCredentialChecksTimeseriesGroupByCompromisedRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  format?: "JSON" | "CSV";
}

export const GetLeakedCredentialChecksTimeseriesGroupByCompromisedRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(
    T.Http({
      method: "GET",
      path: "/radar/leaked_credential_checks/timeseries_groups/compromised",
    }),
  )
  .annotations({
    identifier: "GetLeakedCredentialChecksTimeseriesGroupByCompromisedRequest",
  }) as unknown as Schema.Schema<GetLeakedCredentialChecksTimeseriesGroupByCompromisedRequest>;

export interface GetLeakedCredentialChecksTimeseriesGroupByCompromisedResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { CLEAN: string[]; COMPROMISED: string[]; timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetLeakedCredentialChecksTimeseriesGroupByCompromisedResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      CLEAN: Schema.Array(Schema.String),
      COMPROMISED: Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetLeakedCredentialChecksTimeseriesGroupByCompromisedResponse",
}) as unknown as Schema.Schema<GetLeakedCredentialChecksTimeseriesGroupByCompromisedResponse>;

export const getLeakedCredentialChecksTimeseriesGroupByCompromised: (
  input: GetLeakedCredentialChecksTimeseriesGroupByCompromisedRequest,
) => Effect.Effect<
  GetLeakedCredentialChecksTimeseriesGroupByCompromisedResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetLeakedCredentialChecksTimeseriesGroupByCompromisedRequest,
  output: GetLeakedCredentialChecksTimeseriesGroupByCompromisedResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetLeakedCredentialChecksTimeseriesGroupRequest {
  dimension: "COMPROMISED" | "BOT_CLASS";
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  botClass?: "LIKELY_AUTOMATED" | "LIKELY_HUMAN"[];
  compromised?: "CLEAN" | "COMPROMISED"[];
  checkResult?:
    | "CLEAN"
    | "USERNAME_LEAKED"
    | "USERNAME_PASSWORD_SIMILAR"
    | "USERNAME_AND_PASSWORD_LEAKED"
    | "PASSWORD_LEAKED"[];
  limitPerGroup?: number;
  normalization?: "PERCENTAGE_CHANGE" | "MIN0_MAX";
  format?: "JSON" | "CSV";
}

export const GetLeakedCredentialChecksTimeseriesGroupRequest = Schema.Struct({
  dimension: Schema.Literal("COMPROMISED", "BOT_CLASS").pipe(T.HttpPath("dimension")),
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  botClass: Schema.optional(Schema.Array(Schema.Literal("LIKELY_AUTOMATED", "LIKELY_HUMAN"))).pipe(
    T.HttpQuery("botClass"),
  ),
  compromised: Schema.optional(Schema.Array(Schema.Literal("CLEAN", "COMPROMISED"))).pipe(
    T.HttpQuery("compromised"),
  ),
  checkResult: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "CLEAN",
        "USERNAME_LEAKED",
        "USERNAME_PASSWORD_SIMILAR",
        "USERNAME_AND_PASSWORD_LEAKED",
        "PASSWORD_LEAKED",
      ),
    ),
  ).pipe(T.HttpQuery("checkResult")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE_CHANGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(
    T.Http({
      method: "GET",
      path: "/radar/leaked_credential_checks/timeseries_groups/{dimension}",
    }),
  )
  .annotations({
    identifier: "GetLeakedCredentialChecksTimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetLeakedCredentialChecksTimeseriesGroupRequest>;

export interface GetLeakedCredentialChecksTimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetLeakedCredentialChecksTimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetLeakedCredentialChecksTimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetLeakedCredentialChecksTimeseriesGroupResponse>;

export const getLeakedCredentialChecksTimeseriesGroup: (
  input: GetLeakedCredentialChecksTimeseriesGroupRequest,
) => Effect.Effect<
  GetLeakedCredentialChecksTimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetLeakedCredentialChecksTimeseriesGroupRequest,
  output: GetLeakedCredentialChecksTimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetNetflowsSummaryDeprecatedRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  format?: "JSON" | "CSV";
}

export const GetNetflowsSummaryDeprecatedRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/netflows/summary" }))
  .annotations({
    identifier: "GetNetflowsSummaryDeprecatedRequest",
  }) as unknown as Schema.Schema<GetNetflowsSummaryDeprecatedRequest>;

export interface GetNetflowsSummaryDeprecatedResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { HTTP: string; OTHER: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetNetflowsSummaryDeprecatedResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      HTTP: Schema.String,
      OTHER: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetNetflowsSummaryDeprecatedResponse",
}) as unknown as Schema.Schema<GetNetflowsSummaryDeprecatedResponse>;

export const getNetflowsSummaryDeprecated: (
  input: GetNetflowsSummaryDeprecatedRequest,
) => Effect.Effect<
  GetNetflowsSummaryDeprecatedResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetNetflowsSummaryDeprecatedRequest,
  output: GetNetflowsSummaryDeprecatedResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetNetflowsSummaryRequest {
  dimension: "ADM1" | "PRODUCT";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  product?: "HTTP" | "ALL"[];
  limitPerGroup?: number;
  format?: "JSON" | "CSV";
}

export const GetNetflowsSummaryRequest = Schema.Struct({
  dimension: Schema.Literal("ADM1", "PRODUCT").pipe(T.HttpPath("dimension")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  product: Schema.optional(Schema.Array(Schema.Literal("HTTP", "ALL"))).pipe(
    T.HttpQuery("product"),
  ),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/netflows/summary/{dimension}" }))
  .annotations({
    identifier: "GetNetflowsSummaryRequest",
  }) as unknown as Schema.Schema<GetNetflowsSummaryRequest>;

export interface GetNetflowsSummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetNetflowsSummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetNetflowsSummaryResponse",
}) as unknown as Schema.Schema<GetNetflowsSummaryResponse>;

export const getNetflowsSummary: (
  input: GetNetflowsSummaryRequest,
) => Effect.Effect<
  GetNetflowsSummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetNetflowsSummaryRequest,
  output: GetNetflowsSummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetNetflowsTimeseriesRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  product?: "HTTP" | "ALL"[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  normalization?: "PERCENTAGE_CHANGE" | "MIN0_MAX";
  format?: "JSON" | "CSV";
}

export const GetNetflowsTimeseriesRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  product: Schema.optional(Schema.Array(Schema.Literal("HTTP", "ALL"))).pipe(
    T.HttpQuery("product"),
  ),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE_CHANGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/netflows/timeseries" }))
  .annotations({
    identifier: "GetNetflowsTimeseriesRequest",
  }) as unknown as Schema.Schema<GetNetflowsTimeseriesRequest>;

export interface GetNetflowsTimeseriesResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[]; values: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetNetflowsTimeseriesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
      values: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetNetflowsTimeseriesResponse",
}) as unknown as Schema.Schema<GetNetflowsTimeseriesResponse>;

export const getNetflowsTimeseries: (
  input: GetNetflowsTimeseriesRequest,
) => Effect.Effect<
  GetNetflowsTimeseriesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetNetflowsTimeseriesRequest,
  output: GetNetflowsTimeseriesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetNetflowsTimeseriesGroupRequest {
  dimension: "ADM1" | "PRODUCT";
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  limitPerGroup?: number;
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  product?: "HTTP" | "ALL"[];
  format?: "JSON" | "CSV";
}

export const GetNetflowsTimeseriesGroupRequest = Schema.Struct({
  dimension: Schema.Literal("ADM1", "PRODUCT").pipe(T.HttpPath("dimension")),
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  product: Schema.optional(Schema.Array(Schema.Literal("HTTP", "ALL"))).pipe(
    T.HttpQuery("product"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/netflows/timeseries_groups/{dimension}" }))
  .annotations({
    identifier: "GetNetflowsTimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetNetflowsTimeseriesGroupRequest>;

export interface GetNetflowsTimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetNetflowsTimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetNetflowsTimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetNetflowsTimeseriesGroupResponse>;

export const getNetflowsTimeseriesGroup: (
  input: GetNetflowsTimeseriesGroupRequest,
) => Effect.Effect<
  GetNetflowsTimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetNetflowsTimeseriesGroupRequest,
  output: GetNetflowsTimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetNetflowsTopAsesRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  format?: "JSON" | "CSV";
}

export const GetNetflowsTopAsesRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/netflows/top/ases" }))
  .annotations({
    identifier: "GetNetflowsTopAsesRequest",
  }) as unknown as Schema.Schema<GetNetflowsTopAsesRequest>;

export interface GetNetflowsTopAsesResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientASN: number; clientASName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetNetflowsTopAsesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientASN: Schema.Number,
        clientASName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetNetflowsTopAsesResponse",
}) as unknown as Schema.Schema<GetNetflowsTopAsesResponse>;

export const getNetflowsTopAses: (
  input: GetNetflowsTopAsesRequest,
) => Effect.Effect<
  GetNetflowsTopAsesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetNetflowsTopAsesRequest,
  output: GetNetflowsTopAsesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetNetflowsTopLocationsRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  geoId?: string[];
  format?: "JSON" | "CSV";
}

export const GetNetflowsTopLocationsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  geoId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("geoId")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/netflows/top/locations" }))
  .annotations({
    identifier: "GetNetflowsTopLocationsRequest",
  }) as unknown as Schema.Schema<GetNetflowsTopLocationsRequest>;

export interface GetNetflowsTopLocationsResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetNetflowsTopLocationsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetNetflowsTopLocationsResponse",
}) as unknown as Schema.Schema<GetNetflowsTopLocationsResponse>;

export const getNetflowsTopLocations: (
  input: GetNetflowsTopLocationsRequest,
) => Effect.Effect<
  GetNetflowsTopLocationsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetNetflowsTopLocationsRequest,
  output: GetNetflowsTopLocationsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetOriginsRequest {
  limit?: number;
  offset?: number;
  format?: "JSON" | "CSV";
}

export const GetOriginsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/origins" }))
  .annotations({ identifier: "GetOriginsRequest" }) as unknown as Schema.Schema<GetOriginsRequest>;

export interface GetOriginsResponse {
  result: { origins: { regions: { region: string }[]; slug: string }[] };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetOriginsResponse = Schema.Struct({
  result: Schema.Struct({
    origins: Schema.Array(
      Schema.Struct({
        regions: Schema.Array(
          Schema.Struct({
            region: Schema.String,
          }),
        ),
        slug: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetOriginsResponse",
}) as unknown as Schema.Schema<GetOriginsResponse>;

export const getOrigins: (
  input: GetOriginsRequest,
) => Effect.Effect<
  GetOriginsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetOriginsRequest,
  output: GetOriginsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetOriginsSummaryRequest {
  dimension: "REGION" | "SUCCESS_RATE" | "PERCENTILE";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  limitPerGroup?: number;
  origin: "AMAZON" | "GOOGLE" | "MICROSOFT" | "ORACLE"[];
  metric:
    | "CONNECTION_FAILURES"
    | "REQUESTS"
    | "RESPONSE_HEADER_RECEIVE_DURATION"
    | "TCP_HANDSHAKE_DURATION"
    | "TCP_RTT"
    | "TLS_HANDSHAKE_DURATION";
  region?: string[];
  format?: "JSON" | "CSV";
}

export const GetOriginsSummaryRequest = Schema.Struct({
  dimension: Schema.Literal("REGION", "SUCCESS_RATE", "PERCENTILE").pipe(T.HttpPath("dimension")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  origin: Schema.Array(Schema.Literal("AMAZON", "GOOGLE", "MICROSOFT", "ORACLE")).pipe(
    T.HttpQuery("origin"),
  ),
  metric: Schema.Literal(
    "CONNECTION_FAILURES",
    "REQUESTS",
    "RESPONSE_HEADER_RECEIVE_DURATION",
    "TCP_HANDSHAKE_DURATION",
    "TCP_RTT",
    "TLS_HANDSHAKE_DURATION",
  ).pipe(T.HttpQuery("metric")),
  region: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("region")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/origins/summary/{dimension}" }))
  .annotations({
    identifier: "GetOriginsSummaryRequest",
  }) as unknown as Schema.Schema<GetOriginsSummaryRequest>;

export interface GetOriginsSummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: Record<string, unknown>;
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetOriginsSummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Record({ key: Schema.String, value: Schema.String }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetOriginsSummaryResponse",
}) as unknown as Schema.Schema<GetOriginsSummaryResponse>;

export const getOriginsSummary: (
  input: GetOriginsSummaryRequest,
) => Effect.Effect<
  GetOriginsSummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetOriginsSummaryRequest,
  output: GetOriginsSummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetOriginsTimeseriesRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  origin: "AMAZON" | "GOOGLE" | "MICROSOFT" | "ORACLE"[];
  metric:
    | "CONNECTION_FAILURES"
    | "REQUESTS"
    | "RESPONSE_HEADER_RECEIVE_DURATION"
    | "TCP_HANDSHAKE_DURATION"
    | "TCP_RTT"
    | "TLS_HANDSHAKE_DURATION";
  region?: string[];
  format?: "JSON" | "CSV";
}

export const GetOriginsTimeseriesRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  origin: Schema.Array(Schema.Literal("AMAZON", "GOOGLE", "MICROSOFT", "ORACLE")).pipe(
    T.HttpQuery("origin"),
  ),
  metric: Schema.Literal(
    "CONNECTION_FAILURES",
    "REQUESTS",
    "RESPONSE_HEADER_RECEIVE_DURATION",
    "TCP_HANDSHAKE_DURATION",
    "TCP_RTT",
    "TLS_HANDSHAKE_DURATION",
  ).pipe(T.HttpQuery("metric")),
  region: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("region")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/origins/timeseries" }))
  .annotations({
    identifier: "GetOriginsTimeseriesRequest",
  }) as unknown as Schema.Schema<GetOriginsTimeseriesRequest>;

export interface GetOriginsTimeseriesResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetOriginsTimeseriesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetOriginsTimeseriesResponse",
}) as unknown as Schema.Schema<GetOriginsTimeseriesResponse>;

export const getOriginsTimeseries: (
  input: GetOriginsTimeseriesRequest,
) => Effect.Effect<
  GetOriginsTimeseriesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetOriginsTimeseriesRequest,
  output: GetOriginsTimeseriesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetOriginsTimeseriesGroupRequest {
  dimension: "REGION" | "SUCCESS_RATE" | "PERCENTILE";
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  limitPerGroup?: number;
  origin: "AMAZON" | "GOOGLE" | "MICROSOFT" | "ORACLE"[];
  metric:
    | "CONNECTION_FAILURES"
    | "REQUESTS"
    | "RESPONSE_HEADER_RECEIVE_DURATION"
    | "TCP_HANDSHAKE_DURATION"
    | "TCP_RTT"
    | "TLS_HANDSHAKE_DURATION";
  region?: string[];
  normalization?: "PERCENTAGE" | "MIN0_MAX";
  format?: "JSON" | "CSV";
}

export const GetOriginsTimeseriesGroupRequest = Schema.Struct({
  dimension: Schema.Literal("REGION", "SUCCESS_RATE", "PERCENTILE").pipe(T.HttpPath("dimension")),
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  origin: Schema.Array(Schema.Literal("AMAZON", "GOOGLE", "MICROSOFT", "ORACLE")).pipe(
    T.HttpQuery("origin"),
  ),
  metric: Schema.Literal(
    "CONNECTION_FAILURES",
    "REQUESTS",
    "RESPONSE_HEADER_RECEIVE_DURATION",
    "TCP_HANDSHAKE_DURATION",
    "TCP_RTT",
    "TLS_HANDSHAKE_DURATION",
  ).pipe(T.HttpQuery("metric")),
  region: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("region")),
  normalization: Schema.optional(Schema.Literal("PERCENTAGE", "MIN0_MAX")).pipe(
    T.HttpQuery("normalization"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/origins/timeseries_groups/{dimension}" }))
  .annotations({
    identifier: "GetOriginsTimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetOriginsTimeseriesGroupRequest>;

export interface GetOriginsTimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetOriginsTimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetOriginsTimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetOriginsTimeseriesGroupResponse>;

export const getOriginsTimeseriesGroup: (
  input: GetOriginsTimeseriesGroupRequest,
) => Effect.Effect<
  GetOriginsTimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetOriginsTimeseriesGroupRequest,
  output: GetOriginsTimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetOriginDetailsRequest {
  slug: "AMAZON" | "GOOGLE" | "MICROSOFT" | "ORACLE";
  format?: "JSON" | "CSV";
}

export const GetOriginDetailsRequest = Schema.Struct({
  slug: Schema.Literal("AMAZON", "GOOGLE", "MICROSOFT", "ORACLE").pipe(T.HttpPath("slug")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/origins/{slug}" }))
  .annotations({
    identifier: "GetOriginDetailsRequest",
  }) as unknown as Schema.Schema<GetOriginDetailsRequest>;

export interface GetOriginDetailsResponse {
  result: { origin: { regions: { region: string }[]; slug: string } };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetOriginDetailsResponse = Schema.Struct({
  result: Schema.Struct({
    origin: Schema.Struct({
      regions: Schema.Array(
        Schema.Struct({
          region: Schema.String,
        }),
      ),
      slug: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetOriginDetailsResponse",
}) as unknown as Schema.Schema<GetOriginDetailsResponse>;

export const getOriginDetails: (
  input: GetOriginDetailsRequest,
) => Effect.Effect<
  GetOriginDetailsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetOriginDetailsRequest,
  output: GetOriginDetailsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetQualityIndexSummaryRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  metric: "BANDWIDTH" | "DNS" | "LATENCY";
  format?: "JSON" | "CSV";
}

export const GetQualityIndexSummaryRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  metric: Schema.Literal("BANDWIDTH", "DNS", "LATENCY").pipe(T.HttpQuery("metric")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/quality/iqi/summary" }))
  .annotations({
    identifier: "GetQualityIndexSummaryRequest",
  }) as unknown as Schema.Schema<GetQualityIndexSummaryRequest>;

export interface GetQualityIndexSummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: { p25: string; p50: string; p75: string };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetQualityIndexSummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      p25: Schema.String,
      p50: Schema.String,
      p75: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetQualityIndexSummaryResponse",
}) as unknown as Schema.Schema<GetQualityIndexSummaryResponse>;

export const getQualityIndexSummary: (
  input: GetQualityIndexSummaryRequest,
) => Effect.Effect<
  GetQualityIndexSummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetQualityIndexSummaryRequest,
  output: GetQualityIndexSummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetQualityIndexTimeseriesGroupRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  interpolation?: boolean;
  metric: "BANDWIDTH" | "DNS" | "LATENCY";
  format?: "JSON" | "CSV";
}

export const GetQualityIndexTimeseriesGroupRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  interpolation: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("interpolation")),
  metric: Schema.Literal("BANDWIDTH", "DNS", "LATENCY").pipe(T.HttpQuery("metric")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/quality/iqi/timeseries_groups" }))
  .annotations({
    identifier: "GetQualityIndexTimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetQualityIndexTimeseriesGroupRequest>;

export interface GetQualityIndexTimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { p25: string[]; p50: string[]; p75: string[]; timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetQualityIndexTimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      p25: Schema.Array(Schema.String),
      p50: Schema.Array(Schema.String),
      p75: Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.String),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetQualityIndexTimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetQualityIndexTimeseriesGroupResponse>;

export const getQualityIndexTimeseriesGroup: (
  input: GetQualityIndexTimeseriesGroupRequest,
) => Effect.Effect<
  GetQualityIndexTimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetQualityIndexTimeseriesGroupRequest,
  output: GetQualityIndexTimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetQualitySpeedHistogramRequest {
  name?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  bucketSize?: number;
  metricGroup?: "BANDWIDTH" | "LATENCY" | "JITTER";
  format?: "JSON" | "CSV";
}

export const GetQualitySpeedHistogramRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  bucketSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("bucketSize")),
  metricGroup: Schema.optional(Schema.Literal("BANDWIDTH", "LATENCY", "JITTER")).pipe(
    T.HttpQuery("metricGroup"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/quality/speed/histogram" }))
  .annotations({
    identifier: "GetQualitySpeedHistogramRequest",
  }) as unknown as Schema.Schema<GetQualitySpeedHistogramRequest>;

export interface GetQualitySpeedHistogramResponse {
  result: {
    histogram_0: { bandwidthDownload: string[]; bandwidthUpload: string[]; bucketMin: string[] };
    meta: {
      bucketSize: number;
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      totalTests: number[];
      units: { name: string; value: string }[];
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetQualitySpeedHistogramResponse = Schema.Struct({
  result: Schema.Struct({
    histogram_0: Schema.Struct({
      bandwidthDownload: Schema.Array(Schema.String),
      bandwidthUpload: Schema.Array(Schema.String),
      bucketMin: Schema.Array(Schema.String),
    }),
    meta: Schema.Struct({
      bucketSize: Schema.Number,
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      totalTests: Schema.Array(Schema.Number),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetQualitySpeedHistogramResponse",
}) as unknown as Schema.Schema<GetQualitySpeedHistogramResponse>;

export const getQualitySpeedHistogram: (
  input: GetQualitySpeedHistogramRequest,
) => Effect.Effect<
  GetQualitySpeedHistogramResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetQualitySpeedHistogramRequest,
  output: GetQualitySpeedHistogramResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetQualitySpeedSummaryRequest {
  name?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  format?: "JSON" | "CSV";
}

export const GetQualitySpeedSummaryRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/quality/speed/summary" }))
  .annotations({
    identifier: "GetQualitySpeedSummaryRequest",
  }) as unknown as Schema.Schema<GetQualitySpeedSummaryRequest>;

export interface GetQualitySpeedSummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: {
      bandwidthDownload: string;
      bandwidthUpload: string;
      jitterIdle: string;
      jitterLoaded: string;
      latencyIdle: string;
      latencyLoaded: string;
      packetLoss: string;
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetQualitySpeedSummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      bandwidthDownload: Schema.String,
      bandwidthUpload: Schema.String,
      jitterIdle: Schema.String,
      jitterLoaded: Schema.String,
      latencyIdle: Schema.String,
      latencyLoaded: Schema.String,
      packetLoss: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetQualitySpeedSummaryResponse",
}) as unknown as Schema.Schema<GetQualitySpeedSummaryResponse>;

export const getQualitySpeedSummary: (
  input: GetQualitySpeedSummaryRequest,
) => Effect.Effect<
  GetQualitySpeedSummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetQualitySpeedSummaryRequest,
  output: GetQualitySpeedSummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetQualitySpeedTopAsesRequest {
  limit?: number;
  name?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  orderBy?:
    | "BANDWIDTH_DOWNLOAD"
    | "BANDWIDTH_UPLOAD"
    | "LATENCY_IDLE"
    | "LATENCY_LOADED"
    | "JITTER_IDLE"
    | "JITTER_LOADED";
  reverse?: boolean;
  format?: "JSON" | "CSV";
}

export const GetQualitySpeedTopAsesRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  orderBy: Schema.optional(
    Schema.Literal(
      "BANDWIDTH_DOWNLOAD",
      "BANDWIDTH_UPLOAD",
      "LATENCY_IDLE",
      "LATENCY_LOADED",
      "JITTER_IDLE",
      "JITTER_LOADED",
    ),
  ).pipe(T.HttpQuery("orderBy")),
  reverse: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("reverse")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/quality/speed/top/ases" }))
  .annotations({
    identifier: "GetQualitySpeedTopAsesRequest",
  }) as unknown as Schema.Schema<GetQualitySpeedTopAsesRequest>;

export interface GetQualitySpeedTopAsesResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: {
      bandwidthDownload: string;
      bandwidthUpload: string;
      clientASN: number;
      clientASName: string;
      jitterIdle: string;
      jitterLoaded: string;
      latencyIdle: string;
      latencyLoaded: string;
      numTests: number;
      rankPower: number;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetQualitySpeedTopAsesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        bandwidthDownload: Schema.String,
        bandwidthUpload: Schema.String,
        clientASN: Schema.Number,
        clientASName: Schema.String,
        jitterIdle: Schema.String,
        jitterLoaded: Schema.String,
        latencyIdle: Schema.String,
        latencyLoaded: Schema.String,
        numTests: Schema.Number,
        rankPower: Schema.Number,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetQualitySpeedTopAsesResponse",
}) as unknown as Schema.Schema<GetQualitySpeedTopAsesResponse>;

export const getQualitySpeedTopAses: (
  input: GetQualitySpeedTopAsesRequest,
) => Effect.Effect<
  GetQualitySpeedTopAsesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetQualitySpeedTopAsesRequest,
  output: GetQualitySpeedTopAsesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetQualitySpeedTopLocationsRequest {
  limit?: number;
  name?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  orderBy?:
    | "BANDWIDTH_DOWNLOAD"
    | "BANDWIDTH_UPLOAD"
    | "LATENCY_IDLE"
    | "LATENCY_LOADED"
    | "JITTER_IDLE"
    | "JITTER_LOADED";
  reverse?: boolean;
  format?: "JSON" | "CSV";
}

export const GetQualitySpeedTopLocationsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  orderBy: Schema.optional(
    Schema.Literal(
      "BANDWIDTH_DOWNLOAD",
      "BANDWIDTH_UPLOAD",
      "LATENCY_IDLE",
      "LATENCY_LOADED",
      "JITTER_IDLE",
      "JITTER_LOADED",
    ),
  ).pipe(T.HttpQuery("orderBy")),
  reverse: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("reverse")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/quality/speed/top/locations" }))
  .annotations({
    identifier: "GetQualitySpeedTopLocationsRequest",
  }) as unknown as Schema.Schema<GetQualitySpeedTopLocationsRequest>;

export interface GetQualitySpeedTopLocationsResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: {
      bandwidthDownload: string;
      bandwidthUpload: string;
      clientCountryAlpha2: string;
      clientCountryName: string;
      jitterIdle: string;
      jitterLoaded: string;
      latencyIdle: string;
      latencyLoaded: string;
      numTests: number;
      rankPower: number;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetQualitySpeedTopLocationsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        bandwidthDownload: Schema.String,
        bandwidthUpload: Schema.String,
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        jitterIdle: Schema.String,
        jitterLoaded: Schema.String,
        latencyIdle: Schema.String,
        latencyLoaded: Schema.String,
        numTests: Schema.Number,
        rankPower: Schema.Number,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetQualitySpeedTopLocationsResponse",
}) as unknown as Schema.Schema<GetQualitySpeedTopLocationsResponse>;

export const getQualitySpeedTopLocations: (
  input: GetQualitySpeedTopLocationsRequest,
) => Effect.Effect<
  GetQualitySpeedTopLocationsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetQualitySpeedTopLocationsRequest,
  output: GetQualitySpeedTopLocationsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetRankingDomainDetailsRequest {
  domain: string;
  limit?: number;
  rankingType?: "POPULAR" | "TRENDING_RISE" | "TRENDING_STEADY";
  name?: string[];
  includeTopLocations?: boolean;
  date?: string[];
  format?: "JSON" | "CSV";
}

export const GetRankingDomainDetailsRequest = Schema.Struct({
  domain: Schema.String.pipe(T.HttpPath("domain")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  rankingType: Schema.optional(Schema.Literal("POPULAR", "TRENDING_RISE", "TRENDING_STEADY")).pipe(
    T.HttpQuery("rankingType"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  includeTopLocations: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("includeTopLocations")),
  date: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("date")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ranking/domain/{domain}" }))
  .annotations({
    identifier: "GetRankingDomainDetailsRequest",
  }) as unknown as Schema.Schema<GetRankingDomainDetailsRequest>;

export interface GetRankingDomainDetailsResponse {
  result: {
    details_0: {
      bucket?: string;
      categories: { id: number; name: string; superCategoryId: number }[];
      rank?: number;
      top_locations?: { locationCode: string; locationName: string; rank: number }[];
    };
    meta: { dateRange: { endTime: string; startTime: string }[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetRankingDomainDetailsResponse = Schema.Struct({
  result: Schema.Struct({
    details_0: Schema.Struct({
      bucket: Schema.optional(Schema.NullOr(Schema.String)),
      categories: Schema.Array(
        Schema.Struct({
          id: Schema.Number,
          name: Schema.String,
          superCategoryId: Schema.Number,
        }),
      ),
      rank: Schema.optional(Schema.NullOr(Schema.Number)),
      top_locations: Schema.optional(
        Schema.NullOr(
          Schema.Array(
            Schema.Struct({
              locationCode: Schema.String,
              locationName: Schema.String,
              rank: Schema.Number,
            }),
          ),
        ),
      ),
    }),
    meta: Schema.Struct({
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetRankingDomainDetailsResponse",
}) as unknown as Schema.Schema<GetRankingDomainDetailsResponse>;

export const getRankingDomainDetails: (
  input: GetRankingDomainDetailsRequest,
) => Effect.Effect<
  GetRankingDomainDetailsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRankingDomainDetailsRequest,
  output: GetRankingDomainDetailsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetRankingInternetServicesCategoriesRequest {
  limit?: number;
  name?: string[];
  date?: string[];
  format?: "JSON" | "CSV";
}

export const GetRankingInternetServicesCategoriesRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  date: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("date")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ranking/internet_services/categories" }))
  .annotations({
    identifier: "GetRankingInternetServicesCategoriesRequest",
  }) as unknown as Schema.Schema<GetRankingInternetServicesCategoriesRequest>;

export interface GetRankingInternetServicesCategoriesResponse {
  result: { categories_0: { name: string }[] };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetRankingInternetServicesCategoriesResponse = Schema.Struct({
  result: Schema.Struct({
    categories_0: Schema.Array(
      Schema.Struct({
        name: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetRankingInternetServicesCategoriesResponse",
}) as unknown as Schema.Schema<GetRankingInternetServicesCategoriesResponse>;

export const getRankingInternetServicesCategories: (
  input: GetRankingInternetServicesCategoriesRequest,
) => Effect.Effect<
  GetRankingInternetServicesCategoriesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRankingInternetServicesCategoriesRequest,
  output: GetRankingInternetServicesCategoriesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetRankingInternetServicesTimeseriesRequest {
  serviceCategory?: string[];
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  format?: "JSON" | "CSV";
}

export const GetRankingInternetServicesTimeseriesRequest = Schema.Struct({
  serviceCategory: Schema.optional(Schema.Array(Schema.String)).pipe(
    T.HttpQuery("serviceCategory"),
  ),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ranking/internet_services/timeseries_groups" }))
  .annotations({
    identifier: "GetRankingInternetServicesTimeseriesRequest",
  }) as unknown as Schema.Schema<GetRankingInternetServicesTimeseriesRequest>;

export interface GetRankingInternetServicesTimeseriesResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetRankingInternetServicesTimeseriesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetRankingInternetServicesTimeseriesResponse",
}) as unknown as Schema.Schema<GetRankingInternetServicesTimeseriesResponse>;

export const getRankingInternetServicesTimeseries: (
  input: GetRankingInternetServicesTimeseriesRequest,
) => Effect.Effect<
  GetRankingInternetServicesTimeseriesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRankingInternetServicesTimeseriesRequest,
  output: GetRankingInternetServicesTimeseriesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetRankingTopInternetServicesRequest {
  serviceCategory?: string[];
  limit?: number;
  name?: string[];
  date?: string[];
  format?: "JSON" | "CSV";
}

export const GetRankingTopInternetServicesRequest = Schema.Struct({
  serviceCategory: Schema.optional(Schema.Array(Schema.String)).pipe(
    T.HttpQuery("serviceCategory"),
  ),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  date: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("date")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ranking/internet_services/top" }))
  .annotations({
    identifier: "GetRankingTopInternetServicesRequest",
  }) as unknown as Schema.Schema<GetRankingTopInternetServicesRequest>;

export interface GetRankingTopInternetServicesResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { rank: number; service: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetRankingTopInternetServicesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        rank: Schema.Number,
        service: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetRankingTopInternetServicesResponse",
}) as unknown as Schema.Schema<GetRankingTopInternetServicesResponse>;

export const getRankingTopInternetServices: (
  input: GetRankingTopInternetServicesRequest,
) => Effect.Effect<
  GetRankingTopInternetServicesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRankingTopInternetServicesRequest,
  output: GetRankingTopInternetServicesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetRankingDomainTimeseriesRequest {
  limit?: number;
  rankingType?: "POPULAR" | "TRENDING_RISE" | "TRENDING_STEADY";
  name?: string[];
  location?: string[];
  domains?: string[];
  domainCategory?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  format?: "JSON" | "CSV";
}

export const GetRankingDomainTimeseriesRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  rankingType: Schema.optional(Schema.Literal("POPULAR", "TRENDING_RISE", "TRENDING_STEADY")).pipe(
    T.HttpQuery("rankingType"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  domains: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("domains")),
  domainCategory: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("domainCategory")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ranking/timeseries_groups" }))
  .annotations({
    identifier: "GetRankingDomainTimeseriesRequest",
  }) as unknown as Schema.Schema<GetRankingDomainTimeseriesRequest>;

export interface GetRankingDomainTimeseriesResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: { timestamps: string[] };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetRankingDomainTimeseriesResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetRankingDomainTimeseriesResponse",
}) as unknown as Schema.Schema<GetRankingDomainTimeseriesResponse>;

export const getRankingDomainTimeseries: (
  input: GetRankingDomainTimeseriesRequest,
) => Effect.Effect<
  GetRankingDomainTimeseriesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRankingDomainTimeseriesRequest,
  output: GetRankingDomainTimeseriesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetRankingTopDomainsRequest {
  limit?: number;
  name?: string[];
  location?: string[];
  domainCategory?: string[];
  date?: string[];
  rankingType?: "POPULAR" | "TRENDING_RISE" | "TRENDING_STEADY";
  format?: "JSON" | "CSV";
}

export const GetRankingTopDomainsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  domainCategory: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("domainCategory")),
  date: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("date")),
  rankingType: Schema.optional(Schema.Literal("POPULAR", "TRENDING_RISE", "TRENDING_STEADY")).pipe(
    T.HttpQuery("rankingType"),
  ),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/ranking/top" }))
  .annotations({
    identifier: "GetRankingTopDomainsRequest",
  }) as unknown as Schema.Schema<GetRankingTopDomainsRequest>;

export interface GetRankingTopDomainsResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: {
      categories: { id: number; name: string; superCategoryId: number }[];
      domain: string;
      pctRankChange?: number;
      rank: number;
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetRankingTopDomainsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        categories: Schema.Array(
          Schema.Struct({
            id: Schema.Number,
            name: Schema.String,
            superCategoryId: Schema.Number,
          }),
        ),
        domain: Schema.String,
        pctRankChange: Schema.optional(Schema.NullOr(Schema.Number)),
        rank: Schema.Number,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetRankingTopDomainsResponse",
}) as unknown as Schema.Schema<GetRankingTopDomainsResponse>;

export const getRankingTopDomains: (
  input: GetRankingTopDomainsRequest,
) => Effect.Effect<
  GetRankingTopDomainsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRankingTopDomainsRequest,
  output: GetRankingTopDomainsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetRobotsTxtTopDomainCategoriesByFilesParsedRequest {
  limit?: number;
  name?: string[];
  userAgentCategory?: "AI";
  date?: string[];
  format?: "JSON" | "CSV";
}

export const GetRobotsTxtTopDomainCategoriesByFilesParsedRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  userAgentCategory: Schema.optional(Schema.Literal("AI")).pipe(T.HttpQuery("userAgentCategory")),
  date: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("date")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/robots_txt/top/domain_categories" }))
  .annotations({
    identifier: "GetRobotsTxtTopDomainCategoriesByFilesParsedRequest",
  }) as unknown as Schema.Schema<GetRobotsTxtTopDomainCategoriesByFilesParsedRequest>;

export interface GetRobotsTxtTopDomainCategoriesByFilesParsedResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { name: string; value: number }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetRobotsTxtTopDomainCategoriesByFilesParsedResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        name: Schema.String,
        value: Schema.Number,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetRobotsTxtTopDomainCategoriesByFilesParsedResponse",
}) as unknown as Schema.Schema<GetRobotsTxtTopDomainCategoriesByFilesParsedResponse>;

export const getRobotsTxtTopDomainCategoriesByFilesParsed: (
  input: GetRobotsTxtTopDomainCategoriesByFilesParsedRequest,
) => Effect.Effect<
  GetRobotsTxtTopDomainCategoriesByFilesParsedResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRobotsTxtTopDomainCategoriesByFilesParsedRequest,
  output: GetRobotsTxtTopDomainCategoriesByFilesParsedResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetRobotsTxtTopUserAgentsByDirectiveRequest {
  limit?: number;
  name?: string[];
  userAgentCategory?: "AI";
  date?: string[];
  domainCategory?: string[];
  directive?: "ALLOW" | "DISALLOW";
  format?: "JSON" | "CSV";
}

export const GetRobotsTxtTopUserAgentsByDirectiveRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  userAgentCategory: Schema.optional(Schema.Literal("AI")).pipe(T.HttpQuery("userAgentCategory")),
  date: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("date")),
  domainCategory: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("domainCategory")),
  directive: Schema.optional(Schema.Literal("ALLOW", "DISALLOW")).pipe(T.HttpQuery("directive")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/robots_txt/top/user_agents/directive" }))
  .annotations({
    identifier: "GetRobotsTxtTopUserAgentsByDirectiveRequest",
  }) as unknown as Schema.Schema<GetRobotsTxtTopUserAgentsByDirectiveRequest>;

export interface GetRobotsTxtTopUserAgentsByDirectiveResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { fully?: number; name: string; partially?: number; value: number }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetRobotsTxtTopUserAgentsByDirectiveResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        fully: Schema.optional(Schema.NullOr(Schema.Number)),
        name: Schema.String,
        partially: Schema.optional(Schema.NullOr(Schema.Number)),
        value: Schema.Number,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetRobotsTxtTopUserAgentsByDirectiveResponse",
}) as unknown as Schema.Schema<GetRobotsTxtTopUserAgentsByDirectiveResponse>;

export const getRobotsTxtTopUserAgentsByDirective: (
  input: GetRobotsTxtTopUserAgentsByDirectiveRequest,
) => Effect.Effect<
  GetRobotsTxtTopUserAgentsByDirectiveResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRobotsTxtTopUserAgentsByDirectiveRequest,
  output: GetRobotsTxtTopUserAgentsByDirectiveResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetSearchGlobalRequest {
  limit?: number;
  limitPerGroup?: number;
  query: string;
  include?:
    | "ADM1S"
    | "ASNS"
    | "BOTS"
    | "CERTIFICATE_AUTHORITIES"
    | "CERTIFICATE_LOGS"
    | "ORIGINS"
    | "ORIGIN_REGIONS"
    | "INDUSTRIES"
    | "LOCATIONS"
    | "NOTEBOOKS"
    | "TLDS"
    | "VERTICALS"[];
  exclude?:
    | "ADM1S"
    | "ASNS"
    | "BOTS"
    | "CERTIFICATE_AUTHORITIES"
    | "CERTIFICATE_LOGS"
    | "ORIGINS"
    | "ORIGIN_REGIONS"
    | "INDUSTRIES"
    | "LOCATIONS"
    | "NOTEBOOKS"
    | "TLDS"
    | "VERTICALS"[];
  format?: "JSON" | "CSV";
}

export const GetSearchGlobalRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  limitPerGroup: Schema.optional(Schema.Number).pipe(T.HttpQuery("limitPerGroup")),
  query: Schema.String.pipe(T.HttpQuery("query")),
  include: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "ADM1S",
        "ASNS",
        "BOTS",
        "CERTIFICATE_AUTHORITIES",
        "CERTIFICATE_LOGS",
        "ORIGINS",
        "ORIGIN_REGIONS",
        "INDUSTRIES",
        "LOCATIONS",
        "NOTEBOOKS",
        "TLDS",
        "VERTICALS",
      ),
    ),
  ).pipe(T.HttpQuery("include")),
  exclude: Schema.optional(
    Schema.Array(
      Schema.Literal(
        "ADM1S",
        "ASNS",
        "BOTS",
        "CERTIFICATE_AUTHORITIES",
        "CERTIFICATE_LOGS",
        "ORIGINS",
        "ORIGIN_REGIONS",
        "INDUSTRIES",
        "LOCATIONS",
        "NOTEBOOKS",
        "TLDS",
        "VERTICALS",
      ),
    ),
  ).pipe(T.HttpQuery("exclude")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/search/global" }))
  .annotations({
    identifier: "GetSearchGlobalRequest",
  }) as unknown as Schema.Schema<GetSearchGlobalRequest>;

export interface GetSearchGlobalResponse {
  result: { search: { code: string; name: string; type: string }[] };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetSearchGlobalResponse = Schema.Struct({
  result: Schema.Struct({
    search: Schema.Array(
      Schema.Struct({
        code: Schema.String,
        name: Schema.String,
        type: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetSearchGlobalResponse",
}) as unknown as Schema.Schema<GetSearchGlobalResponse>;

export const getSearchGlobal: (
  input: GetSearchGlobalRequest,
) => Effect.Effect<
  GetSearchGlobalResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSearchGlobalRequest,
  output: GetSearchGlobalResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetTcpResetsTimeoutsSummaryRequest {
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  format?: "JSON" | "CSV";
}

export const GetTcpResetsTimeoutsSummaryRequest = Schema.Struct({
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/tcp_resets_timeouts/summary" }))
  .annotations({
    identifier: "GetTcpResetsTimeoutsSummaryRequest",
  }) as unknown as Schema.Schema<GetTcpResetsTimeoutsSummaryRequest>;

export interface GetTcpResetsTimeoutsSummaryResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    summary_0: {
      later_in_flow: string;
      no_match: string;
      post_ack: string;
      post_psh: string;
      post_syn: string;
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetTcpResetsTimeoutsSummaryResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    summary_0: Schema.Struct({
      later_in_flow: Schema.String,
      no_match: Schema.String,
      post_ack: Schema.String,
      post_psh: Schema.String,
      post_syn: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetTcpResetsTimeoutsSummaryResponse",
}) as unknown as Schema.Schema<GetTcpResetsTimeoutsSummaryResponse>;

export const getTcpResetsTimeoutsSummary: (
  input: GetTcpResetsTimeoutsSummaryRequest,
) => Effect.Effect<
  GetTcpResetsTimeoutsSummaryResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTcpResetsTimeoutsSummaryRequest,
  output: GetTcpResetsTimeoutsSummaryResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetTcpResetsTimeoutsTimeseriesGroupRequest {
  aggInterval?: "15m" | "1h" | "1d" | "1w";
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  format?: "JSON" | "CSV";
}

export const GetTcpResetsTimeoutsTimeseriesGroupRequest = Schema.Struct({
  aggInterval: Schema.optional(Schema.Literal("15m", "1h", "1d", "1w")).pipe(
    T.HttpQuery("aggInterval"),
  ),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/tcp_resets_timeouts/timeseries_groups" }))
  .annotations({
    identifier: "GetTcpResetsTimeoutsTimeseriesGroupRequest",
  }) as unknown as Schema.Schema<GetTcpResetsTimeoutsTimeseriesGroupRequest>;

export interface GetTcpResetsTimeoutsTimeseriesGroupResponse {
  result: {
    meta: {
      aggInterval: "FIFTEEN_MINUTES" | "ONE_HOUR" | "ONE_DAY" | "ONE_WEEK" | "ONE_MONTH";
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    serie_0: {
      later_in_flow: string[];
      no_match: string[];
      post_ack: string[];
      post_psh: string[];
      post_syn: string[];
      timestamps: string[];
    };
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetTcpResetsTimeoutsTimeseriesGroupResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      aggInterval: Schema.Literal(
        "FIFTEEN_MINUTES",
        "ONE_HOUR",
        "ONE_DAY",
        "ONE_WEEK",
        "ONE_MONTH",
      ),
      confidenceInfo: Schema.Struct({
        annotations: Schema.Array(
          Schema.Struct({
            dataSource: Schema.Literal(
              "ALL",
              "AI_BOTS",
              "AI_GATEWAY",
              "BGP",
              "BOTS",
              "CONNECTION_ANOMALY",
              "CT",
              "DNS",
              "DNS_MAGNITUDE",
              "DNS_AS112",
              "DOS",
              "EMAIL_ROUTING",
              "EMAIL_SECURITY",
              "FW",
              "FW_PG",
              "HTTP",
              "HTTP_CONTROL",
              "HTTP_CRAWLER_REFERER",
              "HTTP_ORIGINS",
              "IQI",
              "LEAKED_CREDENTIALS",
              "NET",
              "ROBOTS_TXT",
              "SPEED",
              "WORKERS_AI",
            ),
            description: Schema.String,
            endDate: Schema.Date,
            eventType: Schema.Literal(
              "EVENT",
              "GENERAL",
              "OUTAGE",
              "PARTIAL_PROJECTION",
              "PIPELINE",
              "TRAFFIC_ANOMALY",
            ),
            isInstantaneous: Schema.Boolean,
            linkedUrl: Schema.String,
            startDate: Schema.Date,
          }),
        ),
        level: Schema.Number,
      }),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    serie_0: Schema.Struct({
      later_in_flow: Schema.Array(Schema.String),
      no_match: Schema.Array(Schema.String),
      post_ack: Schema.Array(Schema.String),
      post_psh: Schema.Array(Schema.String),
      post_syn: Schema.Array(Schema.String),
      timestamps: Schema.Array(Schema.Date),
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetTcpResetsTimeoutsTimeseriesGroupResponse",
}) as unknown as Schema.Schema<GetTcpResetsTimeoutsTimeseriesGroupResponse>;

export const getTcpResetsTimeoutsTimeseriesGroup: (
  input: GetTcpResetsTimeoutsTimeseriesGroupRequest,
) => Effect.Effect<
  GetTcpResetsTimeoutsTimeseriesGroupResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTcpResetsTimeoutsTimeseriesGroupRequest,
  output: GetTcpResetsTimeoutsTimeseriesGroupResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetTldsRequest {
  limit?: number;
  offset?: number;
  tldManager?: string;
  tldType?: "GENERIC" | "COUNTRY_CODE" | "GENERIC_RESTRICTED" | "INFRASTRUCTURE" | "SPONSORED";
  tld?: string;
  format?: "JSON" | "CSV";
}

export const GetTldsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset")),
  tldManager: Schema.optional(Schema.String).pipe(T.HttpQuery("tldManager")),
  tldType: Schema.optional(
    Schema.Literal("GENERIC", "COUNTRY_CODE", "GENERIC_RESTRICTED", "INFRASTRUCTURE", "SPONSORED"),
  ).pipe(T.HttpQuery("tldType")),
  tld: Schema.optional(Schema.String).pipe(T.HttpQuery("tld")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/tlds" }))
  .annotations({ identifier: "GetTldsRequest" }) as unknown as Schema.Schema<GetTldsRequest>;

export interface GetTldsResponse {
  result: { tlds: { manager: string; tld: string; type: string }[] };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetTldsResponse = Schema.Struct({
  result: Schema.Struct({
    tlds: Schema.Array(
      Schema.Struct({
        manager: Schema.String,
        tld: Schema.String,
        type: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({ identifier: "GetTldsResponse" }) as unknown as Schema.Schema<GetTldsResponse>;

export const getTlds: (
  input: GetTldsRequest,
) => Effect.Effect<
  GetTldsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTldsRequest,
  output: GetTldsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetTldDetailsRequest {
  tld: string;
  format?: "JSON" | "CSV";
}

export const GetTldDetailsRequest = Schema.Struct({
  tld: Schema.String.pipe(T.HttpPath("tld")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/tlds/{tld}" }))
  .annotations({
    identifier: "GetTldDetailsRequest",
  }) as unknown as Schema.Schema<GetTldDetailsRequest>;

export interface GetTldDetailsResponse {
  result: { tld: { manager: string; tld: string; type: string } };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetTldDetailsResponse = Schema.Struct({
  result: Schema.Struct({
    tld: Schema.Struct({
      manager: Schema.String,
      tld: Schema.String,
      type: Schema.String,
    }),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetTldDetailsResponse",
}) as unknown as Schema.Schema<GetTldDetailsResponse>;

export const getTldDetails: (
  input: GetTldDetailsRequest,
) => Effect.Effect<
  GetTldDetailsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTldDetailsRequest,
  output: GetTldDetailsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetTrafficAnomaliesRequest {
  limit?: number;
  offset?: number;
  dateRange?: string;
  dateStart?: string;
  dateEnd?: string;
  status?: "VERIFIED" | "UNVERIFIED";
  type?: "LOCATION" | "AS" | "ORIGIN"[];
  asn?: number;
  location?: string;
  origin?: string;
  format?: "JSON" | "CSV";
}

export const GetTrafficAnomaliesRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset")),
  dateRange: Schema.optional(Schema.String).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Date).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Date).pipe(T.HttpQuery("dateEnd")),
  status: Schema.optional(Schema.Literal("VERIFIED", "UNVERIFIED")).pipe(T.HttpQuery("status")),
  type: Schema.optional(Schema.Array(Schema.Literal("LOCATION", "AS", "ORIGIN"))).pipe(
    T.HttpQuery("type"),
  ),
  asn: Schema.optional(Schema.Number).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.String).pipe(T.HttpQuery("location")),
  origin: Schema.optional(Schema.String).pipe(T.HttpQuery("origin")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/traffic_anomalies" }))
  .annotations({
    identifier: "GetTrafficAnomaliesRequest",
  }) as unknown as Schema.Schema<GetTrafficAnomaliesRequest>;

export interface GetTrafficAnomaliesResponse {
  result: {
    trafficAnomalies: {
      asnDetails?: { asn: string; locations?: { code: string; name: string }; name: string };
      endDate?: string;
      locationDetails?: { code: string; name: string };
      originDetails?: { name: string; origin: string };
      startDate: string;
      status: string;
      type: string;
      uuid: string;
      visibleInDataSources?: string[];
    }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetTrafficAnomaliesResponse = Schema.Struct({
  result: Schema.Struct({
    trafficAnomalies: Schema.Array(
      Schema.Struct({
        asnDetails: Schema.optional(
          Schema.NullOr(
            Schema.Struct({
              asn: Schema.String,
              locations: Schema.optional(
                Schema.NullOr(
                  Schema.Struct({
                    code: Schema.String,
                    name: Schema.String,
                  }),
                ),
              ),
              name: Schema.String,
            }),
          ),
        ),
        endDate: Schema.optional(Schema.NullOr(Schema.Date)),
        locationDetails: Schema.optional(
          Schema.NullOr(
            Schema.Struct({
              code: Schema.String,
              name: Schema.String,
            }),
          ),
        ),
        originDetails: Schema.optional(
          Schema.NullOr(
            Schema.Struct({
              name: Schema.String,
              origin: Schema.String,
            }),
          ),
        ),
        startDate: Schema.String,
        status: Schema.String,
        type: Schema.String,
        uuid: Schema.String,
        visibleInDataSources: Schema.optional(Schema.NullOr(Schema.Array(Schema.String))),
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetTrafficAnomaliesResponse",
}) as unknown as Schema.Schema<GetTrafficAnomaliesResponse>;

export const getTrafficAnomalies: (
  input: GetTrafficAnomaliesRequest,
) => Effect.Effect<
  GetTrafficAnomaliesResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTrafficAnomaliesRequest,
  output: GetTrafficAnomaliesResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetTrafficAnomaliesTopRequest {
  limit?: number;
  dateRange?: string;
  dateStart?: string;
  dateEnd?: string;
  status?: "VERIFIED" | "UNVERIFIED";
  format?: "JSON" | "CSV";
}

export const GetTrafficAnomaliesTopRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  dateRange: Schema.optional(Schema.String).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Date).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Date).pipe(T.HttpQuery("dateEnd")),
  status: Schema.optional(Schema.Literal("VERIFIED", "UNVERIFIED")).pipe(T.HttpQuery("status")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/traffic_anomalies/locations" }))
  .annotations({
    identifier: "GetTrafficAnomaliesTopRequest",
  }) as unknown as Schema.Schema<GetTrafficAnomaliesTopRequest>;

export interface GetTrafficAnomaliesTopResponse {
  result: {
    trafficAnomalies: { clientCountryAlpha2: string; clientCountryName: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetTrafficAnomaliesTopResponse = Schema.Struct({
  result: Schema.Struct({
    trafficAnomalies: Schema.Array(
      Schema.Struct({
        clientCountryAlpha2: Schema.String,
        clientCountryName: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetTrafficAnomaliesTopResponse",
}) as unknown as Schema.Schema<GetTrafficAnomaliesTopResponse>;

export const getTrafficAnomaliesTop: (
  input: GetTrafficAnomaliesTopRequest,
) => Effect.Effect<
  GetTrafficAnomaliesTopResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTrafficAnomaliesTopRequest,
  output: GetTrafficAnomaliesTopResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetVerifiedBotsTopByHttpRequestsRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  format?: "JSON" | "CSV";
}

export const GetVerifiedBotsTopByHttpRequestsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/verified_bots/top/bots" }))
  .annotations({
    identifier: "GetVerifiedBotsTopByHttpRequestsRequest",
  }) as unknown as Schema.Schema<GetVerifiedBotsTopByHttpRequestsRequest>;

export interface GetVerifiedBotsTopByHttpRequestsResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { botCategory: string; botName: string; botOwner: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetVerifiedBotsTopByHttpRequestsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        botCategory: Schema.String,
        botName: Schema.String,
        botOwner: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetVerifiedBotsTopByHttpRequestsResponse",
}) as unknown as Schema.Schema<GetVerifiedBotsTopByHttpRequestsResponse>;

export const getVerifiedBotsTopByHttpRequests: (
  input: GetVerifiedBotsTopByHttpRequestsRequest,
) => Effect.Effect<
  GetVerifiedBotsTopByHttpRequestsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetVerifiedBotsTopByHttpRequestsRequest,
  output: GetVerifiedBotsTopByHttpRequestsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));

export interface GetVerifiedBotsTopCategoriesByHttpRequestsRequest {
  limit?: number;
  name?: string[];
  dateRange?: string[];
  dateStart?: string[];
  dateEnd?: string[];
  asn?: string[];
  location?: string[];
  continent?: string[];
  format?: "JSON" | "CSV";
}

export const GetVerifiedBotsTopCategoriesByHttpRequestsRequest = Schema.Struct({
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("name")),
  dateRange: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dateRange")),
  dateStart: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateStart")),
  dateEnd: Schema.optional(Schema.Array(Schema.Date)).pipe(T.HttpQuery("dateEnd")),
  asn: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("asn")),
  location: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("location")),
  continent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("continent")),
  format: Schema.optional(Schema.Literal("JSON", "CSV")).pipe(T.HttpQuery("format")),
})
  .pipe(T.Http({ method: "GET", path: "/radar/verified_bots/top/categories" }))
  .annotations({
    identifier: "GetVerifiedBotsTopCategoriesByHttpRequestsRequest",
  }) as unknown as Schema.Schema<GetVerifiedBotsTopCategoriesByHttpRequestsRequest>;

export interface GetVerifiedBotsTopCategoriesByHttpRequestsResponse {
  result: {
    meta: {
      confidenceInfo: {
        annotations: {
          dataSource:
            | "ALL"
            | "AI_BOTS"
            | "AI_GATEWAY"
            | "BGP"
            | "BOTS"
            | "CONNECTION_ANOMALY"
            | "CT"
            | "DNS"
            | "DNS_MAGNITUDE"
            | "DNS_AS112"
            | "DOS"
            | "EMAIL_ROUTING"
            | "EMAIL_SECURITY"
            | "FW"
            | "FW_PG"
            | "HTTP"
            | "HTTP_CONTROL"
            | "HTTP_CRAWLER_REFERER"
            | "HTTP_ORIGINS"
            | "IQI"
            | "LEAKED_CREDENTIALS"
            | "NET"
            | "ROBOTS_TXT"
            | "SPEED"
            | "WORKERS_AI";
          description: string;
          endDate: string;
          eventType:
            | "EVENT"
            | "GENERAL"
            | "OUTAGE"
            | "PARTIAL_PROJECTION"
            | "PIPELINE"
            | "TRAFFIC_ANOMALY";
          isInstantaneous: boolean;
          linkedUrl: string;
          startDate: string;
        }[];
        level: number;
      };
      dateRange: { endTime: string; startTime: string }[];
      lastUpdated: string;
      normalization:
        | "PERCENTAGE"
        | "MIN0_MAX"
        | "MIN_MAX"
        | "RAW_VALUES"
        | "PERCENTAGE_CHANGE"
        | "ROLLING_AVERAGE"
        | "OVERLAPPED_PERCENTAGE"
        | "RATIO";
      units: { name: string; value: string }[];
    };
    top_0: { botCategory: string; value: string }[];
  };
  result_info?: {
    page?: number;
    per_page?: number;
    count?: number;
    total_count?: number;
    cursor?: string;
  };
}

export const GetVerifiedBotsTopCategoriesByHttpRequestsResponse = Schema.Struct({
  result: Schema.Struct({
    meta: Schema.Struct({
      confidenceInfo: Schema.NullOr(
        Schema.Struct({
          annotations: Schema.Array(
            Schema.Struct({
              dataSource: Schema.Literal(
                "ALL",
                "AI_BOTS",
                "AI_GATEWAY",
                "BGP",
                "BOTS",
                "CONNECTION_ANOMALY",
                "CT",
                "DNS",
                "DNS_MAGNITUDE",
                "DNS_AS112",
                "DOS",
                "EMAIL_ROUTING",
                "EMAIL_SECURITY",
                "FW",
                "FW_PG",
                "HTTP",
                "HTTP_CONTROL",
                "HTTP_CRAWLER_REFERER",
                "HTTP_ORIGINS",
                "IQI",
                "LEAKED_CREDENTIALS",
                "NET",
                "ROBOTS_TXT",
                "SPEED",
                "WORKERS_AI",
              ),
              description: Schema.String,
              endDate: Schema.Date,
              eventType: Schema.Literal(
                "EVENT",
                "GENERAL",
                "OUTAGE",
                "PARTIAL_PROJECTION",
                "PIPELINE",
                "TRAFFIC_ANOMALY",
              ),
              isInstantaneous: Schema.Boolean,
              linkedUrl: Schema.String,
              startDate: Schema.Date,
            }),
          ),
          level: Schema.Number,
        }),
      ),
      dateRange: Schema.Array(
        Schema.Struct({
          endTime: Schema.Date,
          startTime: Schema.Date,
        }),
      ),
      lastUpdated: Schema.Date,
      normalization: Schema.Literal(
        "PERCENTAGE",
        "MIN0_MAX",
        "MIN_MAX",
        "RAW_VALUES",
        "PERCENTAGE_CHANGE",
        "ROLLING_AVERAGE",
        "OVERLAPPED_PERCENTAGE",
        "RATIO",
      ),
      units: Schema.Array(
        Schema.Struct({
          name: Schema.String,
          value: Schema.String,
        }),
      ),
    }),
    top_0: Schema.Array(
      Schema.Struct({
        botCategory: Schema.String,
        value: Schema.String,
      }),
    ),
  }),
  result_info: Schema.optional(
    Schema.Struct({
      page: Schema.optional(Schema.Number),
      per_page: Schema.optional(Schema.Number),
      count: Schema.optional(Schema.Number),
      total_count: Schema.optional(Schema.Number),
      cursor: Schema.optional(Schema.String),
    }),
  ),
}).annotations({
  identifier: "GetVerifiedBotsTopCategoriesByHttpRequestsResponse",
}) as unknown as Schema.Schema<GetVerifiedBotsTopCategoriesByHttpRequestsResponse>;

export const getVerifiedBotsTopCategoriesByHttpRequests: (
  input: GetVerifiedBotsTopCategoriesByHttpRequestsRequest,
) => Effect.Effect<
  GetVerifiedBotsTopCategoriesByHttpRequestsResponse,
  | RateLimited
  | TooManyRequests
  | AuthenticationError
  | InvalidToken
  | MissingToken
  | TokenExpired
  | Unauthorized
  | CloudflareError
  | UnknownCloudflareError
  | CloudflareNetworkError
  | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetVerifiedBotsTopCategoriesByHttpRequestsRequest,
  output: GetVerifiedBotsTopCategoriesByHttpRequestsResponse,
  errors: [
    RateLimited.pipe(T.HttpErrorCode(971)),
    TooManyRequests.pipe(T.HttpErrorCode(6100)),
    AuthenticationError.pipe(T.HttpErrorCode(10000)),
    InvalidToken.pipe(T.HttpErrorCode(9103)),
    MissingToken.pipe(T.HttpErrorCode(9106)),
    TokenExpired.pipe(T.HttpErrorCode(9109)),
    Unauthorized.pipe(T.HttpErrorCode(9000)),
  ],
}));
