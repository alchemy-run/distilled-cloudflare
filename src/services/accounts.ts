/**
 * Cloudflare ACCOUNTS API
 *
 * Generated from Cloudflare OpenAPI specification.
 * DO NOT EDIT - regenerate with: bun generate --service accounts
 */

import * as Effect from "effect/Effect";
import * as Schema from "effect/Schema";
import type { HttpClient } from "@effect/platform";
import * as API from "../client/api.ts";
import * as T from "../traits.ts";
import type { ApiToken } from "../auth.ts";
import {
  CloudflareError,
  UnknownCloudflareError,
  CloudflareNetworkError,
  CloudflareHttpError,
} from "../errors.ts";
import {
  AuthenticationError,
  InvalidToken,
  MissingToken,
  RateLimited,
  TokenExpired,
  TooManyRequests,
  Unauthorized,
} from "../errors/generated.ts";

// ============================================================
// Named schemas (required for circular references)
// ============================================================

export const cloudflare_pipelines_SourceField = Schema.Struct({
  metadata_key: Schema.optional(Schema.String),
  name: Schema.String,
  required: Schema.optional(Schema.Boolean),
  sql_name: Schema.optional(Schema.String)
});

export const cloudflare_pipelines_FieldType = Schema.Union(Schema.Struct({
  type: Schema.Literal("int32")
}), Schema.Struct({
  type: Schema.Literal("int64")
}), Schema.Struct({
  type: Schema.Literal("float32")
}), Schema.Struct({
  type: Schema.Literal("float64")
}), Schema.Struct({
  type: Schema.Literal("bool")
}), Schema.Struct({
  type: Schema.Literal("string")
}), Schema.Struct({
  type: Schema.Literal("binary")
}), Schema.Struct({
  type: Schema.Literal("timestamp")
}), Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("struct")
}), Schema.Struct({
  type: Schema.Literal("list")
}));

export const cloudflare_pipelines_StructField = Schema.Struct({
  fields: Schema.Array(cloudflare_pipelines_SourceField),
  name: Schema.optional(Schema.String)
});

export const cloudflare_pipelines_ListField = Schema.Struct({
  items: cloudflare_pipelines_SourceField
});

// ============================================================
// Operations
// ============================================================

export interface ListAccountsRequest {
  name?: string;
  page?: number;
  per_page?: number;
  direction?: "asc" | "desc";
}

export const ListAccountsRequest = Schema.Struct({
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts" }),
).annotations({ identifier: "ListAccountsRequest" }) as unknown as Schema.Schema<ListAccountsRequest>;

export interface ListAccountsResponse {
  result: { created_on?: string; id: string; managed_by?: { parent_org_id?: string; parent_org_name?: string }; name: string; settings?: { abuse_contact_email?: string; enforce_twofactor?: boolean }; type: "standard" | "enterprise" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAccountsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  id: Schema.String,
  managed_by: Schema.optional(Schema.Struct({
  parent_org_id: Schema.optional(Schema.String),
  parent_org_name: Schema.optional(Schema.String)
})),
  name: Schema.String,
  settings: Schema.optional(Schema.Struct({
  abuse_contact_email: Schema.optional(Schema.String),
  enforce_twofactor: Schema.optional(Schema.Boolean)
})),
  type: Schema.Literal("standard", "enterprise")
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAccountsResponse" }) as unknown as Schema.Schema<ListAccountsResponse>;

export const listAccounts: (
  input: ListAccountsRequest
) => Effect.Effect<
  ListAccountsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccountsRequest,
  output: ListAccountsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountCreationRequest {
  body: { name: string; type?: "standard" | "enterprise"; unit?: { id?: string } };
}

export const AccountCreationRequest = Schema.Struct({
  body: Schema.Struct({
  name: Schema.String,
  type: Schema.optional(Schema.Literal("standard", "enterprise")),
  unit: Schema.optional(Schema.Struct({
  id: Schema.optional(Schema.String)
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts" }),
).annotations({ identifier: "AccountCreationRequest" }) as unknown as Schema.Schema<AccountCreationRequest>;

export interface AccountCreationResponse {
  result: { created_on?: string; id: string; managed_by?: { parent_org_id?: string; parent_org_name?: string }; name: string; settings?: { abuse_contact_email?: string; enforce_twofactor?: boolean }; type: "standard" | "enterprise" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountCreationResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  id: Schema.String,
  managed_by: Schema.optional(Schema.Struct({
  parent_org_id: Schema.optional(Schema.String),
  parent_org_name: Schema.optional(Schema.String)
})),
  name: Schema.String,
  settings: Schema.optional(Schema.Struct({
  abuse_contact_email: Schema.optional(Schema.String),
  enforce_twofactor: Schema.optional(Schema.Boolean)
})),
  type: Schema.Literal("standard", "enterprise")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountCreationResponse" }) as unknown as Schema.Schema<AccountCreationResponse>;

export const accountCreation: (
  input: AccountCreationRequest
) => Effect.Effect<
  AccountCreationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountCreationRequest,
  output: AccountCreationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountsBatchmoveaccountsRequest {
  body: { account_ids: string[]; destination_organization_id: string };
}

export const AccountsBatchmoveaccountsRequest = Schema.Struct({
  body: Schema.Struct({
  account_ids: Schema.Array(Schema.String),
  destination_organization_id: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/move" }),
).annotations({ identifier: "AccountsBatchmoveaccountsRequest" }) as unknown as Schema.Schema<AccountsBatchmoveaccountsRequest>;

export interface AccountsBatchmoveaccountsResponse {
  result: { statuses: { message?: string; moved: boolean; tag: string } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountsBatchmoveaccountsResponse = Schema.Struct({
  result: Schema.Struct({
  statuses: Schema.Struct({
  message: Schema.optional(Schema.String),
  moved: Schema.Boolean,
  tag: Schema.String
})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountsBatchmoveaccountsResponse" }) as unknown as Schema.Schema<AccountsBatchmoveaccountsResponse>;

export const accountsBatchmoveaccounts: (
  input: AccountsBatchmoveaccountsRequest
) => Effect.Effect<
  AccountsBatchmoveaccountsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountsBatchmoveaccountsRequest,
  output: AccountsBatchmoveaccountsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListCustomPagesRequest {
  account_identifier: string;
}

export const ListCustomPagesRequest = Schema.Struct({
  account_identifier: Schema.String.pipe(T.HttpPath("account_identifier"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_identifier}/custom_pages" }),
).annotations({ identifier: "ListCustomPagesRequest" }) as unknown as Schema.Schema<ListCustomPagesRequest>;

export interface ListCustomPagesResponse {
  result: { created_on?: string; description?: string; id?: string; modified_on?: string; preview_target?: string; required_tokens?: string[]; state?: "default" | "customized"; url?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListCustomPagesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  preview_target: Schema.optional(Schema.String),
  required_tokens: Schema.optional(Schema.Array(Schema.String)),
  state: Schema.optional(Schema.Literal("default", "customized")),
  url: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListCustomPagesResponse" }) as unknown as Schema.Schema<ListCustomPagesResponse>;

export const listCustomPages: (
  input: ListCustomPagesRequest
) => Effect.Effect<
  ListCustomPagesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListCustomPagesRequest,
  output: ListCustomPagesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetACustomPageRequest {
  identifier: "1000_errors" | "500_errors" | "basic_challenge" | "country_challenge" | "ip_block" | "managed_challenge" | "ratelimit_block" | "under_attack" | "waf_block" | "waf_challenge";
  account_identifier: string;
}

export const GetACustomPageRequest = Schema.Struct({
  identifier: Schema.Literal("1000_errors", "500_errors", "basic_challenge", "country_challenge", "ip_block", "managed_challenge", "ratelimit_block", "under_attack", "waf_block", "waf_challenge").pipe(T.HttpPath("identifier")),
  account_identifier: Schema.String.pipe(T.HttpPath("account_identifier"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_identifier}/custom_pages/{identifier}" }),
).annotations({ identifier: "GetACustomPageRequest" }) as unknown as Schema.Schema<GetACustomPageRequest>;

export interface GetACustomPageResponse {
  result: { created_on?: string; description?: string; id?: string; modified_on?: string; preview_target?: string; required_tokens?: string[]; state?: "default" | "customized"; url?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetACustomPageResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  preview_target: Schema.optional(Schema.String),
  required_tokens: Schema.optional(Schema.Array(Schema.String)),
  state: Schema.optional(Schema.Literal("default", "customized")),
  url: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetACustomPageResponse" }) as unknown as Schema.Schema<GetACustomPageResponse>;

export const getACustomPage: (
  input: GetACustomPageRequest
) => Effect.Effect<
  GetACustomPageResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetACustomPageRequest,
  output: GetACustomPageResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateACustomPageRequest {
  identifier: "1000_errors" | "500_errors" | "basic_challenge" | "country_challenge" | "ip_block" | "managed_challenge" | "ratelimit_block" | "under_attack" | "waf_block" | "waf_challenge";
  account_identifier: string;
  body: unknown;
}

export const UpdateACustomPageRequest = Schema.Struct({
  identifier: Schema.Literal("1000_errors", "500_errors", "basic_challenge", "country_challenge", "ip_block", "managed_challenge", "ratelimit_block", "under_attack", "waf_block", "waf_challenge").pipe(T.HttpPath("identifier")),
  account_identifier: Schema.String.pipe(T.HttpPath("account_identifier")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_identifier}/custom_pages/{identifier}" }),
).annotations({ identifier: "UpdateACustomPageRequest" }) as unknown as Schema.Schema<UpdateACustomPageRequest>;

export interface UpdateACustomPageResponse {
  result: { created_on?: string; description?: string; id?: string; modified_on?: string; preview_target?: string; required_tokens?: string[]; state?: "default" | "customized"; url?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateACustomPageResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  preview_target: Schema.optional(Schema.String),
  required_tokens: Schema.optional(Schema.Array(Schema.String)),
  state: Schema.optional(Schema.Literal("default", "customized")),
  url: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateACustomPageResponse" }) as unknown as Schema.Schema<UpdateACustomPageResponse>;

export const updateACustomPage: (
  input: UpdateACustomPageRequest
) => Effect.Effect<
  UpdateACustomPageResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateACustomPageRequest,
  output: UpdateACustomPageResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountsAccountDetailsRequest {
  account_id: unknown;
}

export const AccountsAccountDetailsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}" }),
).annotations({ identifier: "AccountsAccountDetailsRequest" }) as unknown as Schema.Schema<AccountsAccountDetailsRequest>;

export interface AccountsAccountDetailsResponse {
  result: { created_on?: string; id: string; managed_by?: { parent_org_id?: string; parent_org_name?: string }; name: string; settings?: { abuse_contact_email?: string; enforce_twofactor?: boolean }; type: "standard" | "enterprise" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountsAccountDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  id: Schema.String,
  managed_by: Schema.optional(Schema.Struct({
  parent_org_id: Schema.optional(Schema.String),
  parent_org_name: Schema.optional(Schema.String)
})),
  name: Schema.String,
  settings: Schema.optional(Schema.Struct({
  abuse_contact_email: Schema.optional(Schema.String),
  enforce_twofactor: Schema.optional(Schema.Boolean)
})),
  type: Schema.Literal("standard", "enterprise")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountsAccountDetailsResponse" }) as unknown as Schema.Schema<AccountsAccountDetailsResponse>;

export const accountsAccountDetails: (
  input: AccountsAccountDetailsRequest
) => Effect.Effect<
  AccountsAccountDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountsAccountDetailsRequest,
  output: AccountsAccountDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAccountRequest {
  account_id: unknown;
  body: unknown;
}

export const UpdateAccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  id: Schema.String,
  managed_by: Schema.optional(Schema.Struct({
  parent_org_id: Schema.optional(Schema.String),
  parent_org_name: Schema.optional(Schema.String)
})),
  name: Schema.String,
  settings: Schema.optional(Schema.Struct({
  abuse_contact_email: Schema.optional(Schema.String),
  enforce_twofactor: Schema.optional(Schema.Boolean)
})),
  type: Schema.Literal("standard", "enterprise")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}" }),
).annotations({ identifier: "UpdateAccountRequest" }) as unknown as Schema.Schema<UpdateAccountRequest>;

export interface UpdateAccountResponse {
  result: { created_on?: string; id: string; managed_by?: { parent_org_id?: string; parent_org_name?: string }; name: string; settings?: { abuse_contact_email?: string; enforce_twofactor?: boolean }; type: "standard" | "enterprise" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAccountResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  id: Schema.String,
  managed_by: Schema.optional(Schema.Struct({
  parent_org_id: Schema.optional(Schema.String),
  parent_org_name: Schema.optional(Schema.String)
})),
  name: Schema.String,
  settings: Schema.optional(Schema.Struct({
  abuse_contact_email: Schema.optional(Schema.String),
  enforce_twofactor: Schema.optional(Schema.Boolean)
})),
  type: Schema.Literal("standard", "enterprise")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAccountResponse" }) as unknown as Schema.Schema<UpdateAccountResponse>;

export const updateAccount: (
  input: UpdateAccountRequest
) => Effect.Effect<
  UpdateAccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccountRequest,
  output: UpdateAccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountDeletionRequest {
  account_id: string;
}

export const AccountDeletionRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}" }),
).annotations({ identifier: "AccountDeletionRequest" }) as unknown as Schema.Schema<AccountDeletionRequest>;

export interface AccountDeletionResponse {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountDeletionResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountDeletionResponse" }) as unknown as Schema.Schema<AccountDeletionResponse>;

export const accountDeletion: (
  input: AccountDeletionRequest
) => Effect.Effect<
  AccountDeletionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountDeletionRequest,
  output: AccountDeletionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListabusereportsRequest {
  account_id: string;
  page?: number;
  per_page?: number;
  sort?: string;
  domain?: string;
  created_before?: string;
  created_after?: string;
  status?: "accepted" | "in_review";
  type?: "PHISH" | "GEN" | "THREAT" | "DMCA" | "EMER" | "TM" | "REG_WHO" | "NCSEI" | "NETWORK";
  mitigation_status?: "pending" | "active" | "in_review" | "cancelled" | "removed";
}

export const ListabusereportsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  sort: Schema.optional(Schema.String).pipe(T.HttpQuery("sort")),
  domain: Schema.optional(Schema.String).pipe(T.HttpQuery("domain")),
  created_before: Schema.optional(Schema.String).pipe(T.HttpQuery("created_before")),
  created_after: Schema.optional(Schema.String).pipe(T.HttpQuery("created_after")),
  status: Schema.optional(Schema.Literal("accepted", "in_review")).pipe(T.HttpQuery("status")),
  type: Schema.optional(Schema.Literal("PHISH", "GEN", "THREAT", "DMCA", "EMER", "TM", "REG_WHO", "NCSEI", "NETWORK")).pipe(T.HttpQuery("type")),
  mitigation_status: Schema.optional(Schema.Literal("pending", "active", "in_review", "cancelled", "removed")).pipe(T.HttpQuery("mitigation_status"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/abuse-reports" }),
).annotations({ identifier: "ListabusereportsRequest" }) as unknown as Schema.Schema<ListabusereportsRequest>;

export interface ListabusereportsResponse {
  result: { reports: { cdate: string; domain: string; id: string; justification?: string; mitigation_summary: { accepted_url_count: number; active_count: number; external_host_notified: boolean; in_review_count: number; pending_count: number }; original_work?: string; status: "accepted" | "in_review"; submitter?: { company?: string; email?: string; name?: string; telephone?: string }; type: "PHISH" | "GEN" | "THREAT" | "DMCA" | "EMER" | "TM" | "REG_WHO" | "NCSEI" | "NETWORK"; urls?: string[] }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListabusereportsResponse = Schema.Struct({
  result: Schema.Struct({
  reports: Schema.Array(Schema.Struct({
  cdate: Schema.String,
  domain: Schema.String,
  id: Schema.String,
  justification: Schema.optional(Schema.String),
  mitigation_summary: Schema.Struct({
  accepted_url_count: Schema.Number,
  active_count: Schema.Number,
  external_host_notified: Schema.Boolean,
  in_review_count: Schema.Number,
  pending_count: Schema.Number
}),
  original_work: Schema.optional(Schema.String),
  status: Schema.Literal("accepted", "in_review"),
  submitter: Schema.optional(Schema.Struct({
  company: Schema.optional(Schema.String),
  email: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  telephone: Schema.optional(Schema.String)
})),
  type: Schema.Literal("PHISH", "GEN", "THREAT", "DMCA", "EMER", "TM", "REG_WHO", "NCSEI", "NETWORK"),
  urls: Schema.optional(Schema.Array(Schema.String))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListabusereportsResponse" }) as unknown as Schema.Schema<ListabusereportsResponse>;

export const listabusereports: (
  input: ListabusereportsRequest
) => Effect.Effect<
  ListabusereportsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListabusereportsRequest,
  output: ListabusereportsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListmitigationsRequest {
  account_id: string;
  report_id: string;
  page?: number;
  per_page?: number;
  sort?: "type,asc" | "type,desc" | "effective_date,asc" | "effective_date,desc" | "status,asc" | "status,desc" | "entity_type,asc" | "entity_type,desc";
  type?: "legal_block" | "phishing_interstitial" | "network_block" | "rate_limit_cache" | "account_suspend" | "redirect_video_stream";
  effective_before?: string;
  effective_after?: string;
  status?: "pending" | "active" | "in_review" | "cancelled" | "removed";
  entity_type?: "url_pattern" | "account" | "zone";
}

export const ListmitigationsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  report_id: Schema.String.pipe(T.HttpPath("report_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  sort: Schema.optional(Schema.Literal("type,asc", "type,desc", "effective_date,asc", "effective_date,desc", "status,asc", "status,desc", "entity_type,asc", "entity_type,desc")).pipe(T.HttpQuery("sort")),
  type: Schema.optional(Schema.Literal("legal_block", "phishing_interstitial", "network_block", "rate_limit_cache", "account_suspend", "redirect_video_stream")).pipe(T.HttpQuery("type")),
  effective_before: Schema.optional(Schema.String).pipe(T.HttpQuery("effective_before")),
  effective_after: Schema.optional(Schema.String).pipe(T.HttpQuery("effective_after")),
  status: Schema.optional(Schema.Literal("pending", "active", "in_review", "cancelled", "removed")).pipe(T.HttpQuery("status")),
  entity_type: Schema.optional(Schema.Literal("url_pattern", "account", "zone")).pipe(T.HttpQuery("entity_type"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/abuse-reports/{report_id}/mitigations" }),
).annotations({ identifier: "ListmitigationsRequest" }) as unknown as Schema.Schema<ListmitigationsRequest>;

export interface ListmitigationsResponse {
  result: { mitigations: { effective_date: string; entity_id: string; entity_type: "url_pattern" | "account" | "zone"; id: string; status: "pending" | "active" | "in_review" | "cancelled" | "removed"; type: "legal_block" | "phishing_interstitial" | "network_block" | "rate_limit_cache" | "account_suspend" | "redirect_video_stream" }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListmitigationsResponse = Schema.Struct({
  result: Schema.Struct({
  mitigations: Schema.Array(Schema.Struct({
  effective_date: Schema.String,
  entity_id: Schema.String,
  entity_type: Schema.Literal("url_pattern", "account", "zone"),
  id: Schema.String,
  status: Schema.Literal("pending", "active", "in_review", "cancelled", "removed"),
  type: Schema.Literal("legal_block", "phishing_interstitial", "network_block", "rate_limit_cache", "account_suspend", "redirect_video_stream")
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListmitigationsResponse" }) as unknown as Schema.Schema<ListmitigationsResponse>;

export const listmitigations: (
  input: ListmitigationsRequest
) => Effect.Effect<
  ListmitigationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListmitigationsRequest,
  output: ListmitigationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface RequestreviewRequest {
  account_id: string;
  report_id: string;
  body: { appeals: { id: string; reason: "removed" | "misclassified" }[] };
}

export const RequestreviewRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  report_id: Schema.String.pipe(T.HttpPath("report_id")),
  body: Schema.Struct({
  appeals: Schema.Array(Schema.Struct({
  id: Schema.String,
  reason: Schema.Literal("removed", "misclassified")
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/abuse-reports/{report_id}/mitigations/appeal" }),
).annotations({ identifier: "RequestreviewRequest" }) as unknown as Schema.Schema<RequestreviewRequest>;

export interface RequestreviewResponse {
  result: { effective_date: string; entity_id: string; entity_type: "url_pattern" | "account" | "zone"; id: string; status: "pending" | "active" | "in_review" | "cancelled" | "removed"; type: "legal_block" | "phishing_interstitial" | "network_block" | "rate_limit_cache" | "account_suspend" | "redirect_video_stream" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const RequestreviewResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  effective_date: Schema.String,
  entity_id: Schema.String,
  entity_type: Schema.Literal("url_pattern", "account", "zone"),
  id: Schema.String,
  status: Schema.Literal("pending", "active", "in_review", "cancelled", "removed"),
  type: Schema.Literal("legal_block", "phishing_interstitial", "network_block", "rate_limit_cache", "account_suspend", "redirect_video_stream")
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "RequestreviewResponse" }) as unknown as Schema.Schema<RequestreviewResponse>;

export const requestreview: (
  input: RequestreviewRequest
) => Effect.Effect<
  RequestreviewResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: RequestreviewRequest,
  output: RequestreviewResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetabusereportRequest {
  account_id: string;
  report_param: string;
}

export const GetabusereportRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  report_param: Schema.String.pipe(T.HttpPath("report_param"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/abuse-reports/{report_param}" }),
).annotations({ identifier: "GetabusereportRequest" }) as unknown as Schema.Schema<GetabusereportRequest>;

export interface GetabusereportResponse {
  result: { cdate: string; domain: string; id: string; justification?: string; mitigation_summary: { accepted_url_count: number; active_count: number; external_host_notified: boolean; in_review_count: number; pending_count: number }; original_work?: string; status: "accepted" | "in_review"; submitter?: { company?: string; email?: string; name?: string; telephone?: string }; type: "PHISH" | "GEN" | "THREAT" | "DMCA" | "EMER" | "TM" | "REG_WHO" | "NCSEI" | "NETWORK"; urls?: string[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetabusereportResponse = Schema.Struct({
  result: Schema.Struct({
  cdate: Schema.String,
  domain: Schema.String,
  id: Schema.String,
  justification: Schema.optional(Schema.String),
  mitigation_summary: Schema.Struct({
  accepted_url_count: Schema.Number,
  active_count: Schema.Number,
  external_host_notified: Schema.Boolean,
  in_review_count: Schema.Number,
  pending_count: Schema.Number
}),
  original_work: Schema.optional(Schema.String),
  status: Schema.Literal("accepted", "in_review"),
  submitter: Schema.optional(Schema.Struct({
  company: Schema.optional(Schema.String),
  email: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  telephone: Schema.optional(Schema.String)
})),
  type: Schema.Literal("PHISH", "GEN", "THREAT", "DMCA", "EMER", "TM", "REG_WHO", "NCSEI", "NETWORK"),
  urls: Schema.optional(Schema.Array(Schema.String))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetabusereportResponse" }) as unknown as Schema.Schema<GetabusereportResponse>;

export const getabusereport: (
  input: GetabusereportRequest
) => Effect.Effect<
  GetabusereportResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetabusereportRequest,
  output: GetabusereportResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SubmitabusereportRequest {
  account_id: string;
  report_param: string;
  body: unknown;
}

export const SubmitabusereportRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  report_param: Schema.String.pipe(T.HttpPath("report_param")),
  body: Schema.Union(Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({}), Schema.Struct({})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/abuse-reports/{report_param}" }),
).annotations({ identifier: "SubmitabusereportRequest" }) as unknown as Schema.Schema<SubmitabusereportRequest>;

export interface SubmitabusereportResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SubmitabusereportResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SubmitabusereportResponse" }) as unknown as Schema.Schema<SubmitabusereportResponse>;

export const submitabusereport: (
  input: SubmitabusereportRequest
) => Effect.Effect<
  SubmitabusereportResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SubmitabusereportRequest,
  output: SubmitabusereportResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAddressMapsRequest {
  account_id: string;
}

export const ListAddressMapsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/addressing/address_maps" }),
).annotations({ identifier: "ListAddressMapsRequest" }) as unknown as Schema.Schema<ListAddressMapsRequest>;

export interface ListAddressMapsResponse {
  result: { can_delete?: boolean; can_modify_ips?: boolean; created_at?: string; default_sni?: string; description?: string; enabled?: boolean; id?: string; modified_at?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAddressMapsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  can_delete: Schema.optional(Schema.Boolean),
  can_modify_ips: Schema.optional(Schema.Boolean),
  created_at: Schema.optional(Schema.Date),
  default_sni: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  modified_at: Schema.optional(Schema.Date)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAddressMapsResponse" }) as unknown as Schema.Schema<ListAddressMapsResponse>;

export const listAddressMaps: (
  input: ListAddressMapsRequest
) => Effect.Effect<
  ListAddressMapsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAddressMapsRequest,
  output: ListAddressMapsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateAddressMapRequest {
  account_id: string;
  body: unknown;
}

export const CreateAddressMapRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/addressing/address_maps" }),
).annotations({ identifier: "CreateAddressMapRequest" }) as unknown as Schema.Schema<CreateAddressMapRequest>;

export interface CreateAddressMapResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateAddressMapResponse = Schema.Struct({
  result: Schema.Struct({
  ips: Schema.optional(Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  ip: Schema.optional(Schema.String)
}))),
  memberships: Schema.optional(Schema.Array(Schema.Struct({
  can_delete: Schema.optional(Schema.Boolean),
  created_at: Schema.optional(Schema.Date),
  identifier: Schema.optional(Schema.String),
  kind: Schema.optional(Schema.Literal("zone", "account"))
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateAddressMapResponse" }) as unknown as Schema.Schema<CreateAddressMapResponse>;

export const createAddressMap: (
  input: CreateAddressMapRequest
) => Effect.Effect<
  CreateAddressMapResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAddressMapRequest,
  output: CreateAddressMapResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface IpAddressManagementAddressMapsAddressMapDetailsRequest {
  address_map_id: string;
  account_id: string;
}

export const IpAddressManagementAddressMapsAddressMapDetailsRequest = Schema.Struct({
  address_map_id: Schema.String.pipe(T.HttpPath("address_map_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/addressing/address_maps/{address_map_id}" }),
).annotations({ identifier: "IpAddressManagementAddressMapsAddressMapDetailsRequest" }) as unknown as Schema.Schema<IpAddressManagementAddressMapsAddressMapDetailsRequest>;

export interface IpAddressManagementAddressMapsAddressMapDetailsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const IpAddressManagementAddressMapsAddressMapDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  ips: Schema.optional(Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  ip: Schema.optional(Schema.String)
}))),
  memberships: Schema.optional(Schema.Array(Schema.Struct({
  can_delete: Schema.optional(Schema.Boolean),
  created_at: Schema.optional(Schema.Date),
  identifier: Schema.optional(Schema.String),
  kind: Schema.optional(Schema.Literal("zone", "account"))
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "IpAddressManagementAddressMapsAddressMapDetailsResponse" }) as unknown as Schema.Schema<IpAddressManagementAddressMapsAddressMapDetailsResponse>;

export const ipAddressManagementAddressMapsAddressMapDetails: (
  input: IpAddressManagementAddressMapsAddressMapDetailsRequest
) => Effect.Effect<
  IpAddressManagementAddressMapsAddressMapDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: IpAddressManagementAddressMapsAddressMapDetailsRequest,
  output: IpAddressManagementAddressMapsAddressMapDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAddressMapRequest {
  address_map_id: string;
  account_id: string;
}

export const DeleteAddressMapRequest = Schema.Struct({
  address_map_id: Schema.String.pipe(T.HttpPath("address_map_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/addressing/address_maps/{address_map_id}" }),
).annotations({ identifier: "DeleteAddressMapRequest" }) as unknown as Schema.Schema<DeleteAddressMapRequest>;

export interface DeleteAddressMapResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAddressMapResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAddressMapResponse" }) as unknown as Schema.Schema<DeleteAddressMapResponse>;

export const deleteAddressMap: (
  input: DeleteAddressMapRequest
) => Effect.Effect<
  DeleteAddressMapResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAddressMapRequest,
  output: DeleteAddressMapResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAddressMapRequest {
  address_map_id: string;
  account_id: string;
  body: unknown;
}

export const UpdateAddressMapRequest = Schema.Struct({
  address_map_id: Schema.String.pipe(T.HttpPath("address_map_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/addressing/address_maps/{address_map_id}" }),
).annotations({ identifier: "UpdateAddressMapRequest" }) as unknown as Schema.Schema<UpdateAddressMapRequest>;

export interface UpdateAddressMapResponse {
  result: { can_delete?: boolean; can_modify_ips?: boolean; created_at?: string; default_sni?: string; description?: string; enabled?: boolean; id?: string; modified_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAddressMapResponse = Schema.Struct({
  result: Schema.Struct({
  can_delete: Schema.optional(Schema.Boolean),
  can_modify_ips: Schema.optional(Schema.Boolean),
  created_at: Schema.optional(Schema.Date),
  default_sni: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  modified_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAddressMapResponse" }) as unknown as Schema.Schema<UpdateAddressMapResponse>;

export const updateAddressMap: (
  input: UpdateAddressMapRequest
) => Effect.Effect<
  UpdateAddressMapResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAddressMapRequest,
  output: UpdateAddressMapResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapRequest {
  account_id: string;
  address_map_id: string;
}

export const IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  address_map_id: Schema.String.pipe(T.HttpPath("address_map_id"))
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/addressing/address_maps/{address_map_id}/accounts/{account_id}" }),
).annotations({ identifier: "IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapRequest" }) as unknown as Schema.Schema<IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapRequest>;

export interface IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapResponse" }) as unknown as Schema.Schema<IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapResponse>;

export const ipAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMap: (
  input: IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapRequest
) => Effect.Effect<
  IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapRequest,
  output: IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapRequest {
  account_id: string;
  address_map_id: string;
}

export const IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  address_map_id: Schema.String.pipe(T.HttpPath("address_map_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/addressing/address_maps/{address_map_id}/accounts/{account_id}" }),
).annotations({ identifier: "IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapRequest" }) as unknown as Schema.Schema<IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapRequest>;

export interface IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapResponse" }) as unknown as Schema.Schema<IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapResponse>;

export const ipAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMap: (
  input: IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapRequest
) => Effect.Effect<
  IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapRequest,
  output: IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface IpAddressManagementAddressMapsAddAnIpToAnAddressMapRequest {
  ip_address: string;
  address_map_id: string;
  account_id: string;
}

export const IpAddressManagementAddressMapsAddAnIpToAnAddressMapRequest = Schema.Struct({
  ip_address: Schema.String.pipe(T.HttpPath("ip_address")),
  address_map_id: Schema.String.pipe(T.HttpPath("address_map_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/addressing/address_maps/{address_map_id}/ips/{ip_address}" }),
).annotations({ identifier: "IpAddressManagementAddressMapsAddAnIpToAnAddressMapRequest" }) as unknown as Schema.Schema<IpAddressManagementAddressMapsAddAnIpToAnAddressMapRequest>;

export interface IpAddressManagementAddressMapsAddAnIpToAnAddressMapResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const IpAddressManagementAddressMapsAddAnIpToAnAddressMapResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "IpAddressManagementAddressMapsAddAnIpToAnAddressMapResponse" }) as unknown as Schema.Schema<IpAddressManagementAddressMapsAddAnIpToAnAddressMapResponse>;

export const ipAddressManagementAddressMapsAddAnIpToAnAddressMap: (
  input: IpAddressManagementAddressMapsAddAnIpToAnAddressMapRequest
) => Effect.Effect<
  IpAddressManagementAddressMapsAddAnIpToAnAddressMapResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: IpAddressManagementAddressMapsAddAnIpToAnAddressMapRequest,
  output: IpAddressManagementAddressMapsAddAnIpToAnAddressMapResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapRequest {
  ip_address: string;
  address_map_id: string;
  account_id: string;
}

export const IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapRequest = Schema.Struct({
  ip_address: Schema.String.pipe(T.HttpPath("ip_address")),
  address_map_id: Schema.String.pipe(T.HttpPath("address_map_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/addressing/address_maps/{address_map_id}/ips/{ip_address}" }),
).annotations({ identifier: "IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapRequest" }) as unknown as Schema.Schema<IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapRequest>;

export interface IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapResponse" }) as unknown as Schema.Schema<IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapResponse>;

export const ipAddressManagementAddressMapsRemoveAnIpFromAnAddressMap: (
  input: IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapRequest
) => Effect.Effect<
  IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapRequest,
  output: IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapRequest {
  zone_id: string;
  address_map_id: string;
  account_id: string;
}

export const IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  address_map_id: Schema.String.pipe(T.HttpPath("address_map_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/addressing/address_maps/{address_map_id}/zones/{zone_id}" }),
).annotations({ identifier: "IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapRequest" }) as unknown as Schema.Schema<IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapRequest>;

export interface IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapResponse" }) as unknown as Schema.Schema<IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapResponse>;

export const ipAddressManagementAddressMapsAddAZoneMembershipToAnAddressMap: (
  input: IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapRequest
) => Effect.Effect<
  IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapRequest,
  output: IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapRequest {
  zone_id: string;
  address_map_id: string;
  account_id: string;
}

export const IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapRequest = Schema.Struct({
  zone_id: Schema.String.pipe(T.HttpPath("zone_id")),
  address_map_id: Schema.String.pipe(T.HttpPath("address_map_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/addressing/address_maps/{address_map_id}/zones/{zone_id}" }),
).annotations({ identifier: "IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapRequest" }) as unknown as Schema.Schema<IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapRequest>;

export interface IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapResponse" }) as unknown as Schema.Schema<IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapResponse>;

export const ipAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMap: (
  input: IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapRequest
) => Effect.Effect<
  IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapRequest,
  output: IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListLeasesRequest {
  account_id: string;
}

export const ListLeasesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/addressing/leases" }),
).annotations({ identifier: "ListLeasesRequest" }) as unknown as Schema.Schema<ListLeasesRequest>;

export interface ListLeasesResponse {
  result: { active_from?: string; cidrs?: string[]; created_at?: string; id?: string; modified_at?: string; owner_id?: string; purpose?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListLeasesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  active_from: Schema.optional(Schema.Date),
  cidrs: Schema.optional(Schema.Array(Schema.String)),
  created_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  modified_at: Schema.optional(Schema.Date),
  owner_id: Schema.optional(Schema.String),
  purpose: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListLeasesResponse" }) as unknown as Schema.Schema<ListLeasesResponse>;

export const listLeases: (
  input: ListLeasesRequest
) => Effect.Effect<
  ListLeasesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListLeasesRequest,
  output: ListLeasesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface IpAddressManagementPrefixesUploadLoaDocumentRequest {
  account_id: string;
  body: FormData;
}

export const IpAddressManagementPrefixesUploadLoaDocumentRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.instanceOf(FormData).pipe(T.HttpFormData())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/addressing/loa_documents" }),
).annotations({ identifier: "IpAddressManagementPrefixesUploadLoaDocumentRequest" }) as unknown as Schema.Schema<IpAddressManagementPrefixesUploadLoaDocumentRequest>;

export interface IpAddressManagementPrefixesUploadLoaDocumentResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const IpAddressManagementPrefixesUploadLoaDocumentResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "IpAddressManagementPrefixesUploadLoaDocumentResponse" }) as unknown as Schema.Schema<IpAddressManagementPrefixesUploadLoaDocumentResponse>;

export const ipAddressManagementPrefixesUploadLoaDocument: (
  input: IpAddressManagementPrefixesUploadLoaDocumentRequest
) => Effect.Effect<
  IpAddressManagementPrefixesUploadLoaDocumentResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: IpAddressManagementPrefixesUploadLoaDocumentRequest,
  output: IpAddressManagementPrefixesUploadLoaDocumentResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface IpAddressManagementPrefixesDownloadLoaDocumentRequest {
  loa_document_id: string;
  account_id: string;
}

export const IpAddressManagementPrefixesDownloadLoaDocumentRequest = Schema.Struct({
  loa_document_id: Schema.String.pipe(T.HttpPath("loa_document_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/addressing/loa_documents/{loa_document_id}/download" }),
).annotations({ identifier: "IpAddressManagementPrefixesDownloadLoaDocumentRequest" }) as unknown as Schema.Schema<IpAddressManagementPrefixesDownloadLoaDocumentRequest>;

export interface IpAddressManagementPrefixesDownloadLoaDocumentResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const IpAddressManagementPrefixesDownloadLoaDocumentResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "IpAddressManagementPrefixesDownloadLoaDocumentResponse" }) as unknown as Schema.Schema<IpAddressManagementPrefixesDownloadLoaDocumentResponse>;

export const ipAddressManagementPrefixesDownloadLoaDocument: (
  input: IpAddressManagementPrefixesDownloadLoaDocumentRequest
) => Effect.Effect<
  IpAddressManagementPrefixesDownloadLoaDocumentResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: IpAddressManagementPrefixesDownloadLoaDocumentRequest,
  output: IpAddressManagementPrefixesDownloadLoaDocumentResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListPrefixesRequest {
  account_id: string;
}

export const ListPrefixesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/addressing/prefixes" }),
).annotations({ identifier: "ListPrefixesRequest" }) as unknown as Schema.Schema<ListPrefixesRequest>;

export interface ListPrefixesResponse {
  result: { account_id?: string; advertised?: boolean; advertised_modified_at?: string; approved?: string; asn?: number; cidr?: string; created_at?: string; delegate_loa_creation?: boolean; description?: string; id?: string; irr_validation_state?: string; loa_document_id?: string; modified_at?: string; on_demand_enabled?: boolean; on_demand_locked?: boolean; ownership_validation_state?: string; ownership_validation_token?: string; rpki_validation_state?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListPrefixesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  account_id: Schema.optional(Schema.String),
  advertised: Schema.optional(Schema.Boolean),
  advertised_modified_at: Schema.optional(Schema.Date),
  approved: Schema.optional(Schema.String),
  asn: Schema.optional(Schema.Number),
  cidr: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  delegate_loa_creation: Schema.optional(Schema.Boolean),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  irr_validation_state: Schema.optional(Schema.String),
  loa_document_id: Schema.optional(Schema.String),
  modified_at: Schema.optional(Schema.Date),
  on_demand_enabled: Schema.optional(Schema.Boolean),
  on_demand_locked: Schema.optional(Schema.Boolean),
  ownership_validation_state: Schema.optional(Schema.String),
  ownership_validation_token: Schema.optional(Schema.String),
  rpki_validation_state: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListPrefixesResponse" }) as unknown as Schema.Schema<ListPrefixesResponse>;

export const listPrefixes: (
  input: ListPrefixesRequest
) => Effect.Effect<
  ListPrefixesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListPrefixesRequest,
  output: ListPrefixesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface IpAddressManagementPrefixesAddPrefixRequest {
  account_id: string;
  body: unknown;
}

export const IpAddressManagementPrefixesAddPrefixRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/addressing/prefixes" }),
).annotations({ identifier: "IpAddressManagementPrefixesAddPrefixRequest" }) as unknown as Schema.Schema<IpAddressManagementPrefixesAddPrefixRequest>;

export interface IpAddressManagementPrefixesAddPrefixResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const IpAddressManagementPrefixesAddPrefixResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "IpAddressManagementPrefixesAddPrefixResponse" }) as unknown as Schema.Schema<IpAddressManagementPrefixesAddPrefixResponse>;

export const ipAddressManagementPrefixesAddPrefix: (
  input: IpAddressManagementPrefixesAddPrefixRequest
) => Effect.Effect<
  IpAddressManagementPrefixesAddPrefixResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: IpAddressManagementPrefixesAddPrefixRequest,
  output: IpAddressManagementPrefixesAddPrefixResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface IpAddressManagementPrefixesPrefixDetailsRequest {
  prefix_id: string;
  account_id: string;
}

export const IpAddressManagementPrefixesPrefixDetailsRequest = Schema.Struct({
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}" }),
).annotations({ identifier: "IpAddressManagementPrefixesPrefixDetailsRequest" }) as unknown as Schema.Schema<IpAddressManagementPrefixesPrefixDetailsRequest>;

export interface IpAddressManagementPrefixesPrefixDetailsResponse {
  result: { account_id?: string; advertised?: boolean; advertised_modified_at?: string; approved?: string; asn?: number; cidr?: string; created_at?: string; delegate_loa_creation?: boolean; description?: string; id?: string; irr_validation_state?: string; loa_document_id?: string; modified_at?: string; on_demand_enabled?: boolean; on_demand_locked?: boolean; ownership_validation_state?: string; ownership_validation_token?: string; rpki_validation_state?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const IpAddressManagementPrefixesPrefixDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.optional(Schema.String),
  advertised: Schema.optional(Schema.Boolean),
  advertised_modified_at: Schema.optional(Schema.Date),
  approved: Schema.optional(Schema.String),
  asn: Schema.optional(Schema.Number),
  cidr: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  delegate_loa_creation: Schema.optional(Schema.Boolean),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  irr_validation_state: Schema.optional(Schema.String),
  loa_document_id: Schema.optional(Schema.String),
  modified_at: Schema.optional(Schema.Date),
  on_demand_enabled: Schema.optional(Schema.Boolean),
  on_demand_locked: Schema.optional(Schema.Boolean),
  ownership_validation_state: Schema.optional(Schema.String),
  ownership_validation_token: Schema.optional(Schema.String),
  rpki_validation_state: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "IpAddressManagementPrefixesPrefixDetailsResponse" }) as unknown as Schema.Schema<IpAddressManagementPrefixesPrefixDetailsResponse>;

export const ipAddressManagementPrefixesPrefixDetails: (
  input: IpAddressManagementPrefixesPrefixDetailsRequest
) => Effect.Effect<
  IpAddressManagementPrefixesPrefixDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: IpAddressManagementPrefixesPrefixDetailsRequest,
  output: IpAddressManagementPrefixesPrefixDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletePrefixRequest {
  prefix_id: string;
  account_id: string;
}

export const DeletePrefixRequest = Schema.Struct({
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}" }),
).annotations({ identifier: "DeletePrefixRequest" }) as unknown as Schema.Schema<DeletePrefixRequest>;

export interface DeletePrefixResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletePrefixResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletePrefixResponse" }) as unknown as Schema.Schema<DeletePrefixResponse>;

export const deletePrefix: (
  input: DeletePrefixRequest
) => Effect.Effect<
  DeletePrefixResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletePrefixRequest,
  output: DeletePrefixResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatePrefixDescriptionRequest {
  prefix_id: string;
  account_id: string;
  body: unknown;
}

export const UpdatePrefixDescriptionRequest = Schema.Struct({
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}" }),
).annotations({ identifier: "UpdatePrefixDescriptionRequest" }) as unknown as Schema.Schema<UpdatePrefixDescriptionRequest>;

export interface UpdatePrefixDescriptionResponse {
  result: { account_id?: string; advertised?: boolean; advertised_modified_at?: string; approved?: string; asn?: number; cidr?: string; created_at?: string; delegate_loa_creation?: boolean; description?: string; id?: string; irr_validation_state?: string; loa_document_id?: string; modified_at?: string; on_demand_enabled?: boolean; on_demand_locked?: boolean; ownership_validation_state?: string; ownership_validation_token?: string; rpki_validation_state?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatePrefixDescriptionResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.optional(Schema.String),
  advertised: Schema.optional(Schema.Boolean),
  advertised_modified_at: Schema.optional(Schema.Date),
  approved: Schema.optional(Schema.String),
  asn: Schema.optional(Schema.Number),
  cidr: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  delegate_loa_creation: Schema.optional(Schema.Boolean),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  irr_validation_state: Schema.optional(Schema.String),
  loa_document_id: Schema.optional(Schema.String),
  modified_at: Schema.optional(Schema.Date),
  on_demand_enabled: Schema.optional(Schema.Boolean),
  on_demand_locked: Schema.optional(Schema.Boolean),
  ownership_validation_state: Schema.optional(Schema.String),
  ownership_validation_token: Schema.optional(Schema.String),
  rpki_validation_state: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatePrefixDescriptionResponse" }) as unknown as Schema.Schema<UpdatePrefixDescriptionResponse>;

export const updatePrefixDescription: (
  input: UpdatePrefixDescriptionRequest
) => Effect.Effect<
  UpdatePrefixDescriptionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatePrefixDescriptionRequest,
  output: UpdatePrefixDescriptionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListBgpPrefixesRequest {
  account_id: string;
  prefix_id: string;
}

export const ListBgpPrefixesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}/bgp/prefixes" }),
).annotations({ identifier: "ListBgpPrefixesRequest" }) as unknown as Schema.Schema<ListBgpPrefixesRequest>;

export interface ListBgpPrefixesResponse {
  result: { asn?: number; asn_prepend_count?: number; auto_advertise_withdraw?: boolean; bgp_signal_opts?: { enabled?: boolean; modified_at?: string }; cidr?: string; created_at?: string; id?: string; modified_at?: string; on_demand?: { advertised?: boolean; advertised_modified_at?: string; on_demand_enabled?: boolean; on_demand_locked?: boolean } }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListBgpPrefixesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  asn: Schema.optional(Schema.Number),
  asn_prepend_count: Schema.optional(Schema.Number),
  auto_advertise_withdraw: Schema.optional(Schema.Boolean),
  bgp_signal_opts: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  modified_at: Schema.optional(Schema.Date)
})),
  cidr: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  modified_at: Schema.optional(Schema.Date),
  on_demand: Schema.optional(Schema.Struct({
  advertised: Schema.optional(Schema.Boolean),
  advertised_modified_at: Schema.optional(Schema.Date),
  on_demand_enabled: Schema.optional(Schema.Boolean),
  on_demand_locked: Schema.optional(Schema.Boolean)
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListBgpPrefixesResponse" }) as unknown as Schema.Schema<ListBgpPrefixesResponse>;

export const listBgpPrefixes: (
  input: ListBgpPrefixesRequest
) => Effect.Effect<
  ListBgpPrefixesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListBgpPrefixesRequest,
  output: ListBgpPrefixesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateBgpPrefixRequest {
  account_id: string;
  prefix_id: string;
  body: { cidr: string };
}

export const CreateBgpPrefixRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  body: Schema.Struct({
  cidr: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}/bgp/prefixes" }),
).annotations({ identifier: "CreateBgpPrefixRequest" }) as unknown as Schema.Schema<CreateBgpPrefixRequest>;

export interface CreateBgpPrefixResponse {
  result: { asn?: number; asn_prepend_count?: number; auto_advertise_withdraw?: boolean; bgp_signal_opts?: { enabled?: boolean; modified_at?: string }; cidr?: string; created_at?: string; id?: string; modified_at?: string; on_demand?: { advertised?: boolean; advertised_modified_at?: string; on_demand_enabled?: boolean; on_demand_locked?: boolean } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateBgpPrefixResponse = Schema.Struct({
  result: Schema.Struct({
  asn: Schema.optional(Schema.Number),
  asn_prepend_count: Schema.optional(Schema.Number),
  auto_advertise_withdraw: Schema.optional(Schema.Boolean),
  bgp_signal_opts: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  modified_at: Schema.optional(Schema.Date)
})),
  cidr: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  modified_at: Schema.optional(Schema.Date),
  on_demand: Schema.optional(Schema.Struct({
  advertised: Schema.optional(Schema.Boolean),
  advertised_modified_at: Schema.optional(Schema.Date),
  on_demand_enabled: Schema.optional(Schema.Boolean),
  on_demand_locked: Schema.optional(Schema.Boolean)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateBgpPrefixResponse" }) as unknown as Schema.Schema<CreateBgpPrefixResponse>;

export const createBgpPrefix: (
  input: CreateBgpPrefixRequest
) => Effect.Effect<
  CreateBgpPrefixResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateBgpPrefixRequest,
  output: CreateBgpPrefixResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface IpAddressManagementPrefixesFetchBgpPrefixRequest {
  account_id: string;
  prefix_id: string;
  bgp_prefix_id: string;
}

export const IpAddressManagementPrefixesFetchBgpPrefixRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  bgp_prefix_id: Schema.String.pipe(T.HttpPath("bgp_prefix_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}/bgp/prefixes/{bgp_prefix_id}" }),
).annotations({ identifier: "IpAddressManagementPrefixesFetchBgpPrefixRequest" }) as unknown as Schema.Schema<IpAddressManagementPrefixesFetchBgpPrefixRequest>;

export interface IpAddressManagementPrefixesFetchBgpPrefixResponse {
  result: { asn?: number; asn_prepend_count?: number; auto_advertise_withdraw?: boolean; bgp_signal_opts?: { enabled?: boolean; modified_at?: string }; cidr?: string; created_at?: string; id?: string; modified_at?: string; on_demand?: { advertised?: boolean; advertised_modified_at?: string; on_demand_enabled?: boolean; on_demand_locked?: boolean } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const IpAddressManagementPrefixesFetchBgpPrefixResponse = Schema.Struct({
  result: Schema.Struct({
  asn: Schema.optional(Schema.Number),
  asn_prepend_count: Schema.optional(Schema.Number),
  auto_advertise_withdraw: Schema.optional(Schema.Boolean),
  bgp_signal_opts: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  modified_at: Schema.optional(Schema.Date)
})),
  cidr: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  modified_at: Schema.optional(Schema.Date),
  on_demand: Schema.optional(Schema.Struct({
  advertised: Schema.optional(Schema.Boolean),
  advertised_modified_at: Schema.optional(Schema.Date),
  on_demand_enabled: Schema.optional(Schema.Boolean),
  on_demand_locked: Schema.optional(Schema.Boolean)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "IpAddressManagementPrefixesFetchBgpPrefixResponse" }) as unknown as Schema.Schema<IpAddressManagementPrefixesFetchBgpPrefixResponse>;

export const ipAddressManagementPrefixesFetchBgpPrefix: (
  input: IpAddressManagementPrefixesFetchBgpPrefixRequest
) => Effect.Effect<
  IpAddressManagementPrefixesFetchBgpPrefixResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: IpAddressManagementPrefixesFetchBgpPrefixRequest,
  output: IpAddressManagementPrefixesFetchBgpPrefixResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteBgpPrefixRequest {
  account_id: string;
  prefix_id: string;
  bgp_prefix_id: string;
}

export const DeleteBgpPrefixRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  bgp_prefix_id: Schema.String.pipe(T.HttpPath("bgp_prefix_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}/bgp/prefixes/{bgp_prefix_id}" }),
).annotations({ identifier: "DeleteBgpPrefixRequest" }) as unknown as Schema.Schema<DeleteBgpPrefixRequest>;

export interface DeleteBgpPrefixResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteBgpPrefixResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteBgpPrefixResponse" }) as unknown as Schema.Schema<DeleteBgpPrefixResponse>;

export const deleteBgpPrefix: (
  input: DeleteBgpPrefixRequest
) => Effect.Effect<
  DeleteBgpPrefixResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteBgpPrefixRequest,
  output: DeleteBgpPrefixResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateBgpPrefixRequest {
  account_id: string;
  prefix_id: string;
  bgp_prefix_id: string;
  body: { asn_prepend_count?: number; auto_advertise_withdraw?: boolean; on_demand?: { advertised?: boolean } };
}

export const UpdateBgpPrefixRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  bgp_prefix_id: Schema.String.pipe(T.HttpPath("bgp_prefix_id")),
  body: Schema.Struct({
  asn_prepend_count: Schema.optional(Schema.Number),
  auto_advertise_withdraw: Schema.optional(Schema.Boolean),
  on_demand: Schema.optional(Schema.Struct({
  advertised: Schema.optional(Schema.Boolean)
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}/bgp/prefixes/{bgp_prefix_id}" }),
).annotations({ identifier: "UpdateBgpPrefixRequest" }) as unknown as Schema.Schema<UpdateBgpPrefixRequest>;

export interface UpdateBgpPrefixResponse {
  result: { asn?: number; asn_prepend_count?: number; auto_advertise_withdraw?: boolean; bgp_signal_opts?: { enabled?: boolean; modified_at?: string }; cidr?: string; created_at?: string; id?: string; modified_at?: string; on_demand?: { advertised?: boolean; advertised_modified_at?: string; on_demand_enabled?: boolean; on_demand_locked?: boolean } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateBgpPrefixResponse = Schema.Struct({
  result: Schema.Struct({
  asn: Schema.optional(Schema.Number),
  asn_prepend_count: Schema.optional(Schema.Number),
  auto_advertise_withdraw: Schema.optional(Schema.Boolean),
  bgp_signal_opts: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  modified_at: Schema.optional(Schema.Date)
})),
  cidr: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  modified_at: Schema.optional(Schema.Date),
  on_demand: Schema.optional(Schema.Struct({
  advertised: Schema.optional(Schema.Boolean),
  advertised_modified_at: Schema.optional(Schema.Date),
  on_demand_enabled: Schema.optional(Schema.Boolean),
  on_demand_locked: Schema.optional(Schema.Boolean)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateBgpPrefixResponse" }) as unknown as Schema.Schema<UpdateBgpPrefixResponse>;

export const updateBgpPrefix: (
  input: UpdateBgpPrefixRequest
) => Effect.Effect<
  UpdateBgpPrefixResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateBgpPrefixRequest,
  output: UpdateBgpPrefixResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAdvertisementStatusRequest {
  prefix_id: string;
  account_id: string;
}

export const GetAdvertisementStatusRequest = Schema.Struct({
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}/bgp/status" }),
).annotations({ identifier: "GetAdvertisementStatusRequest" }) as unknown as Schema.Schema<GetAdvertisementStatusRequest>;

export interface GetAdvertisementStatusResponse {
  result: { advertised?: boolean; advertised_modified_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAdvertisementStatusResponse = Schema.Struct({
  result: Schema.Struct({
  advertised: Schema.optional(Schema.Boolean),
  advertised_modified_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAdvertisementStatusResponse" }) as unknown as Schema.Schema<GetAdvertisementStatusResponse>;

export const getAdvertisementStatus: (
  input: GetAdvertisementStatusRequest
) => Effect.Effect<
  GetAdvertisementStatusResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAdvertisementStatusRequest,
  output: GetAdvertisementStatusResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatePrefixDynamicAdvertisementStatusRequest {
  prefix_id: string;
  account_id: string;
  body: unknown;
}

export const UpdatePrefixDynamicAdvertisementStatusRequest = Schema.Struct({
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}/bgp/status" }),
).annotations({ identifier: "UpdatePrefixDynamicAdvertisementStatusRequest" }) as unknown as Schema.Schema<UpdatePrefixDynamicAdvertisementStatusRequest>;

export interface UpdatePrefixDynamicAdvertisementStatusResponse {
  result: { advertised?: boolean; advertised_modified_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatePrefixDynamicAdvertisementStatusResponse = Schema.Struct({
  result: Schema.Struct({
  advertised: Schema.optional(Schema.Boolean),
  advertised_modified_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatePrefixDynamicAdvertisementStatusResponse" }) as unknown as Schema.Schema<UpdatePrefixDynamicAdvertisementStatusResponse>;

export const updatePrefixDynamicAdvertisementStatus: (
  input: UpdatePrefixDynamicAdvertisementStatusRequest
) => Effect.Effect<
  UpdatePrefixDynamicAdvertisementStatusResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatePrefixDynamicAdvertisementStatusRequest,
  output: UpdatePrefixDynamicAdvertisementStatusResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListServiceBindingsRequest {
  account_id: string;
  prefix_id: string;
}

export const ListServiceBindingsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}/bindings" }),
).annotations({ identifier: "ListServiceBindingsRequest" }) as unknown as Schema.Schema<ListServiceBindingsRequest>;

export interface ListServiceBindingsResponse {
  result: { cidr?: string; id?: string; provisioning?: { state?: "provisioning" | "active" }; service_id?: string; service_name?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListServiceBindingsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  cidr: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  provisioning: Schema.optional(Schema.Struct({
  state: Schema.optional(Schema.Literal("provisioning", "active"))
})),
  service_id: Schema.optional(Schema.String),
  service_name: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListServiceBindingsResponse" }) as unknown as Schema.Schema<ListServiceBindingsResponse>;

export const listServiceBindings: (
  input: ListServiceBindingsRequest
) => Effect.Effect<
  ListServiceBindingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListServiceBindingsRequest,
  output: ListServiceBindingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateServiceBindingRequest {
  account_id: string;
  prefix_id: string;
  body: { cidr: string; service_id: string };
}

export const CreateServiceBindingRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  body: Schema.Struct({
  cidr: Schema.String,
  service_id: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}/bindings" }),
).annotations({ identifier: "CreateServiceBindingRequest" }) as unknown as Schema.Schema<CreateServiceBindingRequest>;

export interface CreateServiceBindingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateServiceBindingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateServiceBindingResponse" }) as unknown as Schema.Schema<CreateServiceBindingResponse>;

export const createServiceBinding: (
  input: CreateServiceBindingRequest
) => Effect.Effect<
  CreateServiceBindingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateServiceBindingRequest,
  output: CreateServiceBindingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetServiceBindingRequest {
  account_id: string;
  prefix_id: string;
  binding_id: string;
}

export const GetServiceBindingRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  binding_id: Schema.String.pipe(T.HttpPath("binding_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}/bindings/{binding_id}" }),
).annotations({ identifier: "GetServiceBindingRequest" }) as unknown as Schema.Schema<GetServiceBindingRequest>;

export interface GetServiceBindingResponse {
  result: { cidr?: string; id?: string; provisioning?: { state?: "provisioning" | "active" }; service_id?: string; service_name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetServiceBindingResponse = Schema.Struct({
  result: Schema.Struct({
  cidr: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  provisioning: Schema.optional(Schema.Struct({
  state: Schema.optional(Schema.Literal("provisioning", "active"))
})),
  service_id: Schema.optional(Schema.String),
  service_name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetServiceBindingResponse" }) as unknown as Schema.Schema<GetServiceBindingResponse>;

export const getServiceBinding: (
  input: GetServiceBindingRequest
) => Effect.Effect<
  GetServiceBindingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetServiceBindingRequest,
  output: GetServiceBindingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteServiceBindingRequest {
  account_id: string;
  prefix_id: string;
  binding_id: string;
}

export const DeleteServiceBindingRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  binding_id: Schema.String.pipe(T.HttpPath("binding_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}/bindings/{binding_id}" }),
).annotations({ identifier: "DeleteServiceBindingRequest" }) as unknown as Schema.Schema<DeleteServiceBindingRequest>;

export interface DeleteServiceBindingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteServiceBindingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteServiceBindingResponse" }) as unknown as Schema.Schema<DeleteServiceBindingResponse>;

export const deleteServiceBinding: (
  input: DeleteServiceBindingRequest
) => Effect.Effect<
  DeleteServiceBindingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteServiceBindingRequest,
  output: DeleteServiceBindingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListPrefixDelegationsRequest {
  prefix_id: string;
  account_id: string;
}

export const ListPrefixDelegationsRequest = Schema.Struct({
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}/delegations" }),
).annotations({ identifier: "ListPrefixDelegationsRequest" }) as unknown as Schema.Schema<ListPrefixDelegationsRequest>;

export interface ListPrefixDelegationsResponse {
  result: { cidr?: string; created_at?: string; delegated_account_id?: string; id?: string; modified_at?: string; parent_prefix_id?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListPrefixDelegationsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  cidr: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  delegated_account_id: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_at: Schema.optional(Schema.Date),
  parent_prefix_id: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListPrefixDelegationsResponse" }) as unknown as Schema.Schema<ListPrefixDelegationsResponse>;

export const listPrefixDelegations: (
  input: ListPrefixDelegationsRequest
) => Effect.Effect<
  ListPrefixDelegationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListPrefixDelegationsRequest,
  output: ListPrefixDelegationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatePrefixDelegationRequest {
  prefix_id: string;
  account_id: string;
  body: unknown;
}

export const CreatePrefixDelegationRequest = Schema.Struct({
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}/delegations" }),
).annotations({ identifier: "CreatePrefixDelegationRequest" }) as unknown as Schema.Schema<CreatePrefixDelegationRequest>;

export interface CreatePrefixDelegationResponse {
  result: { cidr?: string; created_at?: string; delegated_account_id?: string; id?: string; modified_at?: string; parent_prefix_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatePrefixDelegationResponse = Schema.Struct({
  result: Schema.Struct({
  cidr: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  delegated_account_id: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  modified_at: Schema.optional(Schema.Date),
  parent_prefix_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatePrefixDelegationResponse" }) as unknown as Schema.Schema<CreatePrefixDelegationResponse>;

export const createPrefixDelegation: (
  input: CreatePrefixDelegationRequest
) => Effect.Effect<
  CreatePrefixDelegationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatePrefixDelegationRequest,
  output: CreatePrefixDelegationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletePrefixDelegationRequest {
  delegation_id: string;
  prefix_id: string;
  account_id: string;
}

export const DeletePrefixDelegationRequest = Schema.Struct({
  delegation_id: Schema.String.pipe(T.HttpPath("delegation_id")),
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}/delegations/{delegation_id}" }),
).annotations({ identifier: "DeletePrefixDelegationRequest" }) as unknown as Schema.Schema<DeletePrefixDelegationRequest>;

export interface DeletePrefixDelegationResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletePrefixDelegationResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletePrefixDelegationResponse" }) as unknown as Schema.Schema<DeletePrefixDelegationResponse>;

export const deletePrefixDelegation: (
  input: DeletePrefixDelegationRequest
) => Effect.Effect<
  DeletePrefixDelegationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletePrefixDelegationRequest,
  output: DeletePrefixDelegationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface IpAddressManagementPrefixesValidatePrefixRequest {
  prefix_id: string;
  account_id: string;
}

export const IpAddressManagementPrefixesValidatePrefixRequest = Schema.Struct({
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/addressing/prefixes/{prefix_id}/validate" }),
).annotations({ identifier: "IpAddressManagementPrefixesValidatePrefixRequest" }) as unknown as Schema.Schema<IpAddressManagementPrefixesValidatePrefixRequest>;

export interface IpAddressManagementPrefixesValidatePrefixResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const IpAddressManagementPrefixesValidatePrefixResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "IpAddressManagementPrefixesValidatePrefixResponse" }) as unknown as Schema.Schema<IpAddressManagementPrefixesValidatePrefixResponse>;

export const ipAddressManagementPrefixesValidatePrefix: (
  input: IpAddressManagementPrefixesValidatePrefixRequest
) => Effect.Effect<
  IpAddressManagementPrefixesValidatePrefixResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: IpAddressManagementPrefixesValidatePrefixRequest,
  output: IpAddressManagementPrefixesValidatePrefixResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListRegionsRequest {
}

export const ListRegionsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/addressing/regional_hostnames/regions" }),
).annotations({ identifier: "ListRegionsRequest" }) as unknown as Schema.Schema<ListRegionsRequest>;

export interface ListRegionsResponse {
  result: { key?: string; label?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListRegionsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  key: Schema.optional(Schema.String),
  label: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListRegionsResponse" }) as unknown as Schema.Schema<ListRegionsResponse>;

export const listRegions: (
  input: ListRegionsRequest
) => Effect.Effect<
  ListRegionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListRegionsRequest,
  output: ListRegionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListServicesRequest {
  account_id: string;
}

export const ListServicesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/addressing/services" }),
).annotations({ identifier: "ListServicesRequest" }) as unknown as Schema.Schema<ListServicesRequest>;

export interface ListServicesResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListServicesResponse = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListServicesResponse" }) as unknown as Schema.Schema<ListServicesResponse>;

export const listServices: (
  input: ListServicesRequest
) => Effect.Effect<
  ListServicesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListServicesRequest,
  output: ListServicesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListEvaluatorsRequest {
  account_id: string;
  page?: number;
  per_page?: number;
  order_by?: string;
  order_by_direction?: "asc" | "desc";
}

export const ListEvaluatorsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order_by: Schema.optional(Schema.String).pipe(T.HttpQuery("order_by")),
  order_by_direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("order_by_direction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/evaluation-types" }),
).annotations({ identifier: "ListEvaluatorsRequest" }) as unknown as Schema.Schema<ListEvaluatorsRequest>;

export interface ListEvaluatorsResponse {
  result: { created_at: string; description: string; enable: boolean; id: string; mandatory: boolean; modified_at: string; name: string; type: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListEvaluatorsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.Date,
  description: Schema.String,
  enable: Schema.Boolean,
  id: Schema.String,
  mandatory: Schema.Boolean,
  modified_at: Schema.Date,
  name: Schema.String,
  type: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListEvaluatorsResponse" }) as unknown as Schema.Schema<ListEvaluatorsResponse>;

export const listEvaluators: (
  input: ListEvaluatorsRequest
) => Effect.Effect<
  ListEvaluatorsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListEvaluatorsRequest,
  output: ListEvaluatorsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListGatewayRequest {
  account_id: string;
  page?: number;
  per_page?: number;
  search?: string;
}

export const ListGatewayRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways" }),
).annotations({ identifier: "ListGatewayRequest" }) as unknown as Schema.Schema<ListGatewayRequest>;

export interface ListGatewayResponse {
  result: { account_id: string; account_tag: string; authentication?: boolean; cache_invalidate_on_update: boolean; cache_ttl: number; collect_logs: boolean; created_at: string; dlp?: unknown; id: string; internal_id: string; log_management?: number; log_management_strategy?: "STOP_INSERTING" | "DELETE_OLDEST"; logpush?: boolean; logpush_public_key?: string; modified_at: string; otel?: { authorization: string; headers: Record<string, unknown>; url: string }[]; rate_limiting_interval: number; rate_limiting_limit: number; rate_limiting_technique: "fixed" | "sliding"; store_id?: string; stripe?: { authorization: string; usage_events: { payload: string }[] }; zdr?: boolean }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListGatewayResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  authentication: Schema.optional(Schema.Boolean),
  cache_invalidate_on_update: Schema.Boolean,
  cache_ttl: Schema.Number,
  collect_logs: Schema.Boolean,
  created_at: Schema.Date,
  dlp: Schema.optional(Schema.Union(Schema.Struct({
  action: Schema.Literal("BLOCK", "FLAG"),
  enabled: Schema.Boolean,
  profiles: Schema.Array(Schema.String)
}), Schema.Struct({
  enabled: Schema.Boolean,
  policies: Schema.Array(Schema.Struct({
  action: Schema.Literal("FLAG", "BLOCK"),
  check: Schema.Array(Schema.Literal("REQUEST", "RESPONSE")),
  enabled: Schema.Boolean,
  id: Schema.String,
  profiles: Schema.Array(Schema.String)
}))
}))),
  id: Schema.String,
  internal_id: Schema.UUID,
  log_management: Schema.optional(Schema.Number),
  log_management_strategy: Schema.optional(Schema.Literal("STOP_INSERTING", "DELETE_OLDEST")),
  logpush: Schema.optional(Schema.Boolean),
  logpush_public_key: Schema.optional(Schema.String),
  modified_at: Schema.Date,
  otel: Schema.optional(Schema.Array(Schema.Struct({
  authorization: Schema.String,
  headers: Schema.Record({ key: Schema.String, value: Schema.String }),
  url: Schema.String
}))),
  rate_limiting_interval: Schema.Number,
  rate_limiting_limit: Schema.Number,
  rate_limiting_technique: Schema.Literal("fixed", "sliding"),
  store_id: Schema.optional(Schema.String),
  stripe: Schema.optional(Schema.Struct({
  authorization: Schema.String,
  usage_events: Schema.Array(Schema.Struct({
  payload: Schema.String
}))
})),
  zdr: Schema.optional(Schema.Boolean)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListGatewayResponse" }) as unknown as Schema.Schema<ListGatewayResponse>;

export const listGateway: (
  input: ListGatewayRequest
) => Effect.Effect<
  ListGatewayResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListGatewayRequest,
  output: ListGatewayResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateGatewayRequest {
  account_id: string;
  body: { authentication?: boolean; cache_invalidate_on_update: boolean; cache_ttl: number; collect_logs: boolean; id: string; log_management?: number; log_management_strategy?: "STOP_INSERTING" | "DELETE_OLDEST"; logpush?: boolean; logpush_public_key?: string; rate_limiting_interval: number; rate_limiting_limit: number; rate_limiting_technique: "fixed" | "sliding"; zdr?: boolean };
}

export const CreateGatewayRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  authentication: Schema.optional(Schema.Boolean),
  cache_invalidate_on_update: Schema.Boolean,
  cache_ttl: Schema.Number,
  collect_logs: Schema.Boolean,
  id: Schema.String,
  log_management: Schema.optional(Schema.Number),
  log_management_strategy: Schema.optional(Schema.Literal("STOP_INSERTING", "DELETE_OLDEST")),
  logpush: Schema.optional(Schema.Boolean),
  logpush_public_key: Schema.optional(Schema.String),
  rate_limiting_interval: Schema.Number,
  rate_limiting_limit: Schema.Number,
  rate_limiting_technique: Schema.Literal("fixed", "sliding"),
  zdr: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai-gateway/gateways" }),
).annotations({ identifier: "CreateGatewayRequest" }) as unknown as Schema.Schema<CreateGatewayRequest>;

export interface CreateGatewayResponse {
  result: { account_id: string; account_tag: string; authentication?: boolean; cache_invalidate_on_update: boolean; cache_ttl: number; collect_logs: boolean; created_at: string; dlp?: unknown; id: string; internal_id: string; log_management?: number; log_management_strategy?: "STOP_INSERTING" | "DELETE_OLDEST"; logpush?: boolean; logpush_public_key?: string; modified_at: string; otel?: { authorization: string; headers: Record<string, unknown>; url: string }[]; rate_limiting_interval: number; rate_limiting_limit: number; rate_limiting_technique: "fixed" | "sliding"; store_id?: string; stripe?: { authorization: string; usage_events: { payload: string }[] }; zdr?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateGatewayResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  authentication: Schema.optional(Schema.Boolean),
  cache_invalidate_on_update: Schema.Boolean,
  cache_ttl: Schema.Number,
  collect_logs: Schema.Boolean,
  created_at: Schema.Date,
  dlp: Schema.optional(Schema.Union(Schema.Struct({
  action: Schema.Literal("BLOCK", "FLAG"),
  enabled: Schema.Boolean,
  profiles: Schema.Array(Schema.String)
}), Schema.Struct({
  enabled: Schema.Boolean,
  policies: Schema.Array(Schema.Struct({
  action: Schema.Literal("FLAG", "BLOCK"),
  check: Schema.Array(Schema.Literal("REQUEST", "RESPONSE")),
  enabled: Schema.Boolean,
  id: Schema.String,
  profiles: Schema.Array(Schema.String)
}))
}))),
  id: Schema.String,
  internal_id: Schema.UUID,
  log_management: Schema.optional(Schema.Number),
  log_management_strategy: Schema.optional(Schema.Literal("STOP_INSERTING", "DELETE_OLDEST")),
  logpush: Schema.optional(Schema.Boolean),
  logpush_public_key: Schema.optional(Schema.String),
  modified_at: Schema.Date,
  otel: Schema.optional(Schema.Array(Schema.Struct({
  authorization: Schema.String,
  headers: Schema.Record({ key: Schema.String, value: Schema.String }),
  url: Schema.String
}))),
  rate_limiting_interval: Schema.Number,
  rate_limiting_limit: Schema.Number,
  rate_limiting_technique: Schema.Literal("fixed", "sliding"),
  store_id: Schema.optional(Schema.String),
  stripe: Schema.optional(Schema.Struct({
  authorization: Schema.String,
  usage_events: Schema.Array(Schema.Struct({
  payload: Schema.String
}))
})),
  zdr: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateGatewayResponse" }) as unknown as Schema.Schema<CreateGatewayResponse>;

export const createGateway: (
  input: CreateGatewayRequest
) => Effect.Effect<
  CreateGatewayResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateGatewayRequest,
  output: CreateGatewayResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDatasetRequest {
  account_id: string;
  gateway_id: string;
  page?: number;
  per_page?: number;
  name?: string;
  enable?: boolean;
  search?: string;
}

export const ListDatasetRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  enable: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("enable")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/datasets" }),
).annotations({ identifier: "ListDatasetRequest" }) as unknown as Schema.Schema<ListDatasetRequest>;

export interface ListDatasetResponse {
  result: { account_id: string; account_tag: string; created_at: string; enable: boolean; filters: { key: "created_at" | "request_content_type" | "response_content_type" | "success" | "cached" | "provider" | "model" | "cost" | "tokens" | "tokens_in" | "tokens_out" | "duration" | "feedback"; operator: "eq" | "contains" | "lt" | "gt"; value: unknown[] }[]; gateway_id: string; id: string; modified_at: string; name: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDatasetResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  created_at: Schema.Date,
  enable: Schema.Boolean,
  filters: Schema.Array(Schema.Struct({
  key: Schema.Literal("created_at", "request_content_type", "response_content_type", "success", "cached", "provider", "model", "cost", "tokens", "tokens_in", "tokens_out", "duration", "feedback"),
  operator: Schema.Literal("eq", "contains", "lt", "gt"),
  value: Schema.Array(Schema.Union(Schema.String, Schema.Number, Schema.Boolean))
})),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDatasetResponse" }) as unknown as Schema.Schema<ListDatasetResponse>;

export const listDataset: (
  input: ListDatasetRequest
) => Effect.Effect<
  ListDatasetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDatasetRequest,
  output: ListDatasetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateDatasetRequest {
  gateway_id: string;
  account_id: string;
  body: { enable: boolean; filters: { key: "created_at" | "request_content_type" | "response_content_type" | "success" | "cached" | "provider" | "model" | "cost" | "tokens" | "tokens_in" | "tokens_out" | "duration" | "feedback"; operator: "eq" | "contains" | "lt" | "gt"; value: unknown[] }[]; name: string };
}

export const CreateDatasetRequest = Schema.Struct({
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  enable: Schema.Boolean,
  filters: Schema.Array(Schema.Struct({
  key: Schema.Literal("created_at", "request_content_type", "response_content_type", "success", "cached", "provider", "model", "cost", "tokens", "tokens_in", "tokens_out", "duration", "feedback"),
  operator: Schema.Literal("eq", "contains", "lt", "gt"),
  value: Schema.Array(Schema.Union(Schema.String, Schema.Number, Schema.Boolean))
})),
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/datasets" }),
).annotations({ identifier: "CreateDatasetRequest" }) as unknown as Schema.Schema<CreateDatasetRequest>;

export interface CreateDatasetResponse {
  result: { account_id: string; account_tag: string; created_at: string; enable: boolean; filters: { key: "created_at" | "request_content_type" | "response_content_type" | "success" | "cached" | "provider" | "model" | "cost" | "tokens" | "tokens_in" | "tokens_out" | "duration" | "feedback"; operator: "eq" | "contains" | "lt" | "gt"; value: unknown[] }[]; gateway_id: string; id: string; modified_at: string; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateDatasetResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  created_at: Schema.Date,
  enable: Schema.Boolean,
  filters: Schema.Array(Schema.Struct({
  key: Schema.Literal("created_at", "request_content_type", "response_content_type", "success", "cached", "provider", "model", "cost", "tokens", "tokens_in", "tokens_out", "duration", "feedback"),
  operator: Schema.Literal("eq", "contains", "lt", "gt"),
  value: Schema.Array(Schema.Union(Schema.String, Schema.Number, Schema.Boolean))
})),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateDatasetResponse" }) as unknown as Schema.Schema<CreateDatasetResponse>;

export const createDataset: (
  input: CreateDatasetRequest
) => Effect.Effect<
  CreateDatasetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDatasetRequest,
  output: CreateDatasetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AigConfigFetchDatasetRequest {
  account_id: string;
  gateway_id: string;
  id: string;
}

export const AigConfigFetchDatasetRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  id: Schema.String.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/datasets/{id}" }),
).annotations({ identifier: "AigConfigFetchDatasetRequest" }) as unknown as Schema.Schema<AigConfigFetchDatasetRequest>;

export interface AigConfigFetchDatasetResponse {
  result: { account_id: string; account_tag: string; created_at: string; enable: boolean; filters: { key: "created_at" | "request_content_type" | "response_content_type" | "success" | "cached" | "provider" | "model" | "cost" | "tokens" | "tokens_in" | "tokens_out" | "duration" | "feedback"; operator: "eq" | "contains" | "lt" | "gt"; value: unknown[] }[]; gateway_id: string; id: string; modified_at: string; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AigConfigFetchDatasetResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  created_at: Schema.Date,
  enable: Schema.Boolean,
  filters: Schema.Array(Schema.Struct({
  key: Schema.Literal("created_at", "request_content_type", "response_content_type", "success", "cached", "provider", "model", "cost", "tokens", "tokens_in", "tokens_out", "duration", "feedback"),
  operator: Schema.Literal("eq", "contains", "lt", "gt"),
  value: Schema.Array(Schema.Union(Schema.String, Schema.Number, Schema.Boolean))
})),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AigConfigFetchDatasetResponse" }) as unknown as Schema.Schema<AigConfigFetchDatasetResponse>;

export const aigConfigFetchDataset: (
  input: AigConfigFetchDatasetRequest
) => Effect.Effect<
  AigConfigFetchDatasetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AigConfigFetchDatasetRequest,
  output: AigConfigFetchDatasetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateDatasetRequest {
  account_id: string;
  gateway_id: string;
  id: string;
  body: { enable: boolean; filters: { key: "created_at" | "request_content_type" | "response_content_type" | "success" | "cached" | "provider" | "model" | "cost" | "tokens" | "tokens_in" | "tokens_out" | "duration" | "feedback"; operator: "eq" | "contains" | "lt" | "gt"; value: unknown[] }[]; name: string };
}

export const UpdateDatasetRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  id: Schema.String.pipe(T.HttpPath("id")),
  body: Schema.Struct({
  enable: Schema.Boolean,
  filters: Schema.Array(Schema.Struct({
  key: Schema.Literal("created_at", "request_content_type", "response_content_type", "success", "cached", "provider", "model", "cost", "tokens", "tokens_in", "tokens_out", "duration", "feedback"),
  operator: Schema.Literal("eq", "contains", "lt", "gt"),
  value: Schema.Array(Schema.Union(Schema.String, Schema.Number, Schema.Boolean))
})),
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/datasets/{id}" }),
).annotations({ identifier: "UpdateDatasetRequest" }) as unknown as Schema.Schema<UpdateDatasetRequest>;

export interface UpdateDatasetResponse {
  result: { account_id: string; account_tag: string; created_at: string; enable: boolean; filters: { key: "created_at" | "request_content_type" | "response_content_type" | "success" | "cached" | "provider" | "model" | "cost" | "tokens" | "tokens_in" | "tokens_out" | "duration" | "feedback"; operator: "eq" | "contains" | "lt" | "gt"; value: unknown[] }[]; gateway_id: string; id: string; modified_at: string; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateDatasetResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  created_at: Schema.Date,
  enable: Schema.Boolean,
  filters: Schema.Array(Schema.Struct({
  key: Schema.Literal("created_at", "request_content_type", "response_content_type", "success", "cached", "provider", "model", "cost", "tokens", "tokens_in", "tokens_out", "duration", "feedback"),
  operator: Schema.Literal("eq", "contains", "lt", "gt"),
  value: Schema.Array(Schema.Union(Schema.String, Schema.Number, Schema.Boolean))
})),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateDatasetResponse" }) as unknown as Schema.Schema<UpdateDatasetResponse>;

export const updateDataset: (
  input: UpdateDatasetRequest
) => Effect.Effect<
  UpdateDatasetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDatasetRequest,
  output: UpdateDatasetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDatasetRequest {
  account_id: string;
  gateway_id: string;
  id: string;
}

export const DeleteDatasetRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  id: Schema.String.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/datasets/{id}" }),
).annotations({ identifier: "DeleteDatasetRequest" }) as unknown as Schema.Schema<DeleteDatasetRequest>;

export interface DeleteDatasetResponse {
  result: { account_id: string; account_tag: string; created_at: string; enable: boolean; filters: { key: "created_at" | "request_content_type" | "response_content_type" | "success" | "cached" | "provider" | "model" | "cost" | "tokens" | "tokens_in" | "tokens_out" | "duration" | "feedback"; operator: "eq" | "contains" | "lt" | "gt"; value: unknown[] }[]; gateway_id: string; id: string; modified_at: string; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDatasetResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  created_at: Schema.Date,
  enable: Schema.Boolean,
  filters: Schema.Array(Schema.Struct({
  key: Schema.Literal("created_at", "request_content_type", "response_content_type", "success", "cached", "provider", "model", "cost", "tokens", "tokens_in", "tokens_out", "duration", "feedback"),
  operator: Schema.Literal("eq", "contains", "lt", "gt"),
  value: Schema.Array(Schema.Union(Schema.String, Schema.Number, Schema.Boolean))
})),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDatasetResponse" }) as unknown as Schema.Schema<DeleteDatasetResponse>;

export const deleteDataset: (
  input: DeleteDatasetRequest
) => Effect.Effect<
  DeleteDatasetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDatasetRequest,
  output: DeleteDatasetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListEvaluationsRequest {
  account_id: string;
  gateway_id: string;
  page?: number;
  per_page?: number;
  name?: string;
  processed?: boolean;
  search?: string;
}

export const ListEvaluationsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  processed: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("processed")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/evaluations" }),
).annotations({ identifier: "ListEvaluationsRequest" }) as unknown as Schema.Schema<ListEvaluationsRequest>;

export interface ListEvaluationsResponse {
  result: { account_id: string; account_tag: string; created_at: string; datasets: { account_id: string; account_tag: string; created_at: string; enable: boolean; filters: { key: "created_at" | "request_content_type" | "response_content_type" | "success" | "cached" | "provider" | "model" | "cost" | "tokens" | "tokens_in" | "tokens_out" | "duration" | "feedback"; operator: "eq" | "contains" | "lt" | "gt"; value: unknown[] }[]; gateway_id: string; id: string; modified_at: string; name: string }[]; gateway_id: string; id: string; modified_at: string; name: string; processed: boolean; results: { created_at: string; evaluation_id: string; evaluation_type_id: string; id: string; modified_at: string; result: string; status: number; status_description: string; total_logs: number }[]; total_logs: number }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListEvaluationsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  created_at: Schema.Date,
  datasets: Schema.Array(Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  created_at: Schema.Date,
  enable: Schema.Boolean,
  filters: Schema.Array(Schema.Struct({
  key: Schema.Literal("created_at", "request_content_type", "response_content_type", "success", "cached", "provider", "model", "cost", "tokens", "tokens_in", "tokens_out", "duration", "feedback"),
  operator: Schema.Literal("eq", "contains", "lt", "gt"),
  value: Schema.Array(Schema.Union(Schema.String, Schema.Number, Schema.Boolean))
})),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String
})),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  processed: Schema.Boolean,
  results: Schema.Array(Schema.Struct({
  created_at: Schema.Date,
  evaluation_id: Schema.String,
  evaluation_type_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  result: Schema.String,
  status: Schema.Number,
  status_description: Schema.String,
  total_logs: Schema.Number
})),
  total_logs: Schema.Number
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListEvaluationsResponse" }) as unknown as Schema.Schema<ListEvaluationsResponse>;

export const listEvaluations: (
  input: ListEvaluationsRequest
) => Effect.Effect<
  ListEvaluationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListEvaluationsRequest,
  output: ListEvaluationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateEvaluationsRequest {
  gateway_id: string;
  account_id: string;
  body: { dataset_ids: string[]; evaluation_type_ids: string[]; name: string };
}

export const CreateEvaluationsRequest = Schema.Struct({
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  dataset_ids: Schema.Array(Schema.String),
  evaluation_type_ids: Schema.Array(Schema.String),
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/evaluations" }),
).annotations({ identifier: "CreateEvaluationsRequest" }) as unknown as Schema.Schema<CreateEvaluationsRequest>;

export interface CreateEvaluationsResponse {
  result: { account_id: string; account_tag: string; created_at: string; datasets: { account_id: string; account_tag: string; created_at: string; enable: boolean; filters: { key: "created_at" | "request_content_type" | "response_content_type" | "success" | "cached" | "provider" | "model" | "cost" | "tokens" | "tokens_in" | "tokens_out" | "duration" | "feedback"; operator: "eq" | "contains" | "lt" | "gt"; value: unknown[] }[]; gateway_id: string; id: string; modified_at: string; name: string }[]; gateway_id: string; id: string; modified_at: string; name: string; processed: boolean; results: { created_at: string; evaluation_id: string; evaluation_type_id: string; id: string; modified_at: string; result: string; status: number; status_description: string; total_logs: number }[]; total_logs: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateEvaluationsResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  created_at: Schema.Date,
  datasets: Schema.Array(Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  created_at: Schema.Date,
  enable: Schema.Boolean,
  filters: Schema.Array(Schema.Struct({
  key: Schema.Literal("created_at", "request_content_type", "response_content_type", "success", "cached", "provider", "model", "cost", "tokens", "tokens_in", "tokens_out", "duration", "feedback"),
  operator: Schema.Literal("eq", "contains", "lt", "gt"),
  value: Schema.Array(Schema.Union(Schema.String, Schema.Number, Schema.Boolean))
})),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String
})),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  processed: Schema.Boolean,
  results: Schema.Array(Schema.Struct({
  created_at: Schema.Date,
  evaluation_id: Schema.String,
  evaluation_type_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  result: Schema.String,
  status: Schema.Number,
  status_description: Schema.String,
  total_logs: Schema.Number
})),
  total_logs: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateEvaluationsResponse" }) as unknown as Schema.Schema<CreateEvaluationsResponse>;

export const createEvaluations: (
  input: CreateEvaluationsRequest
) => Effect.Effect<
  CreateEvaluationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateEvaluationsRequest,
  output: CreateEvaluationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AigConfigFetchEvaluationsRequest {
  account_id: string;
  gateway_id: string;
  id: string;
}

export const AigConfigFetchEvaluationsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  id: Schema.String.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/evaluations/{id}" }),
).annotations({ identifier: "AigConfigFetchEvaluationsRequest" }) as unknown as Schema.Schema<AigConfigFetchEvaluationsRequest>;

export interface AigConfigFetchEvaluationsResponse {
  result: { account_id: string; account_tag: string; created_at: string; datasets: { account_id: string; account_tag: string; created_at: string; enable: boolean; filters: { key: "created_at" | "request_content_type" | "response_content_type" | "success" | "cached" | "provider" | "model" | "cost" | "tokens" | "tokens_in" | "tokens_out" | "duration" | "feedback"; operator: "eq" | "contains" | "lt" | "gt"; value: unknown[] }[]; gateway_id: string; id: string; modified_at: string; name: string }[]; gateway_id: string; id: string; modified_at: string; name: string; processed: boolean; results: { created_at: string; evaluation_id: string; evaluation_type_id: string; id: string; modified_at: string; result: string; status: number; status_description: string; total_logs: number }[]; total_logs: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AigConfigFetchEvaluationsResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  created_at: Schema.Date,
  datasets: Schema.Array(Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  created_at: Schema.Date,
  enable: Schema.Boolean,
  filters: Schema.Array(Schema.Struct({
  key: Schema.Literal("created_at", "request_content_type", "response_content_type", "success", "cached", "provider", "model", "cost", "tokens", "tokens_in", "tokens_out", "duration", "feedback"),
  operator: Schema.Literal("eq", "contains", "lt", "gt"),
  value: Schema.Array(Schema.Union(Schema.String, Schema.Number, Schema.Boolean))
})),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String
})),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  processed: Schema.Boolean,
  results: Schema.Array(Schema.Struct({
  created_at: Schema.Date,
  evaluation_id: Schema.String,
  evaluation_type_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  result: Schema.String,
  status: Schema.Number,
  status_description: Schema.String,
  total_logs: Schema.Number
})),
  total_logs: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AigConfigFetchEvaluationsResponse" }) as unknown as Schema.Schema<AigConfigFetchEvaluationsResponse>;

export const aigConfigFetchEvaluations: (
  input: AigConfigFetchEvaluationsRequest
) => Effect.Effect<
  AigConfigFetchEvaluationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AigConfigFetchEvaluationsRequest,
  output: AigConfigFetchEvaluationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteEvaluationsRequest {
  account_id: string;
  gateway_id: string;
  id: string;
}

export const DeleteEvaluationsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  id: Schema.String.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/evaluations/{id}" }),
).annotations({ identifier: "DeleteEvaluationsRequest" }) as unknown as Schema.Schema<DeleteEvaluationsRequest>;

export interface DeleteEvaluationsResponse {
  result: { account_id: string; account_tag: string; created_at: string; datasets: { account_id: string; account_tag: string; created_at: string; enable: boolean; filters: { key: "created_at" | "request_content_type" | "response_content_type" | "success" | "cached" | "provider" | "model" | "cost" | "tokens" | "tokens_in" | "tokens_out" | "duration" | "feedback"; operator: "eq" | "contains" | "lt" | "gt"; value: unknown[] }[]; gateway_id: string; id: string; modified_at: string; name: string }[]; gateway_id: string; id: string; modified_at: string; name: string; processed: boolean; results: { created_at: string; evaluation_id: string; evaluation_type_id: string; id: string; modified_at: string; result: string; status: number; status_description: string; total_logs: number }[]; total_logs: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteEvaluationsResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  created_at: Schema.Date,
  datasets: Schema.Array(Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  created_at: Schema.Date,
  enable: Schema.Boolean,
  filters: Schema.Array(Schema.Struct({
  key: Schema.Literal("created_at", "request_content_type", "response_content_type", "success", "cached", "provider", "model", "cost", "tokens", "tokens_in", "tokens_out", "duration", "feedback"),
  operator: Schema.Literal("eq", "contains", "lt", "gt"),
  value: Schema.Array(Schema.Union(Schema.String, Schema.Number, Schema.Boolean))
})),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String
})),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  processed: Schema.Boolean,
  results: Schema.Array(Schema.Struct({
  created_at: Schema.Date,
  evaluation_id: Schema.String,
  evaluation_type_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  result: Schema.String,
  status: Schema.Number,
  status_description: Schema.String,
  total_logs: Schema.Number
})),
  total_logs: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteEvaluationsResponse" }) as unknown as Schema.Schema<DeleteEvaluationsResponse>;

export const deleteEvaluations: (
  input: DeleteEvaluationsRequest
) => Effect.Effect<
  DeleteEvaluationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteEvaluationsRequest,
  output: DeleteEvaluationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListGatewayLogsRequest {
  account_id: string;
  gateway_id: string;
  search?: string;
  page?: number;
  per_page?: number;
  order_by?: "created_at" | "provider" | "model" | "model_type" | "success" | "cached";
  order_by_direction?: "asc" | "desc";
  filters?: { key: "id" | "created_at" | "request_content_type" | "response_content_type" | "request_type" | "success" | "cached" | "provider" | "model" | "model_type" | "cost" | "tokens" | "tokens_in" | "tokens_out" | "duration" | "feedback" | "event_id" | "metadata.key" | "metadata.value" | "prompts.prompt_id" | "prompts.version_id" | "authentication" | "wholesale" | "compatibilityMode" | "dlp_action"; operator: "eq" | "neq" | "contains" | "lt" | "gt"; value: unknown[] }[];
  meta_info?: boolean;
  direction?: "asc" | "desc";
  start_date?: string;
  end_date?: string;
  min_cost?: number;
  max_cost?: number;
  min_tokens_in?: number;
  max_tokens_in?: number;
  min_tokens_out?: number;
  max_tokens_out?: number;
  min_total_tokens?: number;
  max_total_tokens?: number;
  min_duration?: number;
  max_duration?: number;
  feedback?: unknown;
  success?: boolean;
  cached?: boolean;
  model?: string;
  model_type?: string;
  provider?: string;
  request_content_type?: string;
  response_content_type?: string;
}

export const ListGatewayLogsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order_by: Schema.optional(Schema.Literal("created_at", "provider", "model", "model_type", "success", "cached")).pipe(T.HttpQuery("order_by")),
  order_by_direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("order_by_direction")),
  filters: Schema.optional(Schema.Array(Schema.Struct({
  key: Schema.Literal("id", "created_at", "request_content_type", "response_content_type", "request_type", "success", "cached", "provider", "model", "model_type", "cost", "tokens", "tokens_in", "tokens_out", "duration", "feedback", "event_id", "metadata.key", "metadata.value", "prompts.prompt_id", "prompts.version_id", "authentication", "wholesale", "compatibilityMode", "dlp_action"),
  operator: Schema.Literal("eq", "neq", "contains", "lt", "gt"),
  value: Schema.Array(Schema.Union(Schema.String, Schema.Number, Schema.Boolean))
}))).pipe(T.HttpQuery("filters")),
  meta_info: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("meta_info")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction")),
  start_date: Schema.optional(Schema.Date).pipe(T.HttpQuery("start_date")),
  end_date: Schema.optional(Schema.Date).pipe(T.HttpQuery("end_date")),
  min_cost: Schema.optional(Schema.Number).pipe(T.HttpQuery("min_cost")),
  max_cost: Schema.optional(Schema.Number).pipe(T.HttpQuery("max_cost")),
  min_tokens_in: Schema.optional(Schema.Number).pipe(T.HttpQuery("min_tokens_in")),
  max_tokens_in: Schema.optional(Schema.Number).pipe(T.HttpQuery("max_tokens_in")),
  min_tokens_out: Schema.optional(Schema.Number).pipe(T.HttpQuery("min_tokens_out")),
  max_tokens_out: Schema.optional(Schema.Number).pipe(T.HttpQuery("max_tokens_out")),
  min_total_tokens: Schema.optional(Schema.Number).pipe(T.HttpQuery("min_total_tokens")),
  max_total_tokens: Schema.optional(Schema.Number).pipe(T.HttpQuery("max_total_tokens")),
  min_duration: Schema.optional(Schema.Number).pipe(T.HttpQuery("min_duration")),
  max_duration: Schema.optional(Schema.Number).pipe(T.HttpQuery("max_duration")),
  feedback: Schema.optional(Schema.Union(Schema.Literal(-1), Schema.Literal(0), Schema.Literal(1))).pipe(T.HttpQuery("feedback")),
  success: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("success")),
  cached: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("cached")),
  model: Schema.optional(Schema.String).pipe(T.HttpQuery("model")),
  model_type: Schema.optional(Schema.String).pipe(T.HttpQuery("model_type")),
  provider: Schema.optional(Schema.String).pipe(T.HttpQuery("provider")),
  request_content_type: Schema.optional(Schema.String).pipe(T.HttpQuery("request_content_type")),
  response_content_type: Schema.optional(Schema.String).pipe(T.HttpQuery("response_content_type"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/logs" }),
).annotations({ identifier: "ListGatewayLogsRequest" }) as unknown as Schema.Schema<ListGatewayLogsRequest>;

export interface ListGatewayLogsResponse {
  result: { cached: boolean; cost?: number; created_at: string; custom_cost?: boolean; duration: number; id: string; metadata?: string; model: string; model_type?: string; path: string; provider: string; request_content_type?: string; request_type?: string; response_content_type?: string; status_code?: number; step?: number; success: boolean; tokens_in: number; tokens_out: number }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListGatewayLogsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  cached: Schema.Boolean,
  cost: Schema.optional(Schema.Number),
  created_at: Schema.Date,
  custom_cost: Schema.optional(Schema.Boolean),
  duration: Schema.Number,
  id: Schema.String,
  metadata: Schema.optional(Schema.String),
  model: Schema.String,
  model_type: Schema.optional(Schema.String),
  path: Schema.String,
  provider: Schema.String,
  request_content_type: Schema.optional(Schema.String),
  request_type: Schema.optional(Schema.String),
  response_content_type: Schema.optional(Schema.String),
  status_code: Schema.optional(Schema.Number),
  step: Schema.optional(Schema.Number),
  success: Schema.Boolean,
  tokens_in: Schema.Number,
  tokens_out: Schema.Number
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListGatewayLogsResponse" }) as unknown as Schema.Schema<ListGatewayLogsResponse>;

export const listGatewayLogs: (
  input: ListGatewayLogsRequest
) => Effect.Effect<
  ListGatewayLogsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListGatewayLogsRequest,
  output: ListGatewayLogsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteGatewayLogsRequest {
  account_id: string;
  gateway_id: string;
  order_by?: "created_at" | "provider" | "model" | "model_type" | "success" | "cached" | "cost" | "tokens_in" | "tokens_out" | "duration" | "feedback";
  order_by_direction?: "asc" | "desc";
  filters?: { key: "id" | "created_at" | "request_content_type" | "response_content_type" | "request_type" | "success" | "cached" | "provider" | "model" | "model_type" | "cost" | "tokens" | "tokens_in" | "tokens_out" | "duration" | "feedback" | "event_id" | "metadata.key" | "metadata.value" | "prompts.prompt_id" | "prompts.version_id" | "authentication" | "wholesale" | "compatibilityMode" | "dlp_action"; operator: "eq" | "neq" | "contains" | "lt" | "gt"; value: unknown[] }[];
  limit?: number;
}

export const DeleteGatewayLogsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  order_by: Schema.optional(Schema.Literal("created_at", "provider", "model", "model_type", "success", "cached", "cost", "tokens_in", "tokens_out", "duration", "feedback")).pipe(T.HttpQuery("order_by")),
  order_by_direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("order_by_direction")),
  filters: Schema.optional(Schema.Array(Schema.Struct({
  key: Schema.Literal("id", "created_at", "request_content_type", "response_content_type", "request_type", "success", "cached", "provider", "model", "model_type", "cost", "tokens", "tokens_in", "tokens_out", "duration", "feedback", "event_id", "metadata.key", "metadata.value", "prompts.prompt_id", "prompts.version_id", "authentication", "wholesale", "compatibilityMode", "dlp_action"),
  operator: Schema.Literal("eq", "neq", "contains", "lt", "gt"),
  value: Schema.Array(Schema.Union(Schema.String, Schema.Number, Schema.Boolean))
}))).pipe(T.HttpQuery("filters")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/logs" }),
).annotations({ identifier: "DeleteGatewayLogsRequest" }) as unknown as Schema.Schema<DeleteGatewayLogsRequest>;

export interface DeleteGatewayLogsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteGatewayLogsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteGatewayLogsResponse" }) as unknown as Schema.Schema<DeleteGatewayLogsResponse>;

export const deleteGatewayLogs: (
  input: DeleteGatewayLogsRequest
) => Effect.Effect<
  DeleteGatewayLogsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteGatewayLogsRequest,
  output: DeleteGatewayLogsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetGatewayLogDetailRequest {
  id: string;
  gateway_id: string;
  account_id: string;
}

export const GetGatewayLogDetailRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/logs/{id}" }),
).annotations({ identifier: "GetGatewayLogDetailRequest" }) as unknown as Schema.Schema<GetGatewayLogDetailRequest>;

export interface GetGatewayLogDetailResponse {
  result: { cached: boolean; cost?: number; created_at: string; custom_cost?: boolean; duration: number; id: string; metadata?: string; model: string; model_type?: string; path: string; provider: string; request_content_type?: string; request_head?: string; request_head_complete?: boolean; request_size?: number; request_type?: string; response_content_type?: string; response_head?: string; response_head_complete?: boolean; response_size?: number; status_code?: number; step?: number; success: boolean; tokens_in: number; tokens_out: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetGatewayLogDetailResponse = Schema.Struct({
  result: Schema.Struct({
  cached: Schema.Boolean,
  cost: Schema.optional(Schema.Number),
  created_at: Schema.Date,
  custom_cost: Schema.optional(Schema.Boolean),
  duration: Schema.Number,
  id: Schema.String,
  metadata: Schema.optional(Schema.String),
  model: Schema.String,
  model_type: Schema.optional(Schema.String),
  path: Schema.String,
  provider: Schema.String,
  request_content_type: Schema.optional(Schema.String),
  request_head: Schema.optional(Schema.String),
  request_head_complete: Schema.optional(Schema.Boolean),
  request_size: Schema.optional(Schema.Number),
  request_type: Schema.optional(Schema.String),
  response_content_type: Schema.optional(Schema.String),
  response_head: Schema.optional(Schema.String),
  response_head_complete: Schema.optional(Schema.Boolean),
  response_size: Schema.optional(Schema.Number),
  status_code: Schema.optional(Schema.Number),
  step: Schema.optional(Schema.Number),
  success: Schema.Boolean,
  tokens_in: Schema.Number,
  tokens_out: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetGatewayLogDetailResponse" }) as unknown as Schema.Schema<GetGatewayLogDetailResponse>;

export const getGatewayLogDetail: (
  input: GetGatewayLogDetailRequest
) => Effect.Effect<
  GetGatewayLogDetailResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGatewayLogDetailRequest,
  output: GetGatewayLogDetailResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchGatewayLogRequest {
  id: string;
  gateway_id: string;
  account_id: string;
  body: { feedback?: number; metadata?: Record<string, unknown>; score?: number };
}

export const PatchGatewayLogRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  feedback: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Union(Schema.String, Schema.Number, Schema.Boolean) })),
  score: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/logs/{id}" }),
).annotations({ identifier: "PatchGatewayLogRequest" }) as unknown as Schema.Schema<PatchGatewayLogRequest>;

export interface PatchGatewayLogResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchGatewayLogResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchGatewayLogResponse" }) as unknown as Schema.Schema<PatchGatewayLogResponse>;

export const patchGatewayLog: (
  input: PatchGatewayLogRequest
) => Effect.Effect<
  PatchGatewayLogResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchGatewayLogRequest,
  output: PatchGatewayLogResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetGatewayLogRequestRequest {
  id: string;
  gateway_id: string;
  account_id: string;
}

export const GetGatewayLogRequestRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/logs/{id}/request" }),
).annotations({ identifier: "GetGatewayLogRequestRequest" }) as unknown as Schema.Schema<GetGatewayLogRequestRequest>;

export interface GetGatewayLogRequestResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetGatewayLogRequestResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetGatewayLogRequestResponse" }) as unknown as Schema.Schema<GetGatewayLogRequestResponse>;

export const getGatewayLogRequest: (
  input: GetGatewayLogRequestRequest
) => Effect.Effect<
  GetGatewayLogRequestResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGatewayLogRequestRequest,
  output: GetGatewayLogRequestResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetGatewayLogResponseRequest {
  id: string;
  gateway_id: string;
  account_id: string;
}

export const GetGatewayLogResponseRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/logs/{id}/response" }),
).annotations({ identifier: "GetGatewayLogResponseRequest" }) as unknown as Schema.Schema<GetGatewayLogResponseRequest>;

export interface GetGatewayLogResponseResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetGatewayLogResponseResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetGatewayLogResponseResponse" }) as unknown as Schema.Schema<GetGatewayLogResponseResponse>;

export const getGatewayLogResponse: (
  input: GetGatewayLogResponseRequest
) => Effect.Effect<
  GetGatewayLogResponseResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGatewayLogResponseRequest,
  output: GetGatewayLogResponseResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListProvidersRequest {
  account_id: string;
  gateway_id: string;
  page?: number;
  per_page?: number;
}

export const ListProvidersRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/provider_configs" }),
).annotations({ identifier: "ListProvidersRequest" }) as unknown as Schema.Schema<ListProvidersRequest>;

export interface ListProvidersResponse {
  result: { account_id: string; account_tag: string; alias: string; default_config: boolean; gateway_id: string; id: string; modified_at: string; provider_slug: string; rate_limit?: number; rate_limit_period?: number; secret_id: string; secret_preview: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListProvidersResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  alias: Schema.String,
  default_config: Schema.Boolean,
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  provider_slug: Schema.String,
  rate_limit: Schema.optional(Schema.Number),
  rate_limit_period: Schema.optional(Schema.Number),
  secret_id: Schema.String,
  secret_preview: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListProvidersResponse" }) as unknown as Schema.Schema<ListProvidersResponse>;

export const listProviders: (
  input: ListProvidersRequest
) => Effect.Effect<
  ListProvidersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListProvidersRequest,
  output: ListProvidersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateProvidersRequest {
  account_id: string;
  gateway_id: string;
  body: { alias: string; default_config: boolean; provider_slug: string; rate_limit?: number; rate_limit_period?: number; secret: string; secret_id: string };
}

export const CreateProvidersRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  body: Schema.Struct({
  alias: Schema.String,
  default_config: Schema.Boolean,
  provider_slug: Schema.String,
  rate_limit: Schema.optional(Schema.Number),
  rate_limit_period: Schema.optional(Schema.Number),
  secret: Schema.String,
  secret_id: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/provider_configs" }),
).annotations({ identifier: "CreateProvidersRequest" }) as unknown as Schema.Schema<CreateProvidersRequest>;

export interface CreateProvidersResponse {
  result: { account_id: string; account_tag: string; alias: string; default_config: boolean; gateway_id: string; id: string; modified_at: string; provider_slug: string; rate_limit?: number; rate_limit_period?: number; secret_id: string; secret_preview: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateProvidersResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  alias: Schema.String,
  default_config: Schema.Boolean,
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  provider_slug: Schema.String,
  rate_limit: Schema.optional(Schema.Number),
  rate_limit_period: Schema.optional(Schema.Number),
  secret_id: Schema.String,
  secret_preview: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateProvidersResponse" }) as unknown as Schema.Schema<CreateProvidersResponse>;

export const createProviders: (
  input: CreateProvidersRequest
) => Effect.Effect<
  CreateProvidersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateProvidersRequest,
  output: CreateProvidersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateProvidersRequest {
  account_id: string;
  gateway_id: string;
  id: string;
  body: { secret: string };
}

export const UpdateProvidersRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  id: Schema.String.pipe(T.HttpPath("id")),
  body: Schema.Struct({
  secret: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/provider_configs/{id}" }),
).annotations({ identifier: "UpdateProvidersRequest" }) as unknown as Schema.Schema<UpdateProvidersRequest>;

export interface UpdateProvidersResponse {
  result: { account_id: string; account_tag: string; alias: string; default_config: boolean; gateway_id: string; id: string; modified_at: string; provider_slug: string; rate_limit?: number; rate_limit_period?: number; secret_id: string; secret_preview: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateProvidersResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  alias: Schema.String,
  default_config: Schema.Boolean,
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  provider_slug: Schema.String,
  rate_limit: Schema.optional(Schema.Number),
  rate_limit_period: Schema.optional(Schema.Number),
  secret_id: Schema.String,
  secret_preview: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateProvidersResponse" }) as unknown as Schema.Schema<UpdateProvidersResponse>;

export const updateProviders: (
  input: UpdateProvidersRequest
) => Effect.Effect<
  UpdateProvidersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateProvidersRequest,
  output: UpdateProvidersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteProvidersRequest {
  account_id: string;
  gateway_id: string;
  id: string;
}

export const DeleteProvidersRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  id: Schema.String.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/provider_configs/{id}" }),
).annotations({ identifier: "DeleteProvidersRequest" }) as unknown as Schema.Schema<DeleteProvidersRequest>;

export interface DeleteProvidersResponse {
  result: { account_id: string; account_tag: string; alias: string; default_config: boolean; gateway_id: string; id: string; modified_at: string; provider_slug: string; rate_limit?: number; rate_limit_period?: number; secret_id: string; secret_preview: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteProvidersResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  alias: Schema.String,
  default_config: Schema.Boolean,
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  provider_slug: Schema.String,
  rate_limit: Schema.optional(Schema.Number),
  rate_limit_period: Schema.optional(Schema.Number),
  secret_id: Schema.String,
  secret_preview: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteProvidersResponse" }) as unknown as Schema.Schema<DeleteProvidersResponse>;

export const deleteProviders: (
  input: DeleteProvidersRequest
) => Effect.Effect<
  DeleteProvidersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteProvidersRequest,
  output: DeleteProvidersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListGatewayDynamicRoutesRequest {
  account_id: string;
  gateway_id: string;
}

export const ListGatewayDynamicRoutesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/routes" }),
).annotations({ identifier: "ListGatewayDynamicRoutesRequest" }) as unknown as Schema.Schema<ListGatewayDynamicRoutesRequest>;

export interface ListGatewayDynamicRoutesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListGatewayDynamicRoutesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListGatewayDynamicRoutesResponse" }) as unknown as Schema.Schema<ListGatewayDynamicRoutesResponse>;

export const listGatewayDynamicRoutes: (
  input: ListGatewayDynamicRoutesRequest
) => Effect.Effect<
  ListGatewayDynamicRoutesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListGatewayDynamicRoutesRequest,
  output: ListGatewayDynamicRoutesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostGatewayDynamicRouteRequest {
  account_id: string;
  gateway_id: string;
  body: { elements: unknown[]; name: string };
}

export const PostGatewayDynamicRouteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  body: Schema.Struct({
  elements: Schema.Array(Schema.Union(Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  next: Schema.Struct({
  elementId: Schema.String
})
}),
  type: Schema.Literal("start")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  false: Schema.Struct({
  elementId: Schema.String
}),
  true: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  conditions: Schema.optional(Schema.Struct({}))
}),
  type: Schema.Literal("conditional")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Record({ key: Schema.String, value: Schema.Struct({
  elementId: Schema.String
}) }),
  type: Schema.Literal("percentage")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  fallback: Schema.Struct({
  elementId: Schema.String
}),
  success: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  key: Schema.String,
  limit: Schema.Number,
  limitType: Schema.Literal("count", "cost"),
  window: Schema.Number
}),
  type: Schema.Literal("rate")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  fallback: Schema.Struct({
  elementId: Schema.String
}),
  success: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  model: Schema.String,
  provider: Schema.String,
  retries: Schema.Number,
  timeout: Schema.Number
}),
  type: Schema.Literal("model")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Record({ key: Schema.String, value: Schema.Struct({
  elementId: Schema.String
}) }),
  type: Schema.Literal("end")
}))),
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/routes" }),
).annotations({ identifier: "PostGatewayDynamicRouteRequest" }) as unknown as Schema.Schema<PostGatewayDynamicRouteRequest>;

export interface PostGatewayDynamicRouteResponse {
  result: { account_tag: string; created_at: string; deployment: { comment?: string; created_at: string; deployment_id: string; version_id: string }; elements: unknown[]; gateway_id: string; id: string; modified_at: string; name: string; version: { active: "true" | "false"; comment?: string; created_at: string; data: string; version_id: string } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostGatewayDynamicRouteResponse = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.String,
  created_at: Schema.Date,
  deployment: Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.String,
  deployment_id: Schema.String,
  version_id: Schema.String
}),
  elements: Schema.Array(Schema.Union(Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  next: Schema.Struct({
  elementId: Schema.String
})
}),
  type: Schema.Literal("start")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  false: Schema.Struct({
  elementId: Schema.String
}),
  true: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  conditions: Schema.optional(Schema.Struct({}))
}),
  type: Schema.Literal("conditional")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Record({ key: Schema.String, value: Schema.Struct({
  elementId: Schema.String
}) }),
  type: Schema.Literal("percentage")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  fallback: Schema.Struct({
  elementId: Schema.String
}),
  success: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  key: Schema.String,
  limit: Schema.Number,
  limitType: Schema.Literal("count", "cost"),
  window: Schema.Number
}),
  type: Schema.Literal("rate")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  fallback: Schema.Struct({
  elementId: Schema.String
}),
  success: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  model: Schema.String,
  provider: Schema.String,
  retries: Schema.Number,
  timeout: Schema.Number
}),
  type: Schema.Literal("model")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Record({ key: Schema.String, value: Schema.Struct({
  elementId: Schema.String
}) }),
  type: Schema.Literal("end")
}))),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  version: Schema.Struct({
  active: Schema.Literal("true", "false"),
  comment: Schema.optional(Schema.String),
  created_at: Schema.String,
  data: Schema.String,
  version_id: Schema.String
})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostGatewayDynamicRouteResponse" }) as unknown as Schema.Schema<PostGatewayDynamicRouteResponse>;

export const postGatewayDynamicRoute: (
  input: PostGatewayDynamicRouteRequest
) => Effect.Effect<
  PostGatewayDynamicRouteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostGatewayDynamicRouteRequest,
  output: PostGatewayDynamicRouteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetGatewayDynamicRouteRequest {
  account_id: string;
  gateway_id: string;
  id: string;
}

export const GetGatewayDynamicRouteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  id: Schema.String.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/routes/{id}" }),
).annotations({ identifier: "GetGatewayDynamicRouteRequest" }) as unknown as Schema.Schema<GetGatewayDynamicRouteRequest>;

export interface GetGatewayDynamicRouteResponse {
  result: { account_tag: string; created_at: string; deployment: { comment?: string; created_at: string; deployment_id: string; version_id: string }; elements: unknown[]; gateway_id: string; id: string; modified_at: string; name: string; version: { active: "true" | "false"; comment?: string; created_at: string; data: string; version_id: string } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetGatewayDynamicRouteResponse = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.String,
  created_at: Schema.Date,
  deployment: Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.String,
  deployment_id: Schema.String,
  version_id: Schema.String
}),
  elements: Schema.Array(Schema.Union(Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  next: Schema.Struct({
  elementId: Schema.String
})
}),
  type: Schema.Literal("start")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  false: Schema.Struct({
  elementId: Schema.String
}),
  true: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  conditions: Schema.optional(Schema.Struct({}))
}),
  type: Schema.Literal("conditional")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Record({ key: Schema.String, value: Schema.Struct({
  elementId: Schema.String
}) }),
  type: Schema.Literal("percentage")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  fallback: Schema.Struct({
  elementId: Schema.String
}),
  success: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  key: Schema.String,
  limit: Schema.Number,
  limitType: Schema.Literal("count", "cost"),
  window: Schema.Number
}),
  type: Schema.Literal("rate")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  fallback: Schema.Struct({
  elementId: Schema.String
}),
  success: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  model: Schema.String,
  provider: Schema.String,
  retries: Schema.Number,
  timeout: Schema.Number
}),
  type: Schema.Literal("model")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Record({ key: Schema.String, value: Schema.Struct({
  elementId: Schema.String
}) }),
  type: Schema.Literal("end")
}))),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  version: Schema.Struct({
  active: Schema.Literal("true", "false"),
  comment: Schema.optional(Schema.String),
  created_at: Schema.String,
  data: Schema.String,
  version_id: Schema.String
})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetGatewayDynamicRouteResponse" }) as unknown as Schema.Schema<GetGatewayDynamicRouteResponse>;

export const getGatewayDynamicRoute: (
  input: GetGatewayDynamicRouteRequest
) => Effect.Effect<
  GetGatewayDynamicRouteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGatewayDynamicRouteRequest,
  output: GetGatewayDynamicRouteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteGatewayDynamicRouteRequest {
  account_id: string;
  gateway_id: string;
  id: string;
}

export const DeleteGatewayDynamicRouteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  id: Schema.String.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/routes/{id}" }),
).annotations({ identifier: "DeleteGatewayDynamicRouteRequest" }) as unknown as Schema.Schema<DeleteGatewayDynamicRouteRequest>;

export interface DeleteGatewayDynamicRouteResponse {
  result: { account_tag: string; created_at: string; elements: unknown[]; gateway_id: string; id: string; modified_at: string; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteGatewayDynamicRouteResponse = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.String,
  created_at: Schema.Date,
  elements: Schema.Array(Schema.Union(Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  next: Schema.Struct({
  elementId: Schema.String
})
}),
  type: Schema.Literal("start")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  false: Schema.Struct({
  elementId: Schema.String
}),
  true: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  conditions: Schema.optional(Schema.Struct({}))
}),
  type: Schema.Literal("conditional")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Record({ key: Schema.String, value: Schema.Struct({
  elementId: Schema.String
}) }),
  type: Schema.Literal("percentage")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  fallback: Schema.Struct({
  elementId: Schema.String
}),
  success: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  key: Schema.String,
  limit: Schema.Number,
  limitType: Schema.Literal("count", "cost"),
  window: Schema.Number
}),
  type: Schema.Literal("rate")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  fallback: Schema.Struct({
  elementId: Schema.String
}),
  success: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  model: Schema.String,
  provider: Schema.String,
  retries: Schema.Number,
  timeout: Schema.Number
}),
  type: Schema.Literal("model")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Record({ key: Schema.String, value: Schema.Struct({
  elementId: Schema.String
}) }),
  type: Schema.Literal("end")
}))),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteGatewayDynamicRouteResponse" }) as unknown as Schema.Schema<DeleteGatewayDynamicRouteResponse>;

export const deleteGatewayDynamicRoute: (
  input: DeleteGatewayDynamicRouteRequest
) => Effect.Effect<
  DeleteGatewayDynamicRouteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteGatewayDynamicRouteRequest,
  output: DeleteGatewayDynamicRouteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateGatewayDynamicRouteRequest {
  account_id: string;
  gateway_id: string;
  id: string;
  body: { name: string };
}

export const UpdateGatewayDynamicRouteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  id: Schema.String.pipe(T.HttpPath("id")),
  body: Schema.Struct({
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/routes/{id}" }),
).annotations({ identifier: "UpdateGatewayDynamicRouteRequest" }) as unknown as Schema.Schema<UpdateGatewayDynamicRouteRequest>;

export interface UpdateGatewayDynamicRouteResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateGatewayDynamicRouteResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateGatewayDynamicRouteResponse" }) as unknown as Schema.Schema<UpdateGatewayDynamicRouteResponse>;

export const updateGatewayDynamicRoute: (
  input: UpdateGatewayDynamicRouteRequest
) => Effect.Effect<
  UpdateGatewayDynamicRouteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateGatewayDynamicRouteRequest,
  output: UpdateGatewayDynamicRouteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListGatewayDynamicRouteDeploymentsRequest {
  account_id: string;
  gateway_id: string;
  id: string;
}

export const ListGatewayDynamicRouteDeploymentsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  id: Schema.String.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/routes/{id}/deployments" }),
).annotations({ identifier: "ListGatewayDynamicRouteDeploymentsRequest" }) as unknown as Schema.Schema<ListGatewayDynamicRouteDeploymentsRequest>;

export interface ListGatewayDynamicRouteDeploymentsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListGatewayDynamicRouteDeploymentsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListGatewayDynamicRouteDeploymentsResponse" }) as unknown as Schema.Schema<ListGatewayDynamicRouteDeploymentsResponse>;

export const listGatewayDynamicRouteDeployments: (
  input: ListGatewayDynamicRouteDeploymentsRequest
) => Effect.Effect<
  ListGatewayDynamicRouteDeploymentsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListGatewayDynamicRouteDeploymentsRequest,
  output: ListGatewayDynamicRouteDeploymentsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostGatewayDynamicRouteDeploymentRequest {
  account_id: string;
  gateway_id: string;
  id: string;
  body: { comment: string; version_id: string };
}

export const PostGatewayDynamicRouteDeploymentRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  id: Schema.String.pipe(T.HttpPath("id")),
  body: Schema.Struct({
  comment: Schema.String,
  version_id: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/routes/{id}/deployments" }),
).annotations({ identifier: "PostGatewayDynamicRouteDeploymentRequest" }) as unknown as Schema.Schema<PostGatewayDynamicRouteDeploymentRequest>;

export interface PostGatewayDynamicRouteDeploymentResponse {
  result: { account_tag: string; created_at: string; elements: unknown[]; gateway_id: string; id: string; modified_at: string; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostGatewayDynamicRouteDeploymentResponse = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.String,
  created_at: Schema.Date,
  elements: Schema.Array(Schema.Union(Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  next: Schema.Struct({
  elementId: Schema.String
})
}),
  type: Schema.Literal("start")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  false: Schema.Struct({
  elementId: Schema.String
}),
  true: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  conditions: Schema.optional(Schema.Struct({}))
}),
  type: Schema.Literal("conditional")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Record({ key: Schema.String, value: Schema.Struct({
  elementId: Schema.String
}) }),
  type: Schema.Literal("percentage")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  fallback: Schema.Struct({
  elementId: Schema.String
}),
  success: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  key: Schema.String,
  limit: Schema.Number,
  limitType: Schema.Literal("count", "cost"),
  window: Schema.Number
}),
  type: Schema.Literal("rate")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  fallback: Schema.Struct({
  elementId: Schema.String
}),
  success: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  model: Schema.String,
  provider: Schema.String,
  retries: Schema.Number,
  timeout: Schema.Number
}),
  type: Schema.Literal("model")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Record({ key: Schema.String, value: Schema.Struct({
  elementId: Schema.String
}) }),
  type: Schema.Literal("end")
}))),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostGatewayDynamicRouteDeploymentResponse" }) as unknown as Schema.Schema<PostGatewayDynamicRouteDeploymentResponse>;

export const postGatewayDynamicRouteDeployment: (
  input: PostGatewayDynamicRouteDeploymentRequest
) => Effect.Effect<
  PostGatewayDynamicRouteDeploymentResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostGatewayDynamicRouteDeploymentRequest,
  output: PostGatewayDynamicRouteDeploymentResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListGatewayDynamicRouteVersionsRequest {
  account_id: string;
  gateway_id: string;
  id: string;
}

export const ListGatewayDynamicRouteVersionsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  id: Schema.String.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/routes/{id}/versions" }),
).annotations({ identifier: "ListGatewayDynamicRouteVersionsRequest" }) as unknown as Schema.Schema<ListGatewayDynamicRouteVersionsRequest>;

export interface ListGatewayDynamicRouteVersionsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListGatewayDynamicRouteVersionsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListGatewayDynamicRouteVersionsResponse" }) as unknown as Schema.Schema<ListGatewayDynamicRouteVersionsResponse>;

export const listGatewayDynamicRouteVersions: (
  input: ListGatewayDynamicRouteVersionsRequest
) => Effect.Effect<
  ListGatewayDynamicRouteVersionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListGatewayDynamicRouteVersionsRequest,
  output: ListGatewayDynamicRouteVersionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostGatewayDynamicRouteVersionRequest {
  account_id: string;
  gateway_id: string;
  id: string;
  body: { comment: string; elements: unknown[] };
}

export const PostGatewayDynamicRouteVersionRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  id: Schema.String.pipe(T.HttpPath("id")),
  body: Schema.Struct({
  comment: Schema.String,
  elements: Schema.Array(Schema.Union(Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  next: Schema.Struct({
  elementId: Schema.String
})
}),
  type: Schema.Literal("start")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  false: Schema.Struct({
  elementId: Schema.String
}),
  true: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  conditions: Schema.optional(Schema.Struct({}))
}),
  type: Schema.Literal("conditional")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Record({ key: Schema.String, value: Schema.Struct({
  elementId: Schema.String
}) }),
  type: Schema.Literal("percentage")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  fallback: Schema.Struct({
  elementId: Schema.String
}),
  success: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  key: Schema.String,
  limit: Schema.Number,
  limitType: Schema.Literal("count", "cost"),
  window: Schema.Number
}),
  type: Schema.Literal("rate")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  fallback: Schema.Struct({
  elementId: Schema.String
}),
  success: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  model: Schema.String,
  provider: Schema.String,
  retries: Schema.Number,
  timeout: Schema.Number
}),
  type: Schema.Literal("model")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Record({ key: Schema.String, value: Schema.Struct({
  elementId: Schema.String
}) }),
  type: Schema.Literal("end")
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/routes/{id}/versions" }),
).annotations({ identifier: "PostGatewayDynamicRouteVersionRequest" }) as unknown as Schema.Schema<PostGatewayDynamicRouteVersionRequest>;

export interface PostGatewayDynamicRouteVersionResponse {
  result: { account_tag: string; created_at: string; elements: unknown[]; gateway_id: string; id: string; modified_at: string; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostGatewayDynamicRouteVersionResponse = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.String,
  created_at: Schema.Date,
  elements: Schema.Array(Schema.Union(Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  next: Schema.Struct({
  elementId: Schema.String
})
}),
  type: Schema.Literal("start")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  false: Schema.Struct({
  elementId: Schema.String
}),
  true: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  conditions: Schema.optional(Schema.Struct({}))
}),
  type: Schema.Literal("conditional")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Record({ key: Schema.String, value: Schema.Struct({
  elementId: Schema.String
}) }),
  type: Schema.Literal("percentage")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  fallback: Schema.Struct({
  elementId: Schema.String
}),
  success: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  key: Schema.String,
  limit: Schema.Number,
  limitType: Schema.Literal("count", "cost"),
  window: Schema.Number
}),
  type: Schema.Literal("rate")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  fallback: Schema.Struct({
  elementId: Schema.String
}),
  success: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  model: Schema.String,
  provider: Schema.String,
  retries: Schema.Number,
  timeout: Schema.Number
}),
  type: Schema.Literal("model")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Record({ key: Schema.String, value: Schema.Struct({
  elementId: Schema.String
}) }),
  type: Schema.Literal("end")
}))),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostGatewayDynamicRouteVersionResponse" }) as unknown as Schema.Schema<PostGatewayDynamicRouteVersionResponse>;

export const postGatewayDynamicRouteVersion: (
  input: PostGatewayDynamicRouteVersionRequest
) => Effect.Effect<
  PostGatewayDynamicRouteVersionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostGatewayDynamicRouteVersionRequest,
  output: PostGatewayDynamicRouteVersionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetGatewayDynamicRouteVersionRequest {
  account_id: string;
  gateway_id: string;
  id: string;
  version_id: string;
}

export const GetGatewayDynamicRouteVersionRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  id: Schema.String.pipe(T.HttpPath("id")),
  version_id: Schema.String.pipe(T.HttpPath("version_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/routes/{id}/versions/{version_id}" }),
).annotations({ identifier: "GetGatewayDynamicRouteVersionRequest" }) as unknown as Schema.Schema<GetGatewayDynamicRouteVersionRequest>;

export interface GetGatewayDynamicRouteVersionResponse {
  result: { account_tag: string; active: "true" | "false"; comment?: string; created_at: string; data: string; elements: unknown[]; gateway_id: string; id: string; modified_at: string; name: string; version_id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetGatewayDynamicRouteVersionResponse = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.String,
  active: Schema.Literal("true", "false"),
  comment: Schema.optional(Schema.String),
  created_at: Schema.String,
  data: Schema.String,
  elements: Schema.Array(Schema.Union(Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  next: Schema.Struct({
  elementId: Schema.String
})
}),
  type: Schema.Literal("start")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  false: Schema.Struct({
  elementId: Schema.String
}),
  true: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  conditions: Schema.optional(Schema.Struct({}))
}),
  type: Schema.Literal("conditional")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Record({ key: Schema.String, value: Schema.Struct({
  elementId: Schema.String
}) }),
  type: Schema.Literal("percentage")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  fallback: Schema.Struct({
  elementId: Schema.String
}),
  success: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  key: Schema.String,
  limit: Schema.Number,
  limitType: Schema.Literal("count", "cost"),
  window: Schema.Number
}),
  type: Schema.Literal("rate")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Struct({
  fallback: Schema.Struct({
  elementId: Schema.String
}),
  success: Schema.Struct({
  elementId: Schema.String
})
}),
  properties: Schema.Struct({
  model: Schema.String,
  provider: Schema.String,
  retries: Schema.Number,
  timeout: Schema.Number
}),
  type: Schema.Literal("model")
}), Schema.Struct({
  id: Schema.String,
  outputs: Schema.Record({ key: Schema.String, value: Schema.Struct({
  elementId: Schema.String
}) }),
  type: Schema.Literal("end")
}))),
  gateway_id: Schema.String,
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  version_id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetGatewayDynamicRouteVersionResponse" }) as unknown as Schema.Schema<GetGatewayDynamicRouteVersionResponse>;

export const getGatewayDynamicRouteVersion: (
  input: GetGatewayDynamicRouteVersionRequest
) => Effect.Effect<
  GetGatewayDynamicRouteVersionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGatewayDynamicRouteVersionRequest,
  output: GetGatewayDynamicRouteVersionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetGatewayUrlRequest {
  gateway_id: string;
  account_id: string;
  provider: string;
}

export const GetGatewayUrlRequest = Schema.Struct({
  gateway_id: Schema.String.pipe(T.HttpPath("gateway_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  provider: Schema.String.pipe(T.HttpPath("provider"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways/{gateway_id}/url/{provider}" }),
).annotations({ identifier: "GetGatewayUrlRequest" }) as unknown as Schema.Schema<GetGatewayUrlRequest>;

export interface GetGatewayUrlResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetGatewayUrlResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetGatewayUrlResponse" }) as unknown as Schema.Schema<GetGatewayUrlResponse>;

export const getGatewayUrl: (
  input: GetGatewayUrlRequest
) => Effect.Effect<
  GetGatewayUrlResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGatewayUrlRequest,
  output: GetGatewayUrlResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AigConfigFetchGatewayRequest {
  account_id: string;
  id: string;
}

export const AigConfigFetchGatewayRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.String.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-gateway/gateways/{id}" }),
).annotations({ identifier: "AigConfigFetchGatewayRequest" }) as unknown as Schema.Schema<AigConfigFetchGatewayRequest>;

export interface AigConfigFetchGatewayResponse {
  result: { account_id: string; account_tag: string; authentication?: boolean; cache_invalidate_on_update: boolean; cache_ttl: number; collect_logs: boolean; created_at: string; dlp?: unknown; id: string; internal_id: string; log_management?: number; log_management_strategy?: "STOP_INSERTING" | "DELETE_OLDEST"; logpush?: boolean; logpush_public_key?: string; modified_at: string; otel?: { authorization: string; headers: Record<string, unknown>; url: string }[]; rate_limiting_interval: number; rate_limiting_limit: number; rate_limiting_technique: "fixed" | "sliding"; store_id?: string; stripe?: { authorization: string; usage_events: { payload: string }[] }; zdr?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AigConfigFetchGatewayResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  authentication: Schema.optional(Schema.Boolean),
  cache_invalidate_on_update: Schema.Boolean,
  cache_ttl: Schema.Number,
  collect_logs: Schema.Boolean,
  created_at: Schema.Date,
  dlp: Schema.optional(Schema.Union(Schema.Struct({
  action: Schema.Literal("BLOCK", "FLAG"),
  enabled: Schema.Boolean,
  profiles: Schema.Array(Schema.String)
}), Schema.Struct({
  enabled: Schema.Boolean,
  policies: Schema.Array(Schema.Struct({
  action: Schema.Literal("FLAG", "BLOCK"),
  check: Schema.Array(Schema.Literal("REQUEST", "RESPONSE")),
  enabled: Schema.Boolean,
  id: Schema.String,
  profiles: Schema.Array(Schema.String)
}))
}))),
  id: Schema.String,
  internal_id: Schema.UUID,
  log_management: Schema.optional(Schema.Number),
  log_management_strategy: Schema.optional(Schema.Literal("STOP_INSERTING", "DELETE_OLDEST")),
  logpush: Schema.optional(Schema.Boolean),
  logpush_public_key: Schema.optional(Schema.String),
  modified_at: Schema.Date,
  otel: Schema.optional(Schema.Array(Schema.Struct({
  authorization: Schema.String,
  headers: Schema.Record({ key: Schema.String, value: Schema.String }),
  url: Schema.String
}))),
  rate_limiting_interval: Schema.Number,
  rate_limiting_limit: Schema.Number,
  rate_limiting_technique: Schema.Literal("fixed", "sliding"),
  store_id: Schema.optional(Schema.String),
  stripe: Schema.optional(Schema.Struct({
  authorization: Schema.String,
  usage_events: Schema.Array(Schema.Struct({
  payload: Schema.String
}))
})),
  zdr: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AigConfigFetchGatewayResponse" }) as unknown as Schema.Schema<AigConfigFetchGatewayResponse>;

export const aigConfigFetchGateway: (
  input: AigConfigFetchGatewayRequest
) => Effect.Effect<
  AigConfigFetchGatewayResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AigConfigFetchGatewayRequest,
  output: AigConfigFetchGatewayResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateGatewayRequest {
  account_id: string;
  id: string;
  body: { authentication?: boolean; cache_invalidate_on_update: boolean; cache_ttl: number; collect_logs: boolean; dlp?: unknown; log_management?: number; log_management_strategy?: "STOP_INSERTING" | "DELETE_OLDEST"; logpush?: boolean; logpush_public_key?: string; otel?: { authorization: string; headers: Record<string, unknown>; url: string }[]; rate_limiting_interval: number; rate_limiting_limit: number; rate_limiting_technique: "fixed" | "sliding"; store_id?: string; stripe?: { authorization: string; usage_events: { payload: string }[] }; zdr?: boolean };
}

export const UpdateGatewayRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.String.pipe(T.HttpPath("id")),
  body: Schema.Struct({
  authentication: Schema.optional(Schema.Boolean),
  cache_invalidate_on_update: Schema.Boolean,
  cache_ttl: Schema.Number,
  collect_logs: Schema.Boolean,
  dlp: Schema.optional(Schema.Union(Schema.Struct({
  action: Schema.Literal("BLOCK", "FLAG"),
  enabled: Schema.Boolean,
  profiles: Schema.Array(Schema.String)
}), Schema.Struct({
  enabled: Schema.Boolean,
  policies: Schema.Array(Schema.Struct({
  action: Schema.Literal("FLAG", "BLOCK"),
  check: Schema.Array(Schema.Literal("REQUEST", "RESPONSE")),
  enabled: Schema.Boolean,
  id: Schema.String,
  profiles: Schema.Array(Schema.String)
}))
}))),
  log_management: Schema.optional(Schema.Number),
  log_management_strategy: Schema.optional(Schema.Literal("STOP_INSERTING", "DELETE_OLDEST")),
  logpush: Schema.optional(Schema.Boolean),
  logpush_public_key: Schema.optional(Schema.String),
  otel: Schema.optional(Schema.Array(Schema.Struct({
  authorization: Schema.String,
  headers: Schema.Record({ key: Schema.String, value: Schema.String }),
  url: Schema.String
}))),
  rate_limiting_interval: Schema.Number,
  rate_limiting_limit: Schema.Number,
  rate_limiting_technique: Schema.Literal("fixed", "sliding"),
  store_id: Schema.optional(Schema.String),
  stripe: Schema.optional(Schema.Struct({
  authorization: Schema.String,
  usage_events: Schema.Array(Schema.Struct({
  payload: Schema.String
}))
})),
  zdr: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/ai-gateway/gateways/{id}" }),
).annotations({ identifier: "UpdateGatewayRequest" }) as unknown as Schema.Schema<UpdateGatewayRequest>;

export interface UpdateGatewayResponse {
  result: { account_id: string; account_tag: string; authentication?: boolean; cache_invalidate_on_update: boolean; cache_ttl: number; collect_logs: boolean; created_at: string; dlp?: unknown; id: string; internal_id: string; log_management?: number; log_management_strategy?: "STOP_INSERTING" | "DELETE_OLDEST"; logpush?: boolean; logpush_public_key?: string; modified_at: string; otel?: { authorization: string; headers: Record<string, unknown>; url: string }[]; rate_limiting_interval: number; rate_limiting_limit: number; rate_limiting_technique: "fixed" | "sliding"; store_id?: string; stripe?: { authorization: string; usage_events: { payload: string }[] }; zdr?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateGatewayResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  authentication: Schema.optional(Schema.Boolean),
  cache_invalidate_on_update: Schema.Boolean,
  cache_ttl: Schema.Number,
  collect_logs: Schema.Boolean,
  created_at: Schema.Date,
  dlp: Schema.optional(Schema.Union(Schema.Struct({
  action: Schema.Literal("BLOCK", "FLAG"),
  enabled: Schema.Boolean,
  profiles: Schema.Array(Schema.String)
}), Schema.Struct({
  enabled: Schema.Boolean,
  policies: Schema.Array(Schema.Struct({
  action: Schema.Literal("FLAG", "BLOCK"),
  check: Schema.Array(Schema.Literal("REQUEST", "RESPONSE")),
  enabled: Schema.Boolean,
  id: Schema.String,
  profiles: Schema.Array(Schema.String)
}))
}))),
  id: Schema.String,
  internal_id: Schema.UUID,
  log_management: Schema.optional(Schema.Number),
  log_management_strategy: Schema.optional(Schema.Literal("STOP_INSERTING", "DELETE_OLDEST")),
  logpush: Schema.optional(Schema.Boolean),
  logpush_public_key: Schema.optional(Schema.String),
  modified_at: Schema.Date,
  otel: Schema.optional(Schema.Array(Schema.Struct({
  authorization: Schema.String,
  headers: Schema.Record({ key: Schema.String, value: Schema.String }),
  url: Schema.String
}))),
  rate_limiting_interval: Schema.Number,
  rate_limiting_limit: Schema.Number,
  rate_limiting_technique: Schema.Literal("fixed", "sliding"),
  store_id: Schema.optional(Schema.String),
  stripe: Schema.optional(Schema.Struct({
  authorization: Schema.String,
  usage_events: Schema.Array(Schema.Struct({
  payload: Schema.String
}))
})),
  zdr: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateGatewayResponse" }) as unknown as Schema.Schema<UpdateGatewayResponse>;

export const updateGateway: (
  input: UpdateGatewayRequest
) => Effect.Effect<
  UpdateGatewayResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateGatewayRequest,
  output: UpdateGatewayResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteGatewayRequest {
  account_id: string;
  id: string;
}

export const DeleteGatewayRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.String.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/ai-gateway/gateways/{id}" }),
).annotations({ identifier: "DeleteGatewayRequest" }) as unknown as Schema.Schema<DeleteGatewayRequest>;

export interface DeleteGatewayResponse {
  result: { account_id: string; account_tag: string; authentication?: boolean; cache_invalidate_on_update: boolean; cache_ttl: number; collect_logs: boolean; created_at: string; dlp?: unknown; id: string; internal_id: string; log_management?: number; log_management_strategy?: "STOP_INSERTING" | "DELETE_OLDEST"; logpush?: boolean; logpush_public_key?: string; modified_at: string; otel?: { authorization: string; headers: Record<string, unknown>; url: string }[]; rate_limiting_interval: number; rate_limiting_limit: number; rate_limiting_technique: "fixed" | "sliding"; store_id?: string; stripe?: { authorization: string; usage_events: { payload: string }[] }; zdr?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteGatewayResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  authentication: Schema.optional(Schema.Boolean),
  cache_invalidate_on_update: Schema.Boolean,
  cache_ttl: Schema.Number,
  collect_logs: Schema.Boolean,
  created_at: Schema.Date,
  dlp: Schema.optional(Schema.Union(Schema.Struct({
  action: Schema.Literal("BLOCK", "FLAG"),
  enabled: Schema.Boolean,
  profiles: Schema.Array(Schema.String)
}), Schema.Struct({
  enabled: Schema.Boolean,
  policies: Schema.Array(Schema.Struct({
  action: Schema.Literal("FLAG", "BLOCK"),
  check: Schema.Array(Schema.Literal("REQUEST", "RESPONSE")),
  enabled: Schema.Boolean,
  id: Schema.String,
  profiles: Schema.Array(Schema.String)
}))
}))),
  id: Schema.String,
  internal_id: Schema.UUID,
  log_management: Schema.optional(Schema.Number),
  log_management_strategy: Schema.optional(Schema.Literal("STOP_INSERTING", "DELETE_OLDEST")),
  logpush: Schema.optional(Schema.Boolean),
  logpush_public_key: Schema.optional(Schema.String),
  modified_at: Schema.Date,
  otel: Schema.optional(Schema.Array(Schema.Struct({
  authorization: Schema.String,
  headers: Schema.Record({ key: Schema.String, value: Schema.String }),
  url: Schema.String
}))),
  rate_limiting_interval: Schema.Number,
  rate_limiting_limit: Schema.Number,
  rate_limiting_technique: Schema.Literal("fixed", "sliding"),
  store_id: Schema.optional(Schema.String),
  stripe: Schema.optional(Schema.Struct({
  authorization: Schema.String,
  usage_events: Schema.Array(Schema.Struct({
  payload: Schema.String
}))
})),
  zdr: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteGatewayResponse" }) as unknown as Schema.Schema<DeleteGatewayResponse>;

export const deleteGateway: (
  input: DeleteGatewayRequest
) => Effect.Effect<
  DeleteGatewayResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteGatewayRequest,
  output: DeleteGatewayResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListInstancesRequest {
  account_id: string;
  page?: number;
  per_page?: number;
  search?: string;
}

export const ListInstancesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-search/instances" }),
).annotations({ identifier: "ListInstancesRequest" }) as unknown as Schema.Schema<ListInstancesRequest>;

export interface ListInstancesResponse {
  result: { account_id: string; account_tag: string; ai_gateway_id?: string; ai_search_model?: unknown; cache?: boolean; cache_threshold?: "super_strict_match" | "close_enough" | "flexible_friend" | "anything_goes"; chunk?: boolean; chunk_overlap?: number; chunk_size?: number; created_at: string; created_by?: string; embedding_model?: unknown; enable?: boolean; engine_version?: number; hybrid_search_enabled?: boolean; id: string; internal_id: string; last_activity?: string; max_num_results?: number; metadata?: { created_from_aisearch_wizard?: boolean; worker_domain?: string }; modified_at: string; modified_by?: string; paused?: boolean; public_endpoint_id?: string; public_endpoint_params?: { authorized_hosts?: string[]; enabled?: boolean; rate_limit?: { period_ms?: number; requests?: number; technique?: "fixed" | "sliding" } }; reranking?: boolean; reranking_model?: unknown; rewrite_model?: unknown; rewrite_query?: boolean; score_threshold?: number; source: string; source_params?: { exclude_items?: string[]; include_items?: string[]; prefix?: string; r2_jurisdiction?: string; web_crawler?: { parse_options?: { include_headers?: Record<string, unknown>; include_images?: boolean; use_browser_rendering?: boolean }; parse_type?: "sitemap" | "feed-rss"; store_options?: { r2_jurisdiction?: string; storage_id: string; storage_type?: "r2" } } }; status?: string; summarization?: boolean; summarization_model?: unknown; system_prompt_ai_search?: string; system_prompt_index_summarization?: string; system_prompt_rewrite_query?: string; token_id: string; type: "r2" | "web-crawler"; vectorize_active_namespace?: string; vectorize_name: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListInstancesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  ai_gateway_id: Schema.optional(Schema.String),
  ai_search_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  cache: Schema.optional(Schema.Boolean),
  cache_threshold: Schema.optional(Schema.Literal("super_strict_match", "close_enough", "flexible_friend", "anything_goes")),
  chunk: Schema.optional(Schema.Boolean),
  chunk_overlap: Schema.optional(Schema.Number),
  chunk_size: Schema.optional(Schema.Number),
  created_at: Schema.Date,
  created_by: Schema.optional(Schema.String),
  embedding_model: Schema.optional(Schema.Union(Schema.Literal("@cf/baai/bge-m3", "@cf/baai/bge-large-en-v1.5", "@cf/google/embeddinggemma-300m", "@cf/qwen/qwen3-embedding-0.6b", "google-ai-studio/gemini-embedding-001", "openai/text-embedding-3-small", "openai/text-embedding-3-large"), Schema.Literal(""))),
  enable: Schema.optional(Schema.Boolean),
  engine_version: Schema.optional(Schema.Number),
  hybrid_search_enabled: Schema.optional(Schema.Boolean),
  id: Schema.String,
  internal_id: Schema.UUID,
  last_activity: Schema.optional(Schema.Date),
  max_num_results: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Struct({
  created_from_aisearch_wizard: Schema.optional(Schema.Boolean),
  worker_domain: Schema.optional(Schema.String)
})),
  modified_at: Schema.Date,
  modified_by: Schema.optional(Schema.String),
  paused: Schema.optional(Schema.Boolean),
  public_endpoint_id: Schema.optional(Schema.String),
  public_endpoint_params: Schema.optional(Schema.Struct({
  authorized_hosts: Schema.optional(Schema.Array(Schema.String)),
  enabled: Schema.optional(Schema.Boolean),
  rate_limit: Schema.optional(Schema.Struct({
  period_ms: Schema.optional(Schema.Number),
  requests: Schema.optional(Schema.Number),
  technique: Schema.optional(Schema.Literal("fixed", "sliding"))
}))
})),
  reranking: Schema.optional(Schema.Boolean),
  reranking_model: Schema.optional(Schema.Union(Schema.Literal("@cf/baai/bge-reranker-base"), Schema.Literal(""))),
  rewrite_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  rewrite_query: Schema.optional(Schema.Boolean),
  score_threshold: Schema.optional(Schema.Number),
  source: Schema.String,
  source_params: Schema.optional(Schema.Struct({
  exclude_items: Schema.optional(Schema.Array(Schema.String)),
  include_items: Schema.optional(Schema.Array(Schema.String)),
  prefix: Schema.optional(Schema.String),
  r2_jurisdiction: Schema.optional(Schema.String),
  web_crawler: Schema.optional(Schema.Struct({
  parse_options: Schema.optional(Schema.Struct({
  include_headers: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  include_images: Schema.optional(Schema.Boolean),
  use_browser_rendering: Schema.optional(Schema.Boolean)
})),
  parse_type: Schema.optional(Schema.Literal("sitemap", "feed-rss")),
  store_options: Schema.optional(Schema.Struct({
  r2_jurisdiction: Schema.optional(Schema.String),
  storage_id: Schema.String,
  storage_type: Schema.optional(Schema.Literal("r2"))
}))
}))
})),
  status: Schema.optional(Schema.String),
  summarization: Schema.optional(Schema.Boolean),
  summarization_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  system_prompt_ai_search: Schema.optional(Schema.String),
  system_prompt_index_summarization: Schema.optional(Schema.String),
  system_prompt_rewrite_query: Schema.optional(Schema.String),
  token_id: Schema.UUID,
  type: Schema.Literal("r2", "web-crawler"),
  vectorize_active_namespace: Schema.optional(Schema.String),
  vectorize_name: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListInstancesResponse" }) as unknown as Schema.Schema<ListInstancesResponse>;

export const listInstances: (
  input: ListInstancesRequest
) => Effect.Effect<
  ListInstancesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListInstancesRequest,
  output: ListInstancesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateInstancesRequest {
  account_id: string;
  body: { ai_gateway_id?: string; ai_search_model?: unknown; chunk?: boolean; chunk_overlap?: number; chunk_size?: number; embedding_model?: unknown; hybrid_search_enabled?: boolean; id: string; max_num_results?: number; metadata?: { created_from_aisearch_wizard?: boolean; worker_domain?: string }; public_endpoint_params?: { authorized_hosts?: string[]; enabled?: boolean; rate_limit?: { period_ms?: number; requests?: number; technique?: "fixed" | "sliding" } }; reranking?: boolean; reranking_model?: unknown; rewrite_model?: unknown; rewrite_query?: boolean; score_threshold?: number; source: string; source_params?: { exclude_items?: string[]; include_items?: string[]; prefix?: string; r2_jurisdiction?: string; web_crawler?: { parse_options?: { include_headers?: Record<string, unknown>; include_images?: boolean; use_browser_rendering?: boolean }; parse_type?: "sitemap" | "feed-rss"; store_options?: { r2_jurisdiction?: string; storage_id: string; storage_type?: "r2" } } }; token_id: string; type: "r2" | "web-crawler" };
}

export const CreateInstancesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  ai_gateway_id: Schema.optional(Schema.String),
  ai_search_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  chunk: Schema.optional(Schema.Boolean),
  chunk_overlap: Schema.optional(Schema.Number),
  chunk_size: Schema.optional(Schema.Number),
  embedding_model: Schema.optional(Schema.Union(Schema.Literal("@cf/baai/bge-m3", "@cf/baai/bge-large-en-v1.5", "@cf/google/embeddinggemma-300m", "@cf/qwen/qwen3-embedding-0.6b", "google-ai-studio/gemini-embedding-001", "openai/text-embedding-3-small", "openai/text-embedding-3-large"), Schema.Literal(""))),
  hybrid_search_enabled: Schema.optional(Schema.Boolean),
  id: Schema.String,
  max_num_results: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Struct({
  created_from_aisearch_wizard: Schema.optional(Schema.Boolean),
  worker_domain: Schema.optional(Schema.String)
})),
  public_endpoint_params: Schema.optional(Schema.Struct({
  authorized_hosts: Schema.optional(Schema.Array(Schema.String)),
  enabled: Schema.optional(Schema.Boolean),
  rate_limit: Schema.optional(Schema.Struct({
  period_ms: Schema.optional(Schema.Number),
  requests: Schema.optional(Schema.Number),
  technique: Schema.optional(Schema.Literal("fixed", "sliding"))
}))
})),
  reranking: Schema.optional(Schema.Boolean),
  reranking_model: Schema.optional(Schema.Union(Schema.Literal("@cf/baai/bge-reranker-base"), Schema.Literal(""))),
  rewrite_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  rewrite_query: Schema.optional(Schema.Boolean),
  score_threshold: Schema.optional(Schema.Number),
  source: Schema.String,
  source_params: Schema.optional(Schema.Struct({
  exclude_items: Schema.optional(Schema.Array(Schema.String)),
  include_items: Schema.optional(Schema.Array(Schema.String)),
  prefix: Schema.optional(Schema.String),
  r2_jurisdiction: Schema.optional(Schema.String),
  web_crawler: Schema.optional(Schema.Struct({
  parse_options: Schema.optional(Schema.Struct({
  include_headers: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  include_images: Schema.optional(Schema.Boolean),
  use_browser_rendering: Schema.optional(Schema.Boolean)
})),
  parse_type: Schema.optional(Schema.Literal("sitemap", "feed-rss")),
  store_options: Schema.optional(Schema.Struct({
  r2_jurisdiction: Schema.optional(Schema.String),
  storage_id: Schema.String,
  storage_type: Schema.optional(Schema.Literal("r2"))
}))
}))
})),
  token_id: Schema.UUID,
  type: Schema.Literal("r2", "web-crawler")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai-search/instances" }),
).annotations({ identifier: "CreateInstancesRequest" }) as unknown as Schema.Schema<CreateInstancesRequest>;

export interface CreateInstancesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateInstancesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateInstancesResponse" }) as unknown as Schema.Schema<CreateInstancesResponse>;

export const createInstances: (
  input: CreateInstancesRequest
) => Effect.Effect<
  CreateInstancesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateInstancesRequest,
  output: CreateInstancesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AiSearchFetchInstancesRequest {
  account_id: string;
  id: string;
}

export const AiSearchFetchInstancesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.String.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-search/instances/{id}" }),
).annotations({ identifier: "AiSearchFetchInstancesRequest" }) as unknown as Schema.Schema<AiSearchFetchInstancesRequest>;

export interface AiSearchFetchInstancesResponse {
  result: { account_id: string; account_tag: string; ai_gateway_id?: string; ai_search_model?: unknown; cache?: boolean; cache_threshold?: "super_strict_match" | "close_enough" | "flexible_friend" | "anything_goes"; chunk?: boolean; chunk_overlap?: number; chunk_size?: number; created_at: string; created_by?: string; embedding_model?: unknown; enable?: boolean; engine_version?: number; hybrid_search_enabled?: boolean; id: string; internal_id: string; last_activity?: string; max_num_results?: number; metadata?: { created_from_aisearch_wizard?: boolean; worker_domain?: string }; modified_at: string; modified_by?: string; paused?: boolean; public_endpoint_id?: string; public_endpoint_params?: { authorized_hosts?: string[]; enabled?: boolean; rate_limit?: { period_ms?: number; requests?: number; technique?: "fixed" | "sliding" } }; reranking?: boolean; reranking_model?: unknown; rewrite_model?: unknown; rewrite_query?: boolean; score_threshold?: number; source: string; source_params?: { exclude_items?: string[]; include_items?: string[]; prefix?: string; r2_jurisdiction?: string; web_crawler?: { parse_options?: { include_headers?: Record<string, unknown>; include_images?: boolean; use_browser_rendering?: boolean }; parse_type?: "sitemap" | "feed-rss"; store_options?: { r2_jurisdiction?: string; storage_id: string; storage_type?: "r2" } } }; status?: string; summarization?: boolean; summarization_model?: unknown; system_prompt_ai_search?: string; system_prompt_index_summarization?: string; system_prompt_rewrite_query?: string; token_id: string; type: "r2" | "web-crawler"; vectorize_active_namespace?: string; vectorize_name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AiSearchFetchInstancesResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  ai_gateway_id: Schema.optional(Schema.String),
  ai_search_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  cache: Schema.optional(Schema.Boolean),
  cache_threshold: Schema.optional(Schema.Literal("super_strict_match", "close_enough", "flexible_friend", "anything_goes")),
  chunk: Schema.optional(Schema.Boolean),
  chunk_overlap: Schema.optional(Schema.Number),
  chunk_size: Schema.optional(Schema.Number),
  created_at: Schema.Date,
  created_by: Schema.optional(Schema.String),
  embedding_model: Schema.optional(Schema.Union(Schema.Literal("@cf/baai/bge-m3", "@cf/baai/bge-large-en-v1.5", "@cf/google/embeddinggemma-300m", "@cf/qwen/qwen3-embedding-0.6b", "google-ai-studio/gemini-embedding-001", "openai/text-embedding-3-small", "openai/text-embedding-3-large"), Schema.Literal(""))),
  enable: Schema.optional(Schema.Boolean),
  engine_version: Schema.optional(Schema.Number),
  hybrid_search_enabled: Schema.optional(Schema.Boolean),
  id: Schema.String,
  internal_id: Schema.UUID,
  last_activity: Schema.optional(Schema.Date),
  max_num_results: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Struct({
  created_from_aisearch_wizard: Schema.optional(Schema.Boolean),
  worker_domain: Schema.optional(Schema.String)
})),
  modified_at: Schema.Date,
  modified_by: Schema.optional(Schema.String),
  paused: Schema.optional(Schema.Boolean),
  public_endpoint_id: Schema.optional(Schema.String),
  public_endpoint_params: Schema.optional(Schema.Struct({
  authorized_hosts: Schema.optional(Schema.Array(Schema.String)),
  enabled: Schema.optional(Schema.Boolean),
  rate_limit: Schema.optional(Schema.Struct({
  period_ms: Schema.optional(Schema.Number),
  requests: Schema.optional(Schema.Number),
  technique: Schema.optional(Schema.Literal("fixed", "sliding"))
}))
})),
  reranking: Schema.optional(Schema.Boolean),
  reranking_model: Schema.optional(Schema.Union(Schema.Literal("@cf/baai/bge-reranker-base"), Schema.Literal(""))),
  rewrite_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  rewrite_query: Schema.optional(Schema.Boolean),
  score_threshold: Schema.optional(Schema.Number),
  source: Schema.String,
  source_params: Schema.optional(Schema.Struct({
  exclude_items: Schema.optional(Schema.Array(Schema.String)),
  include_items: Schema.optional(Schema.Array(Schema.String)),
  prefix: Schema.optional(Schema.String),
  r2_jurisdiction: Schema.optional(Schema.String),
  web_crawler: Schema.optional(Schema.Struct({
  parse_options: Schema.optional(Schema.Struct({
  include_headers: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  include_images: Schema.optional(Schema.Boolean),
  use_browser_rendering: Schema.optional(Schema.Boolean)
})),
  parse_type: Schema.optional(Schema.Literal("sitemap", "feed-rss")),
  store_options: Schema.optional(Schema.Struct({
  r2_jurisdiction: Schema.optional(Schema.String),
  storage_id: Schema.String,
  storage_type: Schema.optional(Schema.Literal("r2"))
}))
}))
})),
  status: Schema.optional(Schema.String),
  summarization: Schema.optional(Schema.Boolean),
  summarization_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  system_prompt_ai_search: Schema.optional(Schema.String),
  system_prompt_index_summarization: Schema.optional(Schema.String),
  system_prompt_rewrite_query: Schema.optional(Schema.String),
  token_id: Schema.UUID,
  type: Schema.Literal("r2", "web-crawler"),
  vectorize_active_namespace: Schema.optional(Schema.String),
  vectorize_name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AiSearchFetchInstancesResponse" }) as unknown as Schema.Schema<AiSearchFetchInstancesResponse>;

export const aiSearchFetchInstances: (
  input: AiSearchFetchInstancesRequest
) => Effect.Effect<
  AiSearchFetchInstancesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AiSearchFetchInstancesRequest,
  output: AiSearchFetchInstancesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateInstancesRequest {
  account_id: string;
  id: string;
  body: { ai_gateway_id?: string; ai_search_model?: unknown; cache?: boolean; cache_threshold?: "super_strict_match" | "close_enough" | "flexible_friend" | "anything_goes"; chunk?: boolean; chunk_overlap?: number; chunk_size?: number; embedding_model?: unknown; hybrid_search_enabled?: boolean; max_num_results?: number; metadata?: { created_from_aisearch_wizard?: boolean; worker_domain?: string }; paused?: boolean; public_endpoint_params?: { authorized_hosts?: string[]; enabled?: boolean; rate_limit?: { period_ms?: number; requests?: number; technique?: "fixed" | "sliding" } }; reranking?: boolean; reranking_model?: unknown; rewrite_model?: unknown; rewrite_query?: boolean; score_threshold?: number; source_params?: { exclude_items?: string[]; include_items?: string[]; prefix?: string; r2_jurisdiction?: string; web_crawler?: { parse_options?: { include_headers?: Record<string, unknown>; include_images?: boolean; use_browser_rendering?: boolean }; parse_type?: "sitemap" | "feed-rss"; store_options?: { r2_jurisdiction?: string; storage_id: string; storage_type?: "r2" } } }; summarization?: boolean; summarization_model?: unknown; system_prompt_ai_search?: string; system_prompt_index_summarization?: string; system_prompt_rewrite_query?: string; token_id?: string };
}

export const UpdateInstancesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.String.pipe(T.HttpPath("id")),
  body: Schema.Struct({
  ai_gateway_id: Schema.optional(Schema.String),
  ai_search_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  cache: Schema.optional(Schema.Boolean),
  cache_threshold: Schema.optional(Schema.Literal("super_strict_match", "close_enough", "flexible_friend", "anything_goes")),
  chunk: Schema.optional(Schema.Boolean),
  chunk_overlap: Schema.optional(Schema.Number),
  chunk_size: Schema.optional(Schema.Number),
  embedding_model: Schema.optional(Schema.Union(Schema.Literal("@cf/baai/bge-m3", "@cf/baai/bge-large-en-v1.5", "@cf/google/embeddinggemma-300m", "@cf/qwen/qwen3-embedding-0.6b", "google-ai-studio/gemini-embedding-001", "openai/text-embedding-3-small", "openai/text-embedding-3-large"), Schema.Literal(""))),
  hybrid_search_enabled: Schema.optional(Schema.Boolean),
  max_num_results: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Struct({
  created_from_aisearch_wizard: Schema.optional(Schema.Boolean),
  worker_domain: Schema.optional(Schema.String)
})),
  paused: Schema.optional(Schema.Boolean),
  public_endpoint_params: Schema.optional(Schema.Struct({
  authorized_hosts: Schema.optional(Schema.Array(Schema.String)),
  enabled: Schema.optional(Schema.Boolean),
  rate_limit: Schema.optional(Schema.Struct({
  period_ms: Schema.optional(Schema.Number),
  requests: Schema.optional(Schema.Number),
  technique: Schema.optional(Schema.Literal("fixed", "sliding"))
}))
})),
  reranking: Schema.optional(Schema.Boolean),
  reranking_model: Schema.optional(Schema.Union(Schema.Literal("@cf/baai/bge-reranker-base"), Schema.Literal(""))),
  rewrite_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  rewrite_query: Schema.optional(Schema.Boolean),
  score_threshold: Schema.optional(Schema.Number),
  source_params: Schema.optional(Schema.Struct({
  exclude_items: Schema.optional(Schema.Array(Schema.String)),
  include_items: Schema.optional(Schema.Array(Schema.String)),
  prefix: Schema.optional(Schema.String),
  r2_jurisdiction: Schema.optional(Schema.String),
  web_crawler: Schema.optional(Schema.Struct({
  parse_options: Schema.optional(Schema.Struct({
  include_headers: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  include_images: Schema.optional(Schema.Boolean),
  use_browser_rendering: Schema.optional(Schema.Boolean)
})),
  parse_type: Schema.optional(Schema.Literal("sitemap", "feed-rss")),
  store_options: Schema.optional(Schema.Struct({
  r2_jurisdiction: Schema.optional(Schema.String),
  storage_id: Schema.String,
  storage_type: Schema.optional(Schema.Literal("r2"))
}))
}))
})),
  summarization: Schema.optional(Schema.Boolean),
  summarization_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  system_prompt_ai_search: Schema.optional(Schema.String),
  system_prompt_index_summarization: Schema.optional(Schema.String),
  system_prompt_rewrite_query: Schema.optional(Schema.String),
  token_id: Schema.optional(Schema.UUID)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/ai-search/instances/{id}" }),
).annotations({ identifier: "UpdateInstancesRequest" }) as unknown as Schema.Schema<UpdateInstancesRequest>;

export interface UpdateInstancesResponse {
  result: { account_id: string; account_tag: string; ai_gateway_id?: string; ai_search_model?: unknown; cache?: boolean; cache_threshold?: "super_strict_match" | "close_enough" | "flexible_friend" | "anything_goes"; chunk?: boolean; chunk_overlap?: number; chunk_size?: number; created_at: string; created_by?: string; embedding_model?: unknown; enable?: boolean; engine_version?: number; hybrid_search_enabled?: boolean; id: string; internal_id: string; last_activity?: string; max_num_results?: number; metadata?: { created_from_aisearch_wizard?: boolean; worker_domain?: string }; modified_at: string; modified_by?: string; paused?: boolean; public_endpoint_id?: string; public_endpoint_params?: { authorized_hosts?: string[]; enabled?: boolean; rate_limit?: { period_ms?: number; requests?: number; technique?: "fixed" | "sliding" } }; reranking?: boolean; reranking_model?: unknown; rewrite_model?: unknown; rewrite_query?: boolean; score_threshold?: number; source: string; source_params?: { exclude_items?: string[]; include_items?: string[]; prefix?: string; r2_jurisdiction?: string; web_crawler?: { parse_options?: { include_headers?: Record<string, unknown>; include_images?: boolean; use_browser_rendering?: boolean }; parse_type?: "sitemap" | "feed-rss"; store_options?: { r2_jurisdiction?: string; storage_id: string; storage_type?: "r2" } } }; status?: string; summarization?: boolean; summarization_model?: unknown; system_prompt_ai_search?: string; system_prompt_index_summarization?: string; system_prompt_rewrite_query?: string; token_id: string; type: "r2" | "web-crawler"; vectorize_active_namespace?: string; vectorize_name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateInstancesResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  ai_gateway_id: Schema.optional(Schema.String),
  ai_search_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  cache: Schema.optional(Schema.Boolean),
  cache_threshold: Schema.optional(Schema.Literal("super_strict_match", "close_enough", "flexible_friend", "anything_goes")),
  chunk: Schema.optional(Schema.Boolean),
  chunk_overlap: Schema.optional(Schema.Number),
  chunk_size: Schema.optional(Schema.Number),
  created_at: Schema.Date,
  created_by: Schema.optional(Schema.String),
  embedding_model: Schema.optional(Schema.Union(Schema.Literal("@cf/baai/bge-m3", "@cf/baai/bge-large-en-v1.5", "@cf/google/embeddinggemma-300m", "@cf/qwen/qwen3-embedding-0.6b", "google-ai-studio/gemini-embedding-001", "openai/text-embedding-3-small", "openai/text-embedding-3-large"), Schema.Literal(""))),
  enable: Schema.optional(Schema.Boolean),
  engine_version: Schema.optional(Schema.Number),
  hybrid_search_enabled: Schema.optional(Schema.Boolean),
  id: Schema.String,
  internal_id: Schema.UUID,
  last_activity: Schema.optional(Schema.Date),
  max_num_results: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Struct({
  created_from_aisearch_wizard: Schema.optional(Schema.Boolean),
  worker_domain: Schema.optional(Schema.String)
})),
  modified_at: Schema.Date,
  modified_by: Schema.optional(Schema.String),
  paused: Schema.optional(Schema.Boolean),
  public_endpoint_id: Schema.optional(Schema.String),
  public_endpoint_params: Schema.optional(Schema.Struct({
  authorized_hosts: Schema.optional(Schema.Array(Schema.String)),
  enabled: Schema.optional(Schema.Boolean),
  rate_limit: Schema.optional(Schema.Struct({
  period_ms: Schema.optional(Schema.Number),
  requests: Schema.optional(Schema.Number),
  technique: Schema.optional(Schema.Literal("fixed", "sliding"))
}))
})),
  reranking: Schema.optional(Schema.Boolean),
  reranking_model: Schema.optional(Schema.Union(Schema.Literal("@cf/baai/bge-reranker-base"), Schema.Literal(""))),
  rewrite_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  rewrite_query: Schema.optional(Schema.Boolean),
  score_threshold: Schema.optional(Schema.Number),
  source: Schema.String,
  source_params: Schema.optional(Schema.Struct({
  exclude_items: Schema.optional(Schema.Array(Schema.String)),
  include_items: Schema.optional(Schema.Array(Schema.String)),
  prefix: Schema.optional(Schema.String),
  r2_jurisdiction: Schema.optional(Schema.String),
  web_crawler: Schema.optional(Schema.Struct({
  parse_options: Schema.optional(Schema.Struct({
  include_headers: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  include_images: Schema.optional(Schema.Boolean),
  use_browser_rendering: Schema.optional(Schema.Boolean)
})),
  parse_type: Schema.optional(Schema.Literal("sitemap", "feed-rss")),
  store_options: Schema.optional(Schema.Struct({
  r2_jurisdiction: Schema.optional(Schema.String),
  storage_id: Schema.String,
  storage_type: Schema.optional(Schema.Literal("r2"))
}))
}))
})),
  status: Schema.optional(Schema.String),
  summarization: Schema.optional(Schema.Boolean),
  summarization_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  system_prompt_ai_search: Schema.optional(Schema.String),
  system_prompt_index_summarization: Schema.optional(Schema.String),
  system_prompt_rewrite_query: Schema.optional(Schema.String),
  token_id: Schema.UUID,
  type: Schema.Literal("r2", "web-crawler"),
  vectorize_active_namespace: Schema.optional(Schema.String),
  vectorize_name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateInstancesResponse" }) as unknown as Schema.Schema<UpdateInstancesResponse>;

export const updateInstances: (
  input: UpdateInstancesRequest
) => Effect.Effect<
  UpdateInstancesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateInstancesRequest,
  output: UpdateInstancesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteInstancesRequest {
  account_id: string;
  id: string;
}

export const DeleteInstancesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.String.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/ai-search/instances/{id}" }),
).annotations({ identifier: "DeleteInstancesRequest" }) as unknown as Schema.Schema<DeleteInstancesRequest>;

export interface DeleteInstancesResponse {
  result: { account_id: string; account_tag: string; ai_gateway_id?: string; ai_search_model?: unknown; cache?: boolean; cache_threshold?: "super_strict_match" | "close_enough" | "flexible_friend" | "anything_goes"; chunk?: boolean; chunk_overlap?: number; chunk_size?: number; created_at: string; created_by?: string; embedding_model?: unknown; enable?: boolean; engine_version?: number; hybrid_search_enabled?: boolean; id: string; internal_id: string; last_activity?: string; max_num_results?: number; metadata?: { created_from_aisearch_wizard?: boolean; worker_domain?: string }; modified_at: string; modified_by?: string; paused?: boolean; public_endpoint_id?: string; public_endpoint_params?: { authorized_hosts?: string[]; enabled?: boolean; rate_limit?: { period_ms?: number; requests?: number; technique?: "fixed" | "sliding" } }; reranking?: boolean; reranking_model?: unknown; rewrite_model?: unknown; rewrite_query?: boolean; score_threshold?: number; source: string; source_params?: { exclude_items?: string[]; include_items?: string[]; prefix?: string; r2_jurisdiction?: string; web_crawler?: { parse_options?: { include_headers?: Record<string, unknown>; include_images?: boolean; use_browser_rendering?: boolean }; parse_type?: "sitemap" | "feed-rss"; store_options?: { r2_jurisdiction?: string; storage_id: string; storage_type?: "r2" } } }; status?: string; summarization?: boolean; summarization_model?: unknown; system_prompt_ai_search?: string; system_prompt_index_summarization?: string; system_prompt_rewrite_query?: string; token_id: string; type: "r2" | "web-crawler"; vectorize_active_namespace?: string; vectorize_name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteInstancesResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  ai_gateway_id: Schema.optional(Schema.String),
  ai_search_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  cache: Schema.optional(Schema.Boolean),
  cache_threshold: Schema.optional(Schema.Literal("super_strict_match", "close_enough", "flexible_friend", "anything_goes")),
  chunk: Schema.optional(Schema.Boolean),
  chunk_overlap: Schema.optional(Schema.Number),
  chunk_size: Schema.optional(Schema.Number),
  created_at: Schema.Date,
  created_by: Schema.optional(Schema.String),
  embedding_model: Schema.optional(Schema.Union(Schema.Literal("@cf/baai/bge-m3", "@cf/baai/bge-large-en-v1.5", "@cf/google/embeddinggemma-300m", "@cf/qwen/qwen3-embedding-0.6b", "google-ai-studio/gemini-embedding-001", "openai/text-embedding-3-small", "openai/text-embedding-3-large"), Schema.Literal(""))),
  enable: Schema.optional(Schema.Boolean),
  engine_version: Schema.optional(Schema.Number),
  hybrid_search_enabled: Schema.optional(Schema.Boolean),
  id: Schema.String,
  internal_id: Schema.UUID,
  last_activity: Schema.optional(Schema.Date),
  max_num_results: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Struct({
  created_from_aisearch_wizard: Schema.optional(Schema.Boolean),
  worker_domain: Schema.optional(Schema.String)
})),
  modified_at: Schema.Date,
  modified_by: Schema.optional(Schema.String),
  paused: Schema.optional(Schema.Boolean),
  public_endpoint_id: Schema.optional(Schema.String),
  public_endpoint_params: Schema.optional(Schema.Struct({
  authorized_hosts: Schema.optional(Schema.Array(Schema.String)),
  enabled: Schema.optional(Schema.Boolean),
  rate_limit: Schema.optional(Schema.Struct({
  period_ms: Schema.optional(Schema.Number),
  requests: Schema.optional(Schema.Number),
  technique: Schema.optional(Schema.Literal("fixed", "sliding"))
}))
})),
  reranking: Schema.optional(Schema.Boolean),
  reranking_model: Schema.optional(Schema.Union(Schema.Literal("@cf/baai/bge-reranker-base"), Schema.Literal(""))),
  rewrite_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  rewrite_query: Schema.optional(Schema.Boolean),
  score_threshold: Schema.optional(Schema.Number),
  source: Schema.String,
  source_params: Schema.optional(Schema.Struct({
  exclude_items: Schema.optional(Schema.Array(Schema.String)),
  include_items: Schema.optional(Schema.Array(Schema.String)),
  prefix: Schema.optional(Schema.String),
  r2_jurisdiction: Schema.optional(Schema.String),
  web_crawler: Schema.optional(Schema.Struct({
  parse_options: Schema.optional(Schema.Struct({
  include_headers: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  include_images: Schema.optional(Schema.Boolean),
  use_browser_rendering: Schema.optional(Schema.Boolean)
})),
  parse_type: Schema.optional(Schema.Literal("sitemap", "feed-rss")),
  store_options: Schema.optional(Schema.Struct({
  r2_jurisdiction: Schema.optional(Schema.String),
  storage_id: Schema.String,
  storage_type: Schema.optional(Schema.Literal("r2"))
}))
}))
})),
  status: Schema.optional(Schema.String),
  summarization: Schema.optional(Schema.Boolean),
  summarization_model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  system_prompt_ai_search: Schema.optional(Schema.String),
  system_prompt_index_summarization: Schema.optional(Schema.String),
  system_prompt_rewrite_query: Schema.optional(Schema.String),
  token_id: Schema.UUID,
  type: Schema.Literal("r2", "web-crawler"),
  vectorize_active_namespace: Schema.optional(Schema.String),
  vectorize_name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteInstancesResponse" }) as unknown as Schema.Schema<DeleteInstancesResponse>;

export const deleteInstances: (
  input: DeleteInstancesRequest
) => Effect.Effect<
  DeleteInstancesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteInstancesRequest,
  output: DeleteInstancesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListItemsRequest {
  id: string;
  account_id: string;
  page?: number;
  per_page?: number;
  search?: string;
  status?: "queued" | "running" | "completed" | "error" | "skipped";
}

export const ListItemsRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
  status: Schema.optional(Schema.Literal("queued", "running", "completed", "error", "skipped")).pipe(T.HttpQuery("status"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-search/instances/{id}/items" }),
).annotations({ identifier: "ListItemsRequest" }) as unknown as Schema.Schema<ListItemsRequest>;

export interface ListItemsResponse {
  result: { error?: string; id: string; key: string; last_seen_at?: string; next_action?: string; status: "queued" | "running" | "completed" | "error" | "skipped" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListItemsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  error: Schema.optional(Schema.String),
  id: Schema.String,
  key: Schema.String,
  last_seen_at: Schema.optional(Schema.Date),
  next_action: Schema.optional(Schema.String),
  status: Schema.Literal("queued", "running", "completed", "error", "skipped")
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListItemsResponse" }) as unknown as Schema.Schema<ListItemsResponse>;

export const listItems: (
  input: ListItemsRequest
) => Effect.Effect<
  ListItemsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListItemsRequest,
  output: ListItemsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetItemRequest {
  id: string;
  item_id: string;
  account_id: string;
}

export const GetItemRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  item_id: Schema.String.pipe(T.HttpPath("item_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-search/instances/{id}/items/{item_id}" }),
).annotations({ identifier: "GetItemRequest" }) as unknown as Schema.Schema<GetItemRequest>;

export interface GetItemResponse {
  result: { error?: string; id: string; key: string; last_seen_at?: string; next_action?: string; status: "queued" | "running" | "completed" | "error" | "skipped" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetItemResponse = Schema.Struct({
  result: Schema.Struct({
  error: Schema.optional(Schema.String),
  id: Schema.String,
  key: Schema.String,
  last_seen_at: Schema.optional(Schema.Date),
  next_action: Schema.optional(Schema.String),
  status: Schema.Literal("queued", "running", "completed", "error", "skipped")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetItemResponse" }) as unknown as Schema.Schema<GetItemResponse>;

export const getItem: (
  input: GetItemRequest
) => Effect.Effect<
  GetItemResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetItemRequest,
  output: GetItemResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListJobsRequest {
  id: string;
  account_id: string;
  page?: number;
  per_page?: number;
}

export const ListJobsRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-search/instances/{id}/jobs" }),
).annotations({ identifier: "ListJobsRequest" }) as unknown as Schema.Schema<ListJobsRequest>;

export interface ListJobsResponse {
  result: { end_reason?: string; ended_at?: string; id: string; last_seen_at?: string; source: "user" | "schedule"; started_at?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListJobsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  end_reason: Schema.optional(Schema.String),
  ended_at: Schema.optional(Schema.String),
  id: Schema.String,
  last_seen_at: Schema.optional(Schema.String),
  source: Schema.Literal("user", "schedule"),
  started_at: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListJobsResponse" }) as unknown as Schema.Schema<ListJobsResponse>;

export const listJobs: (
  input: ListJobsRequest
) => Effect.Effect<
  ListJobsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListJobsRequest,
  output: ListJobsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateJobRequest {
  id: string;
  account_id: string;
}

export const CreateJobRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai-search/instances/{id}/jobs" }),
).annotations({ identifier: "CreateJobRequest" }) as unknown as Schema.Schema<CreateJobRequest>;

export interface CreateJobResponse {
  result: { end_reason?: string; ended_at?: string; id: string; last_seen_at?: string; source: "user" | "schedule"; started_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateJobResponse = Schema.Struct({
  result: Schema.Struct({
  end_reason: Schema.optional(Schema.String),
  ended_at: Schema.optional(Schema.String),
  id: Schema.String,
  last_seen_at: Schema.optional(Schema.String),
  source: Schema.Literal("user", "schedule"),
  started_at: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateJobResponse" }) as unknown as Schema.Schema<CreateJobResponse>;

export const createJob: (
  input: CreateJobRequest
) => Effect.Effect<
  CreateJobResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateJobRequest,
  output: CreateJobResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetJobRequest {
  id: string;
  job_id: string;
  account_id: string;
}

export const GetJobRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  job_id: Schema.String.pipe(T.HttpPath("job_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-search/instances/{id}/jobs/{job_id}" }),
).annotations({ identifier: "GetJobRequest" }) as unknown as Schema.Schema<GetJobRequest>;

export interface GetJobResponse {
  result: { end_reason?: string; ended_at?: string; id: string; last_seen_at?: string; source: "user" | "schedule"; started_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetJobResponse = Schema.Struct({
  result: Schema.Struct({
  end_reason: Schema.optional(Schema.String),
  ended_at: Schema.optional(Schema.String),
  id: Schema.String,
  last_seen_at: Schema.optional(Schema.String),
  source: Schema.Literal("user", "schedule"),
  started_at: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetJobResponse" }) as unknown as Schema.Schema<GetJobResponse>;

export const getJob: (
  input: GetJobRequest
) => Effect.Effect<
  GetJobResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetJobRequest,
  output: GetJobResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListJobLogsRequest {
  id: string;
  job_id: string;
  account_id: string;
  page?: number;
  per_page?: number;
}

export const ListJobLogsRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  job_id: Schema.String.pipe(T.HttpPath("job_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-search/instances/{id}/jobs/{job_id}/logs" }),
).annotations({ identifier: "ListJobLogsRequest" }) as unknown as Schema.Schema<ListJobLogsRequest>;

export interface ListJobLogsResponse {
  result: { created_at: number; id: number; message: string; message_type: number }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListJobLogsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.Number,
  id: Schema.Number,
  message: Schema.String,
  message_type: Schema.Number
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListJobLogsResponse" }) as unknown as Schema.Schema<ListJobLogsResponse>;

export const listJobLogs: (
  input: ListJobLogsRequest
) => Effect.Effect<
  ListJobLogsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListJobLogsRequest,
  output: ListJobLogsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AiSearchStatsRequest {
  id: string;
  account_id: string;
}

export const AiSearchStatsRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-search/instances/{id}/stats" }),
).annotations({ identifier: "AiSearchStatsRequest" }) as unknown as Schema.Schema<AiSearchStatsRequest>;

export interface AiSearchStatsResponse {
  result: { completed?: number; error?: number; file_embed_errors?: Record<string, unknown>; index_source_errors?: Record<string, unknown>; last_activity?: string; queued?: number; running?: number; skipped?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AiSearchStatsResponse = Schema.Struct({
  result: Schema.Struct({
  completed: Schema.optional(Schema.Number),
  error: Schema.optional(Schema.Number),
  file_embed_errors: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Unknown })),
  index_source_errors: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Unknown })),
  last_activity: Schema.optional(Schema.Date),
  queued: Schema.optional(Schema.Number),
  running: Schema.optional(Schema.Number),
  skipped: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AiSearchStatsResponse" }) as unknown as Schema.Schema<AiSearchStatsResponse>;

export const aiSearchStats: (
  input: AiSearchStatsRequest
) => Effect.Effect<
  AiSearchStatsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AiSearchStatsRequest,
  output: AiSearchStatsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListTokensRequest {
  account_id: string;
  page?: number;
  per_page?: number;
}

export const ListTokensRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-search/tokens" }),
).annotations({ identifier: "ListTokensRequest" }) as unknown as Schema.Schema<ListTokensRequest>;

export interface ListTokensResponse {
  result: { account_id: string; account_tag: string; cf_api_id: string; cf_api_key: string; created_at: string; created_by?: string; enabled?: boolean; id: string; legacy?: boolean; modified_at: string; modified_by?: string; name: string; synced_at?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListTokensResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  cf_api_id: Schema.String,
  cf_api_key: Schema.String,
  created_at: Schema.Date,
  created_by: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.UUID,
  legacy: Schema.optional(Schema.Boolean),
  modified_at: Schema.Date,
  modified_by: Schema.optional(Schema.String),
  name: Schema.String,
  synced_at: Schema.optional(Schema.Date)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListTokensResponse" }) as unknown as Schema.Schema<ListTokensResponse>;

export const listTokens: (
  input: ListTokensRequest
) => Effect.Effect<
  ListTokensResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListTokensRequest,
  output: ListTokensResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateTokensRequest {
  account_id: string;
  body: { cf_api_id: string; cf_api_key: string; legacy?: boolean; name: string };
}

export const CreateTokensRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  cf_api_id: Schema.String,
  cf_api_key: Schema.String,
  legacy: Schema.optional(Schema.Boolean),
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai-search/tokens" }),
).annotations({ identifier: "CreateTokensRequest" }) as unknown as Schema.Schema<CreateTokensRequest>;

export interface CreateTokensResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateTokensResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateTokensResponse" }) as unknown as Schema.Schema<CreateTokensResponse>;

export const createTokens: (
  input: CreateTokensRequest
) => Effect.Effect<
  CreateTokensResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateTokensRequest,
  output: CreateTokensResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AiSearchFetchTokensRequest {
  account_id: string;
  id: string;
}

export const AiSearchFetchTokensRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.UUID.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai-search/tokens/{id}" }),
).annotations({ identifier: "AiSearchFetchTokensRequest" }) as unknown as Schema.Schema<AiSearchFetchTokensRequest>;

export interface AiSearchFetchTokensResponse {
  result: { account_id: string; account_tag: string; cf_api_id: string; cf_api_key: string; created_at: string; created_by?: string; enabled?: boolean; id: string; legacy?: boolean; modified_at: string; modified_by?: string; name: string; synced_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AiSearchFetchTokensResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  cf_api_id: Schema.String,
  cf_api_key: Schema.String,
  created_at: Schema.Date,
  created_by: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.UUID,
  legacy: Schema.optional(Schema.Boolean),
  modified_at: Schema.Date,
  modified_by: Schema.optional(Schema.String),
  name: Schema.String,
  synced_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AiSearchFetchTokensResponse" }) as unknown as Schema.Schema<AiSearchFetchTokensResponse>;

export const aiSearchFetchTokens: (
  input: AiSearchFetchTokensRequest
) => Effect.Effect<
  AiSearchFetchTokensResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AiSearchFetchTokensRequest,
  output: AiSearchFetchTokensResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateTokensRequest {
  account_id: string;
  id: string;
  body: { cf_api_id: string; cf_api_key: string; legacy?: boolean; name: string };
}

export const UpdateTokensRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.UUID.pipe(T.HttpPath("id")),
  body: Schema.Struct({
  cf_api_id: Schema.String,
  cf_api_key: Schema.String,
  legacy: Schema.optional(Schema.Boolean),
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/ai-search/tokens/{id}" }),
).annotations({ identifier: "UpdateTokensRequest" }) as unknown as Schema.Schema<UpdateTokensRequest>;

export interface UpdateTokensResponse {
  result: { account_id: string; account_tag: string; cf_api_id: string; cf_api_key: string; created_at: string; created_by?: string; enabled?: boolean; id: string; legacy?: boolean; modified_at: string; modified_by?: string; name: string; synced_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateTokensResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  cf_api_id: Schema.String,
  cf_api_key: Schema.String,
  created_at: Schema.Date,
  created_by: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.UUID,
  legacy: Schema.optional(Schema.Boolean),
  modified_at: Schema.Date,
  modified_by: Schema.optional(Schema.String),
  name: Schema.String,
  synced_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateTokensResponse" }) as unknown as Schema.Schema<UpdateTokensResponse>;

export const updateTokens: (
  input: UpdateTokensRequest
) => Effect.Effect<
  UpdateTokensResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateTokensRequest,
  output: UpdateTokensResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteTokensRequest {
  account_id: string;
  id: string;
}

export const DeleteTokensRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.UUID.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/ai-search/tokens/{id}" }),
).annotations({ identifier: "DeleteTokensRequest" }) as unknown as Schema.Schema<DeleteTokensRequest>;

export interface DeleteTokensResponse {
  result: { account_id: string; account_tag: string; cf_api_id: string; cf_api_key: string; created_at: string; created_by?: string; enabled?: boolean; id: string; legacy?: boolean; modified_at: string; modified_by?: string; name: string; synced_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteTokensResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  account_tag: Schema.String,
  cf_api_id: Schema.String,
  cf_api_key: Schema.String,
  created_at: Schema.Date,
  created_by: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.UUID,
  legacy: Schema.optional(Schema.Boolean),
  modified_at: Schema.Date,
  modified_by: Schema.optional(Schema.String),
  name: Schema.String,
  synced_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteTokensResponse" }) as unknown as Schema.Schema<DeleteTokensResponse>;

export const deleteTokens: (
  input: DeleteTokensRequest
) => Effect.Effect<
  DeleteTokensResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteTokensRequest,
  output: DeleteTokensResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface WorkersAiSearchAuthorRequest {
  account_id: string;
}

export const WorkersAiSearchAuthorRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/authors/search" }),
).annotations({ identifier: "WorkersAiSearchAuthorRequest" }) as unknown as Schema.Schema<WorkersAiSearchAuthorRequest>;

export interface WorkersAiSearchAuthorResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const WorkersAiSearchAuthorResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "WorkersAiSearchAuthorResponse" }) as unknown as Schema.Schema<WorkersAiSearchAuthorResponse>;

export const workersAiSearchAuthor: (
  input: WorkersAiSearchAuthorRequest
) => Effect.Effect<
  WorkersAiSearchAuthorResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: WorkersAiSearchAuthorRequest,
  output: WorkersAiSearchAuthorResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListFinetunesRequest {
  account_id: string;
}

export const ListFinetunesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/finetunes" }),
).annotations({ identifier: "ListFinetunesRequest" }) as unknown as Schema.Schema<ListFinetunesRequest>;

export interface ListFinetunesResponse {
  result: { created_at: string; description?: string; id: string; model: string; modified_at: string; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListFinetunesResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  description: Schema.optional(Schema.String),
  id: Schema.UUID,
  model: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListFinetunesResponse" }) as unknown as Schema.Schema<ListFinetunesResponse>;

export const listFinetunes: (
  input: ListFinetunesRequest
) => Effect.Effect<
  ListFinetunesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListFinetunesRequest,
  output: ListFinetunesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateFinetuneRequest {
  account_id: string;
  body: { description?: string; model: string; name: string; public?: boolean };
}

export const CreateFinetuneRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  model: Schema.String,
  name: Schema.String,
  public: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/finetunes" }),
).annotations({ identifier: "CreateFinetuneRequest" }) as unknown as Schema.Schema<CreateFinetuneRequest>;

export interface CreateFinetuneResponse {
  result: { created_at: string; description?: string; id: string; model: string; modified_at: string; name: string; public: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateFinetuneResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  description: Schema.optional(Schema.String),
  id: Schema.UUID,
  model: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  public: Schema.Boolean
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateFinetuneResponse" }) as unknown as Schema.Schema<CreateFinetuneResponse>;

export const createFinetune: (
  input: CreateFinetuneRequest
) => Effect.Effect<
  CreateFinetuneResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateFinetuneRequest,
  output: CreateFinetuneResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListPublicFinetunesRequest {
  account_id: string;
  limit?: number;
  offset?: number;
  orderBy?: string;
}

export const ListPublicFinetunesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/finetunes/public" }),
).annotations({ identifier: "ListPublicFinetunesRequest" }) as unknown as Schema.Schema<ListPublicFinetunesRequest>;

export interface ListPublicFinetunesResponse {
  result: { created_at: string; description?: string; id: string; model: string; modified_at: string; name: string; public: boolean }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListPublicFinetunesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.Date,
  description: Schema.optional(Schema.String),
  id: Schema.UUID,
  model: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  public: Schema.Boolean
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListPublicFinetunesResponse" }) as unknown as Schema.Schema<ListPublicFinetunesResponse>;

export const listPublicFinetunes: (
  input: ListPublicFinetunesRequest
) => Effect.Effect<
  ListPublicFinetunesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListPublicFinetunesRequest,
  output: ListPublicFinetunesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface WorkersAiUploadFinetuneAssetRequest {
  account_id: string;
  finetune_id: string;
  body: FormData;
}

export const WorkersAiUploadFinetuneAssetRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  finetune_id: Schema.String.pipe(T.HttpPath("finetune_id")),
  body: Schema.instanceOf(FormData).pipe(T.HttpFormData())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/finetunes/{finetune_id}/finetune-assets" }),
).annotations({ identifier: "WorkersAiUploadFinetuneAssetRequest" }) as unknown as Schema.Schema<WorkersAiUploadFinetuneAssetRequest>;

export interface WorkersAiUploadFinetuneAssetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const WorkersAiUploadFinetuneAssetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "WorkersAiUploadFinetuneAssetResponse" }) as unknown as Schema.Schema<WorkersAiUploadFinetuneAssetResponse>;

export const workersAiUploadFinetuneAsset: (
  input: WorkersAiUploadFinetuneAssetRequest
) => Effect.Effect<
  WorkersAiUploadFinetuneAssetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: WorkersAiUploadFinetuneAssetRequest,
  output: WorkersAiUploadFinetuneAssetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetModelSchemaRequest {
  account_id: string;
  model: string;
}

export const GetModelSchemaRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  model: Schema.String.pipe(T.HttpQuery("model"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/models/schema" }),
).annotations({ identifier: "GetModelSchemaRequest" }) as unknown as Schema.Schema<GetModelSchemaRequest>;

export interface GetModelSchemaResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetModelSchemaResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetModelSchemaResponse" }) as unknown as Schema.Schema<GetModelSchemaResponse>;

export const getModelSchema: (
  input: GetModelSchemaRequest
) => Effect.Effect<
  GetModelSchemaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetModelSchemaRequest,
  output: GetModelSchemaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface WorkersAiSearchModelRequest {
  account_id: string;
  per_page?: number;
  page?: number;
  task?: string;
  author?: string;
  source?: number;
  hide_experimental?: boolean;
  search?: string;
}

export const WorkersAiSearchModelRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  task: Schema.optional(Schema.String).pipe(T.HttpQuery("task")),
  author: Schema.optional(Schema.String).pipe(T.HttpQuery("author")),
  source: Schema.optional(Schema.Number).pipe(T.HttpQuery("source")),
  hide_experimental: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("hide_experimental")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/models/search" }),
).annotations({ identifier: "WorkersAiSearchModelRequest" }) as unknown as Schema.Schema<WorkersAiSearchModelRequest>;

export interface WorkersAiSearchModelResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const WorkersAiSearchModelResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "WorkersAiSearchModelResponse" }) as unknown as Schema.Schema<WorkersAiSearchModelResponse>;

export const workersAiSearchModel: (
  input: WorkersAiSearchModelRequest
) => Effect.Effect<
  WorkersAiSearchModelResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: WorkersAiSearchModelRequest,
  output: WorkersAiSearchModelResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfAi4bharatIndictrans2EnIndic1bRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { target_language: "asm_Beng" | "awa_Deva" | "ben_Beng" | "bho_Deva" | "brx_Deva" | "doi_Deva" | "eng_Latn" | "gom_Deva" | "gon_Deva" | "guj_Gujr" | "hin_Deva" | "hne_Deva" | "kan_Knda" | "kas_Arab" | "kas_Deva" | "kha_Latn" | "lus_Latn" | "mag_Deva" | "mai_Deva" | "mal_Mlym" | "mar_Deva" | "mni_Beng" | "mni_Mtei" | "npi_Deva" | "ory_Orya" | "pan_Guru" | "san_Deva" | "sat_Olck" | "snd_Arab" | "snd_Deva" | "tam_Taml" | "tel_Telu" | "urd_Arab" | "unr_Deva"; text: unknown };
}

export const PostRunCfAi4bharatIndictrans2EnIndic1bRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  target_language: Schema.Literal("asm_Beng", "awa_Deva", "ben_Beng", "bho_Deva", "brx_Deva", "doi_Deva", "eng_Latn", "gom_Deva", "gon_Deva", "guj_Gujr", "hin_Deva", "hne_Deva", "kan_Knda", "kas_Arab", "kas_Deva", "kha_Latn", "lus_Latn", "mag_Deva", "mai_Deva", "mal_Mlym", "mar_Deva", "mni_Beng", "mni_Mtei", "npi_Deva", "ory_Orya", "pan_Guru", "san_Deva", "sat_Olck", "snd_Arab", "snd_Deva", "tam_Taml", "tel_Telu", "urd_Arab", "unr_Deva"),
  text: Schema.Union(Schema.String, Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/ai4bharat/indictrans2-en-indic-1B" }),
).annotations({ identifier: "PostRunCfAi4bharatIndictrans2EnIndic1bRequest" }) as unknown as Schema.Schema<PostRunCfAi4bharatIndictrans2EnIndic1bRequest>;

export interface PostRunCfAi4bharatIndictrans2EnIndic1bResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfAi4bharatIndictrans2EnIndic1bResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfAi4bharatIndictrans2EnIndic1bResponse" }) as unknown as Schema.Schema<PostRunCfAi4bharatIndictrans2EnIndic1bResponse>;

export const postRunCfAi4bharatIndictrans2EnIndic1b: (
  input: PostRunCfAi4bharatIndictrans2EnIndic1bRequest
) => Effect.Effect<
  PostRunCfAi4bharatIndictrans2EnIndic1bResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfAi4bharatIndictrans2EnIndic1bRequest,
  output: PostRunCfAi4bharatIndictrans2EnIndic1bResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfAisingaporeGemmaSeaLionV427bItRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfAisingaporeGemmaSeaLionV427bItRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/aisingapore/gemma-sea-lion-v4-27b-it" }),
).annotations({ identifier: "PostRunCfAisingaporeGemmaSeaLionV427bItRequest" }) as unknown as Schema.Schema<PostRunCfAisingaporeGemmaSeaLionV427bItRequest>;

export interface PostRunCfAisingaporeGemmaSeaLionV427bItResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfAisingaporeGemmaSeaLionV427bItResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfAisingaporeGemmaSeaLionV427bItResponse" }) as unknown as Schema.Schema<PostRunCfAisingaporeGemmaSeaLionV427bItResponse>;

export const postRunCfAisingaporeGemmaSeaLionV427bIt: (
  input: PostRunCfAisingaporeGemmaSeaLionV427bItRequest
) => Effect.Effect<
  PostRunCfAisingaporeGemmaSeaLionV427bItResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfAisingaporeGemmaSeaLionV427bItRequest,
  output: PostRunCfAisingaporeGemmaSeaLionV427bItResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfBaaiBgeBaseEnV15Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfBaaiBgeBaseEnV15Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/baai/bge-base-en-v1.5" }),
).annotations({ identifier: "PostRunCfBaaiBgeBaseEnV15Request" }) as unknown as Schema.Schema<PostRunCfBaaiBgeBaseEnV15Request>;

export interface PostRunCfBaaiBgeBaseEnV15Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfBaaiBgeBaseEnV15Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfBaaiBgeBaseEnV15Response" }) as unknown as Schema.Schema<PostRunCfBaaiBgeBaseEnV15Response>;

export const postRunCfBaaiBgeBaseEnV15: (
  input: PostRunCfBaaiBgeBaseEnV15Request
) => Effect.Effect<
  PostRunCfBaaiBgeBaseEnV15Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfBaaiBgeBaseEnV15Request,
  output: PostRunCfBaaiBgeBaseEnV15Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfBaaiBgeLargeEnV15Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfBaaiBgeLargeEnV15Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/baai/bge-large-en-v1.5" }),
).annotations({ identifier: "PostRunCfBaaiBgeLargeEnV15Request" }) as unknown as Schema.Schema<PostRunCfBaaiBgeLargeEnV15Request>;

export interface PostRunCfBaaiBgeLargeEnV15Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfBaaiBgeLargeEnV15Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfBaaiBgeLargeEnV15Response" }) as unknown as Schema.Schema<PostRunCfBaaiBgeLargeEnV15Response>;

export const postRunCfBaaiBgeLargeEnV15: (
  input: PostRunCfBaaiBgeLargeEnV15Request
) => Effect.Effect<
  PostRunCfBaaiBgeLargeEnV15Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfBaaiBgeLargeEnV15Request,
  output: PostRunCfBaaiBgeLargeEnV15Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfBaaiBgeM3Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfBaaiBgeM3Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/baai/bge-m3" }),
).annotations({ identifier: "PostRunCfBaaiBgeM3Request" }) as unknown as Schema.Schema<PostRunCfBaaiBgeM3Request>;

export interface PostRunCfBaaiBgeM3Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfBaaiBgeM3Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfBaaiBgeM3Response" }) as unknown as Schema.Schema<PostRunCfBaaiBgeM3Response>;

export const postRunCfBaaiBgeM3: (
  input: PostRunCfBaaiBgeM3Request
) => Effect.Effect<
  PostRunCfBaaiBgeM3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfBaaiBgeM3Request,
  output: PostRunCfBaaiBgeM3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfBaaiBgeRerankerBaseRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { contexts: { text?: string }[]; query: string; top_k?: number };
}

export const PostRunCfBaaiBgeRerankerBaseRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  contexts: Schema.Array(Schema.Struct({
  text: Schema.optional(Schema.String)
})),
  query: Schema.String,
  top_k: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/baai/bge-reranker-base" }),
).annotations({ identifier: "PostRunCfBaaiBgeRerankerBaseRequest" }) as unknown as Schema.Schema<PostRunCfBaaiBgeRerankerBaseRequest>;

export interface PostRunCfBaaiBgeRerankerBaseResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfBaaiBgeRerankerBaseResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfBaaiBgeRerankerBaseResponse" }) as unknown as Schema.Schema<PostRunCfBaaiBgeRerankerBaseResponse>;

export const postRunCfBaaiBgeRerankerBase: (
  input: PostRunCfBaaiBgeRerankerBaseRequest
) => Effect.Effect<
  PostRunCfBaaiBgeRerankerBaseResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfBaaiBgeRerankerBaseRequest,
  output: PostRunCfBaaiBgeRerankerBaseResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfBaaiBgeSmallEnV15Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfBaaiBgeSmallEnV15Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/baai/bge-small-en-v1.5" }),
).annotations({ identifier: "PostRunCfBaaiBgeSmallEnV15Request" }) as unknown as Schema.Schema<PostRunCfBaaiBgeSmallEnV15Request>;

export interface PostRunCfBaaiBgeSmallEnV15Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfBaaiBgeSmallEnV15Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfBaaiBgeSmallEnV15Response" }) as unknown as Schema.Schema<PostRunCfBaaiBgeSmallEnV15Response>;

export const postRunCfBaaiBgeSmallEnV15: (
  input: PostRunCfBaaiBgeSmallEnV15Request
) => Effect.Effect<
  PostRunCfBaaiBgeSmallEnV15Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfBaaiBgeSmallEnV15Request,
  output: PostRunCfBaaiBgeSmallEnV15Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfBaaiOmniBgeBaseEnV15Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfBaaiOmniBgeBaseEnV15Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/baai/omni-bge-base-en-v1.5" }),
).annotations({ identifier: "PostRunCfBaaiOmniBgeBaseEnV15Request" }) as unknown as Schema.Schema<PostRunCfBaaiOmniBgeBaseEnV15Request>;

export interface PostRunCfBaaiOmniBgeBaseEnV15Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfBaaiOmniBgeBaseEnV15Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfBaaiOmniBgeBaseEnV15Response" }) as unknown as Schema.Schema<PostRunCfBaaiOmniBgeBaseEnV15Response>;

export const postRunCfBaaiOmniBgeBaseEnV15: (
  input: PostRunCfBaaiOmniBgeBaseEnV15Request
) => Effect.Effect<
  PostRunCfBaaiOmniBgeBaseEnV15Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfBaaiOmniBgeBaseEnV15Request,
  output: PostRunCfBaaiOmniBgeBaseEnV15Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfBaaiOmniBgeLargeEnV15Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfBaaiOmniBgeLargeEnV15Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/baai/omni-bge-large-en-v1.5" }),
).annotations({ identifier: "PostRunCfBaaiOmniBgeLargeEnV15Request" }) as unknown as Schema.Schema<PostRunCfBaaiOmniBgeLargeEnV15Request>;

export interface PostRunCfBaaiOmniBgeLargeEnV15Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfBaaiOmniBgeLargeEnV15Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfBaaiOmniBgeLargeEnV15Response" }) as unknown as Schema.Schema<PostRunCfBaaiOmniBgeLargeEnV15Response>;

export const postRunCfBaaiOmniBgeLargeEnV15: (
  input: PostRunCfBaaiOmniBgeLargeEnV15Request
) => Effect.Effect<
  PostRunCfBaaiOmniBgeLargeEnV15Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfBaaiOmniBgeLargeEnV15Request,
  output: PostRunCfBaaiOmniBgeLargeEnV15Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfBaaiOmniBgeM3Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfBaaiOmniBgeM3Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/baai/omni-bge-m3" }),
).annotations({ identifier: "PostRunCfBaaiOmniBgeM3Request" }) as unknown as Schema.Schema<PostRunCfBaaiOmniBgeM3Request>;

export interface PostRunCfBaaiOmniBgeM3Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfBaaiOmniBgeM3Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfBaaiOmniBgeM3Response" }) as unknown as Schema.Schema<PostRunCfBaaiOmniBgeM3Response>;

export const postRunCfBaaiOmniBgeM3: (
  input: PostRunCfBaaiOmniBgeM3Request
) => Effect.Effect<
  PostRunCfBaaiOmniBgeM3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfBaaiOmniBgeM3Request,
  output: PostRunCfBaaiOmniBgeM3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfBaaiOmniBgeSmallEnV15Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfBaaiOmniBgeSmallEnV15Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/baai/omni-bge-small-en-v1.5" }),
).annotations({ identifier: "PostRunCfBaaiOmniBgeSmallEnV15Request" }) as unknown as Schema.Schema<PostRunCfBaaiOmniBgeSmallEnV15Request>;

export interface PostRunCfBaaiOmniBgeSmallEnV15Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfBaaiOmniBgeSmallEnV15Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfBaaiOmniBgeSmallEnV15Response" }) as unknown as Schema.Schema<PostRunCfBaaiOmniBgeSmallEnV15Response>;

export const postRunCfBaaiOmniBgeSmallEnV15: (
  input: PostRunCfBaaiOmniBgeSmallEnV15Request
) => Effect.Effect<
  PostRunCfBaaiOmniBgeSmallEnV15Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfBaaiOmniBgeSmallEnV15Request,
  output: PostRunCfBaaiOmniBgeSmallEnV15Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfBaaiRayBgeLargeEnV15Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfBaaiRayBgeLargeEnV15Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/baai/ray-bge-large-en-v1.5" }),
).annotations({ identifier: "PostRunCfBaaiRayBgeLargeEnV15Request" }) as unknown as Schema.Schema<PostRunCfBaaiRayBgeLargeEnV15Request>;

export interface PostRunCfBaaiRayBgeLargeEnV15Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfBaaiRayBgeLargeEnV15Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfBaaiRayBgeLargeEnV15Response" }) as unknown as Schema.Schema<PostRunCfBaaiRayBgeLargeEnV15Response>;

export const postRunCfBaaiRayBgeLargeEnV15: (
  input: PostRunCfBaaiRayBgeLargeEnV15Request
) => Effect.Effect<
  PostRunCfBaaiRayBgeLargeEnV15Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfBaaiRayBgeLargeEnV15Request,
  output: PostRunCfBaaiRayBgeLargeEnV15Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfBlackForestLabsFlux1SchnellRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { prompt: string; steps?: number };
}

export const PostRunCfBlackForestLabsFlux1SchnellRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  prompt: Schema.String,
  steps: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/black-forest-labs/flux-1-schnell" }),
).annotations({ identifier: "PostRunCfBlackForestLabsFlux1SchnellRequest" }) as unknown as Schema.Schema<PostRunCfBlackForestLabsFlux1SchnellRequest>;

export interface PostRunCfBlackForestLabsFlux1SchnellResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfBlackForestLabsFlux1SchnellResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfBlackForestLabsFlux1SchnellResponse" }) as unknown as Schema.Schema<PostRunCfBlackForestLabsFlux1SchnellResponse>;

export const postRunCfBlackForestLabsFlux1Schnell: (
  input: PostRunCfBlackForestLabsFlux1SchnellRequest
) => Effect.Effect<
  PostRunCfBlackForestLabsFlux1SchnellResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfBlackForestLabsFlux1SchnellRequest,
  output: PostRunCfBlackForestLabsFlux1SchnellResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfBlackForestLabsFlux2DevRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { multipart: { body?: Record<string, unknown>; contentType?: string } };
}

export const PostRunCfBlackForestLabsFlux2DevRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  multipart: Schema.Struct({
  body: Schema.optional(Schema.Struct({})),
  contentType: Schema.optional(Schema.String)
})
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/black-forest-labs/flux-2-dev" }),
).annotations({ identifier: "PostRunCfBlackForestLabsFlux2DevRequest" }) as unknown as Schema.Schema<PostRunCfBlackForestLabsFlux2DevRequest>;

export interface PostRunCfBlackForestLabsFlux2DevResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfBlackForestLabsFlux2DevResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfBlackForestLabsFlux2DevResponse" }) as unknown as Schema.Schema<PostRunCfBlackForestLabsFlux2DevResponse>;

export const postRunCfBlackForestLabsFlux2Dev: (
  input: PostRunCfBlackForestLabsFlux2DevRequest
) => Effect.Effect<
  PostRunCfBlackForestLabsFlux2DevResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfBlackForestLabsFlux2DevRequest,
  output: PostRunCfBlackForestLabsFlux2DevResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfBytedanceStableDiffusionXlLightningRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { guidance?: number; height?: number; image?: number[]; image_b64?: string; mask?: number[]; negative_prompt?: string; num_steps?: number; prompt: string; seed?: number; strength?: number; width?: number };
}

export const PostRunCfBytedanceStableDiffusionXlLightningRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  guidance: Schema.optional(Schema.Number),
  height: Schema.optional(Schema.Number),
  image: Schema.optional(Schema.Array(Schema.Number)),
  image_b64: Schema.optional(Schema.String),
  mask: Schema.optional(Schema.Array(Schema.Number)),
  negative_prompt: Schema.optional(Schema.String),
  num_steps: Schema.optional(Schema.Number),
  prompt: Schema.String,
  seed: Schema.optional(Schema.Number),
  strength: Schema.optional(Schema.Number),
  width: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/bytedance/stable-diffusion-xl-lightning" }),
).annotations({ identifier: "PostRunCfBytedanceStableDiffusionXlLightningRequest" }) as unknown as Schema.Schema<PostRunCfBytedanceStableDiffusionXlLightningRequest>;

export interface PostRunCfBytedanceStableDiffusionXlLightningResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfBytedanceStableDiffusionXlLightningResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfBytedanceStableDiffusionXlLightningResponse" }) as unknown as Schema.Schema<PostRunCfBytedanceStableDiffusionXlLightningResponse>;

export const postRunCfBytedanceStableDiffusionXlLightning: (
  input: PostRunCfBytedanceStableDiffusionXlLightningRequest
) => Effect.Effect<
  PostRunCfBytedanceStableDiffusionXlLightningResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfBytedanceStableDiffusionXlLightningRequest,
  output: PostRunCfBytedanceStableDiffusionXlLightningResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostWebsocketRunCfDeepgramAuraRequest {
  account_id: string;
}

export const PostWebsocketRunCfDeepgramAuraRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/run/@cf/deepgram/aura" }),
).annotations({ identifier: "PostWebsocketRunCfDeepgramAuraRequest" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramAuraRequest>;

export interface PostWebsocketRunCfDeepgramAuraResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostWebsocketRunCfDeepgramAuraResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostWebsocketRunCfDeepgramAuraResponse" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramAuraResponse>;

export const postWebsocketRunCfDeepgramAura: (
  input: PostWebsocketRunCfDeepgramAuraRequest
) => Effect.Effect<
  PostWebsocketRunCfDeepgramAuraResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostWebsocketRunCfDeepgramAuraRequest,
  output: PostWebsocketRunCfDeepgramAuraResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostWebsocketRunCfDeepgramAura1Request {
  account_id: string;
}

export const PostWebsocketRunCfDeepgramAura1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/run/@cf/deepgram/aura-1" }),
).annotations({ identifier: "PostWebsocketRunCfDeepgramAura1Request" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramAura1Request>;

export interface PostWebsocketRunCfDeepgramAura1Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostWebsocketRunCfDeepgramAura1Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostWebsocketRunCfDeepgramAura1Response" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramAura1Response>;

export const postWebsocketRunCfDeepgramAura1: (
  input: PostWebsocketRunCfDeepgramAura1Request
) => Effect.Effect<
  PostWebsocketRunCfDeepgramAura1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostWebsocketRunCfDeepgramAura1Request,
  output: PostWebsocketRunCfDeepgramAura1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfDeepgramAura1Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { bit_rate?: number; container?: "none" | "wav" | "ogg"; encoding?: "linear16" | "flac" | "mulaw" | "alaw" | "mp3" | "opus" | "aac"; sample_rate?: number; speaker?: "angus" | "asteria" | "arcas" | "orion" | "orpheus" | "athena" | "luna" | "zeus" | "perseus" | "helios" | "hera" | "stella"; text: string };
}

export const PostRunCfDeepgramAura1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  bit_rate: Schema.optional(Schema.Number),
  container: Schema.optional(Schema.Literal("none", "wav", "ogg")),
  encoding: Schema.optional(Schema.Literal("linear16", "flac", "mulaw", "alaw", "mp3", "opus", "aac")),
  sample_rate: Schema.optional(Schema.Number),
  speaker: Schema.optional(Schema.Literal("angus", "asteria", "arcas", "orion", "orpheus", "athena", "luna", "zeus", "perseus", "helios", "hera", "stella")),
  text: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/deepgram/aura-1" }),
).annotations({ identifier: "PostRunCfDeepgramAura1Request" }) as unknown as Schema.Schema<PostRunCfDeepgramAura1Request>;

export interface PostRunCfDeepgramAura1Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfDeepgramAura1Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfDeepgramAura1Response" }) as unknown as Schema.Schema<PostRunCfDeepgramAura1Response>;

export const postRunCfDeepgramAura1: (
  input: PostRunCfDeepgramAura1Request
) => Effect.Effect<
  PostRunCfDeepgramAura1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfDeepgramAura1Request,
  output: PostRunCfDeepgramAura1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostWebsocketRunCfDeepgramAura1InternalRequest {
  account_id: string;
}

export const PostWebsocketRunCfDeepgramAura1InternalRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/run/@cf/deepgram/aura-1-internal" }),
).annotations({ identifier: "PostWebsocketRunCfDeepgramAura1InternalRequest" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramAura1InternalRequest>;

export interface PostWebsocketRunCfDeepgramAura1InternalResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostWebsocketRunCfDeepgramAura1InternalResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostWebsocketRunCfDeepgramAura1InternalResponse" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramAura1InternalResponse>;

export const postWebsocketRunCfDeepgramAura1Internal: (
  input: PostWebsocketRunCfDeepgramAura1InternalRequest
) => Effect.Effect<
  PostWebsocketRunCfDeepgramAura1InternalResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostWebsocketRunCfDeepgramAura1InternalRequest,
  output: PostWebsocketRunCfDeepgramAura1InternalResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostWebsocketRunCfDeepgramAura2Request {
  account_id: string;
}

export const PostWebsocketRunCfDeepgramAura2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/run/@cf/deepgram/aura-2" }),
).annotations({ identifier: "PostWebsocketRunCfDeepgramAura2Request" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramAura2Request>;

export interface PostWebsocketRunCfDeepgramAura2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostWebsocketRunCfDeepgramAura2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostWebsocketRunCfDeepgramAura2Response" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramAura2Response>;

export const postWebsocketRunCfDeepgramAura2: (
  input: PostWebsocketRunCfDeepgramAura2Request
) => Effect.Effect<
  PostWebsocketRunCfDeepgramAura2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostWebsocketRunCfDeepgramAura2Request,
  output: PostWebsocketRunCfDeepgramAura2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostWebsocketRunCfDeepgramAura2EnRequest {
  account_id: string;
}

export const PostWebsocketRunCfDeepgramAura2EnRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/run/@cf/deepgram/aura-2-en" }),
).annotations({ identifier: "PostWebsocketRunCfDeepgramAura2EnRequest" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramAura2EnRequest>;

export interface PostWebsocketRunCfDeepgramAura2EnResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostWebsocketRunCfDeepgramAura2EnResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostWebsocketRunCfDeepgramAura2EnResponse" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramAura2EnResponse>;

export const postWebsocketRunCfDeepgramAura2En: (
  input: PostWebsocketRunCfDeepgramAura2EnRequest
) => Effect.Effect<
  PostWebsocketRunCfDeepgramAura2EnResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostWebsocketRunCfDeepgramAura2EnRequest,
  output: PostWebsocketRunCfDeepgramAura2EnResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfDeepgramAura2EnRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { bit_rate?: number; container?: "none" | "wav" | "ogg"; encoding?: "linear16" | "flac" | "mulaw" | "alaw" | "mp3" | "opus" | "aac"; sample_rate?: number; speaker?: "amalthea" | "andromeda" | "apollo" | "arcas" | "aries" | "asteria" | "athena" | "atlas" | "aurora" | "callista" | "cora" | "cordelia" | "delia" | "draco" | "electra" | "harmonia" | "helena" | "hera" | "hermes" | "hyperion" | "iris" | "janus" | "juno" | "jupiter" | "luna" | "mars" | "minerva" | "neptune" | "odysseus" | "ophelia" | "orion" | "orpheus" | "pandora" | "phoebe" | "pluto" | "saturn" | "thalia" | "theia" | "vesta" | "zeus"; text: string };
}

export const PostRunCfDeepgramAura2EnRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  bit_rate: Schema.optional(Schema.Number),
  container: Schema.optional(Schema.Literal("none", "wav", "ogg")),
  encoding: Schema.optional(Schema.Literal("linear16", "flac", "mulaw", "alaw", "mp3", "opus", "aac")),
  sample_rate: Schema.optional(Schema.Number),
  speaker: Schema.optional(Schema.Literal("amalthea", "andromeda", "apollo", "arcas", "aries", "asteria", "athena", "atlas", "aurora", "callista", "cora", "cordelia", "delia", "draco", "electra", "harmonia", "helena", "hera", "hermes", "hyperion", "iris", "janus", "juno", "jupiter", "luna", "mars", "minerva", "neptune", "odysseus", "ophelia", "orion", "orpheus", "pandora", "phoebe", "pluto", "saturn", "thalia", "theia", "vesta", "zeus")),
  text: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/deepgram/aura-2-en" }),
).annotations({ identifier: "PostRunCfDeepgramAura2EnRequest" }) as unknown as Schema.Schema<PostRunCfDeepgramAura2EnRequest>;

export interface PostRunCfDeepgramAura2EnResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfDeepgramAura2EnResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfDeepgramAura2EnResponse" }) as unknown as Schema.Schema<PostRunCfDeepgramAura2EnResponse>;

export const postRunCfDeepgramAura2En: (
  input: PostRunCfDeepgramAura2EnRequest
) => Effect.Effect<
  PostRunCfDeepgramAura2EnResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfDeepgramAura2EnRequest,
  output: PostRunCfDeepgramAura2EnResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostWebsocketRunCfDeepgramAura2EsRequest {
  account_id: string;
}

export const PostWebsocketRunCfDeepgramAura2EsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/run/@cf/deepgram/aura-2-es" }),
).annotations({ identifier: "PostWebsocketRunCfDeepgramAura2EsRequest" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramAura2EsRequest>;

export interface PostWebsocketRunCfDeepgramAura2EsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostWebsocketRunCfDeepgramAura2EsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostWebsocketRunCfDeepgramAura2EsResponse" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramAura2EsResponse>;

export const postWebsocketRunCfDeepgramAura2Es: (
  input: PostWebsocketRunCfDeepgramAura2EsRequest
) => Effect.Effect<
  PostWebsocketRunCfDeepgramAura2EsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostWebsocketRunCfDeepgramAura2EsRequest,
  output: PostWebsocketRunCfDeepgramAura2EsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfDeepgramAura2EsRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { bit_rate?: number; container?: "none" | "wav" | "ogg"; encoding?: "linear16" | "flac" | "mulaw" | "alaw" | "mp3" | "opus" | "aac"; sample_rate?: number; speaker?: "sirio" | "nestor" | "carina" | "celeste" | "alvaro" | "diana" | "aquila" | "selena" | "estrella" | "javier"; text: string };
}

export const PostRunCfDeepgramAura2EsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  bit_rate: Schema.optional(Schema.Number),
  container: Schema.optional(Schema.Literal("none", "wav", "ogg")),
  encoding: Schema.optional(Schema.Literal("linear16", "flac", "mulaw", "alaw", "mp3", "opus", "aac")),
  sample_rate: Schema.optional(Schema.Number),
  speaker: Schema.optional(Schema.Literal("sirio", "nestor", "carina", "celeste", "alvaro", "diana", "aquila", "selena", "estrella", "javier")),
  text: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/deepgram/aura-2-es" }),
).annotations({ identifier: "PostRunCfDeepgramAura2EsRequest" }) as unknown as Schema.Schema<PostRunCfDeepgramAura2EsRequest>;

export interface PostRunCfDeepgramAura2EsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfDeepgramAura2EsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfDeepgramAura2EsResponse" }) as unknown as Schema.Schema<PostRunCfDeepgramAura2EsResponse>;

export const postRunCfDeepgramAura2Es: (
  input: PostRunCfDeepgramAura2EsRequest
) => Effect.Effect<
  PostRunCfDeepgramAura2EsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfDeepgramAura2EsRequest,
  output: PostRunCfDeepgramAura2EsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostWebsocketRunCfDeepgramFluxRequest {
  account_id: string;
}

export const PostWebsocketRunCfDeepgramFluxRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/run/@cf/deepgram/flux" }),
).annotations({ identifier: "PostWebsocketRunCfDeepgramFluxRequest" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramFluxRequest>;

export interface PostWebsocketRunCfDeepgramFluxResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostWebsocketRunCfDeepgramFluxResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostWebsocketRunCfDeepgramFluxResponse" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramFluxResponse>;

export const postWebsocketRunCfDeepgramFlux: (
  input: PostWebsocketRunCfDeepgramFluxRequest
) => Effect.Effect<
  PostWebsocketRunCfDeepgramFluxResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostWebsocketRunCfDeepgramFluxRequest,
  output: PostWebsocketRunCfDeepgramFluxResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfDeepgramFluxRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { eager_eot_threshold?: string; encoding: "linear16"; eot_threshold?: string; eot_timeout_ms?: string; keyterm?: string; mip_opt_out?: "true" | "false"; sample_rate: string; tag?: string };
}

export const PostRunCfDeepgramFluxRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  eager_eot_threshold: Schema.optional(Schema.String),
  encoding: Schema.Literal("linear16"),
  eot_threshold: Schema.optional(Schema.String),
  eot_timeout_ms: Schema.optional(Schema.String),
  keyterm: Schema.optional(Schema.String),
  mip_opt_out: Schema.optional(Schema.Literal("true", "false")),
  sample_rate: Schema.String,
  tag: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/deepgram/flux" }),
).annotations({ identifier: "PostRunCfDeepgramFluxRequest" }) as unknown as Schema.Schema<PostRunCfDeepgramFluxRequest>;

export interface PostRunCfDeepgramFluxResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfDeepgramFluxResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfDeepgramFluxResponse" }) as unknown as Schema.Schema<PostRunCfDeepgramFluxResponse>;

export const postRunCfDeepgramFlux: (
  input: PostRunCfDeepgramFluxRequest
) => Effect.Effect<
  PostRunCfDeepgramFluxResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfDeepgramFluxRequest,
  output: PostRunCfDeepgramFluxResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostWebsocketRunCfDeepgramNova3Request {
  account_id: string;
}

export const PostWebsocketRunCfDeepgramNova3Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/run/@cf/deepgram/nova-3" }),
).annotations({ identifier: "PostWebsocketRunCfDeepgramNova3Request" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramNova3Request>;

export interface PostWebsocketRunCfDeepgramNova3Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostWebsocketRunCfDeepgramNova3Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostWebsocketRunCfDeepgramNova3Response" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramNova3Response>;

export const postWebsocketRunCfDeepgramNova3: (
  input: PostWebsocketRunCfDeepgramNova3Request
) => Effect.Effect<
  PostWebsocketRunCfDeepgramNova3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostWebsocketRunCfDeepgramNova3Request,
  output: PostWebsocketRunCfDeepgramNova3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfDeepgramNova3Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { audio: { body: Record<string, unknown>; contentType: string }; channels?: number; custom_intent?: string; custom_intent_mode?: "extended" | "strict"; custom_topic?: string; custom_topic_mode?: "extended" | "strict"; detect_entities?: boolean; detect_language?: boolean; diarize?: boolean; dictation?: boolean; encoding?: "linear16" | "flac" | "mulaw" | "amr-nb" | "amr-wb" | "opus" | "speex" | "g729"; endpointing?: string; extra?: string; filler_words?: boolean; interim_results?: boolean; keyterm?: string; keywords?: string; language?: string; measurements?: boolean; mip_opt_out?: boolean; mode?: "general" | "medical" | "finance"; multichannel?: boolean; numerals?: boolean; paragraphs?: boolean; profanity_filter?: boolean; punctuate?: boolean; redact?: string; replace?: string; search?: string; sentiment?: boolean; smart_format?: boolean; topics?: boolean; utt_split?: number; utterance_end_ms?: boolean; utterances?: boolean; vad_events?: boolean };
}

export const PostRunCfDeepgramNova3Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  audio: Schema.Struct({
  body: Schema.Struct({}),
  contentType: Schema.String
}),
  channels: Schema.optional(Schema.Number),
  custom_intent: Schema.optional(Schema.String),
  custom_intent_mode: Schema.optional(Schema.Literal("extended", "strict")),
  custom_topic: Schema.optional(Schema.String),
  custom_topic_mode: Schema.optional(Schema.Literal("extended", "strict")),
  detect_entities: Schema.optional(Schema.Boolean),
  detect_language: Schema.optional(Schema.Boolean),
  diarize: Schema.optional(Schema.Boolean),
  dictation: Schema.optional(Schema.Boolean),
  encoding: Schema.optional(Schema.Literal("linear16", "flac", "mulaw", "amr-nb", "amr-wb", "opus", "speex", "g729")),
  endpointing: Schema.optional(Schema.String),
  extra: Schema.optional(Schema.String),
  filler_words: Schema.optional(Schema.Boolean),
  interim_results: Schema.optional(Schema.Boolean),
  keyterm: Schema.optional(Schema.String),
  keywords: Schema.optional(Schema.String),
  language: Schema.optional(Schema.String),
  measurements: Schema.optional(Schema.Boolean),
  mip_opt_out: Schema.optional(Schema.Boolean),
  mode: Schema.optional(Schema.Literal("general", "medical", "finance")),
  multichannel: Schema.optional(Schema.Boolean),
  numerals: Schema.optional(Schema.Boolean),
  paragraphs: Schema.optional(Schema.Boolean),
  profanity_filter: Schema.optional(Schema.Boolean),
  punctuate: Schema.optional(Schema.Boolean),
  redact: Schema.optional(Schema.String),
  replace: Schema.optional(Schema.String),
  search: Schema.optional(Schema.String),
  sentiment: Schema.optional(Schema.Boolean),
  smart_format: Schema.optional(Schema.Boolean),
  topics: Schema.optional(Schema.Boolean),
  utt_split: Schema.optional(Schema.Number),
  utterance_end_ms: Schema.optional(Schema.Boolean),
  utterances: Schema.optional(Schema.Boolean),
  vad_events: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/deepgram/nova-3" }),
).annotations({ identifier: "PostRunCfDeepgramNova3Request" }) as unknown as Schema.Schema<PostRunCfDeepgramNova3Request>;

export interface PostRunCfDeepgramNova3Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfDeepgramNova3Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfDeepgramNova3Response" }) as unknown as Schema.Schema<PostRunCfDeepgramNova3Response>;

export const postRunCfDeepgramNova3: (
  input: PostRunCfDeepgramNova3Request
) => Effect.Effect<
  PostRunCfDeepgramNova3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfDeepgramNova3Request,
  output: PostRunCfDeepgramNova3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostWebsocketRunCfDeepgramNova3InternalRequest {
  account_id: string;
}

export const PostWebsocketRunCfDeepgramNova3InternalRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/run/@cf/deepgram/nova-3-internal" }),
).annotations({ identifier: "PostWebsocketRunCfDeepgramNova3InternalRequest" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramNova3InternalRequest>;

export interface PostWebsocketRunCfDeepgramNova3InternalResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostWebsocketRunCfDeepgramNova3InternalResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostWebsocketRunCfDeepgramNova3InternalResponse" }) as unknown as Schema.Schema<PostWebsocketRunCfDeepgramNova3InternalResponse>;

export const postWebsocketRunCfDeepgramNova3Internal: (
  input: PostWebsocketRunCfDeepgramNova3InternalRequest
) => Effect.Effect<
  PostWebsocketRunCfDeepgramNova3InternalResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostWebsocketRunCfDeepgramNova3InternalRequest,
  output: PostWebsocketRunCfDeepgramNova3InternalResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfDeepseekAiDeepseekMath7bInstructRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfDeepseekAiDeepseekMath7bInstructRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/deepseek-ai/deepseek-math-7b-instruct" }),
).annotations({ identifier: "PostRunCfDeepseekAiDeepseekMath7bInstructRequest" }) as unknown as Schema.Schema<PostRunCfDeepseekAiDeepseekMath7bInstructRequest>;

export interface PostRunCfDeepseekAiDeepseekMath7bInstructResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfDeepseekAiDeepseekMath7bInstructResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfDeepseekAiDeepseekMath7bInstructResponse" }) as unknown as Schema.Schema<PostRunCfDeepseekAiDeepseekMath7bInstructResponse>;

export const postRunCfDeepseekAiDeepseekMath7bInstruct: (
  input: PostRunCfDeepseekAiDeepseekMath7bInstructRequest
) => Effect.Effect<
  PostRunCfDeepseekAiDeepseekMath7bInstructResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfDeepseekAiDeepseekMath7bInstructRequest,
  output: PostRunCfDeepseekAiDeepseekMath7bInstructResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfDeepseekAiDeepseekR1DistillQwen32bRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfDeepseekAiDeepseekR1DistillQwen32bRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/deepseek-ai/deepseek-r1-distill-qwen-32b" }),
).annotations({ identifier: "PostRunCfDeepseekAiDeepseekR1DistillQwen32bRequest" }) as unknown as Schema.Schema<PostRunCfDeepseekAiDeepseekR1DistillQwen32bRequest>;

export interface PostRunCfDeepseekAiDeepseekR1DistillQwen32bResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfDeepseekAiDeepseekR1DistillQwen32bResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfDeepseekAiDeepseekR1DistillQwen32bResponse" }) as unknown as Schema.Schema<PostRunCfDeepseekAiDeepseekR1DistillQwen32bResponse>;

export const postRunCfDeepseekAiDeepseekR1DistillQwen32b: (
  input: PostRunCfDeepseekAiDeepseekR1DistillQwen32bRequest
) => Effect.Effect<
  PostRunCfDeepseekAiDeepseekR1DistillQwen32bResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfDeepseekAiDeepseekR1DistillQwen32bRequest,
  output: PostRunCfDeepseekAiDeepseekR1DistillQwen32bResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfDefogSqlcoder7b2Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfDefogSqlcoder7b2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/defog/sqlcoder-7b-2" }),
).annotations({ identifier: "PostRunCfDefogSqlcoder7b2Request" }) as unknown as Schema.Schema<PostRunCfDefogSqlcoder7b2Request>;

export interface PostRunCfDefogSqlcoder7b2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfDefogSqlcoder7b2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfDefogSqlcoder7b2Response" }) as unknown as Schema.Schema<PostRunCfDefogSqlcoder7b2Response>;

export const postRunCfDefogSqlcoder7b2: (
  input: PostRunCfDefogSqlcoder7b2Request
) => Effect.Effect<
  PostRunCfDefogSqlcoder7b2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfDefogSqlcoder7b2Request,
  output: PostRunCfDefogSqlcoder7b2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfFacebookBartLargeCnnRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { input_text: string; max_length?: number };
}

export const PostRunCfFacebookBartLargeCnnRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  input_text: Schema.String,
  max_length: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/facebook/bart-large-cnn" }),
).annotations({ identifier: "PostRunCfFacebookBartLargeCnnRequest" }) as unknown as Schema.Schema<PostRunCfFacebookBartLargeCnnRequest>;

export interface PostRunCfFacebookBartLargeCnnResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfFacebookBartLargeCnnResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfFacebookBartLargeCnnResponse" }) as unknown as Schema.Schema<PostRunCfFacebookBartLargeCnnResponse>;

export const postRunCfFacebookBartLargeCnn: (
  input: PostRunCfFacebookBartLargeCnnRequest
) => Effect.Effect<
  PostRunCfFacebookBartLargeCnnResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfFacebookBartLargeCnnRequest,
  output: PostRunCfFacebookBartLargeCnnResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfFacebookOmniBartLargeCnnRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { input_text: string; max_length?: number };
}

export const PostRunCfFacebookOmniBartLargeCnnRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  input_text: Schema.String,
  max_length: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/facebook/omni-bart-large-cnn" }),
).annotations({ identifier: "PostRunCfFacebookOmniBartLargeCnnRequest" }) as unknown as Schema.Schema<PostRunCfFacebookOmniBartLargeCnnRequest>;

export interface PostRunCfFacebookOmniBartLargeCnnResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfFacebookOmniBartLargeCnnResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfFacebookOmniBartLargeCnnResponse" }) as unknown as Schema.Schema<PostRunCfFacebookOmniBartLargeCnnResponse>;

export const postRunCfFacebookOmniBartLargeCnn: (
  input: PostRunCfFacebookOmniBartLargeCnnRequest
) => Effect.Effect<
  PostRunCfFacebookOmniBartLargeCnnResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfFacebookOmniBartLargeCnnRequest,
  output: PostRunCfFacebookOmniBartLargeCnnResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfFacebookOmniDetrResnet50Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
}

export const PostRunCfFacebookOmniDetrResnet50Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/facebook/omni-detr-resnet-50" }),
).annotations({ identifier: "PostRunCfFacebookOmniDetrResnet50Request" }) as unknown as Schema.Schema<PostRunCfFacebookOmniDetrResnet50Request>;

export interface PostRunCfFacebookOmniDetrResnet50Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfFacebookOmniDetrResnet50Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfFacebookOmniDetrResnet50Response" }) as unknown as Schema.Schema<PostRunCfFacebookOmniDetrResnet50Response>;

export const postRunCfFacebookOmniDetrResnet50: (
  input: PostRunCfFacebookOmniDetrResnet50Request
) => Effect.Effect<
  PostRunCfFacebookOmniDetrResnet50Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfFacebookOmniDetrResnet50Request,
  output: PostRunCfFacebookOmniDetrResnet50Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfFblgitUnaCybertron7bV2Bf16Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfFblgitUnaCybertron7bV2Bf16Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/fblgit/una-cybertron-7b-v2-bf16" }),
).annotations({ identifier: "PostRunCfFblgitUnaCybertron7bV2Bf16Request" }) as unknown as Schema.Schema<PostRunCfFblgitUnaCybertron7bV2Bf16Request>;

export interface PostRunCfFblgitUnaCybertron7bV2Bf16Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfFblgitUnaCybertron7bV2Bf16Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfFblgitUnaCybertron7bV2Bf16Response" }) as unknown as Schema.Schema<PostRunCfFblgitUnaCybertron7bV2Bf16Response>;

export const postRunCfFblgitUnaCybertron7bV2Bf16: (
  input: PostRunCfFblgitUnaCybertron7bV2Bf16Request
) => Effect.Effect<
  PostRunCfFblgitUnaCybertron7bV2Bf16Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfFblgitUnaCybertron7bV2Bf16Request,
  output: PostRunCfFblgitUnaCybertron7bV2Bf16Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfGoogleEmbeddinggemma300mRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { text: unknown };
}

export const PostRunCfGoogleEmbeddinggemma300mRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  text: Schema.Union(Schema.String, Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/google/embeddinggemma-300m" }),
).annotations({ identifier: "PostRunCfGoogleEmbeddinggemma300mRequest" }) as unknown as Schema.Schema<PostRunCfGoogleEmbeddinggemma300mRequest>;

export interface PostRunCfGoogleEmbeddinggemma300mResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfGoogleEmbeddinggemma300mResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfGoogleEmbeddinggemma300mResponse" }) as unknown as Schema.Schema<PostRunCfGoogleEmbeddinggemma300mResponse>;

export const postRunCfGoogleEmbeddinggemma300m: (
  input: PostRunCfGoogleEmbeddinggemma300mRequest
) => Effect.Effect<
  PostRunCfGoogleEmbeddinggemma300mResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfGoogleEmbeddinggemma300mRequest,
  output: PostRunCfGoogleEmbeddinggemma300mResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfGoogleGemma2bItLoraRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfGoogleGemma2bItLoraRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/google/gemma-2b-it-lora" }),
).annotations({ identifier: "PostRunCfGoogleGemma2bItLoraRequest" }) as unknown as Schema.Schema<PostRunCfGoogleGemma2bItLoraRequest>;

export interface PostRunCfGoogleGemma2bItLoraResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfGoogleGemma2bItLoraResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfGoogleGemma2bItLoraResponse" }) as unknown as Schema.Schema<PostRunCfGoogleGemma2bItLoraResponse>;

export const postRunCfGoogleGemma2bItLora: (
  input: PostRunCfGoogleGemma2bItLoraRequest
) => Effect.Effect<
  PostRunCfGoogleGemma2bItLoraResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfGoogleGemma2bItLoraRequest,
  output: PostRunCfGoogleGemma2bItLoraResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfGoogleGemma312bItRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfGoogleGemma312bItRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/google/gemma-3-12b-it" }),
).annotations({ identifier: "PostRunCfGoogleGemma312bItRequest" }) as unknown as Schema.Schema<PostRunCfGoogleGemma312bItRequest>;

export interface PostRunCfGoogleGemma312bItResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfGoogleGemma312bItResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfGoogleGemma312bItResponse" }) as unknown as Schema.Schema<PostRunCfGoogleGemma312bItResponse>;

export const postRunCfGoogleGemma312bIt: (
  input: PostRunCfGoogleGemma312bItRequest
) => Effect.Effect<
  PostRunCfGoogleGemma312bItResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfGoogleGemma312bItRequest,
  output: PostRunCfGoogleGemma312bItResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfGoogleGemma7bItLoraRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfGoogleGemma7bItLoraRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/google/gemma-7b-it-lora" }),
).annotations({ identifier: "PostRunCfGoogleGemma7bItLoraRequest" }) as unknown as Schema.Schema<PostRunCfGoogleGemma7bItLoraRequest>;

export interface PostRunCfGoogleGemma7bItLoraResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfGoogleGemma7bItLoraResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfGoogleGemma7bItLoraResponse" }) as unknown as Schema.Schema<PostRunCfGoogleGemma7bItLoraResponse>;

export const postRunCfGoogleGemma7bItLora: (
  input: PostRunCfGoogleGemma7bItLoraRequest
) => Effect.Effect<
  PostRunCfGoogleGemma7bItLoraResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfGoogleGemma7bItLoraRequest,
  output: PostRunCfGoogleGemma7bItLoraResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfGoogleOmniEmbeddinggemma300mRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { text: unknown };
}

export const PostRunCfGoogleOmniEmbeddinggemma300mRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  text: Schema.Union(Schema.String, Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/google/omni-embeddinggemma-300m" }),
).annotations({ identifier: "PostRunCfGoogleOmniEmbeddinggemma300mRequest" }) as unknown as Schema.Schema<PostRunCfGoogleOmniEmbeddinggemma300mRequest>;

export interface PostRunCfGoogleOmniEmbeddinggemma300mResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfGoogleOmniEmbeddinggemma300mResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfGoogleOmniEmbeddinggemma300mResponse" }) as unknown as Schema.Schema<PostRunCfGoogleOmniEmbeddinggemma300mResponse>;

export const postRunCfGoogleOmniEmbeddinggemma300m: (
  input: PostRunCfGoogleOmniEmbeddinggemma300mRequest
) => Effect.Effect<
  PostRunCfGoogleOmniEmbeddinggemma300mResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfGoogleOmniEmbeddinggemma300mRequest,
  output: PostRunCfGoogleOmniEmbeddinggemma300mResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfHuggingfaceDistilbertSst2Int8Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { text: string };
}

export const PostRunCfHuggingfaceDistilbertSst2Int8Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  text: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/huggingface/distilbert-sst-2-int8" }),
).annotations({ identifier: "PostRunCfHuggingfaceDistilbertSst2Int8Request" }) as unknown as Schema.Schema<PostRunCfHuggingfaceDistilbertSst2Int8Request>;

export interface PostRunCfHuggingfaceDistilbertSst2Int8Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfHuggingfaceDistilbertSst2Int8Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfHuggingfaceDistilbertSst2Int8Response" }) as unknown as Schema.Schema<PostRunCfHuggingfaceDistilbertSst2Int8Response>;

export const postRunCfHuggingfaceDistilbertSst2Int8: (
  input: PostRunCfHuggingfaceDistilbertSst2Int8Request
) => Effect.Effect<
  PostRunCfHuggingfaceDistilbertSst2Int8Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfHuggingfaceDistilbertSst2Int8Request,
  output: PostRunCfHuggingfaceDistilbertSst2Int8Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfHuggingfaceOmniDistilbertSst2Int8Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { text: string };
}

export const PostRunCfHuggingfaceOmniDistilbertSst2Int8Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  text: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/huggingface/omni-distilbert-sst-2-int8" }),
).annotations({ identifier: "PostRunCfHuggingfaceOmniDistilbertSst2Int8Request" }) as unknown as Schema.Schema<PostRunCfHuggingfaceOmniDistilbertSst2Int8Request>;

export interface PostRunCfHuggingfaceOmniDistilbertSst2Int8Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfHuggingfaceOmniDistilbertSst2Int8Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfHuggingfaceOmniDistilbertSst2Int8Response" }) as unknown as Schema.Schema<PostRunCfHuggingfaceOmniDistilbertSst2Int8Response>;

export const postRunCfHuggingfaceOmniDistilbertSst2Int8: (
  input: PostRunCfHuggingfaceOmniDistilbertSst2Int8Request
) => Effect.Effect<
  PostRunCfHuggingfaceOmniDistilbertSst2Int8Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfHuggingfaceOmniDistilbertSst2Int8Request,
  output: PostRunCfHuggingfaceOmniDistilbertSst2Int8Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfIbmGraniteGranite40HMicroRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfIbmGraniteGranite40HMicroRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/ibm-granite/granite-4.0-h-micro" }),
).annotations({ identifier: "PostRunCfIbmGraniteGranite40HMicroRequest" }) as unknown as Schema.Schema<PostRunCfIbmGraniteGranite40HMicroRequest>;

export interface PostRunCfIbmGraniteGranite40HMicroResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfIbmGraniteGranite40HMicroResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfIbmGraniteGranite40HMicroResponse" }) as unknown as Schema.Schema<PostRunCfIbmGraniteGranite40HMicroResponse>;

export const postRunCfIbmGraniteGranite40HMicro: (
  input: PostRunCfIbmGraniteGranite40HMicroRequest
) => Effect.Effect<
  PostRunCfIbmGraniteGranite40HMicroResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfIbmGraniteGranite40HMicroRequest,
  output: PostRunCfIbmGraniteGranite40HMicroResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfLeonardoLucidOriginRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { guidance?: number; height?: number; num_steps?: number; prompt: string; seed?: number; steps?: number; width?: number };
}

export const PostRunCfLeonardoLucidOriginRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  guidance: Schema.optional(Schema.Number),
  height: Schema.optional(Schema.Number),
  num_steps: Schema.optional(Schema.Number),
  prompt: Schema.String,
  seed: Schema.optional(Schema.Number),
  steps: Schema.optional(Schema.Number),
  width: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/leonardo/lucid-origin" }),
).annotations({ identifier: "PostRunCfLeonardoLucidOriginRequest" }) as unknown as Schema.Schema<PostRunCfLeonardoLucidOriginRequest>;

export interface PostRunCfLeonardoLucidOriginResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfLeonardoLucidOriginResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfLeonardoLucidOriginResponse" }) as unknown as Schema.Schema<PostRunCfLeonardoLucidOriginResponse>;

export const postRunCfLeonardoLucidOrigin: (
  input: PostRunCfLeonardoLucidOriginRequest
) => Effect.Effect<
  PostRunCfLeonardoLucidOriginResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfLeonardoLucidOriginRequest,
  output: PostRunCfLeonardoLucidOriginResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfLeonardoPhoenix10Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { guidance?: number; height?: number; negative_prompt?: string; num_steps?: number; prompt: string; seed?: number; width?: number };
}

export const PostRunCfLeonardoPhoenix10Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  guidance: Schema.optional(Schema.Number),
  height: Schema.optional(Schema.Number),
  negative_prompt: Schema.optional(Schema.String),
  num_steps: Schema.optional(Schema.Number),
  prompt: Schema.String,
  seed: Schema.optional(Schema.Number),
  width: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/leonardo/phoenix-1.0" }),
).annotations({ identifier: "PostRunCfLeonardoPhoenix10Request" }) as unknown as Schema.Schema<PostRunCfLeonardoPhoenix10Request>;

export interface PostRunCfLeonardoPhoenix10Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfLeonardoPhoenix10Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfLeonardoPhoenix10Response" }) as unknown as Schema.Schema<PostRunCfLeonardoPhoenix10Response>;

export const postRunCfLeonardoPhoenix10: (
  input: PostRunCfLeonardoPhoenix10Request
) => Effect.Effect<
  PostRunCfLeonardoPhoenix10Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfLeonardoPhoenix10Request,
  output: PostRunCfLeonardoPhoenix10Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfLykonDreamshaper8LcmRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { guidance?: number; height?: number; image?: number[]; image_b64?: string; mask?: number[]; negative_prompt?: string; num_steps?: number; prompt: string; seed?: number; strength?: number; width?: number };
}

export const PostRunCfLykonDreamshaper8LcmRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  guidance: Schema.optional(Schema.Number),
  height: Schema.optional(Schema.Number),
  image: Schema.optional(Schema.Array(Schema.Number)),
  image_b64: Schema.optional(Schema.String),
  mask: Schema.optional(Schema.Array(Schema.Number)),
  negative_prompt: Schema.optional(Schema.String),
  num_steps: Schema.optional(Schema.Number),
  prompt: Schema.String,
  seed: Schema.optional(Schema.Number),
  strength: Schema.optional(Schema.Number),
  width: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/lykon/dreamshaper-8-lcm" }),
).annotations({ identifier: "PostRunCfLykonDreamshaper8LcmRequest" }) as unknown as Schema.Schema<PostRunCfLykonDreamshaper8LcmRequest>;

export interface PostRunCfLykonDreamshaper8LcmResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfLykonDreamshaper8LcmResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfLykonDreamshaper8LcmResponse" }) as unknown as Schema.Schema<PostRunCfLykonDreamshaper8LcmResponse>;

export const postRunCfLykonDreamshaper8Lcm: (
  input: PostRunCfLykonDreamshaper8LcmRequest
) => Effect.Effect<
  PostRunCfLykonDreamshaper8LcmResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfLykonDreamshaper8LcmRequest,
  output: PostRunCfLykonDreamshaper8LcmResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMetaLlamaLlama27bChatHfLoraRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMetaLlamaLlama27bChatHfLoraRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/meta-llama/llama-2-7b-chat-hf-lora" }),
).annotations({ identifier: "PostRunCfMetaLlamaLlama27bChatHfLoraRequest" }) as unknown as Schema.Schema<PostRunCfMetaLlamaLlama27bChatHfLoraRequest>;

export interface PostRunCfMetaLlamaLlama27bChatHfLoraResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMetaLlamaLlama27bChatHfLoraResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMetaLlamaLlama27bChatHfLoraResponse" }) as unknown as Schema.Schema<PostRunCfMetaLlamaLlama27bChatHfLoraResponse>;

export const postRunCfMetaLlamaLlama27bChatHfLora: (
  input: PostRunCfMetaLlamaLlama27bChatHfLoraRequest
) => Effect.Effect<
  PostRunCfMetaLlamaLlama27bChatHfLoraResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMetaLlamaLlama27bChatHfLoraRequest,
  output: PostRunCfMetaLlamaLlama27bChatHfLoraResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMetaLlama27bChatFp16Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMetaLlama27bChatFp16Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/meta/llama-2-7b-chat-fp16" }),
).annotations({ identifier: "PostRunCfMetaLlama27bChatFp16Request" }) as unknown as Schema.Schema<PostRunCfMetaLlama27bChatFp16Request>;

export interface PostRunCfMetaLlama27bChatFp16Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMetaLlama27bChatFp16Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMetaLlama27bChatFp16Response" }) as unknown as Schema.Schema<PostRunCfMetaLlama27bChatFp16Response>;

export const postRunCfMetaLlama27bChatFp16: (
  input: PostRunCfMetaLlama27bChatFp16Request
) => Effect.Effect<
  PostRunCfMetaLlama27bChatFp16Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMetaLlama27bChatFp16Request,
  output: PostRunCfMetaLlama27bChatFp16Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMetaLlama27bChatInt8Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMetaLlama27bChatInt8Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/meta/llama-2-7b-chat-int8" }),
).annotations({ identifier: "PostRunCfMetaLlama27bChatInt8Request" }) as unknown as Schema.Schema<PostRunCfMetaLlama27bChatInt8Request>;

export interface PostRunCfMetaLlama27bChatInt8Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMetaLlama27bChatInt8Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMetaLlama27bChatInt8Response" }) as unknown as Schema.Schema<PostRunCfMetaLlama27bChatInt8Response>;

export const postRunCfMetaLlama27bChatInt8: (
  input: PostRunCfMetaLlama27bChatInt8Request
) => Effect.Effect<
  PostRunCfMetaLlama27bChatInt8Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMetaLlama27bChatInt8Request,
  output: PostRunCfMetaLlama27bChatInt8Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMetaLlama38bInstructRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMetaLlama38bInstructRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/meta/llama-3-8b-instruct" }),
).annotations({ identifier: "PostRunCfMetaLlama38bInstructRequest" }) as unknown as Schema.Schema<PostRunCfMetaLlama38bInstructRequest>;

export interface PostRunCfMetaLlama38bInstructResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMetaLlama38bInstructResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMetaLlama38bInstructResponse" }) as unknown as Schema.Schema<PostRunCfMetaLlama38bInstructResponse>;

export const postRunCfMetaLlama38bInstruct: (
  input: PostRunCfMetaLlama38bInstructRequest
) => Effect.Effect<
  PostRunCfMetaLlama38bInstructResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMetaLlama38bInstructRequest,
  output: PostRunCfMetaLlama38bInstructResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMetaLlama38bInstructAwqRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMetaLlama38bInstructAwqRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/meta/llama-3-8b-instruct-awq" }),
).annotations({ identifier: "PostRunCfMetaLlama38bInstructAwqRequest" }) as unknown as Schema.Schema<PostRunCfMetaLlama38bInstructAwqRequest>;

export interface PostRunCfMetaLlama38bInstructAwqResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMetaLlama38bInstructAwqResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMetaLlama38bInstructAwqResponse" }) as unknown as Schema.Schema<PostRunCfMetaLlama38bInstructAwqResponse>;

export const postRunCfMetaLlama38bInstructAwq: (
  input: PostRunCfMetaLlama38bInstructAwqRequest
) => Effect.Effect<
  PostRunCfMetaLlama38bInstructAwqResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMetaLlama38bInstructAwqRequest,
  output: PostRunCfMetaLlama38bInstructAwqResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMetaLlama3170bInstructFp8FastRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMetaLlama3170bInstructFp8FastRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/meta/llama-3.1-70b-instruct-fp8-fast" }),
).annotations({ identifier: "PostRunCfMetaLlama3170bInstructFp8FastRequest" }) as unknown as Schema.Schema<PostRunCfMetaLlama3170bInstructFp8FastRequest>;

export interface PostRunCfMetaLlama3170bInstructFp8FastResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMetaLlama3170bInstructFp8FastResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMetaLlama3170bInstructFp8FastResponse" }) as unknown as Schema.Schema<PostRunCfMetaLlama3170bInstructFp8FastResponse>;

export const postRunCfMetaLlama3170bInstructFp8Fast: (
  input: PostRunCfMetaLlama3170bInstructFp8FastRequest
) => Effect.Effect<
  PostRunCfMetaLlama3170bInstructFp8FastResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMetaLlama3170bInstructFp8FastRequest,
  output: PostRunCfMetaLlama3170bInstructFp8FastResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMetaLlama318bInstructAwqRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMetaLlama318bInstructAwqRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/meta/llama-3.1-8b-instruct-awq" }),
).annotations({ identifier: "PostRunCfMetaLlama318bInstructAwqRequest" }) as unknown as Schema.Schema<PostRunCfMetaLlama318bInstructAwqRequest>;

export interface PostRunCfMetaLlama318bInstructAwqResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMetaLlama318bInstructAwqResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMetaLlama318bInstructAwqResponse" }) as unknown as Schema.Schema<PostRunCfMetaLlama318bInstructAwqResponse>;

export const postRunCfMetaLlama318bInstructAwq: (
  input: PostRunCfMetaLlama318bInstructAwqRequest
) => Effect.Effect<
  PostRunCfMetaLlama318bInstructAwqResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMetaLlama318bInstructAwqRequest,
  output: PostRunCfMetaLlama318bInstructAwqResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMetaLlama318bInstructFp8Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMetaLlama318bInstructFp8Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/meta/llama-3.1-8b-instruct-fp8" }),
).annotations({ identifier: "PostRunCfMetaLlama318bInstructFp8Request" }) as unknown as Schema.Schema<PostRunCfMetaLlama318bInstructFp8Request>;

export interface PostRunCfMetaLlama318bInstructFp8Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMetaLlama318bInstructFp8Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMetaLlama318bInstructFp8Response" }) as unknown as Schema.Schema<PostRunCfMetaLlama318bInstructFp8Response>;

export const postRunCfMetaLlama318bInstructFp8: (
  input: PostRunCfMetaLlama318bInstructFp8Request
) => Effect.Effect<
  PostRunCfMetaLlama318bInstructFp8Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMetaLlama318bInstructFp8Request,
  output: PostRunCfMetaLlama318bInstructFp8Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMetaLlama318bInstructFp8FastRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMetaLlama318bInstructFp8FastRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/meta/llama-3.1-8b-instruct-fp8-fast" }),
).annotations({ identifier: "PostRunCfMetaLlama318bInstructFp8FastRequest" }) as unknown as Schema.Schema<PostRunCfMetaLlama318bInstructFp8FastRequest>;

export interface PostRunCfMetaLlama318bInstructFp8FastResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMetaLlama318bInstructFp8FastResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMetaLlama318bInstructFp8FastResponse" }) as unknown as Schema.Schema<PostRunCfMetaLlama318bInstructFp8FastResponse>;

export const postRunCfMetaLlama318bInstructFp8Fast: (
  input: PostRunCfMetaLlama318bInstructFp8FastRequest
) => Effect.Effect<
  PostRunCfMetaLlama318bInstructFp8FastResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMetaLlama318bInstructFp8FastRequest,
  output: PostRunCfMetaLlama318bInstructFp8FastResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMetaLlama3211bVisionInstructRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMetaLlama3211bVisionInstructRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/meta/llama-3.2-11b-vision-instruct" }),
).annotations({ identifier: "PostRunCfMetaLlama3211bVisionInstructRequest" }) as unknown as Schema.Schema<PostRunCfMetaLlama3211bVisionInstructRequest>;

export interface PostRunCfMetaLlama3211bVisionInstructResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMetaLlama3211bVisionInstructResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMetaLlama3211bVisionInstructResponse" }) as unknown as Schema.Schema<PostRunCfMetaLlama3211bVisionInstructResponse>;

export const postRunCfMetaLlama3211bVisionInstruct: (
  input: PostRunCfMetaLlama3211bVisionInstructRequest
) => Effect.Effect<
  PostRunCfMetaLlama3211bVisionInstructResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMetaLlama3211bVisionInstructRequest,
  output: PostRunCfMetaLlama3211bVisionInstructResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMetaLlama321bInstructRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMetaLlama321bInstructRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/meta/llama-3.2-1b-instruct" }),
).annotations({ identifier: "PostRunCfMetaLlama321bInstructRequest" }) as unknown as Schema.Schema<PostRunCfMetaLlama321bInstructRequest>;

export interface PostRunCfMetaLlama321bInstructResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMetaLlama321bInstructResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMetaLlama321bInstructResponse" }) as unknown as Schema.Schema<PostRunCfMetaLlama321bInstructResponse>;

export const postRunCfMetaLlama321bInstruct: (
  input: PostRunCfMetaLlama321bInstructRequest
) => Effect.Effect<
  PostRunCfMetaLlama321bInstructResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMetaLlama321bInstructRequest,
  output: PostRunCfMetaLlama321bInstructResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMetaLlama323bInstructRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMetaLlama323bInstructRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/meta/llama-3.2-3b-instruct" }),
).annotations({ identifier: "PostRunCfMetaLlama323bInstructRequest" }) as unknown as Schema.Schema<PostRunCfMetaLlama323bInstructRequest>;

export interface PostRunCfMetaLlama323bInstructResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMetaLlama323bInstructResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMetaLlama323bInstructResponse" }) as unknown as Schema.Schema<PostRunCfMetaLlama323bInstructResponse>;

export const postRunCfMetaLlama323bInstruct: (
  input: PostRunCfMetaLlama323bInstructRequest
) => Effect.Effect<
  PostRunCfMetaLlama323bInstructResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMetaLlama323bInstructRequest,
  output: PostRunCfMetaLlama323bInstructResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMetaLlama3370bInstructFp8FastRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMetaLlama3370bInstructFp8FastRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/meta/llama-3.3-70b-instruct-fp8-fast" }),
).annotations({ identifier: "PostRunCfMetaLlama3370bInstructFp8FastRequest" }) as unknown as Schema.Schema<PostRunCfMetaLlama3370bInstructFp8FastRequest>;

export interface PostRunCfMetaLlama3370bInstructFp8FastResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMetaLlama3370bInstructFp8FastResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMetaLlama3370bInstructFp8FastResponse" }) as unknown as Schema.Schema<PostRunCfMetaLlama3370bInstructFp8FastResponse>;

export const postRunCfMetaLlama3370bInstructFp8Fast: (
  input: PostRunCfMetaLlama3370bInstructFp8FastRequest
) => Effect.Effect<
  PostRunCfMetaLlama3370bInstructFp8FastResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMetaLlama3370bInstructFp8FastRequest,
  output: PostRunCfMetaLlama3370bInstructFp8FastResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMetaLlama4Scout17b16eInstructRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMetaLlama4Scout17b16eInstructRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/meta/llama-4-scout-17b-16e-instruct" }),
).annotations({ identifier: "PostRunCfMetaLlama4Scout17b16eInstructRequest" }) as unknown as Schema.Schema<PostRunCfMetaLlama4Scout17b16eInstructRequest>;

export interface PostRunCfMetaLlama4Scout17b16eInstructResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMetaLlama4Scout17b16eInstructResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMetaLlama4Scout17b16eInstructResponse" }) as unknown as Schema.Schema<PostRunCfMetaLlama4Scout17b16eInstructResponse>;

export const postRunCfMetaLlama4Scout17b16eInstruct: (
  input: PostRunCfMetaLlama4Scout17b16eInstructRequest
) => Effect.Effect<
  PostRunCfMetaLlama4Scout17b16eInstructResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMetaLlama4Scout17b16eInstructRequest,
  output: PostRunCfMetaLlama4Scout17b16eInstructResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMetaLlamaGuard38bRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { max_tokens?: number; messages: { content: string; role: "user" | "assistant" }[]; response_format?: { type?: string }; temperature?: number };
}

export const PostRunCfMetaLlamaGuard38bRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  max_tokens: Schema.optional(Schema.Number),
  messages: Schema.Array(Schema.Struct({
  content: Schema.String,
  role: Schema.Literal("user", "assistant")
})),
  response_format: Schema.optional(Schema.Struct({
  type: Schema.optional(Schema.String)
})),
  temperature: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/meta/llama-guard-3-8b" }),
).annotations({ identifier: "PostRunCfMetaLlamaGuard38bRequest" }) as unknown as Schema.Schema<PostRunCfMetaLlamaGuard38bRequest>;

export interface PostRunCfMetaLlamaGuard38bResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMetaLlamaGuard38bResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMetaLlamaGuard38bResponse" }) as unknown as Schema.Schema<PostRunCfMetaLlamaGuard38bResponse>;

export const postRunCfMetaLlamaGuard38b: (
  input: PostRunCfMetaLlamaGuard38bRequest
) => Effect.Effect<
  PostRunCfMetaLlamaGuard38bResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMetaLlamaGuard38bRequest,
  output: PostRunCfMetaLlamaGuard38bResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMetaM2m10012bRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMetaM2m10012bRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/meta/m2m100-1.2b" }),
).annotations({ identifier: "PostRunCfMetaM2m10012bRequest" }) as unknown as Schema.Schema<PostRunCfMetaM2m10012bRequest>;

export interface PostRunCfMetaM2m10012bResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMetaM2m10012bResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMetaM2m10012bResponse" }) as unknown as Schema.Schema<PostRunCfMetaM2m10012bResponse>;

export const postRunCfMetaM2m10012b: (
  input: PostRunCfMetaM2m10012bRequest
) => Effect.Effect<
  PostRunCfMetaM2m10012bResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMetaM2m10012bRequest,
  output: PostRunCfMetaM2m10012bResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMicrosoftPhi2Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMicrosoftPhi2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/microsoft/phi-2" }),
).annotations({ identifier: "PostRunCfMicrosoftPhi2Request" }) as unknown as Schema.Schema<PostRunCfMicrosoftPhi2Request>;

export interface PostRunCfMicrosoftPhi2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMicrosoftPhi2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMicrosoftPhi2Response" }) as unknown as Schema.Schema<PostRunCfMicrosoftPhi2Response>;

export const postRunCfMicrosoftPhi2: (
  input: PostRunCfMicrosoftPhi2Request
) => Effect.Effect<
  PostRunCfMicrosoftPhi2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMicrosoftPhi2Request,
  output: PostRunCfMicrosoftPhi2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMicrosoftResnet50Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
}

export const PostRunCfMicrosoftResnet50Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/microsoft/resnet-50" }),
).annotations({ identifier: "PostRunCfMicrosoftResnet50Request" }) as unknown as Schema.Schema<PostRunCfMicrosoftResnet50Request>;

export interface PostRunCfMicrosoftResnet50Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMicrosoftResnet50Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMicrosoftResnet50Response" }) as unknown as Schema.Schema<PostRunCfMicrosoftResnet50Response>;

export const postRunCfMicrosoftResnet50: (
  input: PostRunCfMicrosoftResnet50Request
) => Effect.Effect<
  PostRunCfMicrosoftResnet50Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMicrosoftResnet50Request,
  output: PostRunCfMicrosoftResnet50Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMistralMistral7bInstructV01Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMistralMistral7bInstructV01Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/mistral/mistral-7b-instruct-v0.1" }),
).annotations({ identifier: "PostRunCfMistralMistral7bInstructV01Request" }) as unknown as Schema.Schema<PostRunCfMistralMistral7bInstructV01Request>;

export interface PostRunCfMistralMistral7bInstructV01Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMistralMistral7bInstructV01Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMistralMistral7bInstructV01Response" }) as unknown as Schema.Schema<PostRunCfMistralMistral7bInstructV01Response>;

export const postRunCfMistralMistral7bInstructV01: (
  input: PostRunCfMistralMistral7bInstructV01Request
) => Effect.Effect<
  PostRunCfMistralMistral7bInstructV01Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMistralMistral7bInstructV01Request,
  output: PostRunCfMistralMistral7bInstructV01Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMistralMistral7bInstructV02LoraRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMistralMistral7bInstructV02LoraRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/mistral/mistral-7b-instruct-v0.2-lora" }),
).annotations({ identifier: "PostRunCfMistralMistral7bInstructV02LoraRequest" }) as unknown as Schema.Schema<PostRunCfMistralMistral7bInstructV02LoraRequest>;

export interface PostRunCfMistralMistral7bInstructV02LoraResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMistralMistral7bInstructV02LoraResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMistralMistral7bInstructV02LoraResponse" }) as unknown as Schema.Schema<PostRunCfMistralMistral7bInstructV02LoraResponse>;

export const postRunCfMistralMistral7bInstructV02Lora: (
  input: PostRunCfMistralMistral7bInstructV02LoraRequest
) => Effect.Effect<
  PostRunCfMistralMistral7bInstructV02LoraResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMistralMistral7bInstructV02LoraRequest,
  output: PostRunCfMistralMistral7bInstructV02LoraResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMistralaiMistralSmall3124bInstructRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfMistralaiMistralSmall3124bInstructRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/mistralai/mistral-small-3.1-24b-instruct" }),
).annotations({ identifier: "PostRunCfMistralaiMistralSmall3124bInstructRequest" }) as unknown as Schema.Schema<PostRunCfMistralaiMistralSmall3124bInstructRequest>;

export interface PostRunCfMistralaiMistralSmall3124bInstructResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMistralaiMistralSmall3124bInstructResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMistralaiMistralSmall3124bInstructResponse" }) as unknown as Schema.Schema<PostRunCfMistralaiMistralSmall3124bInstructResponse>;

export const postRunCfMistralaiMistralSmall3124bInstruct: (
  input: PostRunCfMistralaiMistralSmall3124bInstructRequest
) => Effect.Effect<
  PostRunCfMistralaiMistralSmall3124bInstructResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMistralaiMistralSmall3124bInstructRequest,
  output: PostRunCfMistralaiMistralSmall3124bInstructResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfMyshellAiMelottsRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { lang?: string; prompt: string };
}

export const PostRunCfMyshellAiMelottsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  lang: Schema.optional(Schema.String),
  prompt: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/myshell-ai/melotts" }),
).annotations({ identifier: "PostRunCfMyshellAiMelottsRequest" }) as unknown as Schema.Schema<PostRunCfMyshellAiMelottsRequest>;

export interface PostRunCfMyshellAiMelottsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfMyshellAiMelottsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfMyshellAiMelottsResponse" }) as unknown as Schema.Schema<PostRunCfMyshellAiMelottsResponse>;

export const postRunCfMyshellAiMelotts: (
  input: PostRunCfMyshellAiMelottsRequest
) => Effect.Effect<
  PostRunCfMyshellAiMelottsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfMyshellAiMelottsRequest,
  output: PostRunCfMyshellAiMelottsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfOpenaiGptOss120bRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: unknown;
}

export const PostRunCfOpenaiGptOss120bRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Union(Schema.Struct({
  input: Schema.Union(Schema.String, Schema.Array(Schema.Unknown)),
  reasoning: Schema.optional(Schema.Struct({
  effort: Schema.optional(Schema.Literal("low", "medium", "high")),
  summary: Schema.optional(Schema.Literal("auto", "concise", "detailed"))
}))
}), Schema.Struct({
  requests: Schema.Array(Schema.Struct({
  input: Schema.Union(Schema.String, Schema.Array(Schema.Unknown)),
  reasoning: Schema.optional(Schema.Struct({
  effort: Schema.optional(Schema.Literal("low", "medium", "high")),
  summary: Schema.optional(Schema.Literal("auto", "concise", "detailed"))
}))
}))
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/openai/gpt-oss-120b" }),
).annotations({ identifier: "PostRunCfOpenaiGptOss120bRequest" }) as unknown as Schema.Schema<PostRunCfOpenaiGptOss120bRequest>;

export interface PostRunCfOpenaiGptOss120bResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfOpenaiGptOss120bResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfOpenaiGptOss120bResponse" }) as unknown as Schema.Schema<PostRunCfOpenaiGptOss120bResponse>;

export const postRunCfOpenaiGptOss120b: (
  input: PostRunCfOpenaiGptOss120bRequest
) => Effect.Effect<
  PostRunCfOpenaiGptOss120bResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfOpenaiGptOss120bRequest,
  output: PostRunCfOpenaiGptOss120bResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfOpenaiGptOss20bRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: unknown;
}

export const PostRunCfOpenaiGptOss20bRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Union(Schema.Struct({
  input: Schema.Union(Schema.String, Schema.Array(Schema.Unknown)),
  reasoning: Schema.optional(Schema.Struct({
  effort: Schema.optional(Schema.Literal("low", "medium", "high")),
  summary: Schema.optional(Schema.Literal("auto", "concise", "detailed"))
}))
}), Schema.Struct({
  requests: Schema.Array(Schema.Struct({
  input: Schema.Union(Schema.String, Schema.Array(Schema.Unknown)),
  reasoning: Schema.optional(Schema.Struct({
  effort: Schema.optional(Schema.Literal("low", "medium", "high")),
  summary: Schema.optional(Schema.Literal("auto", "concise", "detailed"))
}))
}))
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/openai/gpt-oss-20b" }),
).annotations({ identifier: "PostRunCfOpenaiGptOss20bRequest" }) as unknown as Schema.Schema<PostRunCfOpenaiGptOss20bRequest>;

export interface PostRunCfOpenaiGptOss20bResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfOpenaiGptOss20bResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfOpenaiGptOss20bResponse" }) as unknown as Schema.Schema<PostRunCfOpenaiGptOss20bResponse>;

export const postRunCfOpenaiGptOss20b: (
  input: PostRunCfOpenaiGptOss20bRequest
) => Effect.Effect<
  PostRunCfOpenaiGptOss20bResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfOpenaiGptOss20bRequest,
  output: PostRunCfOpenaiGptOss20bResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfOpenaiWhisperRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
}

export const PostRunCfOpenaiWhisperRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/openai/whisper" }),
).annotations({ identifier: "PostRunCfOpenaiWhisperRequest" }) as unknown as Schema.Schema<PostRunCfOpenaiWhisperRequest>;

export interface PostRunCfOpenaiWhisperResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfOpenaiWhisperResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfOpenaiWhisperResponse" }) as unknown as Schema.Schema<PostRunCfOpenaiWhisperResponse>;

export const postRunCfOpenaiWhisper: (
  input: PostRunCfOpenaiWhisperRequest
) => Effect.Effect<
  PostRunCfOpenaiWhisperResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfOpenaiWhisperRequest,
  output: PostRunCfOpenaiWhisperResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfOpenaiWhisperLargeV3TurboRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { audio: string; initial_prompt?: string; language?: string; prefix?: string; task?: string; vad_filter?: boolean };
}

export const PostRunCfOpenaiWhisperLargeV3TurboRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  audio: Schema.String,
  initial_prompt: Schema.optional(Schema.String),
  language: Schema.optional(Schema.String),
  prefix: Schema.optional(Schema.String),
  task: Schema.optional(Schema.String),
  vad_filter: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/openai/whisper-large-v3-turbo" }),
).annotations({ identifier: "PostRunCfOpenaiWhisperLargeV3TurboRequest" }) as unknown as Schema.Schema<PostRunCfOpenaiWhisperLargeV3TurboRequest>;

export interface PostRunCfOpenaiWhisperLargeV3TurboResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfOpenaiWhisperLargeV3TurboResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfOpenaiWhisperLargeV3TurboResponse" }) as unknown as Schema.Schema<PostRunCfOpenaiWhisperLargeV3TurboResponse>;

export const postRunCfOpenaiWhisperLargeV3Turbo: (
  input: PostRunCfOpenaiWhisperLargeV3TurboRequest
) => Effect.Effect<
  PostRunCfOpenaiWhisperLargeV3TurboResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfOpenaiWhisperLargeV3TurboRequest,
  output: PostRunCfOpenaiWhisperLargeV3TurboResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfOpenaiWhisperTinyEnRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
}

export const PostRunCfOpenaiWhisperTinyEnRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/openai/whisper-tiny-en" }),
).annotations({ identifier: "PostRunCfOpenaiWhisperTinyEnRequest" }) as unknown as Schema.Schema<PostRunCfOpenaiWhisperTinyEnRequest>;

export interface PostRunCfOpenaiWhisperTinyEnResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfOpenaiWhisperTinyEnResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfOpenaiWhisperTinyEnResponse" }) as unknown as Schema.Schema<PostRunCfOpenaiWhisperTinyEnResponse>;

export const postRunCfOpenaiWhisperTinyEn: (
  input: PostRunCfOpenaiWhisperTinyEnRequest
) => Effect.Effect<
  PostRunCfOpenaiWhisperTinyEnResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfOpenaiWhisperTinyEnRequest,
  output: PostRunCfOpenaiWhisperTinyEnResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfOpenchatOpenchat350106Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfOpenchatOpenchat350106Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/openchat/openchat-3.5-0106" }),
).annotations({ identifier: "PostRunCfOpenchatOpenchat350106Request" }) as unknown as Schema.Schema<PostRunCfOpenchatOpenchat350106Request>;

export interface PostRunCfOpenchatOpenchat350106Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfOpenchatOpenchat350106Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfOpenchatOpenchat350106Response" }) as unknown as Schema.Schema<PostRunCfOpenchatOpenchat350106Response>;

export const postRunCfOpenchatOpenchat350106: (
  input: PostRunCfOpenchatOpenchat350106Request
) => Effect.Effect<
  PostRunCfOpenchatOpenchat350106Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfOpenchatOpenchat350106Request,
  output: PostRunCfOpenchatOpenchat350106Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfPfnetPlamoEmbedding1bRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { text: unknown };
}

export const PostRunCfPfnetPlamoEmbedding1bRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  text: Schema.Union(Schema.String, Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/pfnet/plamo-embedding-1b" }),
).annotations({ identifier: "PostRunCfPfnetPlamoEmbedding1bRequest" }) as unknown as Schema.Schema<PostRunCfPfnetPlamoEmbedding1bRequest>;

export interface PostRunCfPfnetPlamoEmbedding1bResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfPfnetPlamoEmbedding1bResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfPfnetPlamoEmbedding1bResponse" }) as unknown as Schema.Schema<PostRunCfPfnetPlamoEmbedding1bResponse>;

export const postRunCfPfnetPlamoEmbedding1b: (
  input: PostRunCfPfnetPlamoEmbedding1bRequest
) => Effect.Effect<
  PostRunCfPfnetPlamoEmbedding1bResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfPfnetPlamoEmbedding1bRequest,
  output: PostRunCfPfnetPlamoEmbedding1bResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostWebsocketRunCfPipecatAiSmartTurnV2Request {
  account_id: string;
}

export const PostWebsocketRunCfPipecatAiSmartTurnV2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/run/@cf/pipecat-ai/smart-turn-v2" }),
).annotations({ identifier: "PostWebsocketRunCfPipecatAiSmartTurnV2Request" }) as unknown as Schema.Schema<PostWebsocketRunCfPipecatAiSmartTurnV2Request>;

export interface PostWebsocketRunCfPipecatAiSmartTurnV2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostWebsocketRunCfPipecatAiSmartTurnV2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostWebsocketRunCfPipecatAiSmartTurnV2Response" }) as unknown as Schema.Schema<PostWebsocketRunCfPipecatAiSmartTurnV2Response>;

export const postWebsocketRunCfPipecatAiSmartTurnV2: (
  input: PostWebsocketRunCfPipecatAiSmartTurnV2Request
) => Effect.Effect<
  PostWebsocketRunCfPipecatAiSmartTurnV2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostWebsocketRunCfPipecatAiSmartTurnV2Request,
  output: PostWebsocketRunCfPipecatAiSmartTurnV2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostWebsocketRunCfPipecatAiSmartTurnV3Request {
  account_id: string;
}

export const PostWebsocketRunCfPipecatAiSmartTurnV3Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/run/@cf/pipecat-ai/smart-turn-v3" }),
).annotations({ identifier: "PostWebsocketRunCfPipecatAiSmartTurnV3Request" }) as unknown as Schema.Schema<PostWebsocketRunCfPipecatAiSmartTurnV3Request>;

export interface PostWebsocketRunCfPipecatAiSmartTurnV3Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostWebsocketRunCfPipecatAiSmartTurnV3Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostWebsocketRunCfPipecatAiSmartTurnV3Response" }) as unknown as Schema.Schema<PostWebsocketRunCfPipecatAiSmartTurnV3Response>;

export const postWebsocketRunCfPipecatAiSmartTurnV3: (
  input: PostWebsocketRunCfPipecatAiSmartTurnV3Request
) => Effect.Effect<
  PostWebsocketRunCfPipecatAiSmartTurnV3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostWebsocketRunCfPipecatAiSmartTurnV3Request,
  output: PostWebsocketRunCfPipecatAiSmartTurnV3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfQwenQwen1505bChatRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfQwenQwen1505bChatRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/qwen/qwen1.5-0.5b-chat" }),
).annotations({ identifier: "PostRunCfQwenQwen1505bChatRequest" }) as unknown as Schema.Schema<PostRunCfQwenQwen1505bChatRequest>;

export interface PostRunCfQwenQwen1505bChatResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfQwenQwen1505bChatResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfQwenQwen1505bChatResponse" }) as unknown as Schema.Schema<PostRunCfQwenQwen1505bChatResponse>;

export const postRunCfQwenQwen1505bChat: (
  input: PostRunCfQwenQwen1505bChatRequest
) => Effect.Effect<
  PostRunCfQwenQwen1505bChatResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfQwenQwen1505bChatRequest,
  output: PostRunCfQwenQwen1505bChatResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfQwenQwen1518bChatRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfQwenQwen1518bChatRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/qwen/qwen1.5-1.8b-chat" }),
).annotations({ identifier: "PostRunCfQwenQwen1518bChatRequest" }) as unknown as Schema.Schema<PostRunCfQwenQwen1518bChatRequest>;

export interface PostRunCfQwenQwen1518bChatResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfQwenQwen1518bChatResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfQwenQwen1518bChatResponse" }) as unknown as Schema.Schema<PostRunCfQwenQwen1518bChatResponse>;

export const postRunCfQwenQwen1518bChat: (
  input: PostRunCfQwenQwen1518bChatRequest
) => Effect.Effect<
  PostRunCfQwenQwen1518bChatResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfQwenQwen1518bChatRequest,
  output: PostRunCfQwenQwen1518bChatResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfQwenQwen1514bChatAwqRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfQwenQwen1514bChatAwqRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/qwen/qwen1.5-14b-chat-awq" }),
).annotations({ identifier: "PostRunCfQwenQwen1514bChatAwqRequest" }) as unknown as Schema.Schema<PostRunCfQwenQwen1514bChatAwqRequest>;

export interface PostRunCfQwenQwen1514bChatAwqResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfQwenQwen1514bChatAwqResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfQwenQwen1514bChatAwqResponse" }) as unknown as Schema.Schema<PostRunCfQwenQwen1514bChatAwqResponse>;

export const postRunCfQwenQwen1514bChatAwq: (
  input: PostRunCfQwenQwen1514bChatAwqRequest
) => Effect.Effect<
  PostRunCfQwenQwen1514bChatAwqResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfQwenQwen1514bChatAwqRequest,
  output: PostRunCfQwenQwen1514bChatAwqResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfQwenQwen157bChatAwqRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfQwenQwen157bChatAwqRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/qwen/qwen1.5-7b-chat-awq" }),
).annotations({ identifier: "PostRunCfQwenQwen157bChatAwqRequest" }) as unknown as Schema.Schema<PostRunCfQwenQwen157bChatAwqRequest>;

export interface PostRunCfQwenQwen157bChatAwqResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfQwenQwen157bChatAwqResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfQwenQwen157bChatAwqResponse" }) as unknown as Schema.Schema<PostRunCfQwenQwen157bChatAwqResponse>;

export const postRunCfQwenQwen157bChatAwq: (
  input: PostRunCfQwenQwen157bChatAwqRequest
) => Effect.Effect<
  PostRunCfQwenQwen157bChatAwqResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfQwenQwen157bChatAwqRequest,
  output: PostRunCfQwenQwen157bChatAwqResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfQwenQwen25Coder32bInstructRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfQwenQwen25Coder32bInstructRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/qwen/qwen2.5-coder-32b-instruct" }),
).annotations({ identifier: "PostRunCfQwenQwen25Coder32bInstructRequest" }) as unknown as Schema.Schema<PostRunCfQwenQwen25Coder32bInstructRequest>;

export interface PostRunCfQwenQwen25Coder32bInstructResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfQwenQwen25Coder32bInstructResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfQwenQwen25Coder32bInstructResponse" }) as unknown as Schema.Schema<PostRunCfQwenQwen25Coder32bInstructResponse>;

export const postRunCfQwenQwen25Coder32bInstruct: (
  input: PostRunCfQwenQwen25Coder32bInstructRequest
) => Effect.Effect<
  PostRunCfQwenQwen25Coder32bInstructResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfQwenQwen25Coder32bInstructRequest,
  output: PostRunCfQwenQwen25Coder32bInstructResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfQwenQwen330bA3bFp8Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfQwenQwen330bA3bFp8Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/qwen/qwen3-30b-a3b-fp8" }),
).annotations({ identifier: "PostRunCfQwenQwen330bA3bFp8Request" }) as unknown as Schema.Schema<PostRunCfQwenQwen330bA3bFp8Request>;

export interface PostRunCfQwenQwen330bA3bFp8Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfQwenQwen330bA3bFp8Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfQwenQwen330bA3bFp8Response" }) as unknown as Schema.Schema<PostRunCfQwenQwen330bA3bFp8Response>;

export const postRunCfQwenQwen330bA3bFp8: (
  input: PostRunCfQwenQwen330bA3bFp8Request
) => Effect.Effect<
  PostRunCfQwenQwen330bA3bFp8Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfQwenQwen330bA3bFp8Request,
  output: PostRunCfQwenQwen330bA3bFp8Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfQwenQwen3Embedding06bRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { documents?: unknown; instruction?: string; queries?: unknown; text?: unknown };
}

export const PostRunCfQwenQwen3Embedding06bRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  documents: Schema.optional(Schema.Union(Schema.String, Schema.Array(Schema.String))),
  instruction: Schema.optional(Schema.String),
  queries: Schema.optional(Schema.Union(Schema.String, Schema.Array(Schema.String))),
  text: Schema.optional(Schema.Union(Schema.String, Schema.Array(Schema.String)))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/qwen/qwen3-embedding-0.6b" }),
).annotations({ identifier: "PostRunCfQwenQwen3Embedding06bRequest" }) as unknown as Schema.Schema<PostRunCfQwenQwen3Embedding06bRequest>;

export interface PostRunCfQwenQwen3Embedding06bResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfQwenQwen3Embedding06bResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfQwenQwen3Embedding06bResponse" }) as unknown as Schema.Schema<PostRunCfQwenQwen3Embedding06bResponse>;

export const postRunCfQwenQwen3Embedding06b: (
  input: PostRunCfQwenQwen3Embedding06bRequest
) => Effect.Effect<
  PostRunCfQwenQwen3Embedding06bResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfQwenQwen3Embedding06bRequest,
  output: PostRunCfQwenQwen3Embedding06bResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfQwenQwq32bRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfQwenQwq32bRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/qwen/qwq-32b" }),
).annotations({ identifier: "PostRunCfQwenQwq32bRequest" }) as unknown as Schema.Schema<PostRunCfQwenQwq32bRequest>;

export interface PostRunCfQwenQwq32bResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfQwenQwq32bResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfQwenQwq32bResponse" }) as unknown as Schema.Schema<PostRunCfQwenQwq32bResponse>;

export const postRunCfQwenQwq32b: (
  input: PostRunCfQwenQwq32bRequest
) => Effect.Effect<
  PostRunCfQwenQwq32bResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfQwenQwq32bRequest,
  output: PostRunCfQwenQwq32bResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfRunwaymlStableDiffusionV15Img2imgRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { guidance?: number; height?: number; image?: number[]; image_b64?: string; mask?: number[]; negative_prompt?: string; num_steps?: number; prompt: string; seed?: number; strength?: number; width?: number };
}

export const PostRunCfRunwaymlStableDiffusionV15Img2imgRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  guidance: Schema.optional(Schema.Number),
  height: Schema.optional(Schema.Number),
  image: Schema.optional(Schema.Array(Schema.Number)),
  image_b64: Schema.optional(Schema.String),
  mask: Schema.optional(Schema.Array(Schema.Number)),
  negative_prompt: Schema.optional(Schema.String),
  num_steps: Schema.optional(Schema.Number),
  prompt: Schema.String,
  seed: Schema.optional(Schema.Number),
  strength: Schema.optional(Schema.Number),
  width: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/runwayml/stable-diffusion-v1-5-img2img" }),
).annotations({ identifier: "PostRunCfRunwaymlStableDiffusionV15Img2imgRequest" }) as unknown as Schema.Schema<PostRunCfRunwaymlStableDiffusionV15Img2imgRequest>;

export interface PostRunCfRunwaymlStableDiffusionV15Img2imgResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfRunwaymlStableDiffusionV15Img2imgResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfRunwaymlStableDiffusionV15Img2imgResponse" }) as unknown as Schema.Schema<PostRunCfRunwaymlStableDiffusionV15Img2imgResponse>;

export const postRunCfRunwaymlStableDiffusionV15Img2img: (
  input: PostRunCfRunwaymlStableDiffusionV15Img2imgRequest
) => Effect.Effect<
  PostRunCfRunwaymlStableDiffusionV15Img2imgResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfRunwaymlStableDiffusionV15Img2imgRequest,
  output: PostRunCfRunwaymlStableDiffusionV15Img2imgResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfRunwaymlStableDiffusionV15InpaintingRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { guidance?: number; height?: number; image?: number[]; image_b64?: string; mask?: number[]; negative_prompt?: string; num_steps?: number; prompt: string; seed?: number; strength?: number; width?: number };
}

export const PostRunCfRunwaymlStableDiffusionV15InpaintingRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  guidance: Schema.optional(Schema.Number),
  height: Schema.optional(Schema.Number),
  image: Schema.optional(Schema.Array(Schema.Number)),
  image_b64: Schema.optional(Schema.String),
  mask: Schema.optional(Schema.Array(Schema.Number)),
  negative_prompt: Schema.optional(Schema.String),
  num_steps: Schema.optional(Schema.Number),
  prompt: Schema.String,
  seed: Schema.optional(Schema.Number),
  strength: Schema.optional(Schema.Number),
  width: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/runwayml/stable-diffusion-v1-5-inpainting" }),
).annotations({ identifier: "PostRunCfRunwaymlStableDiffusionV15InpaintingRequest" }) as unknown as Schema.Schema<PostRunCfRunwaymlStableDiffusionV15InpaintingRequest>;

export interface PostRunCfRunwaymlStableDiffusionV15InpaintingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfRunwaymlStableDiffusionV15InpaintingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfRunwaymlStableDiffusionV15InpaintingResponse" }) as unknown as Schema.Schema<PostRunCfRunwaymlStableDiffusionV15InpaintingResponse>;

export const postRunCfRunwaymlStableDiffusionV15Inpainting: (
  input: PostRunCfRunwaymlStableDiffusionV15InpaintingRequest
) => Effect.Effect<
  PostRunCfRunwaymlStableDiffusionV15InpaintingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfRunwaymlStableDiffusionV15InpaintingRequest,
  output: PostRunCfRunwaymlStableDiffusionV15InpaintingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfStabilityaiStableDiffusionXlBase10Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: { guidance?: number; height?: number; image?: number[]; image_b64?: string; mask?: number[]; negative_prompt?: string; num_steps?: number; prompt: string; seed?: number; strength?: number; width?: number };
}

export const PostRunCfStabilityaiStableDiffusionXlBase10Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({
  guidance: Schema.optional(Schema.Number),
  height: Schema.optional(Schema.Number),
  image: Schema.optional(Schema.Array(Schema.Number)),
  image_b64: Schema.optional(Schema.String),
  mask: Schema.optional(Schema.Array(Schema.Number)),
  negative_prompt: Schema.optional(Schema.String),
  num_steps: Schema.optional(Schema.Number),
  prompt: Schema.String,
  seed: Schema.optional(Schema.Number),
  strength: Schema.optional(Schema.Number),
  width: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/stabilityai/stable-diffusion-xl-base-1.0" }),
).annotations({ identifier: "PostRunCfStabilityaiStableDiffusionXlBase10Request" }) as unknown as Schema.Schema<PostRunCfStabilityaiStableDiffusionXlBase10Request>;

export interface PostRunCfStabilityaiStableDiffusionXlBase10Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfStabilityaiStableDiffusionXlBase10Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfStabilityaiStableDiffusionXlBase10Response" }) as unknown as Schema.Schema<PostRunCfStabilityaiStableDiffusionXlBase10Response>;

export const postRunCfStabilityaiStableDiffusionXlBase10: (
  input: PostRunCfStabilityaiStableDiffusionXlBase10Request
) => Effect.Effect<
  PostRunCfStabilityaiStableDiffusionXlBase10Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfStabilityaiStableDiffusionXlBase10Request,
  output: PostRunCfStabilityaiStableDiffusionXlBase10Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostWebsocketRunCfSvenTestPipeHttpRequest {
  account_id: string;
}

export const PostWebsocketRunCfSvenTestPipeHttpRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/run/@cf/sven/test-pipe-http" }),
).annotations({ identifier: "PostWebsocketRunCfSvenTestPipeHttpRequest" }) as unknown as Schema.Schema<PostWebsocketRunCfSvenTestPipeHttpRequest>;

export interface PostWebsocketRunCfSvenTestPipeHttpResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostWebsocketRunCfSvenTestPipeHttpResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostWebsocketRunCfSvenTestPipeHttpResponse" }) as unknown as Schema.Schema<PostWebsocketRunCfSvenTestPipeHttpResponse>;

export const postWebsocketRunCfSvenTestPipeHttp: (
  input: PostWebsocketRunCfSvenTestPipeHttpRequest
) => Effect.Effect<
  PostWebsocketRunCfSvenTestPipeHttpResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostWebsocketRunCfSvenTestPipeHttpRequest,
  output: PostWebsocketRunCfSvenTestPipeHttpResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfTheblokeDiscolmGerman7bV1AwqRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfTheblokeDiscolmGerman7bV1AwqRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/thebloke/discolm-german-7b-v1-awq" }),
).annotations({ identifier: "PostRunCfTheblokeDiscolmGerman7bV1AwqRequest" }) as unknown as Schema.Schema<PostRunCfTheblokeDiscolmGerman7bV1AwqRequest>;

export interface PostRunCfTheblokeDiscolmGerman7bV1AwqResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfTheblokeDiscolmGerman7bV1AwqResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfTheblokeDiscolmGerman7bV1AwqResponse" }) as unknown as Schema.Schema<PostRunCfTheblokeDiscolmGerman7bV1AwqResponse>;

export const postRunCfTheblokeDiscolmGerman7bV1Awq: (
  input: PostRunCfTheblokeDiscolmGerman7bV1AwqRequest
) => Effect.Effect<
  PostRunCfTheblokeDiscolmGerman7bV1AwqResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfTheblokeDiscolmGerman7bV1AwqRequest,
  output: PostRunCfTheblokeDiscolmGerman7bV1AwqResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfTiiuaeFalcon7bInstructRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfTiiuaeFalcon7bInstructRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/tiiuae/falcon-7b-instruct" }),
).annotations({ identifier: "PostRunCfTiiuaeFalcon7bInstructRequest" }) as unknown as Schema.Schema<PostRunCfTiiuaeFalcon7bInstructRequest>;

export interface PostRunCfTiiuaeFalcon7bInstructResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfTiiuaeFalcon7bInstructResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfTiiuaeFalcon7bInstructResponse" }) as unknown as Schema.Schema<PostRunCfTiiuaeFalcon7bInstructResponse>;

export const postRunCfTiiuaeFalcon7bInstruct: (
  input: PostRunCfTiiuaeFalcon7bInstructRequest
) => Effect.Effect<
  PostRunCfTiiuaeFalcon7bInstructResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfTiiuaeFalcon7bInstructRequest,
  output: PostRunCfTiiuaeFalcon7bInstructResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunCfTinyllamaTinyllama11bChatV10Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunCfTinyllamaTinyllama11bChatV10Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@cf/tinyllama/tinyllama-1.1b-chat-v1.0" }),
).annotations({ identifier: "PostRunCfTinyllamaTinyllama11bChatV10Request" }) as unknown as Schema.Schema<PostRunCfTinyllamaTinyllama11bChatV10Request>;

export interface PostRunCfTinyllamaTinyllama11bChatV10Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunCfTinyllamaTinyllama11bChatV10Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunCfTinyllamaTinyllama11bChatV10Response" }) as unknown as Schema.Schema<PostRunCfTinyllamaTinyllama11bChatV10Response>;

export const postRunCfTinyllamaTinyllama11bChatV10: (
  input: PostRunCfTinyllamaTinyllama11bChatV10Request
) => Effect.Effect<
  PostRunCfTinyllamaTinyllama11bChatV10Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunCfTinyllamaTinyllama11bChatV10Request,
  output: PostRunCfTinyllamaTinyllama11bChatV10Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunHfGoogleGemma7bItRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunHfGoogleGemma7bItRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@hf/google/gemma-7b-it" }),
).annotations({ identifier: "PostRunHfGoogleGemma7bItRequest" }) as unknown as Schema.Schema<PostRunHfGoogleGemma7bItRequest>;

export interface PostRunHfGoogleGemma7bItResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunHfGoogleGemma7bItResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunHfGoogleGemma7bItResponse" }) as unknown as Schema.Schema<PostRunHfGoogleGemma7bItResponse>;

export const postRunHfGoogleGemma7bIt: (
  input: PostRunHfGoogleGemma7bItRequest
) => Effect.Effect<
  PostRunHfGoogleGemma7bItResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunHfGoogleGemma7bItRequest,
  output: PostRunHfGoogleGemma7bItResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunHfMistralMistral7bInstructV02Request {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunHfMistralMistral7bInstructV02Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@hf/mistral/mistral-7b-instruct-v0.2" }),
).annotations({ identifier: "PostRunHfMistralMistral7bInstructV02Request" }) as unknown as Schema.Schema<PostRunHfMistralMistral7bInstructV02Request>;

export interface PostRunHfMistralMistral7bInstructV02Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunHfMistralMistral7bInstructV02Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunHfMistralMistral7bInstructV02Response" }) as unknown as Schema.Schema<PostRunHfMistralMistral7bInstructV02Response>;

export const postRunHfMistralMistral7bInstructV02: (
  input: PostRunHfMistralMistral7bInstructV02Request
) => Effect.Effect<
  PostRunHfMistralMistral7bInstructV02Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunHfMistralMistral7bInstructV02Request,
  output: PostRunHfMistralMistral7bInstructV02Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunHfNexusflowStarlingLm7bBetaRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunHfNexusflowStarlingLm7bBetaRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@hf/nexusflow/starling-lm-7b-beta" }),
).annotations({ identifier: "PostRunHfNexusflowStarlingLm7bBetaRequest" }) as unknown as Schema.Schema<PostRunHfNexusflowStarlingLm7bBetaRequest>;

export interface PostRunHfNexusflowStarlingLm7bBetaResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunHfNexusflowStarlingLm7bBetaResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunHfNexusflowStarlingLm7bBetaResponse" }) as unknown as Schema.Schema<PostRunHfNexusflowStarlingLm7bBetaResponse>;

export const postRunHfNexusflowStarlingLm7bBeta: (
  input: PostRunHfNexusflowStarlingLm7bBetaRequest
) => Effect.Effect<
  PostRunHfNexusflowStarlingLm7bBetaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunHfNexusflowStarlingLm7bBetaRequest,
  output: PostRunHfNexusflowStarlingLm7bBetaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunHfNousresearchHermes2ProMistral7bRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunHfNousresearchHermes2ProMistral7bRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@hf/nousresearch/hermes-2-pro-mistral-7b" }),
).annotations({ identifier: "PostRunHfNousresearchHermes2ProMistral7bRequest" }) as unknown as Schema.Schema<PostRunHfNousresearchHermes2ProMistral7bRequest>;

export interface PostRunHfNousresearchHermes2ProMistral7bResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunHfNousresearchHermes2ProMistral7bResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunHfNousresearchHermes2ProMistral7bResponse" }) as unknown as Schema.Schema<PostRunHfNousresearchHermes2ProMistral7bResponse>;

export const postRunHfNousresearchHermes2ProMistral7b: (
  input: PostRunHfNousresearchHermes2ProMistral7bRequest
) => Effect.Effect<
  PostRunHfNousresearchHermes2ProMistral7bResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunHfNousresearchHermes2ProMistral7bRequest,
  output: PostRunHfNousresearchHermes2ProMistral7bResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunHfTheblokeDeepseekCoder67bBaseAwqRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunHfTheblokeDeepseekCoder67bBaseAwqRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@hf/thebloke/deepseek-coder-6.7b-base-awq" }),
).annotations({ identifier: "PostRunHfTheblokeDeepseekCoder67bBaseAwqRequest" }) as unknown as Schema.Schema<PostRunHfTheblokeDeepseekCoder67bBaseAwqRequest>;

export interface PostRunHfTheblokeDeepseekCoder67bBaseAwqResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunHfTheblokeDeepseekCoder67bBaseAwqResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunHfTheblokeDeepseekCoder67bBaseAwqResponse" }) as unknown as Schema.Schema<PostRunHfTheblokeDeepseekCoder67bBaseAwqResponse>;

export const postRunHfTheblokeDeepseekCoder67bBaseAwq: (
  input: PostRunHfTheblokeDeepseekCoder67bBaseAwqRequest
) => Effect.Effect<
  PostRunHfTheblokeDeepseekCoder67bBaseAwqResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunHfTheblokeDeepseekCoder67bBaseAwqRequest,
  output: PostRunHfTheblokeDeepseekCoder67bBaseAwqResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunHfTheblokeDeepseekCoder67bInstructAwqRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunHfTheblokeDeepseekCoder67bInstructAwqRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@hf/thebloke/deepseek-coder-6.7b-instruct-awq" }),
).annotations({ identifier: "PostRunHfTheblokeDeepseekCoder67bInstructAwqRequest" }) as unknown as Schema.Schema<PostRunHfTheblokeDeepseekCoder67bInstructAwqRequest>;

export interface PostRunHfTheblokeDeepseekCoder67bInstructAwqResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunHfTheblokeDeepseekCoder67bInstructAwqResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunHfTheblokeDeepseekCoder67bInstructAwqResponse" }) as unknown as Schema.Schema<PostRunHfTheblokeDeepseekCoder67bInstructAwqResponse>;

export const postRunHfTheblokeDeepseekCoder67bInstructAwq: (
  input: PostRunHfTheblokeDeepseekCoder67bInstructAwqRequest
) => Effect.Effect<
  PostRunHfTheblokeDeepseekCoder67bInstructAwqResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunHfTheblokeDeepseekCoder67bInstructAwqRequest,
  output: PostRunHfTheblokeDeepseekCoder67bInstructAwqResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunHfTheblokeLlama213bChatAwqRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunHfTheblokeLlama213bChatAwqRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@hf/thebloke/llama-2-13b-chat-awq" }),
).annotations({ identifier: "PostRunHfTheblokeLlama213bChatAwqRequest" }) as unknown as Schema.Schema<PostRunHfTheblokeLlama213bChatAwqRequest>;

export interface PostRunHfTheblokeLlama213bChatAwqResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunHfTheblokeLlama213bChatAwqResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunHfTheblokeLlama213bChatAwqResponse" }) as unknown as Schema.Schema<PostRunHfTheblokeLlama213bChatAwqResponse>;

export const postRunHfTheblokeLlama213bChatAwq: (
  input: PostRunHfTheblokeLlama213bChatAwqRequest
) => Effect.Effect<
  PostRunHfTheblokeLlama213bChatAwqResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunHfTheblokeLlama213bChatAwqRequest,
  output: PostRunHfTheblokeLlama213bChatAwqResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunHfTheblokeLlamaguard7bAwqRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunHfTheblokeLlamaguard7bAwqRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@hf/thebloke/llamaguard-7b-awq" }),
).annotations({ identifier: "PostRunHfTheblokeLlamaguard7bAwqRequest" }) as unknown as Schema.Schema<PostRunHfTheblokeLlamaguard7bAwqRequest>;

export interface PostRunHfTheblokeLlamaguard7bAwqResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunHfTheblokeLlamaguard7bAwqResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunHfTheblokeLlamaguard7bAwqResponse" }) as unknown as Schema.Schema<PostRunHfTheblokeLlamaguard7bAwqResponse>;

export const postRunHfTheblokeLlamaguard7bAwq: (
  input: PostRunHfTheblokeLlamaguard7bAwqRequest
) => Effect.Effect<
  PostRunHfTheblokeLlamaguard7bAwqResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunHfTheblokeLlamaguard7bAwqRequest,
  output: PostRunHfTheblokeLlamaguard7bAwqResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunHfTheblokeMistral7bInstructV01AwqRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunHfTheblokeMistral7bInstructV01AwqRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@hf/thebloke/mistral-7b-instruct-v0.1-awq" }),
).annotations({ identifier: "PostRunHfTheblokeMistral7bInstructV01AwqRequest" }) as unknown as Schema.Schema<PostRunHfTheblokeMistral7bInstructV01AwqRequest>;

export interface PostRunHfTheblokeMistral7bInstructV01AwqResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunHfTheblokeMistral7bInstructV01AwqResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunHfTheblokeMistral7bInstructV01AwqResponse" }) as unknown as Schema.Schema<PostRunHfTheblokeMistral7bInstructV01AwqResponse>;

export const postRunHfTheblokeMistral7bInstructV01Awq: (
  input: PostRunHfTheblokeMistral7bInstructV01AwqRequest
) => Effect.Effect<
  PostRunHfTheblokeMistral7bInstructV01AwqResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunHfTheblokeMistral7bInstructV01AwqRequest,
  output: PostRunHfTheblokeMistral7bInstructV01AwqResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunHfTheblokeNeuralChat7bV31AwqRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunHfTheblokeNeuralChat7bV31AwqRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@hf/thebloke/neural-chat-7b-v3-1-awq" }),
).annotations({ identifier: "PostRunHfTheblokeNeuralChat7bV31AwqRequest" }) as unknown as Schema.Schema<PostRunHfTheblokeNeuralChat7bV31AwqRequest>;

export interface PostRunHfTheblokeNeuralChat7bV31AwqResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunHfTheblokeNeuralChat7bV31AwqResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunHfTheblokeNeuralChat7bV31AwqResponse" }) as unknown as Schema.Schema<PostRunHfTheblokeNeuralChat7bV31AwqResponse>;

export const postRunHfTheblokeNeuralChat7bV31Awq: (
  input: PostRunHfTheblokeNeuralChat7bV31AwqRequest
) => Effect.Effect<
  PostRunHfTheblokeNeuralChat7bV31AwqResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunHfTheblokeNeuralChat7bV31AwqRequest,
  output: PostRunHfTheblokeNeuralChat7bV31AwqResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunHfTheblokeOpenhermes25Mistral7bAwqRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunHfTheblokeOpenhermes25Mistral7bAwqRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@hf/thebloke/openhermes-2.5-mistral-7b-awq" }),
).annotations({ identifier: "PostRunHfTheblokeOpenhermes25Mistral7bAwqRequest" }) as unknown as Schema.Schema<PostRunHfTheblokeOpenhermes25Mistral7bAwqRequest>;

export interface PostRunHfTheblokeOpenhermes25Mistral7bAwqResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunHfTheblokeOpenhermes25Mistral7bAwqResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunHfTheblokeOpenhermes25Mistral7bAwqResponse" }) as unknown as Schema.Schema<PostRunHfTheblokeOpenhermes25Mistral7bAwqResponse>;

export const postRunHfTheblokeOpenhermes25Mistral7bAwq: (
  input: PostRunHfTheblokeOpenhermes25Mistral7bAwqRequest
) => Effect.Effect<
  PostRunHfTheblokeOpenhermes25Mistral7bAwqResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunHfTheblokeOpenhermes25Mistral7bAwqRequest,
  output: PostRunHfTheblokeOpenhermes25Mistral7bAwqResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunHfTheblokeZephyr7bBetaAwqRequest {
  account_id: string;
  queueRequest?: string;
  tags?: string;
  body: Record<string, unknown>;
}

export const PostRunHfTheblokeZephyr7bBetaAwqRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  queueRequest: Schema.optional(Schema.String).pipe(T.HttpQuery("queueRequest")),
  tags: Schema.optional(Schema.String).pipe(T.HttpQuery("tags")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/@hf/thebloke/zephyr-7b-beta-awq" }),
).annotations({ identifier: "PostRunHfTheblokeZephyr7bBetaAwqRequest" }) as unknown as Schema.Schema<PostRunHfTheblokeZephyr7bBetaAwqRequest>;

export interface PostRunHfTheblokeZephyr7bBetaAwqResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunHfTheblokeZephyr7bBetaAwqResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunHfTheblokeZephyr7bBetaAwqResponse" }) as unknown as Schema.Schema<PostRunHfTheblokeZephyr7bBetaAwqResponse>;

export const postRunHfTheblokeZephyr7bBetaAwq: (
  input: PostRunHfTheblokeZephyr7bBetaAwqRequest
) => Effect.Effect<
  PostRunHfTheblokeZephyr7bBetaAwqResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunHfTheblokeZephyr7bBetaAwqRequest,
  output: PostRunHfTheblokeZephyr7bBetaAwqResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRunModelRequest {
  account_id: string;
  model_name: string;
  body: Record<string, unknown>;
}

export const PostRunModelRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  model_name: Schema.String.pipe(T.HttpPath("model_name")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/run/{model_name}" }),
).annotations({ identifier: "PostRunModelRequest" }) as unknown as Schema.Schema<PostRunModelRequest>;

export interface PostRunModelResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostRunModelResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostRunModelResponse" }) as unknown as Schema.Schema<PostRunModelResponse>;

export const postRunModel: (
  input: PostRunModelRequest
) => Effect.Effect<
  PostRunModelResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRunModelRequest,
  output: PostRunModelResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface WorkersAiSearchTaskRequest {
  account_id: string;
}

export const WorkersAiSearchTaskRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/tasks/search" }),
).annotations({ identifier: "WorkersAiSearchTaskRequest" }) as unknown as Schema.Schema<WorkersAiSearchTaskRequest>;

export interface WorkersAiSearchTaskResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const WorkersAiSearchTaskResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "WorkersAiSearchTaskResponse" }) as unknown as Schema.Schema<WorkersAiSearchTaskResponse>;

export const workersAiSearchTask: (
  input: WorkersAiSearchTaskRequest
) => Effect.Effect<
  WorkersAiSearchTaskResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: WorkersAiSearchTaskRequest,
  output: WorkersAiSearchTaskResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostToMarkdownRequest {
  account_id: string;
}

export const PostToMarkdownRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/ai/tomarkdown" }),
).annotations({ identifier: "PostToMarkdownRequest" }) as unknown as Schema.Schema<PostToMarkdownRequest>;

export interface PostToMarkdownResponse {
  result: { data: string; format: string; mimeType: string; name: string; tokens: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostToMarkdownResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  data: Schema.String,
  format: Schema.String,
  mimeType: Schema.String,
  name: Schema.String,
  tokens: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostToMarkdownResponse" }) as unknown as Schema.Schema<PostToMarkdownResponse>;

export const postToMarkdown: (
  input: PostToMarkdownRequest
) => Effect.Effect<
  PostToMarkdownResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostToMarkdownRequest,
  output: PostToMarkdownResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetToMarkdownSupportedRequest {
  account_id: string;
}

export const GetToMarkdownSupportedRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/ai/tomarkdown/supported" }),
).annotations({ identifier: "GetToMarkdownSupportedRequest" }) as unknown as Schema.Schema<GetToMarkdownSupportedRequest>;

export interface GetToMarkdownSupportedResponse {
  result: { extension: string; mimeType: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetToMarkdownSupportedResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  extension: Schema.String,
  mimeType: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetToMarkdownSupportedResponse" }) as unknown as Schema.Schema<GetToMarkdownSupportedResponse>;

export const getToMarkdownSupported: (
  input: GetToMarkdownSupportedRequest
) => Effect.Effect<
  GetToMarkdownSupportedResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetToMarkdownSupportedRequest,
  output: GetToMarkdownSupportedResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAlertTypesRequest {
  account_id: string;
}

export const GetAlertTypesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/alerting/v3/available_alerts" }),
).annotations({ identifier: "GetAlertTypesRequest" }) as unknown as Schema.Schema<GetAlertTypesRequest>;

export interface GetAlertTypesResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAlertTypesResponse = Schema.Struct({
  result: Schema.Record({ key: Schema.String, value: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  display_name: Schema.optional(Schema.String),
  filter_options: Schema.optional(Schema.Array(Schema.Unknown)),
  type: Schema.optional(Schema.String)
})) }),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAlertTypesResponse" }) as unknown as Schema.Schema<GetAlertTypesResponse>;

export const getAlertTypes: (
  input: GetAlertTypesRequest
) => Effect.Effect<
  GetAlertTypesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAlertTypesRequest,
  output: GetAlertTypesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDeliveryMechanismEligibilityRequest {
  account_id: string;
}

export const GetDeliveryMechanismEligibilityRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/alerting/v3/destinations/eligible" }),
).annotations({ identifier: "GetDeliveryMechanismEligibilityRequest" }) as unknown as Schema.Schema<GetDeliveryMechanismEligibilityRequest>;

export interface GetDeliveryMechanismEligibilityResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDeliveryMechanismEligibilityResponse = Schema.Struct({
  result: Schema.Record({ key: Schema.String, value: Schema.Array(Schema.Struct({
  eligible: Schema.optional(Schema.Boolean),
  ready: Schema.optional(Schema.Boolean),
  type: Schema.optional(Schema.Literal("email", "pagerduty", "webhook"))
})) }),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDeliveryMechanismEligibilityResponse" }) as unknown as Schema.Schema<GetDeliveryMechanismEligibilityResponse>;

export const getDeliveryMechanismEligibility: (
  input: GetDeliveryMechanismEligibilityRequest
) => Effect.Effect<
  GetDeliveryMechanismEligibilityResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDeliveryMechanismEligibilityRequest,
  output: GetDeliveryMechanismEligibilityResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListPagerDutyServicesRequest {
  account_id: string;
}

export const ListPagerDutyServicesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/alerting/v3/destinations/pagerduty" }),
).annotations({ identifier: "ListPagerDutyServicesRequest" }) as unknown as Schema.Schema<ListPagerDutyServicesRequest>;

export interface ListPagerDutyServicesResponse {
  result: { id?: string; name?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListPagerDutyServicesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListPagerDutyServicesResponse" }) as unknown as Schema.Schema<ListPagerDutyServicesResponse>;

export const listPagerDutyServices: (
  input: ListPagerDutyServicesRequest
) => Effect.Effect<
  ListPagerDutyServicesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListPagerDutyServicesRequest,
  output: ListPagerDutyServicesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletePagerDutyServicesRequest {
  account_id: string;
}

export const DeletePagerDutyServicesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/alerting/v3/destinations/pagerduty" }),
).annotations({ identifier: "DeletePagerDutyServicesRequest" }) as unknown as Schema.Schema<DeletePagerDutyServicesRequest>;

export interface DeletePagerDutyServicesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletePagerDutyServicesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletePagerDutyServicesResponse" }) as unknown as Schema.Schema<DeletePagerDutyServicesResponse>;

export const deletePagerDutyServices: (
  input: DeletePagerDutyServicesRequest
) => Effect.Effect<
  DeletePagerDutyServicesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletePagerDutyServicesRequest,
  output: DeletePagerDutyServicesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface NotificationDestinationsWithPagerDutyConnectPagerDutyRequest {
  account_id: string;
}

export const NotificationDestinationsWithPagerDutyConnectPagerDutyRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/alerting/v3/destinations/pagerduty/connect" }),
).annotations({ identifier: "NotificationDestinationsWithPagerDutyConnectPagerDutyRequest" }) as unknown as Schema.Schema<NotificationDestinationsWithPagerDutyConnectPagerDutyRequest>;

export interface NotificationDestinationsWithPagerDutyConnectPagerDutyResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const NotificationDestinationsWithPagerDutyConnectPagerDutyResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "NotificationDestinationsWithPagerDutyConnectPagerDutyResponse" }) as unknown as Schema.Schema<NotificationDestinationsWithPagerDutyConnectPagerDutyResponse>;

export const notificationDestinationsWithPagerDutyConnectPagerDuty: (
  input: NotificationDestinationsWithPagerDutyConnectPagerDutyRequest
) => Effect.Effect<
  NotificationDestinationsWithPagerDutyConnectPagerDutyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: NotificationDestinationsWithPagerDutyConnectPagerDutyRequest,
  output: NotificationDestinationsWithPagerDutyConnectPagerDutyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface NotificationDestinationsWithPagerDutyConnectPagerDutyTokenRequest {
  account_id: string;
  token_id: string;
}

export const NotificationDestinationsWithPagerDutyConnectPagerDutyTokenRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  token_id: Schema.String.pipe(T.HttpPath("token_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/alerting/v3/destinations/pagerduty/connect/{token_id}" }),
).annotations({ identifier: "NotificationDestinationsWithPagerDutyConnectPagerDutyTokenRequest" }) as unknown as Schema.Schema<NotificationDestinationsWithPagerDutyConnectPagerDutyTokenRequest>;

export interface NotificationDestinationsWithPagerDutyConnectPagerDutyTokenResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const NotificationDestinationsWithPagerDutyConnectPagerDutyTokenResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "NotificationDestinationsWithPagerDutyConnectPagerDutyTokenResponse" }) as unknown as Schema.Schema<NotificationDestinationsWithPagerDutyConnectPagerDutyTokenResponse>;

export const notificationDestinationsWithPagerDutyConnectPagerDutyToken: (
  input: NotificationDestinationsWithPagerDutyConnectPagerDutyTokenRequest
) => Effect.Effect<
  NotificationDestinationsWithPagerDutyConnectPagerDutyTokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: NotificationDestinationsWithPagerDutyConnectPagerDutyTokenRequest,
  output: NotificationDestinationsWithPagerDutyConnectPagerDutyTokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListWebhooksRequest {
  account_id: string;
}

export const ListWebhooksRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/alerting/v3/destinations/webhooks" }),
).annotations({ identifier: "ListWebhooksRequest" }) as unknown as Schema.Schema<ListWebhooksRequest>;

export interface ListWebhooksResponse {
  result: { created_at?: string; id?: string; last_failure?: string; last_success?: string; name?: string; secret?: string; type?: "datadog" | "discord" | "feishu" | "gchat" | "generic" | "opsgenie" | "slack" | "splunk"; url?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListWebhooksResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  last_failure: Schema.optional(Schema.Date),
  last_success: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  secret: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("datadog", "discord", "feishu", "gchat", "generic", "opsgenie", "slack", "splunk")),
  url: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListWebhooksResponse" }) as unknown as Schema.Schema<ListWebhooksResponse>;

export const listWebhooks: (
  input: ListWebhooksRequest
) => Effect.Effect<
  ListWebhooksResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListWebhooksRequest,
  output: ListWebhooksResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateAWebhookRequest {
  account_id: string;
  body: unknown;
}

export const CreateAWebhookRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/alerting/v3/destinations/webhooks" }),
).annotations({ identifier: "CreateAWebhookRequest" }) as unknown as Schema.Schema<CreateAWebhookRequest>;

export interface CreateAWebhookResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateAWebhookResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateAWebhookResponse" }) as unknown as Schema.Schema<CreateAWebhookResponse>;

export const createAWebhook: (
  input: CreateAWebhookRequest
) => Effect.Effect<
  CreateAWebhookResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAWebhookRequest,
  output: CreateAWebhookResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAWebhookRequest {
  account_id: string;
  webhook_id: string;
}

export const GetAWebhookRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  webhook_id: Schema.String.pipe(T.HttpPath("webhook_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/alerting/v3/destinations/webhooks/{webhook_id}" }),
).annotations({ identifier: "GetAWebhookRequest" }) as unknown as Schema.Schema<GetAWebhookRequest>;

export interface GetAWebhookResponse {
  result: { created_at?: string; id?: string; last_failure?: string; last_success?: string; name?: string; secret?: string; type?: "datadog" | "discord" | "feishu" | "gchat" | "generic" | "opsgenie" | "slack" | "splunk"; url?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAWebhookResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  last_failure: Schema.optional(Schema.Date),
  last_success: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  secret: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("datadog", "discord", "feishu", "gchat", "generic", "opsgenie", "slack", "splunk")),
  url: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAWebhookResponse" }) as unknown as Schema.Schema<GetAWebhookResponse>;

export const getAWebhook: (
  input: GetAWebhookRequest
) => Effect.Effect<
  GetAWebhookResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAWebhookRequest,
  output: GetAWebhookResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAWebhookRequest {
  webhook_id: string;
  account_id: string;
  body: unknown;
}

export const UpdateAWebhookRequest = Schema.Struct({
  webhook_id: Schema.String.pipe(T.HttpPath("webhook_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/alerting/v3/destinations/webhooks/{webhook_id}" }),
).annotations({ identifier: "UpdateAWebhookRequest" }) as unknown as Schema.Schema<UpdateAWebhookRequest>;

export interface UpdateAWebhookResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAWebhookResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAWebhookResponse" }) as unknown as Schema.Schema<UpdateAWebhookResponse>;

export const updateAWebhook: (
  input: UpdateAWebhookRequest
) => Effect.Effect<
  UpdateAWebhookResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAWebhookRequest,
  output: UpdateAWebhookResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAWebhookRequest {
  webhook_id: string;
  account_id: string;
}

export const DeleteAWebhookRequest = Schema.Struct({
  webhook_id: Schema.String.pipe(T.HttpPath("webhook_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/alerting/v3/destinations/webhooks/{webhook_id}" }),
).annotations({ identifier: "DeleteAWebhookRequest" }) as unknown as Schema.Schema<DeleteAWebhookRequest>;

export interface DeleteAWebhookResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAWebhookResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAWebhookResponse" }) as unknown as Schema.Schema<DeleteAWebhookResponse>;

export const deleteAWebhook: (
  input: DeleteAWebhookRequest
) => Effect.Effect<
  DeleteAWebhookResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAWebhookRequest,
  output: DeleteAWebhookResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListHistoryRequest {
  account_id: string;
  per_page?: number;
  before?: string;
  page?: number;
  since?: string;
}

export const ListHistoryRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  before: Schema.optional(Schema.Date).pipe(T.HttpQuery("before")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  since: Schema.optional(Schema.Date).pipe(T.HttpQuery("since"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/alerting/v3/history" }),
).annotations({ identifier: "ListHistoryRequest" }) as unknown as Schema.Schema<ListHistoryRequest>;

export interface ListHistoryResponse {
  result: { alert_body?: string; alert_type?: string; description?: string; id?: string; mechanism?: string; mechanism_type?: "email" | "pagerduty" | "webhook"; name?: string; policy_id?: string; sent?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListHistoryResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  alert_body: Schema.optional(Schema.String),
  alert_type: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  mechanism: Schema.optional(Schema.String),
  mechanism_type: Schema.optional(Schema.Literal("email", "pagerduty", "webhook")),
  name: Schema.optional(Schema.String),
  policy_id: Schema.optional(Schema.String),
  sent: Schema.optional(Schema.Date)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListHistoryResponse" }) as unknown as Schema.Schema<ListHistoryResponse>;

export const listHistory: (
  input: ListHistoryRequest
) => Effect.Effect<
  ListHistoryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListHistoryRequest,
  output: ListHistoryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListNotificationPoliciesRequest {
  account_id: string;
}

export const ListNotificationPoliciesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/alerting/v3/policies" }),
).annotations({ identifier: "ListNotificationPoliciesRequest" }) as unknown as Schema.Schema<ListNotificationPoliciesRequest>;

export interface ListNotificationPoliciesResponse {
  result: { alert_interval?: string; alert_type?: "abuse_report_alert" | "access_custom_certificate_expiration_type" | "advanced_ddos_attack_l4_alert" | "advanced_ddos_attack_l7_alert" | "advanced_http_alert_error" | "bgp_hijack_notification" | "billing_usage_alert" | "block_notification_block_removed" | "block_notification_new_block" | "block_notification_review_rejected" | "bot_traffic_basic_alert" | "brand_protection_alert" | "brand_protection_digest" | "clickhouse_alert_fw_anomaly" | "clickhouse_alert_fw_ent_anomaly" | "cloudforce_one_request_notification" | "custom_analytics" | "custom_bot_detection_alert" | "custom_ssl_certificate_event_type" | "dedicated_ssl_certificate_event_type" | "device_connectivity_anomaly_alert" | "dos_attack_l4" | "dos_attack_l7" | "expiring_service_token_alert" | "failing_logpush_job_disabled_alert" | "fbm_auto_advertisement" | "fbm_dosd_attack" | "fbm_volumetric_attack" | "health_check_status_notification" | "hostname_aop_custom_certificate_expiration_type" | "http_alert_edge_error" | "http_alert_origin_error" | "image_notification" | "image_resizing_notification" | "incident_alert" | "load_balancing_health_alert" | "load_balancing_pool_enablement_alert" | "logo_match_alert" | "magic_tunnel_health_check_event" | "magic_wan_tunnel_health" | "maintenance_event_notification" | "mtls_certificate_store_certificate_expiration_type" | "pages_event_alert" | "radar_notification" | "real_origin_monitoring" | "scriptmonitor_alert_new_code_change_detections" | "scriptmonitor_alert_new_hosts" | "scriptmonitor_alert_new_malicious_hosts" | "scriptmonitor_alert_new_malicious_scripts" | "scriptmonitor_alert_new_malicious_url" | "scriptmonitor_alert_new_max_length_resource_url" | "scriptmonitor_alert_new_resources" | "secondary_dns_all_primaries_failing" | "secondary_dns_primaries_failing" | "secondary_dns_warning" | "secondary_dns_zone_successfully_updated" | "secondary_dns_zone_validation_warning" | "security_insights_alert" | "sentinel_alert" | "stream_live_notifications" | "synthetic_test_latency_alert" | "synthetic_test_low_availability_alert" | "traffic_anomalies_alert" | "tunnel_health_event" | "tunnel_update_event" | "universal_ssl_event_type" | "web_analytics_metrics_update" | "zone_aop_custom_certificate_expiration_type"; created?: string; description?: string; enabled?: boolean; filters?: { actions?: string[]; affected_asns?: string[]; affected_components?: string[]; affected_locations?: string[]; airport_code?: string[]; alert_trigger_preferences?: string[]; alert_trigger_preferences_value?: string[]; enabled?: string[]; environment?: string[]; event?: string[]; event_source?: string[]; event_type?: string[]; group_by?: string[]; health_check_id?: string[]; incident_impact?: "INCIDENT_IMPACT_NONE" | "INCIDENT_IMPACT_MINOR" | "INCIDENT_IMPACT_MAJOR" | "INCIDENT_IMPACT_CRITICAL"[]; input_id?: string[]; insight_class?: string[]; limit?: string[]; logo_tag?: string[]; megabits_per_second?: string[]; new_health?: string[]; new_status?: string[]; packets_per_second?: string[]; pool_id?: string[]; pop_names?: string[]; product?: string[]; project_id?: string[]; protocol?: string[]; query_tag?: string[]; requests_per_second?: string[]; selectors?: string[]; services?: string[]; slo?: string[]; status?: string[]; target_hostname?: string[]; target_ip?: string[]; target_zone_name?: string[]; traffic_exclusions?: "security_events"[]; tunnel_id?: string[]; tunnel_name?: string[]; type?: string[]; where?: string[]; zones?: string[] }; id?: string; mechanisms?: { email?: { id?: string }[]; pagerduty?: { id?: string }[]; webhooks?: { id?: string }[] }; modified?: string; name?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListNotificationPoliciesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  alert_interval: Schema.optional(Schema.String),
  alert_type: Schema.optional(Schema.Literal("abuse_report_alert", "access_custom_certificate_expiration_type", "advanced_ddos_attack_l4_alert", "advanced_ddos_attack_l7_alert", "advanced_http_alert_error", "bgp_hijack_notification", "billing_usage_alert", "block_notification_block_removed", "block_notification_new_block", "block_notification_review_rejected", "bot_traffic_basic_alert", "brand_protection_alert", "brand_protection_digest", "clickhouse_alert_fw_anomaly", "clickhouse_alert_fw_ent_anomaly", "cloudforce_one_request_notification", "custom_analytics", "custom_bot_detection_alert", "custom_ssl_certificate_event_type", "dedicated_ssl_certificate_event_type", "device_connectivity_anomaly_alert", "dos_attack_l4", "dos_attack_l7", "expiring_service_token_alert", "failing_logpush_job_disabled_alert", "fbm_auto_advertisement", "fbm_dosd_attack", "fbm_volumetric_attack", "health_check_status_notification", "hostname_aop_custom_certificate_expiration_type", "http_alert_edge_error", "http_alert_origin_error", "image_notification", "image_resizing_notification", "incident_alert", "load_balancing_health_alert", "load_balancing_pool_enablement_alert", "logo_match_alert", "magic_tunnel_health_check_event", "magic_wan_tunnel_health", "maintenance_event_notification", "mtls_certificate_store_certificate_expiration_type", "pages_event_alert", "radar_notification", "real_origin_monitoring", "scriptmonitor_alert_new_code_change_detections", "scriptmonitor_alert_new_hosts", "scriptmonitor_alert_new_malicious_hosts", "scriptmonitor_alert_new_malicious_scripts", "scriptmonitor_alert_new_malicious_url", "scriptmonitor_alert_new_max_length_resource_url", "scriptmonitor_alert_new_resources", "secondary_dns_all_primaries_failing", "secondary_dns_primaries_failing", "secondary_dns_warning", "secondary_dns_zone_successfully_updated", "secondary_dns_zone_validation_warning", "security_insights_alert", "sentinel_alert", "stream_live_notifications", "synthetic_test_latency_alert", "synthetic_test_low_availability_alert", "traffic_anomalies_alert", "tunnel_health_event", "tunnel_update_event", "universal_ssl_event_type", "web_analytics_metrics_update", "zone_aop_custom_certificate_expiration_type")),
  created: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  filters: Schema.optional(Schema.Struct({
  actions: Schema.optional(Schema.Array(Schema.String)),
  affected_asns: Schema.optional(Schema.Array(Schema.String)),
  affected_components: Schema.optional(Schema.Array(Schema.String)),
  affected_locations: Schema.optional(Schema.Array(Schema.String)),
  airport_code: Schema.optional(Schema.Array(Schema.String)),
  alert_trigger_preferences: Schema.optional(Schema.Array(Schema.String)),
  alert_trigger_preferences_value: Schema.optional(Schema.Array(Schema.String)),
  enabled: Schema.optional(Schema.Array(Schema.String)),
  environment: Schema.optional(Schema.Array(Schema.String)),
  event: Schema.optional(Schema.Array(Schema.String)),
  event_source: Schema.optional(Schema.Array(Schema.String)),
  event_type: Schema.optional(Schema.Array(Schema.String)),
  group_by: Schema.optional(Schema.Array(Schema.String)),
  health_check_id: Schema.optional(Schema.Array(Schema.String)),
  incident_impact: Schema.optional(Schema.Array(Schema.Literal("INCIDENT_IMPACT_NONE", "INCIDENT_IMPACT_MINOR", "INCIDENT_IMPACT_MAJOR", "INCIDENT_IMPACT_CRITICAL"))),
  input_id: Schema.optional(Schema.Array(Schema.String)),
  insight_class: Schema.optional(Schema.Array(Schema.String)),
  limit: Schema.optional(Schema.Array(Schema.String)),
  logo_tag: Schema.optional(Schema.Array(Schema.String)),
  megabits_per_second: Schema.optional(Schema.Array(Schema.String)),
  new_health: Schema.optional(Schema.Array(Schema.String)),
  new_status: Schema.optional(Schema.Array(Schema.String)),
  packets_per_second: Schema.optional(Schema.Array(Schema.String)),
  pool_id: Schema.optional(Schema.Array(Schema.String)),
  pop_names: Schema.optional(Schema.Array(Schema.String)),
  product: Schema.optional(Schema.Array(Schema.String)),
  project_id: Schema.optional(Schema.Array(Schema.String)),
  protocol: Schema.optional(Schema.Array(Schema.String)),
  query_tag: Schema.optional(Schema.Array(Schema.String)),
  requests_per_second: Schema.optional(Schema.Array(Schema.String)),
  selectors: Schema.optional(Schema.Array(Schema.String)),
  services: Schema.optional(Schema.Array(Schema.String)),
  slo: Schema.optional(Schema.Array(Schema.String)),
  status: Schema.optional(Schema.Array(Schema.String)),
  target_hostname: Schema.optional(Schema.Array(Schema.String)),
  target_ip: Schema.optional(Schema.Array(Schema.String)),
  target_zone_name: Schema.optional(Schema.Array(Schema.String)),
  traffic_exclusions: Schema.optional(Schema.Array(Schema.Literal("security_events"))),
  tunnel_id: Schema.optional(Schema.Array(Schema.String)),
  tunnel_name: Schema.optional(Schema.Array(Schema.String)),
  type: Schema.optional(Schema.Array(Schema.String)),
  where: Schema.optional(Schema.Array(Schema.String)),
  zones: Schema.optional(Schema.Array(Schema.String))
})),
  id: Schema.optional(Schema.String),
  mechanisms: Schema.optional(Schema.Struct({
  email: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String)
}))),
  pagerduty: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String)
}))),
  webhooks: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String)
})))
})),
  modified: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListNotificationPoliciesResponse" }) as unknown as Schema.Schema<ListNotificationPoliciesResponse>;

export const listNotificationPolicies: (
  input: ListNotificationPoliciesRequest
) => Effect.Effect<
  ListNotificationPoliciesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListNotificationPoliciesRequest,
  output: ListNotificationPoliciesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateANotificationPolicyRequest {
  account_id: string;
  body: unknown;
}

export const CreateANotificationPolicyRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/alerting/v3/policies" }),
).annotations({ identifier: "CreateANotificationPolicyRequest" }) as unknown as Schema.Schema<CreateANotificationPolicyRequest>;

export interface CreateANotificationPolicyResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateANotificationPolicyResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateANotificationPolicyResponse" }) as unknown as Schema.Schema<CreateANotificationPolicyResponse>;

export const createANotificationPolicy: (
  input: CreateANotificationPolicyRequest
) => Effect.Effect<
  CreateANotificationPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateANotificationPolicyRequest,
  output: CreateANotificationPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetANotificationPolicyRequest {
  account_id: string;
  policy_id: string;
}

export const GetANotificationPolicyRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  policy_id: Schema.String.pipe(T.HttpPath("policy_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/alerting/v3/policies/{policy_id}" }),
).annotations({ identifier: "GetANotificationPolicyRequest" }) as unknown as Schema.Schema<GetANotificationPolicyRequest>;

export interface GetANotificationPolicyResponse {
  result: { alert_interval?: string; alert_type?: "abuse_report_alert" | "access_custom_certificate_expiration_type" | "advanced_ddos_attack_l4_alert" | "advanced_ddos_attack_l7_alert" | "advanced_http_alert_error" | "bgp_hijack_notification" | "billing_usage_alert" | "block_notification_block_removed" | "block_notification_new_block" | "block_notification_review_rejected" | "bot_traffic_basic_alert" | "brand_protection_alert" | "brand_protection_digest" | "clickhouse_alert_fw_anomaly" | "clickhouse_alert_fw_ent_anomaly" | "cloudforce_one_request_notification" | "custom_analytics" | "custom_bot_detection_alert" | "custom_ssl_certificate_event_type" | "dedicated_ssl_certificate_event_type" | "device_connectivity_anomaly_alert" | "dos_attack_l4" | "dos_attack_l7" | "expiring_service_token_alert" | "failing_logpush_job_disabled_alert" | "fbm_auto_advertisement" | "fbm_dosd_attack" | "fbm_volumetric_attack" | "health_check_status_notification" | "hostname_aop_custom_certificate_expiration_type" | "http_alert_edge_error" | "http_alert_origin_error" | "image_notification" | "image_resizing_notification" | "incident_alert" | "load_balancing_health_alert" | "load_balancing_pool_enablement_alert" | "logo_match_alert" | "magic_tunnel_health_check_event" | "magic_wan_tunnel_health" | "maintenance_event_notification" | "mtls_certificate_store_certificate_expiration_type" | "pages_event_alert" | "radar_notification" | "real_origin_monitoring" | "scriptmonitor_alert_new_code_change_detections" | "scriptmonitor_alert_new_hosts" | "scriptmonitor_alert_new_malicious_hosts" | "scriptmonitor_alert_new_malicious_scripts" | "scriptmonitor_alert_new_malicious_url" | "scriptmonitor_alert_new_max_length_resource_url" | "scriptmonitor_alert_new_resources" | "secondary_dns_all_primaries_failing" | "secondary_dns_primaries_failing" | "secondary_dns_warning" | "secondary_dns_zone_successfully_updated" | "secondary_dns_zone_validation_warning" | "security_insights_alert" | "sentinel_alert" | "stream_live_notifications" | "synthetic_test_latency_alert" | "synthetic_test_low_availability_alert" | "traffic_anomalies_alert" | "tunnel_health_event" | "tunnel_update_event" | "universal_ssl_event_type" | "web_analytics_metrics_update" | "zone_aop_custom_certificate_expiration_type"; created?: string; description?: string; enabled?: boolean; filters?: { actions?: string[]; affected_asns?: string[]; affected_components?: string[]; affected_locations?: string[]; airport_code?: string[]; alert_trigger_preferences?: string[]; alert_trigger_preferences_value?: string[]; enabled?: string[]; environment?: string[]; event?: string[]; event_source?: string[]; event_type?: string[]; group_by?: string[]; health_check_id?: string[]; incident_impact?: "INCIDENT_IMPACT_NONE" | "INCIDENT_IMPACT_MINOR" | "INCIDENT_IMPACT_MAJOR" | "INCIDENT_IMPACT_CRITICAL"[]; input_id?: string[]; insight_class?: string[]; limit?: string[]; logo_tag?: string[]; megabits_per_second?: string[]; new_health?: string[]; new_status?: string[]; packets_per_second?: string[]; pool_id?: string[]; pop_names?: string[]; product?: string[]; project_id?: string[]; protocol?: string[]; query_tag?: string[]; requests_per_second?: string[]; selectors?: string[]; services?: string[]; slo?: string[]; status?: string[]; target_hostname?: string[]; target_ip?: string[]; target_zone_name?: string[]; traffic_exclusions?: "security_events"[]; tunnel_id?: string[]; tunnel_name?: string[]; type?: string[]; where?: string[]; zones?: string[] }; id?: string; mechanisms?: { email?: { id?: string }[]; pagerduty?: { id?: string }[]; webhooks?: { id?: string }[] }; modified?: string; name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetANotificationPolicyResponse = Schema.Struct({
  result: Schema.Struct({
  alert_interval: Schema.optional(Schema.String),
  alert_type: Schema.optional(Schema.Literal("abuse_report_alert", "access_custom_certificate_expiration_type", "advanced_ddos_attack_l4_alert", "advanced_ddos_attack_l7_alert", "advanced_http_alert_error", "bgp_hijack_notification", "billing_usage_alert", "block_notification_block_removed", "block_notification_new_block", "block_notification_review_rejected", "bot_traffic_basic_alert", "brand_protection_alert", "brand_protection_digest", "clickhouse_alert_fw_anomaly", "clickhouse_alert_fw_ent_anomaly", "cloudforce_one_request_notification", "custom_analytics", "custom_bot_detection_alert", "custom_ssl_certificate_event_type", "dedicated_ssl_certificate_event_type", "device_connectivity_anomaly_alert", "dos_attack_l4", "dos_attack_l7", "expiring_service_token_alert", "failing_logpush_job_disabled_alert", "fbm_auto_advertisement", "fbm_dosd_attack", "fbm_volumetric_attack", "health_check_status_notification", "hostname_aop_custom_certificate_expiration_type", "http_alert_edge_error", "http_alert_origin_error", "image_notification", "image_resizing_notification", "incident_alert", "load_balancing_health_alert", "load_balancing_pool_enablement_alert", "logo_match_alert", "magic_tunnel_health_check_event", "magic_wan_tunnel_health", "maintenance_event_notification", "mtls_certificate_store_certificate_expiration_type", "pages_event_alert", "radar_notification", "real_origin_monitoring", "scriptmonitor_alert_new_code_change_detections", "scriptmonitor_alert_new_hosts", "scriptmonitor_alert_new_malicious_hosts", "scriptmonitor_alert_new_malicious_scripts", "scriptmonitor_alert_new_malicious_url", "scriptmonitor_alert_new_max_length_resource_url", "scriptmonitor_alert_new_resources", "secondary_dns_all_primaries_failing", "secondary_dns_primaries_failing", "secondary_dns_warning", "secondary_dns_zone_successfully_updated", "secondary_dns_zone_validation_warning", "security_insights_alert", "sentinel_alert", "stream_live_notifications", "synthetic_test_latency_alert", "synthetic_test_low_availability_alert", "traffic_anomalies_alert", "tunnel_health_event", "tunnel_update_event", "universal_ssl_event_type", "web_analytics_metrics_update", "zone_aop_custom_certificate_expiration_type")),
  created: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  filters: Schema.optional(Schema.Struct({
  actions: Schema.optional(Schema.Array(Schema.String)),
  affected_asns: Schema.optional(Schema.Array(Schema.String)),
  affected_components: Schema.optional(Schema.Array(Schema.String)),
  affected_locations: Schema.optional(Schema.Array(Schema.String)),
  airport_code: Schema.optional(Schema.Array(Schema.String)),
  alert_trigger_preferences: Schema.optional(Schema.Array(Schema.String)),
  alert_trigger_preferences_value: Schema.optional(Schema.Array(Schema.String)),
  enabled: Schema.optional(Schema.Array(Schema.String)),
  environment: Schema.optional(Schema.Array(Schema.String)),
  event: Schema.optional(Schema.Array(Schema.String)),
  event_source: Schema.optional(Schema.Array(Schema.String)),
  event_type: Schema.optional(Schema.Array(Schema.String)),
  group_by: Schema.optional(Schema.Array(Schema.String)),
  health_check_id: Schema.optional(Schema.Array(Schema.String)),
  incident_impact: Schema.optional(Schema.Array(Schema.Literal("INCIDENT_IMPACT_NONE", "INCIDENT_IMPACT_MINOR", "INCIDENT_IMPACT_MAJOR", "INCIDENT_IMPACT_CRITICAL"))),
  input_id: Schema.optional(Schema.Array(Schema.String)),
  insight_class: Schema.optional(Schema.Array(Schema.String)),
  limit: Schema.optional(Schema.Array(Schema.String)),
  logo_tag: Schema.optional(Schema.Array(Schema.String)),
  megabits_per_second: Schema.optional(Schema.Array(Schema.String)),
  new_health: Schema.optional(Schema.Array(Schema.String)),
  new_status: Schema.optional(Schema.Array(Schema.String)),
  packets_per_second: Schema.optional(Schema.Array(Schema.String)),
  pool_id: Schema.optional(Schema.Array(Schema.String)),
  pop_names: Schema.optional(Schema.Array(Schema.String)),
  product: Schema.optional(Schema.Array(Schema.String)),
  project_id: Schema.optional(Schema.Array(Schema.String)),
  protocol: Schema.optional(Schema.Array(Schema.String)),
  query_tag: Schema.optional(Schema.Array(Schema.String)),
  requests_per_second: Schema.optional(Schema.Array(Schema.String)),
  selectors: Schema.optional(Schema.Array(Schema.String)),
  services: Schema.optional(Schema.Array(Schema.String)),
  slo: Schema.optional(Schema.Array(Schema.String)),
  status: Schema.optional(Schema.Array(Schema.String)),
  target_hostname: Schema.optional(Schema.Array(Schema.String)),
  target_ip: Schema.optional(Schema.Array(Schema.String)),
  target_zone_name: Schema.optional(Schema.Array(Schema.String)),
  traffic_exclusions: Schema.optional(Schema.Array(Schema.Literal("security_events"))),
  tunnel_id: Schema.optional(Schema.Array(Schema.String)),
  tunnel_name: Schema.optional(Schema.Array(Schema.String)),
  type: Schema.optional(Schema.Array(Schema.String)),
  where: Schema.optional(Schema.Array(Schema.String)),
  zones: Schema.optional(Schema.Array(Schema.String))
})),
  id: Schema.optional(Schema.String),
  mechanisms: Schema.optional(Schema.Struct({
  email: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String)
}))),
  pagerduty: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String)
}))),
  webhooks: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String)
})))
})),
  modified: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetANotificationPolicyResponse" }) as unknown as Schema.Schema<GetANotificationPolicyResponse>;

export const getANotificationPolicy: (
  input: GetANotificationPolicyRequest
) => Effect.Effect<
  GetANotificationPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetANotificationPolicyRequest,
  output: GetANotificationPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateANotificationPolicyRequest {
  account_id: string;
  policy_id: string;
  body: unknown;
}

export const UpdateANotificationPolicyRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  policy_id: Schema.String.pipe(T.HttpPath("policy_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/alerting/v3/policies/{policy_id}" }),
).annotations({ identifier: "UpdateANotificationPolicyRequest" }) as unknown as Schema.Schema<UpdateANotificationPolicyRequest>;

export interface UpdateANotificationPolicyResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateANotificationPolicyResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateANotificationPolicyResponse" }) as unknown as Schema.Schema<UpdateANotificationPolicyResponse>;

export const updateANotificationPolicy: (
  input: UpdateANotificationPolicyRequest
) => Effect.Effect<
  UpdateANotificationPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateANotificationPolicyRequest,
  output: UpdateANotificationPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteANotificationPolicyRequest {
  account_id: string;
  policy_id: string;
}

export const DeleteANotificationPolicyRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  policy_id: Schema.String.pipe(T.HttpPath("policy_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/alerting/v3/policies/{policy_id}" }),
).annotations({ identifier: "DeleteANotificationPolicyRequest" }) as unknown as Schema.Schema<DeleteANotificationPolicyRequest>;

export interface DeleteANotificationPolicyResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteANotificationPolicyResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteANotificationPolicyResponse" }) as unknown as Schema.Schema<DeleteANotificationPolicyResponse>;

export const deleteANotificationPolicy: (
  input: DeleteANotificationPolicyRequest
) => Effect.Effect<
  DeleteANotificationPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteANotificationPolicyRequest,
  output: DeleteANotificationPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListSilencesRequest {
  account_id: string;
}

export const ListSilencesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/alerting/v3/silences" }),
).annotations({ identifier: "ListSilencesRequest" }) as unknown as Schema.Schema<ListSilencesRequest>;

export interface ListSilencesResponse {
  result: { created_at?: string; end_time?: string; id?: string; policy_id?: string; start_time?: string; updated_at?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListSilencesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.String),
  end_time: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  policy_id: Schema.optional(Schema.String),
  start_time: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListSilencesResponse" }) as unknown as Schema.Schema<ListSilencesResponse>;

export const listSilences: (
  input: ListSilencesRequest
) => Effect.Effect<
  ListSilencesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListSilencesRequest,
  output: ListSilencesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateSilencesRequest {
  account_id: string;
  body: { end_time?: string; policy_id?: string; start_time?: string }[];
}

export const CreateSilencesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Struct({
  end_time: Schema.optional(Schema.String),
  policy_id: Schema.optional(Schema.String),
  start_time: Schema.optional(Schema.String)
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/alerting/v3/silences" }),
).annotations({ identifier: "CreateSilencesRequest" }) as unknown as Schema.Schema<CreateSilencesRequest>;

export interface CreateSilencesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateSilencesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateSilencesResponse" }) as unknown as Schema.Schema<CreateSilencesResponse>;

export const createSilences: (
  input: CreateSilencesRequest
) => Effect.Effect<
  CreateSilencesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateSilencesRequest,
  output: CreateSilencesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateSilencesRequest {
  account_id: string;
  body: { end_time?: string; id?: string; start_time?: string }[];
}

export const UpdateSilencesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Struct({
  end_time: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  start_time: Schema.optional(Schema.String)
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/alerting/v3/silences" }),
).annotations({ identifier: "UpdateSilencesRequest" }) as unknown as Schema.Schema<UpdateSilencesRequest>;

export interface UpdateSilencesResponse {
  result: { created_at?: string; end_time?: string; id?: string; policy_id?: string; start_time?: string; updated_at?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateSilencesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.String),
  end_time: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  policy_id: Schema.optional(Schema.String),
  start_time: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateSilencesResponse" }) as unknown as Schema.Schema<UpdateSilencesResponse>;

export const updateSilences: (
  input: UpdateSilencesRequest
) => Effect.Effect<
  UpdateSilencesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateSilencesRequest,
  output: UpdateSilencesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSilenceRequest {
  account_id: string;
  silence_id: string;
}

export const GetSilenceRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  silence_id: Schema.String.pipe(T.HttpPath("silence_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/alerting/v3/silences/{silence_id}" }),
).annotations({ identifier: "GetSilenceRequest" }) as unknown as Schema.Schema<GetSilenceRequest>;

export interface GetSilenceResponse {
  result: { created_at?: string; end_time?: string; id?: string; policy_id?: string; start_time?: string; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSilenceResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.optional(Schema.String),
  end_time: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  policy_id: Schema.optional(Schema.String),
  start_time: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSilenceResponse" }) as unknown as Schema.Schema<GetSilenceResponse>;

export const getSilence: (
  input: GetSilenceRequest
) => Effect.Effect<
  GetSilenceResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSilenceRequest,
  output: GetSilenceResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteSilencesRequest {
  account_id: string;
  silence_id: string;
}

export const DeleteSilencesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  silence_id: Schema.String.pipe(T.HttpPath("silence_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/alerting/v3/silences/{silence_id}" }),
).annotations({ identifier: "DeleteSilencesRequest" }) as unknown as Schema.Schema<DeleteSilencesRequest>;

export interface DeleteSilencesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteSilencesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteSilencesResponse" }) as unknown as Schema.Schema<DeleteSilencesResponse>;

export const deleteSilences: (
  input: DeleteSilencesRequest
) => Effect.Effect<
  DeleteSilencesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteSilencesRequest,
  output: DeleteSilencesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountAuditLogsRequest {
  account_id: string;
  id?: string;
  export?: boolean;
  "action.type"?: string;
  "actor.ip"?: string;
  "actor.email"?: string;
  since?: unknown;
  before?: unknown;
  "zone.name"?: string;
  direction?: "desc" | "asc";
  per_page?: number;
  page?: number;
  hide_user_logs?: boolean;
}

export const GetAccountAuditLogsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.optional(Schema.String).pipe(T.HttpQuery("id")),
  export: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("export")),
  "action.type": Schema.optional(Schema.String).pipe(T.HttpQuery("action.type")),
  "actor.ip": Schema.optional(Schema.String).pipe(T.HttpQuery("actor.ip")),
  "actor.email": Schema.optional(Schema.String).pipe(T.HttpQuery("actor.email")),
  since: Schema.optional(Schema.Union(Schema.Date, Schema.Date)).pipe(T.HttpQuery("since")),
  before: Schema.optional(Schema.Union(Schema.Date, Schema.Date)).pipe(T.HttpQuery("before")),
  "zone.name": Schema.optional(Schema.String).pipe(T.HttpQuery("zone.name")),
  direction: Schema.optional(Schema.Literal("desc", "asc")).pipe(T.HttpQuery("direction")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  hide_user_logs: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("hide_user_logs"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/audit_logs" }),
).annotations({ identifier: "GetAccountAuditLogsRequest" }) as unknown as Schema.Schema<GetAccountAuditLogsRequest>;

export interface GetAccountAuditLogsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountAuditLogsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountAuditLogsResponse" }) as unknown as Schema.Schema<GetAccountAuditLogsResponse>;

export const getAccountAuditLogs: (
  input: GetAccountAuditLogsRequest
) => Effect.Effect<
  GetAccountAuditLogsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountAuditLogsRequest,
  output: GetAccountAuditLogsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AutoragConfigAiSearchRequest {
  id: string;
  account_id: string;
  body: { filters?: unknown; max_num_results?: number; model?: unknown; query: string; ranking_options?: { ranker?: string; score_threshold?: number }; reranking?: { enabled?: boolean; model?: unknown }; rewrite_query?: boolean; stream?: boolean; system_prompt?: string };
}

export const AutoragConfigAiSearchRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  filters: Schema.optional(Schema.Union(Schema.Struct({
  key: Schema.String,
  type: Schema.Literal("eq", "ne", "gt", "gte", "lt", "lte"),
  value: Schema.Union(Schema.String, Schema.Number, Schema.Boolean)
}), Schema.Struct({
  filters: Schema.Array(Schema.Struct({
  key: Schema.String,
  type: Schema.Literal("eq", "ne", "gt", "gte", "lt", "lte"),
  value: Schema.Union(Schema.String, Schema.Number, Schema.Boolean)
})),
  type: Schema.Literal("and", "or")
}))),
  max_num_results: Schema.optional(Schema.Number),
  model: Schema.optional(Schema.Union(Schema.Literal("@cf/meta/llama-3.3-70b-instruct-fp8-fast", "@cf/meta/llama-3.1-8b-instruct-fast", "@cf/meta/llama-3.1-8b-instruct-fp8", "@cf/meta/llama-4-scout-17b-16e-instruct", "@cf/qwen/qwen3-30b-a3b-fp8", "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b", "@cf/moonshotai/kimi-k2-instruct", "anthropic/claude-3-7-sonnet", "anthropic/claude-sonnet-4", "anthropic/claude-opus-4", "anthropic/claude-3-5-haiku", "cerebras/qwen-3-235b-a22b-instruct", "cerebras/qwen-3-235b-a22b-thinking", "cerebras/llama-3.3-70b", "cerebras/llama-4-maverick-17b-128e-instruct", "cerebras/llama-4-scout-17b-16e-instruct", "cerebras/gpt-oss-120b", "google-ai-studio/gemini-2.5-flash", "google-ai-studio/gemini-2.5-pro", "grok/grok-4", "groq/llama-3.3-70b-versatile", "groq/llama-3.1-8b-instant", "openai/gpt-5", "openai/gpt-5-mini", "openai/gpt-5-nano"), Schema.Literal(""))),
  query: Schema.String,
  ranking_options: Schema.optional(Schema.Struct({
  ranker: Schema.optional(Schema.String),
  score_threshold: Schema.optional(Schema.Number)
})),
  reranking: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  model: Schema.optional(Schema.Union(Schema.Literal("@cf/baai/bge-reranker-base"), Schema.Literal("")))
})),
  rewrite_query: Schema.optional(Schema.Boolean),
  stream: Schema.optional(Schema.Boolean),
  system_prompt: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/autorag/rags/{id}/ai-search" }),
).annotations({ identifier: "AutoragConfigAiSearchRequest" }) as unknown as Schema.Schema<AutoragConfigAiSearchRequest>;

export interface AutoragConfigAiSearchResponse {
  result: { data?: { attributes?: Record<string, unknown>; content?: { text?: string; type?: string }[]; file_id?: string; filename?: string; score: number }[]; has_more?: boolean; next_page?: string; object?: string; response: string; search_query: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AutoragConfigAiSearchResponse = Schema.Struct({
  result: Schema.Struct({
  data: Schema.optional(Schema.Array(Schema.Struct({
  attributes: Schema.optional(Schema.Struct({})),
  content: Schema.optional(Schema.Array(Schema.Struct({
  text: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String)
}))),
  file_id: Schema.optional(Schema.String),
  filename: Schema.optional(Schema.String),
  score: Schema.Number
}))),
  has_more: Schema.optional(Schema.Boolean),
  next_page: Schema.optional(Schema.String),
  object: Schema.optional(Schema.String),
  response: Schema.String,
  search_query: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AutoragConfigAiSearchResponse" }) as unknown as Schema.Schema<AutoragConfigAiSearchResponse>;

export const autoragConfigAiSearch: (
  input: AutoragConfigAiSearchRequest
) => Effect.Effect<
  AutoragConfigAiSearchResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AutoragConfigAiSearchRequest,
  output: AutoragConfigAiSearchResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AutoragConfigFilesRequest {
  id: string;
  account_id: string;
  page?: number;
  per_page?: number;
  search?: string;
  status?: "completed" | "queued" | "running" | "error";
}

export const AutoragConfigFilesRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
  status: Schema.optional(Schema.Literal("completed", "queued", "running", "error")).pipe(T.HttpQuery("status"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/autorag/rags/{id}/files" }),
).annotations({ identifier: "AutoragConfigFilesRequest" }) as unknown as Schema.Schema<AutoragConfigFilesRequest>;

export interface AutoragConfigFilesResponse {
  result: { error: string; key: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AutoragConfigFilesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  error: Schema.String,
  key: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AutoragConfigFilesResponse" }) as unknown as Schema.Schema<AutoragConfigFilesResponse>;

export const autoragConfigFiles: (
  input: AutoragConfigFilesRequest
) => Effect.Effect<
  AutoragConfigFilesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AutoragConfigFilesRequest,
  output: AutoragConfigFilesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListJobs1Request {
  id: string;
  account_id: string;
  page?: number;
  per_page?: number;
}

export const ListJobs1Request = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/autorag/rags/{id}/jobs" }),
).annotations({ identifier: "ListJobs1Request" }) as unknown as Schema.Schema<ListJobs1Request>;

export interface ListJobs1Response {
  result: { end_reason?: string; ended_at?: string; id: string; last_seen_at?: string; source: "user" | "schedule"; started_at?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListJobs1Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  end_reason: Schema.optional(Schema.String),
  ended_at: Schema.optional(Schema.String),
  id: Schema.String,
  last_seen_at: Schema.optional(Schema.String),
  source: Schema.Literal("user", "schedule"),
  started_at: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListJobs1Response" }) as unknown as Schema.Schema<ListJobs1Response>;

export const listJobs1: (
  input: ListJobs1Request
) => Effect.Effect<
  ListJobs1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListJobs1Request,
  output: ListJobs1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetJob1Request {
  id: string;
  job_id: string;
  account_id: string;
}

export const GetJob1Request = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  job_id: Schema.String.pipe(T.HttpPath("job_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/autorag/rags/{id}/jobs/{job_id}" }),
).annotations({ identifier: "GetJob1Request" }) as unknown as Schema.Schema<GetJob1Request>;

export interface GetJob1Response {
  result: { end_reason?: string; ended_at?: string; id: string; last_seen_at?: string; source: "user" | "schedule"; started_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetJob1Response = Schema.Struct({
  result: Schema.Struct({
  end_reason: Schema.optional(Schema.String),
  ended_at: Schema.optional(Schema.String),
  id: Schema.String,
  last_seen_at: Schema.optional(Schema.String),
  source: Schema.Literal("user", "schedule"),
  started_at: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetJob1Response" }) as unknown as Schema.Schema<GetJob1Response>;

export const getJob1: (
  input: GetJob1Request
) => Effect.Effect<
  GetJob1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetJob1Request,
  output: GetJob1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListJobLogs1Request {
  id: string;
  job_id: string;
  account_id: string;
  page?: number;
  per_page?: number;
}

export const ListJobLogs1Request = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  job_id: Schema.String.pipe(T.HttpPath("job_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/autorag/rags/{id}/jobs/{job_id}/logs" }),
).annotations({ identifier: "ListJobLogs1Request" }) as unknown as Schema.Schema<ListJobLogs1Request>;

export interface ListJobLogs1Response {
  result: { created_at: number; id: number; message: string; message_type: number }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListJobLogs1Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.Number,
  id: Schema.Number,
  message: Schema.String,
  message_type: Schema.Number
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListJobLogs1Response" }) as unknown as Schema.Schema<ListJobLogs1Response>;

export const listJobLogs1: (
  input: ListJobLogs1Request
) => Effect.Effect<
  ListJobLogs1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListJobLogs1Request,
  output: ListJobLogs1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AutoragConfigSearchRequest {
  id: string;
  account_id: string;
  body: { filters?: unknown; max_num_results?: number; query: string; ranking_options?: { ranker?: string; score_threshold?: number }; reranking?: { enabled?: boolean; model?: unknown }; rewrite_query?: boolean };
}

export const AutoragConfigSearchRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  filters: Schema.optional(Schema.Union(Schema.Struct({
  key: Schema.String,
  type: Schema.Literal("eq", "ne", "gt", "gte", "lt", "lte"),
  value: Schema.Union(Schema.String, Schema.Number, Schema.Boolean)
}), Schema.Struct({
  filters: Schema.Array(Schema.Struct({
  key: Schema.String,
  type: Schema.Literal("eq", "ne", "gt", "gte", "lt", "lte"),
  value: Schema.Union(Schema.String, Schema.Number, Schema.Boolean)
})),
  type: Schema.Literal("and", "or")
}))),
  max_num_results: Schema.optional(Schema.Number),
  query: Schema.String,
  ranking_options: Schema.optional(Schema.Struct({
  ranker: Schema.optional(Schema.String),
  score_threshold: Schema.optional(Schema.Number)
})),
  reranking: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  model: Schema.optional(Schema.Union(Schema.Literal("@cf/baai/bge-reranker-base"), Schema.Literal("")))
})),
  rewrite_query: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/autorag/rags/{id}/search" }),
).annotations({ identifier: "AutoragConfigSearchRequest" }) as unknown as Schema.Schema<AutoragConfigSearchRequest>;

export interface AutoragConfigSearchResponse {
  result: { data?: { attributes?: Record<string, unknown>; content?: { text?: string; type?: string }[]; file_id?: string; filename?: string; score: number }[]; has_more?: boolean; next_page?: string; object?: string; search_query: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AutoragConfigSearchResponse = Schema.Struct({
  result: Schema.Struct({
  data: Schema.optional(Schema.Array(Schema.Struct({
  attributes: Schema.optional(Schema.Struct({})),
  content: Schema.optional(Schema.Array(Schema.Struct({
  text: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String)
}))),
  file_id: Schema.optional(Schema.String),
  filename: Schema.optional(Schema.String),
  score: Schema.Number
}))),
  has_more: Schema.optional(Schema.Boolean),
  next_page: Schema.optional(Schema.String),
  object: Schema.optional(Schema.String),
  search_query: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AutoragConfigSearchResponse" }) as unknown as Schema.Schema<AutoragConfigSearchResponse>;

export const autoragConfigSearch: (
  input: AutoragConfigSearchRequest
) => Effect.Effect<
  AutoragConfigSearchResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AutoragConfigSearchRequest,
  output: AutoragConfigSearchResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AutoragConfigSyncRequest {
  id: string;
  account_id: string;
}

export const AutoragConfigSyncRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/autorag/rags/{id}/sync" }),
).annotations({ identifier: "AutoragConfigSyncRequest" }) as unknown as Schema.Schema<AutoragConfigSyncRequest>;

export interface AutoragConfigSyncResponse {
  result: { job_id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AutoragConfigSyncResponse = Schema.Struct({
  result: Schema.Struct({
  job_id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AutoragConfigSyncResponse" }) as unknown as Schema.Schema<AutoragConfigSyncResponse>;

export const autoragConfigSync: (
  input: AutoragConfigSyncRequest
) => Effect.Effect<
  AutoragConfigSyncResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AutoragConfigSyncRequest,
  output: AutoragConfigSyncResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountBillingProfileDeprecatedBillingProfileDetailsRequest {
  account_id: string;
}

export const AccountBillingProfileDeprecatedBillingProfileDetailsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/billing/profile" }),
).annotations({ identifier: "AccountBillingProfileDeprecatedBillingProfileDetailsRequest" }) as unknown as Schema.Schema<AccountBillingProfileDeprecatedBillingProfileDetailsRequest>;

export interface AccountBillingProfileDeprecatedBillingProfileDetailsResponse {
  result: { account_type?: string; address?: string; address2?: string; balance?: string; card_expiry_month?: number; card_expiry_year?: number; card_number?: string; city?: string; company?: string; country?: string; created_on?: string; device_data?: string; edited_on?: string; enterprise_billing_email?: string; enterprise_primary_email?: string; first_name?: string; id?: string; is_partner?: boolean; last_name?: string; next_bill_date?: string; payment_address?: string; payment_address2?: string; payment_city?: string; payment_country?: string; payment_email?: string; payment_first_name?: string; payment_gateway?: string; payment_last_name?: string; payment_nonce?: string; payment_state?: string; payment_zipcode?: string; primary_email?: string; state?: string; tax_id_type?: string; telephone?: string; use_legacy?: boolean; validation_code?: string; vat?: string; zipcode?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountBillingProfileDeprecatedBillingProfileDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  account_type: Schema.optional(Schema.String),
  address: Schema.optional(Schema.String),
  address2: Schema.optional(Schema.String),
  balance: Schema.optional(Schema.String),
  card_expiry_month: Schema.optional(Schema.Number),
  card_expiry_year: Schema.optional(Schema.Number),
  card_number: Schema.optional(Schema.String),
  city: Schema.optional(Schema.String),
  company: Schema.optional(Schema.String),
  country: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  device_data: Schema.optional(Schema.String),
  edited_on: Schema.optional(Schema.Date),
  enterprise_billing_email: Schema.optional(Schema.String),
  enterprise_primary_email: Schema.optional(Schema.String),
  first_name: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  is_partner: Schema.optional(Schema.Boolean),
  last_name: Schema.optional(Schema.String),
  next_bill_date: Schema.optional(Schema.Date),
  payment_address: Schema.optional(Schema.String),
  payment_address2: Schema.optional(Schema.String),
  payment_city: Schema.optional(Schema.String),
  payment_country: Schema.optional(Schema.String),
  payment_email: Schema.optional(Schema.String),
  payment_first_name: Schema.optional(Schema.String),
  payment_gateway: Schema.optional(Schema.String),
  payment_last_name: Schema.optional(Schema.String),
  payment_nonce: Schema.optional(Schema.String),
  payment_state: Schema.optional(Schema.String),
  payment_zipcode: Schema.optional(Schema.String),
  primary_email: Schema.optional(Schema.String),
  state: Schema.optional(Schema.String),
  tax_id_type: Schema.optional(Schema.String),
  telephone: Schema.optional(Schema.String),
  use_legacy: Schema.optional(Schema.Boolean),
  validation_code: Schema.optional(Schema.String),
  vat: Schema.optional(Schema.String),
  zipcode: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountBillingProfileDeprecatedBillingProfileDetailsResponse" }) as unknown as Schema.Schema<AccountBillingProfileDeprecatedBillingProfileDetailsResponse>;

export const accountBillingProfileDeprecatedBillingProfileDetails: (
  input: AccountBillingProfileDeprecatedBillingProfileDetailsRequest
) => Effect.Effect<
  AccountBillingProfileDeprecatedBillingProfileDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountBillingProfileDeprecatedBillingProfileDetailsRequest,
  output: AccountBillingProfileDeprecatedBillingProfileDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDayReportRequest {
  account_id: string;
  asn_id: number;
  date?: string;
}

export const GetDayReportRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  asn_id: Schema.Number.pipe(T.HttpPath("asn_id")),
  date: Schema.optional(Schema.Date).pipe(T.HttpQuery("date"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/botnet_feed/asn/{asn_id}/day_report" }),
).annotations({ identifier: "GetDayReportRequest" }) as unknown as Schema.Schema<GetDayReportRequest>;

export interface GetDayReportResponse {
  result: { cidr?: string; date?: string; offense_count?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDayReportResponse = Schema.Struct({
  result: Schema.Struct({
  cidr: Schema.optional(Schema.String),
  date: Schema.optional(Schema.Date),
  offense_count: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDayReportResponse" }) as unknown as Schema.Schema<GetDayReportResponse>;

export const getDayReport: (
  input: GetDayReportRequest
) => Effect.Effect<
  GetDayReportResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDayReportRequest,
  output: GetDayReportResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetFullReportRequest {
  account_id: string;
  asn_id: number;
}

export const GetFullReportRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  asn_id: Schema.Number.pipe(T.HttpPath("asn_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/botnet_feed/asn/{asn_id}/full_report" }),
).annotations({ identifier: "GetFullReportRequest" }) as unknown as Schema.Schema<GetFullReportRequest>;

export interface GetFullReportResponse {
  result: { cidr?: string; date?: string; offense_count?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetFullReportResponse = Schema.Struct({
  result: Schema.Struct({
  cidr: Schema.optional(Schema.String),
  date: Schema.optional(Schema.Date),
  offense_count: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetFullReportResponse" }) as unknown as Schema.Schema<GetFullReportResponse>;

export const getFullReport: (
  input: GetFullReportRequest
) => Effect.Effect<
  GetFullReportResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetFullReportRequest,
  output: GetFullReportResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAsnRequest {
  account_id: string;
}

export const ListAsnRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/botnet_feed/configs/asn" }),
).annotations({ identifier: "ListAsnRequest" }) as unknown as Schema.Schema<ListAsnRequest>;

export interface ListAsnResponse {
  result: { asn?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAsnResponse = Schema.Struct({
  result: Schema.Struct({
  asn: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAsnResponse" }) as unknown as Schema.Schema<ListAsnResponse>;

export const listAsn: (
  input: ListAsnRequest
) => Effect.Effect<
  ListAsnResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAsnRequest,
  output: ListAsnResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAsnRequest {
  account_id: string;
  asn_id: number;
}

export const DeleteAsnRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  asn_id: Schema.Number.pipe(T.HttpPath("asn_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/botnet_feed/configs/asn/{asn_id}" }),
).annotations({ identifier: "DeleteAsnRequest" }) as unknown as Schema.Schema<DeleteAsnRequest>;

export interface DeleteAsnResponse {
  result: { asn?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAsnResponse = Schema.Struct({
  result: Schema.Struct({
  asn: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAsnResponse" }) as unknown as Schema.Schema<DeleteAsnResponse>;

export const deleteAsn: (
  input: DeleteAsnRequest
) => Effect.Effect<
  DeleteAsnResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAsnRequest,
  output: DeleteAsnResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdBrandProtectionAlertsRequest {
}

export const GetAccountsAccountIdBrandProtectionAlertsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/brand-protection/alerts" }),
).annotations({ identifier: "GetAccountsAccountIdBrandProtectionAlertsRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionAlertsRequest>;

export interface GetAccountsAccountIdBrandProtectionAlertsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdBrandProtectionAlertsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdBrandProtectionAlertsResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionAlertsResponse>;

export const getAccountsAccountIdBrandProtectionAlerts: (
  input: GetAccountsAccountIdBrandProtectionAlertsRequest
) => Effect.Effect<
  GetAccountsAccountIdBrandProtectionAlertsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdBrandProtectionAlertsRequest,
  output: GetAccountsAccountIdBrandProtectionAlertsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchAccountsAccountIdBrandProtectionAlertsRequest {
}

export const PatchAccountsAccountIdBrandProtectionAlertsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/brand-protection/alerts" }),
).annotations({ identifier: "PatchAccountsAccountIdBrandProtectionAlertsRequest" }) as unknown as Schema.Schema<PatchAccountsAccountIdBrandProtectionAlertsRequest>;

export interface PatchAccountsAccountIdBrandProtectionAlertsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchAccountsAccountIdBrandProtectionAlertsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchAccountsAccountIdBrandProtectionAlertsResponse" }) as unknown as Schema.Schema<PatchAccountsAccountIdBrandProtectionAlertsResponse>;

export const patchAccountsAccountIdBrandProtectionAlerts: (
  input: PatchAccountsAccountIdBrandProtectionAlertsRequest
) => Effect.Effect<
  PatchAccountsAccountIdBrandProtectionAlertsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchAccountsAccountIdBrandProtectionAlertsRequest,
  output: PatchAccountsAccountIdBrandProtectionAlertsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchAccountsAccountIdBrandProtectionAlertsClearRequest {
}

export const PatchAccountsAccountIdBrandProtectionAlertsClearRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/brand-protection/alerts/clear" }),
).annotations({ identifier: "PatchAccountsAccountIdBrandProtectionAlertsClearRequest" }) as unknown as Schema.Schema<PatchAccountsAccountIdBrandProtectionAlertsClearRequest>;

export interface PatchAccountsAccountIdBrandProtectionAlertsClearResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchAccountsAccountIdBrandProtectionAlertsClearResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchAccountsAccountIdBrandProtectionAlertsClearResponse" }) as unknown as Schema.Schema<PatchAccountsAccountIdBrandProtectionAlertsClearResponse>;

export const patchAccountsAccountIdBrandProtectionAlertsClear: (
  input: PatchAccountsAccountIdBrandProtectionAlertsClearRequest
) => Effect.Effect<
  PatchAccountsAccountIdBrandProtectionAlertsClearResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchAccountsAccountIdBrandProtectionAlertsClearRequest,
  output: PatchAccountsAccountIdBrandProtectionAlertsClearResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchAccountsAccountIdBrandProtectionAlertsRefuteRequest {
}

export const PatchAccountsAccountIdBrandProtectionAlertsRefuteRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/brand-protection/alerts/refute" }),
).annotations({ identifier: "PatchAccountsAccountIdBrandProtectionAlertsRefuteRequest" }) as unknown as Schema.Schema<PatchAccountsAccountIdBrandProtectionAlertsRefuteRequest>;

export interface PatchAccountsAccountIdBrandProtectionAlertsRefuteResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchAccountsAccountIdBrandProtectionAlertsRefuteResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchAccountsAccountIdBrandProtectionAlertsRefuteResponse" }) as unknown as Schema.Schema<PatchAccountsAccountIdBrandProtectionAlertsRefuteResponse>;

export const patchAccountsAccountIdBrandProtectionAlertsRefute: (
  input: PatchAccountsAccountIdBrandProtectionAlertsRefuteRequest
) => Effect.Effect<
  PatchAccountsAccountIdBrandProtectionAlertsRefuteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchAccountsAccountIdBrandProtectionAlertsRefuteRequest,
  output: PatchAccountsAccountIdBrandProtectionAlertsRefuteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchAccountsAccountIdBrandProtectionAlertsVerifyRequest {
}

export const PatchAccountsAccountIdBrandProtectionAlertsVerifyRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/brand-protection/alerts/verify" }),
).annotations({ identifier: "PatchAccountsAccountIdBrandProtectionAlertsVerifyRequest" }) as unknown as Schema.Schema<PatchAccountsAccountIdBrandProtectionAlertsVerifyRequest>;

export interface PatchAccountsAccountIdBrandProtectionAlertsVerifyResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchAccountsAccountIdBrandProtectionAlertsVerifyResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchAccountsAccountIdBrandProtectionAlertsVerifyResponse" }) as unknown as Schema.Schema<PatchAccountsAccountIdBrandProtectionAlertsVerifyResponse>;

export const patchAccountsAccountIdBrandProtectionAlertsVerify: (
  input: PatchAccountsAccountIdBrandProtectionAlertsVerifyRequest
) => Effect.Effect<
  PatchAccountsAccountIdBrandProtectionAlertsVerifyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchAccountsAccountIdBrandProtectionAlertsVerifyRequest,
  output: PatchAccountsAccountIdBrandProtectionAlertsVerifyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdBrandProtectionBrandsRequest {
}

export const GetAccountsAccountIdBrandProtectionBrandsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/brand-protection/brands" }),
).annotations({ identifier: "GetAccountsAccountIdBrandProtectionBrandsRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionBrandsRequest>;

export interface GetAccountsAccountIdBrandProtectionBrandsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdBrandProtectionBrandsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdBrandProtectionBrandsResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionBrandsResponse>;

export const getAccountsAccountIdBrandProtectionBrands: (
  input: GetAccountsAccountIdBrandProtectionBrandsRequest
) => Effect.Effect<
  GetAccountsAccountIdBrandProtectionBrandsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdBrandProtectionBrandsRequest,
  output: GetAccountsAccountIdBrandProtectionBrandsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostAccountsAccountIdBrandProtectionBrandsRequest {
}

export const PostAccountsAccountIdBrandProtectionBrandsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/brand-protection/brands" }),
).annotations({ identifier: "PostAccountsAccountIdBrandProtectionBrandsRequest" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionBrandsRequest>;

export interface PostAccountsAccountIdBrandProtectionBrandsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostAccountsAccountIdBrandProtectionBrandsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostAccountsAccountIdBrandProtectionBrandsResponse" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionBrandsResponse>;

export const postAccountsAccountIdBrandProtectionBrands: (
  input: PostAccountsAccountIdBrandProtectionBrandsRequest
) => Effect.Effect<
  PostAccountsAccountIdBrandProtectionBrandsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostAccountsAccountIdBrandProtectionBrandsRequest,
  output: PostAccountsAccountIdBrandProtectionBrandsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAccountsAccountIdBrandProtectionBrandsRequest {
}

export const DeleteAccountsAccountIdBrandProtectionBrandsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/brand-protection/brands" }),
).annotations({ identifier: "DeleteAccountsAccountIdBrandProtectionBrandsRequest" }) as unknown as Schema.Schema<DeleteAccountsAccountIdBrandProtectionBrandsRequest>;

export interface DeleteAccountsAccountIdBrandProtectionBrandsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAccountsAccountIdBrandProtectionBrandsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAccountsAccountIdBrandProtectionBrandsResponse" }) as unknown as Schema.Schema<DeleteAccountsAccountIdBrandProtectionBrandsResponse>;

export const deleteAccountsAccountIdBrandProtectionBrands: (
  input: DeleteAccountsAccountIdBrandProtectionBrandsRequest
) => Effect.Effect<
  DeleteAccountsAccountIdBrandProtectionBrandsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccountsAccountIdBrandProtectionBrandsRequest,
  output: DeleteAccountsAccountIdBrandProtectionBrandsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdBrandProtectionBrandsPatternsRequest {
}

export const GetAccountsAccountIdBrandProtectionBrandsPatternsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/brand-protection/brands/patterns" }),
).annotations({ identifier: "GetAccountsAccountIdBrandProtectionBrandsPatternsRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionBrandsPatternsRequest>;

export interface GetAccountsAccountIdBrandProtectionBrandsPatternsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdBrandProtectionBrandsPatternsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdBrandProtectionBrandsPatternsResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionBrandsPatternsResponse>;

export const getAccountsAccountIdBrandProtectionBrandsPatterns: (
  input: GetAccountsAccountIdBrandProtectionBrandsPatternsRequest
) => Effect.Effect<
  GetAccountsAccountIdBrandProtectionBrandsPatternsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdBrandProtectionBrandsPatternsRequest,
  output: GetAccountsAccountIdBrandProtectionBrandsPatternsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostAccountsAccountIdBrandProtectionBrandsPatternsRequest {
}

export const PostAccountsAccountIdBrandProtectionBrandsPatternsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/brand-protection/brands/patterns" }),
).annotations({ identifier: "PostAccountsAccountIdBrandProtectionBrandsPatternsRequest" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionBrandsPatternsRequest>;

export interface PostAccountsAccountIdBrandProtectionBrandsPatternsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostAccountsAccountIdBrandProtectionBrandsPatternsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostAccountsAccountIdBrandProtectionBrandsPatternsResponse" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionBrandsPatternsResponse>;

export const postAccountsAccountIdBrandProtectionBrandsPatterns: (
  input: PostAccountsAccountIdBrandProtectionBrandsPatternsRequest
) => Effect.Effect<
  PostAccountsAccountIdBrandProtectionBrandsPatternsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostAccountsAccountIdBrandProtectionBrandsPatternsRequest,
  output: PostAccountsAccountIdBrandProtectionBrandsPatternsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAccountsAccountIdBrandProtectionBrandsPatternsRequest {
}

export const DeleteAccountsAccountIdBrandProtectionBrandsPatternsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/brand-protection/brands/patterns" }),
).annotations({ identifier: "DeleteAccountsAccountIdBrandProtectionBrandsPatternsRequest" }) as unknown as Schema.Schema<DeleteAccountsAccountIdBrandProtectionBrandsPatternsRequest>;

export interface DeleteAccountsAccountIdBrandProtectionBrandsPatternsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAccountsAccountIdBrandProtectionBrandsPatternsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAccountsAccountIdBrandProtectionBrandsPatternsResponse" }) as unknown as Schema.Schema<DeleteAccountsAccountIdBrandProtectionBrandsPatternsResponse>;

export const deleteAccountsAccountIdBrandProtectionBrandsPatterns: (
  input: DeleteAccountsAccountIdBrandProtectionBrandsPatternsRequest
) => Effect.Effect<
  DeleteAccountsAccountIdBrandProtectionBrandsPatternsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccountsAccountIdBrandProtectionBrandsPatternsRequest,
  output: DeleteAccountsAccountIdBrandProtectionBrandsPatternsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchAccountsAccountIdBrandProtectionClearRequest {
}

export const PatchAccountsAccountIdBrandProtectionClearRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/brand-protection/clear" }),
).annotations({ identifier: "PatchAccountsAccountIdBrandProtectionClearRequest" }) as unknown as Schema.Schema<PatchAccountsAccountIdBrandProtectionClearRequest>;

export interface PatchAccountsAccountIdBrandProtectionClearResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchAccountsAccountIdBrandProtectionClearResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchAccountsAccountIdBrandProtectionClearResponse" }) as unknown as Schema.Schema<PatchAccountsAccountIdBrandProtectionClearResponse>;

export const patchAccountsAccountIdBrandProtectionClear: (
  input: PatchAccountsAccountIdBrandProtectionClearRequest
) => Effect.Effect<
  PatchAccountsAccountIdBrandProtectionClearResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchAccountsAccountIdBrandProtectionClearRequest,
  output: PatchAccountsAccountIdBrandProtectionClearResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdBrandProtectionDomainInfoRequest {
}

export const GetAccountsAccountIdBrandProtectionDomainInfoRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/brand-protection/domain-info" }),
).annotations({ identifier: "GetAccountsAccountIdBrandProtectionDomainInfoRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionDomainInfoRequest>;

export interface GetAccountsAccountIdBrandProtectionDomainInfoResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdBrandProtectionDomainInfoResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdBrandProtectionDomainInfoResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionDomainInfoResponse>;

export const getAccountsAccountIdBrandProtectionDomainInfo: (
  input: GetAccountsAccountIdBrandProtectionDomainInfoRequest
) => Effect.Effect<
  GetAccountsAccountIdBrandProtectionDomainInfoResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdBrandProtectionDomainInfoRequest,
  output: GetAccountsAccountIdBrandProtectionDomainInfoResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdBrandProtectionLogoMatchesRequest {
  logo_id?: string[];
  offset?: string;
  limit?: string;
}

export const GetAccountsAccountIdBrandProtectionLogoMatchesRequest = Schema.Struct({
  logo_id: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("logo_id")),
  offset: Schema.optional(Schema.String).pipe(T.HttpQuery("offset")),
  limit: Schema.optional(Schema.String).pipe(T.HttpQuery("limit"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/brand-protection/logo-matches" }),
).annotations({ identifier: "GetAccountsAccountIdBrandProtectionLogoMatchesRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionLogoMatchesRequest>;

export interface GetAccountsAccountIdBrandProtectionLogoMatchesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdBrandProtectionLogoMatchesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdBrandProtectionLogoMatchesResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionLogoMatchesResponse>;

export const getAccountsAccountIdBrandProtectionLogoMatches: (
  input: GetAccountsAccountIdBrandProtectionLogoMatchesRequest
) => Effect.Effect<
  GetAccountsAccountIdBrandProtectionLogoMatchesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdBrandProtectionLogoMatchesRequest,
  output: GetAccountsAccountIdBrandProtectionLogoMatchesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdBrandProtectionLogoMatchesDownloadRequest {
  logo_id?: string[];
  offset?: string;
  limit?: string;
}

export const GetAccountsAccountIdBrandProtectionLogoMatchesDownloadRequest = Schema.Struct({
  logo_id: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("logo_id")),
  offset: Schema.optional(Schema.String).pipe(T.HttpQuery("offset")),
  limit: Schema.optional(Schema.String).pipe(T.HttpQuery("limit"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/brand-protection/logo-matches/download" }),
).annotations({ identifier: "GetAccountsAccountIdBrandProtectionLogoMatchesDownloadRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionLogoMatchesDownloadRequest>;

export interface GetAccountsAccountIdBrandProtectionLogoMatchesDownloadResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdBrandProtectionLogoMatchesDownloadResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdBrandProtectionLogoMatchesDownloadResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionLogoMatchesDownloadResponse>;

export const getAccountsAccountIdBrandProtectionLogoMatchesDownload: (
  input: GetAccountsAccountIdBrandProtectionLogoMatchesDownloadRequest
) => Effect.Effect<
  GetAccountsAccountIdBrandProtectionLogoMatchesDownloadResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdBrandProtectionLogoMatchesDownloadRequest,
  output: GetAccountsAccountIdBrandProtectionLogoMatchesDownloadResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdBrandProtectionLogosRequest {
}

export const GetAccountsAccountIdBrandProtectionLogosRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/brand-protection/logos" }),
).annotations({ identifier: "GetAccountsAccountIdBrandProtectionLogosRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionLogosRequest>;

export interface GetAccountsAccountIdBrandProtectionLogosResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdBrandProtectionLogosResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdBrandProtectionLogosResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionLogosResponse>;

export const getAccountsAccountIdBrandProtectionLogos: (
  input: GetAccountsAccountIdBrandProtectionLogosRequest
) => Effect.Effect<
  GetAccountsAccountIdBrandProtectionLogosResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdBrandProtectionLogosRequest,
  output: GetAccountsAccountIdBrandProtectionLogosResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostAccountsAccountIdBrandProtectionLogosRequest {
  tag?: string;
  match_type?: string;
  threshold?: number;
}

export const PostAccountsAccountIdBrandProtectionLogosRequest = Schema.Struct({
  tag: Schema.optional(Schema.String).pipe(T.HttpQuery("tag")),
  match_type: Schema.optional(Schema.String).pipe(T.HttpQuery("match_type")),
  threshold: Schema.optional(Schema.Number).pipe(T.HttpQuery("threshold"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/brand-protection/logos" }),
).annotations({ identifier: "PostAccountsAccountIdBrandProtectionLogosRequest" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionLogosRequest>;

export interface PostAccountsAccountIdBrandProtectionLogosResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostAccountsAccountIdBrandProtectionLogosResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostAccountsAccountIdBrandProtectionLogosResponse" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionLogosResponse>;

export const postAccountsAccountIdBrandProtectionLogos: (
  input: PostAccountsAccountIdBrandProtectionLogosRequest
) => Effect.Effect<
  PostAccountsAccountIdBrandProtectionLogosResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostAccountsAccountIdBrandProtectionLogosRequest,
  output: PostAccountsAccountIdBrandProtectionLogosResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdBrandProtectionLogosLogoIdRequest {
}

export const GetAccountsAccountIdBrandProtectionLogosLogoIdRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/brand-protection/logos/{logo_id}" }),
).annotations({ identifier: "GetAccountsAccountIdBrandProtectionLogosLogoIdRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionLogosLogoIdRequest>;

export interface GetAccountsAccountIdBrandProtectionLogosLogoIdResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdBrandProtectionLogosLogoIdResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdBrandProtectionLogosLogoIdResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionLogosLogoIdResponse>;

export const getAccountsAccountIdBrandProtectionLogosLogoId: (
  input: GetAccountsAccountIdBrandProtectionLogosLogoIdRequest
) => Effect.Effect<
  GetAccountsAccountIdBrandProtectionLogosLogoIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdBrandProtectionLogosLogoIdRequest,
  output: GetAccountsAccountIdBrandProtectionLogosLogoIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAccountsAccountIdBrandProtectionLogosLogoIdRequest {
}

export const DeleteAccountsAccountIdBrandProtectionLogosLogoIdRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/brand-protection/logos/{logo_id}" }),
).annotations({ identifier: "DeleteAccountsAccountIdBrandProtectionLogosLogoIdRequest" }) as unknown as Schema.Schema<DeleteAccountsAccountIdBrandProtectionLogosLogoIdRequest>;

export interface DeleteAccountsAccountIdBrandProtectionLogosLogoIdResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAccountsAccountIdBrandProtectionLogosLogoIdResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAccountsAccountIdBrandProtectionLogosLogoIdResponse" }) as unknown as Schema.Schema<DeleteAccountsAccountIdBrandProtectionLogosLogoIdResponse>;

export const deleteAccountsAccountIdBrandProtectionLogosLogoId: (
  input: DeleteAccountsAccountIdBrandProtectionLogosLogoIdRequest
) => Effect.Effect<
  DeleteAccountsAccountIdBrandProtectionLogosLogoIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccountsAccountIdBrandProtectionLogosLogoIdRequest,
  output: DeleteAccountsAccountIdBrandProtectionLogosLogoIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdBrandProtectionMatchesRequest {
  id?: string;
  offset?: number;
  limit?: number;
  include_domain_id?: boolean;
}

export const GetAccountsAccountIdBrandProtectionMatchesRequest = Schema.Struct({
  id: Schema.optional(Schema.String).pipe(T.HttpQuery("id")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  include_domain_id: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("include_domain_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/brand-protection/matches" }),
).annotations({ identifier: "GetAccountsAccountIdBrandProtectionMatchesRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionMatchesRequest>;

export interface GetAccountsAccountIdBrandProtectionMatchesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdBrandProtectionMatchesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdBrandProtectionMatchesResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionMatchesResponse>;

export const getAccountsAccountIdBrandProtectionMatches: (
  input: GetAccountsAccountIdBrandProtectionMatchesRequest
) => Effect.Effect<
  GetAccountsAccountIdBrandProtectionMatchesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdBrandProtectionMatchesRequest,
  output: GetAccountsAccountIdBrandProtectionMatchesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdBrandProtectionMatchesDownloadRequest {
  id?: string;
  offset?: number;
  limit?: number;
  include_domain_id?: boolean;
}

export const GetAccountsAccountIdBrandProtectionMatchesDownloadRequest = Schema.Struct({
  id: Schema.optional(Schema.String).pipe(T.HttpQuery("id")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  include_domain_id: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("include_domain_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/brand-protection/matches/download" }),
).annotations({ identifier: "GetAccountsAccountIdBrandProtectionMatchesDownloadRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionMatchesDownloadRequest>;

export interface GetAccountsAccountIdBrandProtectionMatchesDownloadResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdBrandProtectionMatchesDownloadResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdBrandProtectionMatchesDownloadResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionMatchesDownloadResponse>;

export const getAccountsAccountIdBrandProtectionMatchesDownload: (
  input: GetAccountsAccountIdBrandProtectionMatchesDownloadRequest
) => Effect.Effect<
  GetAccountsAccountIdBrandProtectionMatchesDownloadResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdBrandProtectionMatchesDownloadRequest,
  output: GetAccountsAccountIdBrandProtectionMatchesDownloadResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdBrandProtectionQueriesRequest {
}

export const GetAccountsAccountIdBrandProtectionQueriesRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/brand-protection/queries" }),
).annotations({ identifier: "GetAccountsAccountIdBrandProtectionQueriesRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionQueriesRequest>;

export interface GetAccountsAccountIdBrandProtectionQueriesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdBrandProtectionQueriesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdBrandProtectionQueriesResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionQueriesResponse>;

export const getAccountsAccountIdBrandProtectionQueries: (
  input: GetAccountsAccountIdBrandProtectionQueriesRequest
) => Effect.Effect<
  GetAccountsAccountIdBrandProtectionQueriesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdBrandProtectionQueriesRequest,
  output: GetAccountsAccountIdBrandProtectionQueriesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostAccountsAccountIdBrandProtectionQueriesRequest {
  id?: string;
  tag?: string;
  scan?: boolean;
  body: { max_time?: string; min_time?: string; scan?: boolean; string_matches?: unknown; tag?: string };
}

export const PostAccountsAccountIdBrandProtectionQueriesRequest = Schema.Struct({
  id: Schema.optional(Schema.String).pipe(T.HttpQuery("id")),
  tag: Schema.optional(Schema.String).pipe(T.HttpQuery("tag")),
  scan: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("scan")),
  body: Schema.Struct({
  max_time: Schema.optional(Schema.Date),
  min_time: Schema.optional(Schema.Date),
  scan: Schema.optional(Schema.Boolean),
  string_matches: Schema.optional(Schema.Unknown),
  tag: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/brand-protection/queries" }),
).annotations({ identifier: "PostAccountsAccountIdBrandProtectionQueriesRequest" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionQueriesRequest>;

export interface PostAccountsAccountIdBrandProtectionQueriesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostAccountsAccountIdBrandProtectionQueriesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostAccountsAccountIdBrandProtectionQueriesResponse" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionQueriesResponse>;

export const postAccountsAccountIdBrandProtectionQueries: (
  input: PostAccountsAccountIdBrandProtectionQueriesRequest
) => Effect.Effect<
  PostAccountsAccountIdBrandProtectionQueriesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostAccountsAccountIdBrandProtectionQueriesRequest,
  output: PostAccountsAccountIdBrandProtectionQueriesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAccountsAccountIdBrandProtectionQueriesRequest {
  id?: string;
  tag?: string;
  scan?: boolean;
}

export const DeleteAccountsAccountIdBrandProtectionQueriesRequest = Schema.Struct({
  id: Schema.optional(Schema.String).pipe(T.HttpQuery("id")),
  tag: Schema.optional(Schema.String).pipe(T.HttpQuery("tag")),
  scan: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("scan"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/brand-protection/queries" }),
).annotations({ identifier: "DeleteAccountsAccountIdBrandProtectionQueriesRequest" }) as unknown as Schema.Schema<DeleteAccountsAccountIdBrandProtectionQueriesRequest>;

export interface DeleteAccountsAccountIdBrandProtectionQueriesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAccountsAccountIdBrandProtectionQueriesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAccountsAccountIdBrandProtectionQueriesResponse" }) as unknown as Schema.Schema<DeleteAccountsAccountIdBrandProtectionQueriesResponse>;

export const deleteAccountsAccountIdBrandProtectionQueries: (
  input: DeleteAccountsAccountIdBrandProtectionQueriesRequest
) => Effect.Effect<
  DeleteAccountsAccountIdBrandProtectionQueriesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccountsAccountIdBrandProtectionQueriesRequest,
  output: DeleteAccountsAccountIdBrandProtectionQueriesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchAccountsAccountIdBrandProtectionQueriesRequest {
}

export const PatchAccountsAccountIdBrandProtectionQueriesRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/brand-protection/queries" }),
).annotations({ identifier: "PatchAccountsAccountIdBrandProtectionQueriesRequest" }) as unknown as Schema.Schema<PatchAccountsAccountIdBrandProtectionQueriesRequest>;

export interface PatchAccountsAccountIdBrandProtectionQueriesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchAccountsAccountIdBrandProtectionQueriesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchAccountsAccountIdBrandProtectionQueriesResponse" }) as unknown as Schema.Schema<PatchAccountsAccountIdBrandProtectionQueriesResponse>;

export const patchAccountsAccountIdBrandProtectionQueries: (
  input: PatchAccountsAccountIdBrandProtectionQueriesRequest
) => Effect.Effect<
  PatchAccountsAccountIdBrandProtectionQueriesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchAccountsAccountIdBrandProtectionQueriesRequest,
  output: PatchAccountsAccountIdBrandProtectionQueriesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostAccountsAccountIdBrandProtectionQueriesBulkRequest {
  body: { queries?: Record<string, unknown>[] };
}

export const PostAccountsAccountIdBrandProtectionQueriesBulkRequest = Schema.Struct({
  body: Schema.Struct({
  queries: Schema.optional(Schema.Array(Schema.Record({ key: Schema.String, value: Schema.Unknown })))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/brand-protection/queries/bulk" }),
).annotations({ identifier: "PostAccountsAccountIdBrandProtectionQueriesBulkRequest" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionQueriesBulkRequest>;

export interface PostAccountsAccountIdBrandProtectionQueriesBulkResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostAccountsAccountIdBrandProtectionQueriesBulkResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostAccountsAccountIdBrandProtectionQueriesBulkResponse" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionQueriesBulkResponse>;

export const postAccountsAccountIdBrandProtectionQueriesBulk: (
  input: PostAccountsAccountIdBrandProtectionQueriesBulkRequest
) => Effect.Effect<
  PostAccountsAccountIdBrandProtectionQueriesBulkResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostAccountsAccountIdBrandProtectionQueriesBulkRequest,
  output: PostAccountsAccountIdBrandProtectionQueriesBulkResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdBrandProtectionRecentSubmissionsRequest {
}

export const GetAccountsAccountIdBrandProtectionRecentSubmissionsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/brand-protection/recent-submissions" }),
).annotations({ identifier: "GetAccountsAccountIdBrandProtectionRecentSubmissionsRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionRecentSubmissionsRequest>;

export interface GetAccountsAccountIdBrandProtectionRecentSubmissionsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdBrandProtectionRecentSubmissionsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdBrandProtectionRecentSubmissionsResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionRecentSubmissionsResponse>;

export const getAccountsAccountIdBrandProtectionRecentSubmissions: (
  input: GetAccountsAccountIdBrandProtectionRecentSubmissionsRequest
) => Effect.Effect<
  GetAccountsAccountIdBrandProtectionRecentSubmissionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdBrandProtectionRecentSubmissionsRequest,
  output: GetAccountsAccountIdBrandProtectionRecentSubmissionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchAccountsAccountIdBrandProtectionRefuteRequest {
}

export const PatchAccountsAccountIdBrandProtectionRefuteRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/brand-protection/refute" }),
).annotations({ identifier: "PatchAccountsAccountIdBrandProtectionRefuteRequest" }) as unknown as Schema.Schema<PatchAccountsAccountIdBrandProtectionRefuteRequest>;

export interface PatchAccountsAccountIdBrandProtectionRefuteResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchAccountsAccountIdBrandProtectionRefuteResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchAccountsAccountIdBrandProtectionRefuteResponse" }) as unknown as Schema.Schema<PatchAccountsAccountIdBrandProtectionRefuteResponse>;

export const patchAccountsAccountIdBrandProtectionRefute: (
  input: PatchAccountsAccountIdBrandProtectionRefuteRequest
) => Effect.Effect<
  PatchAccountsAccountIdBrandProtectionRefuteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchAccountsAccountIdBrandProtectionRefuteRequest,
  output: PatchAccountsAccountIdBrandProtectionRefuteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostAccountsAccountIdBrandProtectionScanLogoRequest {
}

export const PostAccountsAccountIdBrandProtectionScanLogoRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/brand-protection/scan-logo" }),
).annotations({ identifier: "PostAccountsAccountIdBrandProtectionScanLogoRequest" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionScanLogoRequest>;

export interface PostAccountsAccountIdBrandProtectionScanLogoResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostAccountsAccountIdBrandProtectionScanLogoResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostAccountsAccountIdBrandProtectionScanLogoResponse" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionScanLogoResponse>;

export const postAccountsAccountIdBrandProtectionScanLogo: (
  input: PostAccountsAccountIdBrandProtectionScanLogoRequest
) => Effect.Effect<
  PostAccountsAccountIdBrandProtectionScanLogoResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostAccountsAccountIdBrandProtectionScanLogoRequest,
  output: PostAccountsAccountIdBrandProtectionScanLogoResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostAccountsAccountIdBrandProtectionScanPageRequest {
}

export const PostAccountsAccountIdBrandProtectionScanPageRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/brand-protection/scan-page" }),
).annotations({ identifier: "PostAccountsAccountIdBrandProtectionScanPageRequest" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionScanPageRequest>;

export interface PostAccountsAccountIdBrandProtectionScanPageResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostAccountsAccountIdBrandProtectionScanPageResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostAccountsAccountIdBrandProtectionScanPageResponse" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionScanPageResponse>;

export const postAccountsAccountIdBrandProtectionScanPage: (
  input: PostAccountsAccountIdBrandProtectionScanPageRequest
) => Effect.Effect<
  PostAccountsAccountIdBrandProtectionScanPageResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostAccountsAccountIdBrandProtectionScanPageRequest,
  output: PostAccountsAccountIdBrandProtectionScanPageResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostAccountsAccountIdBrandProtectionSearchRequest {
}

export const PostAccountsAccountIdBrandProtectionSearchRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/brand-protection/search" }),
).annotations({ identifier: "PostAccountsAccountIdBrandProtectionSearchRequest" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionSearchRequest>;

export interface PostAccountsAccountIdBrandProtectionSearchResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostAccountsAccountIdBrandProtectionSearchResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostAccountsAccountIdBrandProtectionSearchResponse" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionSearchResponse>;

export const postAccountsAccountIdBrandProtectionSearch: (
  input: PostAccountsAccountIdBrandProtectionSearchRequest
) => Effect.Effect<
  PostAccountsAccountIdBrandProtectionSearchResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostAccountsAccountIdBrandProtectionSearchRequest,
  output: PostAccountsAccountIdBrandProtectionSearchResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdBrandProtectionSubmissionInfoRequest {
}

export const GetAccountsAccountIdBrandProtectionSubmissionInfoRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/brand-protection/submission-info" }),
).annotations({ identifier: "GetAccountsAccountIdBrandProtectionSubmissionInfoRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionSubmissionInfoRequest>;

export interface GetAccountsAccountIdBrandProtectionSubmissionInfoResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdBrandProtectionSubmissionInfoResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdBrandProtectionSubmissionInfoResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionSubmissionInfoResponse>;

export const getAccountsAccountIdBrandProtectionSubmissionInfo: (
  input: GetAccountsAccountIdBrandProtectionSubmissionInfoRequest
) => Effect.Effect<
  GetAccountsAccountIdBrandProtectionSubmissionInfoResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdBrandProtectionSubmissionInfoRequest,
  output: GetAccountsAccountIdBrandProtectionSubmissionInfoResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostAccountsAccountIdBrandProtectionSubmitRequest {
}

export const PostAccountsAccountIdBrandProtectionSubmitRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/brand-protection/submit" }),
).annotations({ identifier: "PostAccountsAccountIdBrandProtectionSubmitRequest" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionSubmitRequest>;

export interface PostAccountsAccountIdBrandProtectionSubmitResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostAccountsAccountIdBrandProtectionSubmitResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostAccountsAccountIdBrandProtectionSubmitResponse" }) as unknown as Schema.Schema<PostAccountsAccountIdBrandProtectionSubmitResponse>;

export const postAccountsAccountIdBrandProtectionSubmit: (
  input: PostAccountsAccountIdBrandProtectionSubmitRequest
) => Effect.Effect<
  PostAccountsAccountIdBrandProtectionSubmitResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostAccountsAccountIdBrandProtectionSubmitRequest,
  output: PostAccountsAccountIdBrandProtectionSubmitResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdBrandProtectionTotalQueriesRequest {
}

export const GetAccountsAccountIdBrandProtectionTotalQueriesRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/brand-protection/total-queries" }),
).annotations({ identifier: "GetAccountsAccountIdBrandProtectionTotalQueriesRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionTotalQueriesRequest>;

export interface GetAccountsAccountIdBrandProtectionTotalQueriesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdBrandProtectionTotalQueriesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdBrandProtectionTotalQueriesResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionTotalQueriesResponse>;

export const getAccountsAccountIdBrandProtectionTotalQueries: (
  input: GetAccountsAccountIdBrandProtectionTotalQueriesRequest
) => Effect.Effect<
  GetAccountsAccountIdBrandProtectionTotalQueriesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdBrandProtectionTotalQueriesRequest,
  output: GetAccountsAccountIdBrandProtectionTotalQueriesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdBrandProtectionTrackedDomainsRequest {
}

export const GetAccountsAccountIdBrandProtectionTrackedDomainsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/brand-protection/tracked-domains" }),
).annotations({ identifier: "GetAccountsAccountIdBrandProtectionTrackedDomainsRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionTrackedDomainsRequest>;

export interface GetAccountsAccountIdBrandProtectionTrackedDomainsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdBrandProtectionTrackedDomainsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdBrandProtectionTrackedDomainsResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionTrackedDomainsResponse>;

export const getAccountsAccountIdBrandProtectionTrackedDomains: (
  input: GetAccountsAccountIdBrandProtectionTrackedDomainsRequest
) => Effect.Effect<
  GetAccountsAccountIdBrandProtectionTrackedDomainsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdBrandProtectionTrackedDomainsRequest,
  output: GetAccountsAccountIdBrandProtectionTrackedDomainsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdBrandProtectionUrlInfoRequest {
}

export const GetAccountsAccountIdBrandProtectionUrlInfoRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/brand-protection/url-info" }),
).annotations({ identifier: "GetAccountsAccountIdBrandProtectionUrlInfoRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionUrlInfoRequest>;

export interface GetAccountsAccountIdBrandProtectionUrlInfoResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdBrandProtectionUrlInfoResponse = Schema.Struct({
  result: Schema.Array(Schema.Record({ key: Schema.String, value: Schema.Unknown })),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdBrandProtectionUrlInfoResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdBrandProtectionUrlInfoResponse>;

export const getAccountsAccountIdBrandProtectionUrlInfo: (
  input: GetAccountsAccountIdBrandProtectionUrlInfoRequest
) => Effect.Effect<
  GetAccountsAccountIdBrandProtectionUrlInfoResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdBrandProtectionUrlInfoRequest,
  output: GetAccountsAccountIdBrandProtectionUrlInfoResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchAccountsAccountIdBrandProtectionVerifyRequest {
}

export const PatchAccountsAccountIdBrandProtectionVerifyRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/brand-protection/verify" }),
).annotations({ identifier: "PatchAccountsAccountIdBrandProtectionVerifyRequest" }) as unknown as Schema.Schema<PatchAccountsAccountIdBrandProtectionVerifyRequest>;

export interface PatchAccountsAccountIdBrandProtectionVerifyResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchAccountsAccountIdBrandProtectionVerifyResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchAccountsAccountIdBrandProtectionVerifyResponse" }) as unknown as Schema.Schema<PatchAccountsAccountIdBrandProtectionVerifyResponse>;

export const patchAccountsAccountIdBrandProtectionVerify: (
  input: PatchAccountsAccountIdBrandProtectionVerifyRequest
) => Effect.Effect<
  PatchAccountsAccountIdBrandProtectionVerifyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchAccountsAccountIdBrandProtectionVerifyRequest,
  output: PatchAccountsAccountIdBrandProtectionVerifyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostContentRequest {
  account_id: string;
  cacheTTL?: number;
  body: unknown;
}

export const PostContentRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  cacheTTL: Schema.optional(Schema.Number).pipe(T.HttpQuery("cacheTTL")),
  body: Schema.Union(Schema.Struct({
  actionTimeout: Schema.optional(Schema.Number),
  addScriptTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  addStyleTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  allowRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  allowResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  authenticate: Schema.optional(Schema.Struct({
  password: Schema.String,
  username: Schema.String
})),
  bestAttempt: Schema.optional(Schema.Boolean),
  cookies: Schema.optional(Schema.Array(Schema.Struct({
  domain: Schema.optional(Schema.String),
  expires: Schema.optional(Schema.Number),
  httpOnly: Schema.optional(Schema.Boolean),
  name: Schema.String,
  partitionKey: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Union(Schema.Literal("Low"), Schema.Literal("Medium"), Schema.Literal("High"))),
  sameParty: Schema.optional(Schema.Boolean),
  sameSite: Schema.optional(Schema.Union(Schema.Literal("Strict"), Schema.Literal("Lax"), Schema.Literal("None"))),
  secure: Schema.optional(Schema.Boolean),
  sourcePort: Schema.optional(Schema.Number),
  sourceScheme: Schema.optional(Schema.Union(Schema.Literal("Unset"), Schema.Literal("NonSecure"), Schema.Literal("Secure"))),
  url: Schema.optional(Schema.String),
  value: Schema.String
}))),
  emulateMediaType: Schema.optional(Schema.String),
  gotoOptions: Schema.optional(Schema.Struct({
  referer: Schema.optional(Schema.String),
  referrerPolicy: Schema.optional(Schema.String),
  timeout: Schema.optional(Schema.Number),
  waitUntil: Schema.optional(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2"), Schema.Array(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2")))))
})),
  rejectRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  rejectResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  setExtraHTTPHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  setJavaScriptEnabled: Schema.optional(Schema.Boolean),
  url: Schema.String,
  userAgent: Schema.optional(Schema.String),
  viewport: Schema.optional(Schema.Struct({
  deviceScaleFactor: Schema.optional(Schema.Number),
  hasTouch: Schema.optional(Schema.Boolean),
  height: Schema.Number,
  isLandscape: Schema.optional(Schema.Boolean),
  isMobile: Schema.optional(Schema.Boolean),
  width: Schema.Number
})),
  waitForSelector: Schema.optional(Schema.Struct({
  hidden: Schema.optional(Schema.Literal(true)),
  selector: Schema.String,
  timeout: Schema.optional(Schema.Number),
  visible: Schema.optional(Schema.Literal(true))
})),
  waitForTimeout: Schema.optional(Schema.Number)
}), Schema.Struct({
  actionTimeout: Schema.optional(Schema.Number),
  addScriptTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  addStyleTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  allowRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  allowResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  authenticate: Schema.optional(Schema.Struct({
  password: Schema.String,
  username: Schema.String
})),
  bestAttempt: Schema.optional(Schema.Boolean),
  cookies: Schema.optional(Schema.Array(Schema.Struct({
  domain: Schema.optional(Schema.String),
  expires: Schema.optional(Schema.Number),
  httpOnly: Schema.optional(Schema.Boolean),
  name: Schema.String,
  partitionKey: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Union(Schema.Literal("Low"), Schema.Literal("Medium"), Schema.Literal("High"))),
  sameParty: Schema.optional(Schema.Boolean),
  sameSite: Schema.optional(Schema.Union(Schema.Literal("Strict"), Schema.Literal("Lax"), Schema.Literal("None"))),
  secure: Schema.optional(Schema.Boolean),
  sourcePort: Schema.optional(Schema.Number),
  sourceScheme: Schema.optional(Schema.Union(Schema.Literal("Unset"), Schema.Literal("NonSecure"), Schema.Literal("Secure"))),
  url: Schema.optional(Schema.String),
  value: Schema.String
}))),
  emulateMediaType: Schema.optional(Schema.String),
  gotoOptions: Schema.optional(Schema.Struct({
  referer: Schema.optional(Schema.String),
  referrerPolicy: Schema.optional(Schema.String),
  timeout: Schema.optional(Schema.Number),
  waitUntil: Schema.optional(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2"), Schema.Array(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2")))))
})),
  html: Schema.String,
  rejectRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  rejectResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  setExtraHTTPHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  setJavaScriptEnabled: Schema.optional(Schema.Boolean),
  userAgent: Schema.optional(Schema.String),
  viewport: Schema.optional(Schema.Struct({
  deviceScaleFactor: Schema.optional(Schema.Number),
  hasTouch: Schema.optional(Schema.Boolean),
  height: Schema.Number,
  isLandscape: Schema.optional(Schema.Boolean),
  isMobile: Schema.optional(Schema.Boolean),
  width: Schema.Number
})),
  waitForSelector: Schema.optional(Schema.Struct({
  hidden: Schema.optional(Schema.Literal(true)),
  selector: Schema.String,
  timeout: Schema.optional(Schema.Number),
  visible: Schema.optional(Schema.Literal(true))
})),
  waitForTimeout: Schema.optional(Schema.Number)
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/browser-rendering/content" }),
).annotations({ identifier: "PostContentRequest" }) as unknown as Schema.Schema<PostContentRequest>;

export interface PostContentResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostContentResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostContentResponse" }) as unknown as Schema.Schema<PostContentResponse>;

export const postContent: (
  input: PostContentRequest
) => Effect.Effect<
  PostContentResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostContentRequest,
  output: PostContentResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostJsonRequest {
  account_id: string;
  cacheTTL?: number;
  body: unknown;
}

export const PostJsonRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  cacheTTL: Schema.optional(Schema.Number).pipe(T.HttpQuery("cacheTTL")),
  body: Schema.Union(Schema.Struct({
  actionTimeout: Schema.optional(Schema.Number),
  addScriptTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  addStyleTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  allowRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  allowResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  authenticate: Schema.optional(Schema.Struct({
  password: Schema.String,
  username: Schema.String
})),
  bestAttempt: Schema.optional(Schema.Boolean),
  cookies: Schema.optional(Schema.Array(Schema.Struct({
  domain: Schema.optional(Schema.String),
  expires: Schema.optional(Schema.Number),
  httpOnly: Schema.optional(Schema.Boolean),
  name: Schema.String,
  partitionKey: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Union(Schema.Literal("Low"), Schema.Literal("Medium"), Schema.Literal("High"))),
  sameParty: Schema.optional(Schema.Boolean),
  sameSite: Schema.optional(Schema.Union(Schema.Literal("Strict"), Schema.Literal("Lax"), Schema.Literal("None"))),
  secure: Schema.optional(Schema.Boolean),
  sourcePort: Schema.optional(Schema.Number),
  sourceScheme: Schema.optional(Schema.Union(Schema.Literal("Unset"), Schema.Literal("NonSecure"), Schema.Literal("Secure"))),
  url: Schema.optional(Schema.String),
  value: Schema.String
}))),
  custom_ai: Schema.optional(Schema.Array(Schema.Struct({
  authorization: Schema.String,
  model: Schema.String
}))),
  emulateMediaType: Schema.optional(Schema.String),
  gotoOptions: Schema.optional(Schema.Struct({
  referer: Schema.optional(Schema.String),
  referrerPolicy: Schema.optional(Schema.String),
  timeout: Schema.optional(Schema.Number),
  waitUntil: Schema.optional(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2"), Schema.Array(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2")))))
})),
  html: Schema.String,
  prompt: Schema.optional(Schema.String),
  rejectRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  rejectResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  response_format: Schema.optional(Schema.Struct({
  json_schema: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Union(Schema.String, Schema.Number, Schema.Boolean, Schema.Struct({}), Schema.Array(Schema.String)) })),
  type: Schema.String
})),
  setExtraHTTPHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  setJavaScriptEnabled: Schema.optional(Schema.Boolean),
  userAgent: Schema.optional(Schema.String),
  viewport: Schema.optional(Schema.Struct({
  deviceScaleFactor: Schema.optional(Schema.Number),
  hasTouch: Schema.optional(Schema.Boolean),
  height: Schema.Number,
  isLandscape: Schema.optional(Schema.Boolean),
  isMobile: Schema.optional(Schema.Boolean),
  width: Schema.Number
})),
  waitForSelector: Schema.optional(Schema.Struct({
  hidden: Schema.optional(Schema.Literal(true)),
  selector: Schema.String,
  timeout: Schema.optional(Schema.Number),
  visible: Schema.optional(Schema.Literal(true))
})),
  waitForTimeout: Schema.optional(Schema.Number)
}), Schema.Struct({
  actionTimeout: Schema.optional(Schema.Number),
  addScriptTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  addStyleTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  allowRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  allowResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  authenticate: Schema.optional(Schema.Struct({
  password: Schema.String,
  username: Schema.String
})),
  bestAttempt: Schema.optional(Schema.Boolean),
  cookies: Schema.optional(Schema.Array(Schema.Struct({
  domain: Schema.optional(Schema.String),
  expires: Schema.optional(Schema.Number),
  httpOnly: Schema.optional(Schema.Boolean),
  name: Schema.String,
  partitionKey: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Union(Schema.Literal("Low"), Schema.Literal("Medium"), Schema.Literal("High"))),
  sameParty: Schema.optional(Schema.Boolean),
  sameSite: Schema.optional(Schema.Union(Schema.Literal("Strict"), Schema.Literal("Lax"), Schema.Literal("None"))),
  secure: Schema.optional(Schema.Boolean),
  sourcePort: Schema.optional(Schema.Number),
  sourceScheme: Schema.optional(Schema.Union(Schema.Literal("Unset"), Schema.Literal("NonSecure"), Schema.Literal("Secure"))),
  url: Schema.optional(Schema.String),
  value: Schema.String
}))),
  custom_ai: Schema.optional(Schema.Array(Schema.Struct({
  authorization: Schema.String,
  model: Schema.String
}))),
  emulateMediaType: Schema.optional(Schema.String),
  gotoOptions: Schema.optional(Schema.Struct({
  referer: Schema.optional(Schema.String),
  referrerPolicy: Schema.optional(Schema.String),
  timeout: Schema.optional(Schema.Number),
  waitUntil: Schema.optional(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2"), Schema.Array(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2")))))
})),
  prompt: Schema.optional(Schema.String),
  rejectRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  rejectResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  response_format: Schema.optional(Schema.Struct({
  json_schema: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Union(Schema.String, Schema.Number, Schema.Boolean, Schema.Struct({}), Schema.Array(Schema.String)) })),
  type: Schema.String
})),
  setExtraHTTPHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  setJavaScriptEnabled: Schema.optional(Schema.Boolean),
  url: Schema.String,
  userAgent: Schema.optional(Schema.String),
  viewport: Schema.optional(Schema.Struct({
  deviceScaleFactor: Schema.optional(Schema.Number),
  hasTouch: Schema.optional(Schema.Boolean),
  height: Schema.Number,
  isLandscape: Schema.optional(Schema.Boolean),
  isMobile: Schema.optional(Schema.Boolean),
  width: Schema.Number
})),
  waitForSelector: Schema.optional(Schema.Struct({
  hidden: Schema.optional(Schema.Literal(true)),
  selector: Schema.String,
  timeout: Schema.optional(Schema.Number),
  visible: Schema.optional(Schema.Literal(true))
})),
  waitForTimeout: Schema.optional(Schema.Number)
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/browser-rendering/json" }),
).annotations({ identifier: "PostJsonRequest" }) as unknown as Schema.Schema<PostJsonRequest>;

export interface PostJsonResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostJsonResponse = Schema.Struct({
  result: Schema.Record({ key: Schema.String, value: Schema.Struct({}) }),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostJsonResponse" }) as unknown as Schema.Schema<PostJsonResponse>;

export const postJson: (
  input: PostJsonRequest
) => Effect.Effect<
  PostJsonResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostJsonRequest,
  output: PostJsonResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostLinksRequest {
  account_id: string;
  cacheTTL?: number;
  body: unknown;
}

export const PostLinksRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  cacheTTL: Schema.optional(Schema.Number).pipe(T.HttpQuery("cacheTTL")),
  body: Schema.Union(Schema.Struct({
  actionTimeout: Schema.optional(Schema.Number),
  addScriptTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  addStyleTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  allowRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  allowResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  authenticate: Schema.optional(Schema.Struct({
  password: Schema.String,
  username: Schema.String
})),
  bestAttempt: Schema.optional(Schema.Boolean),
  cookies: Schema.optional(Schema.Array(Schema.Struct({
  domain: Schema.optional(Schema.String),
  expires: Schema.optional(Schema.Number),
  httpOnly: Schema.optional(Schema.Boolean),
  name: Schema.String,
  partitionKey: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Union(Schema.Literal("Low"), Schema.Literal("Medium"), Schema.Literal("High"))),
  sameParty: Schema.optional(Schema.Boolean),
  sameSite: Schema.optional(Schema.Union(Schema.Literal("Strict"), Schema.Literal("Lax"), Schema.Literal("None"))),
  secure: Schema.optional(Schema.Boolean),
  sourcePort: Schema.optional(Schema.Number),
  sourceScheme: Schema.optional(Schema.Union(Schema.Literal("Unset"), Schema.Literal("NonSecure"), Schema.Literal("Secure"))),
  url: Schema.optional(Schema.String),
  value: Schema.String
}))),
  emulateMediaType: Schema.optional(Schema.String),
  excludeExternalLinks: Schema.optional(Schema.Boolean),
  gotoOptions: Schema.optional(Schema.Struct({
  referer: Schema.optional(Schema.String),
  referrerPolicy: Schema.optional(Schema.String),
  timeout: Schema.optional(Schema.Number),
  waitUntil: Schema.optional(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2"), Schema.Array(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2")))))
})),
  html: Schema.String,
  rejectRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  rejectResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  setExtraHTTPHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  setJavaScriptEnabled: Schema.optional(Schema.Boolean),
  userAgent: Schema.optional(Schema.String),
  viewport: Schema.optional(Schema.Struct({
  deviceScaleFactor: Schema.optional(Schema.Number),
  hasTouch: Schema.optional(Schema.Boolean),
  height: Schema.Number,
  isLandscape: Schema.optional(Schema.Boolean),
  isMobile: Schema.optional(Schema.Boolean),
  width: Schema.Number
})),
  visibleLinksOnly: Schema.optional(Schema.Boolean),
  waitForSelector: Schema.optional(Schema.Struct({
  hidden: Schema.optional(Schema.Literal(true)),
  selector: Schema.String,
  timeout: Schema.optional(Schema.Number),
  visible: Schema.optional(Schema.Literal(true))
})),
  waitForTimeout: Schema.optional(Schema.Number)
}), Schema.Struct({
  actionTimeout: Schema.optional(Schema.Number),
  addScriptTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  addStyleTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  allowRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  allowResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  authenticate: Schema.optional(Schema.Struct({
  password: Schema.String,
  username: Schema.String
})),
  bestAttempt: Schema.optional(Schema.Boolean),
  cookies: Schema.optional(Schema.Array(Schema.Struct({
  domain: Schema.optional(Schema.String),
  expires: Schema.optional(Schema.Number),
  httpOnly: Schema.optional(Schema.Boolean),
  name: Schema.String,
  partitionKey: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Union(Schema.Literal("Low"), Schema.Literal("Medium"), Schema.Literal("High"))),
  sameParty: Schema.optional(Schema.Boolean),
  sameSite: Schema.optional(Schema.Union(Schema.Literal("Strict"), Schema.Literal("Lax"), Schema.Literal("None"))),
  secure: Schema.optional(Schema.Boolean),
  sourcePort: Schema.optional(Schema.Number),
  sourceScheme: Schema.optional(Schema.Union(Schema.Literal("Unset"), Schema.Literal("NonSecure"), Schema.Literal("Secure"))),
  url: Schema.optional(Schema.String),
  value: Schema.String
}))),
  emulateMediaType: Schema.optional(Schema.String),
  excludeExternalLinks: Schema.optional(Schema.Boolean),
  gotoOptions: Schema.optional(Schema.Struct({
  referer: Schema.optional(Schema.String),
  referrerPolicy: Schema.optional(Schema.String),
  timeout: Schema.optional(Schema.Number),
  waitUntil: Schema.optional(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2"), Schema.Array(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2")))))
})),
  rejectRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  rejectResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  setExtraHTTPHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  setJavaScriptEnabled: Schema.optional(Schema.Boolean),
  url: Schema.String,
  userAgent: Schema.optional(Schema.String),
  viewport: Schema.optional(Schema.Struct({
  deviceScaleFactor: Schema.optional(Schema.Number),
  hasTouch: Schema.optional(Schema.Boolean),
  height: Schema.Number,
  isLandscape: Schema.optional(Schema.Boolean),
  isMobile: Schema.optional(Schema.Boolean),
  width: Schema.Number
})),
  visibleLinksOnly: Schema.optional(Schema.Boolean),
  waitForSelector: Schema.optional(Schema.Struct({
  hidden: Schema.optional(Schema.Literal(true)),
  selector: Schema.String,
  timeout: Schema.optional(Schema.Number),
  visible: Schema.optional(Schema.Literal(true))
})),
  waitForTimeout: Schema.optional(Schema.Number)
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/browser-rendering/links" }),
).annotations({ identifier: "PostLinksRequest" }) as unknown as Schema.Schema<PostLinksRequest>;

export interface PostLinksResponse {
  result: string[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostLinksResponse = Schema.Struct({
  result: Schema.Array(Schema.String),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostLinksResponse" }) as unknown as Schema.Schema<PostLinksResponse>;

export const postLinks: (
  input: PostLinksRequest
) => Effect.Effect<
  PostLinksResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostLinksRequest,
  output: PostLinksResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostMarkdownRequest {
  account_id: string;
  cacheTTL?: number;
  body: unknown;
}

export const PostMarkdownRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  cacheTTL: Schema.optional(Schema.Number).pipe(T.HttpQuery("cacheTTL")),
  body: Schema.Union(Schema.Struct({
  actionTimeout: Schema.optional(Schema.Number),
  addScriptTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  addStyleTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  allowRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  allowResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  authenticate: Schema.optional(Schema.Struct({
  password: Schema.String,
  username: Schema.String
})),
  bestAttempt: Schema.optional(Schema.Boolean),
  cookies: Schema.optional(Schema.Array(Schema.Struct({
  domain: Schema.optional(Schema.String),
  expires: Schema.optional(Schema.Number),
  httpOnly: Schema.optional(Schema.Boolean),
  name: Schema.String,
  partitionKey: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Union(Schema.Literal("Low"), Schema.Literal("Medium"), Schema.Literal("High"))),
  sameParty: Schema.optional(Schema.Boolean),
  sameSite: Schema.optional(Schema.Union(Schema.Literal("Strict"), Schema.Literal("Lax"), Schema.Literal("None"))),
  secure: Schema.optional(Schema.Boolean),
  sourcePort: Schema.optional(Schema.Number),
  sourceScheme: Schema.optional(Schema.Union(Schema.Literal("Unset"), Schema.Literal("NonSecure"), Schema.Literal("Secure"))),
  url: Schema.optional(Schema.String),
  value: Schema.String
}))),
  emulateMediaType: Schema.optional(Schema.String),
  gotoOptions: Schema.optional(Schema.Struct({
  referer: Schema.optional(Schema.String),
  referrerPolicy: Schema.optional(Schema.String),
  timeout: Schema.optional(Schema.Number),
  waitUntil: Schema.optional(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2"), Schema.Array(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2")))))
})),
  rejectRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  rejectResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  setExtraHTTPHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  setJavaScriptEnabled: Schema.optional(Schema.Boolean),
  url: Schema.String,
  userAgent: Schema.optional(Schema.String),
  viewport: Schema.optional(Schema.Struct({
  deviceScaleFactor: Schema.optional(Schema.Number),
  hasTouch: Schema.optional(Schema.Boolean),
  height: Schema.Number,
  isLandscape: Schema.optional(Schema.Boolean),
  isMobile: Schema.optional(Schema.Boolean),
  width: Schema.Number
})),
  waitForSelector: Schema.optional(Schema.Struct({
  hidden: Schema.optional(Schema.Literal(true)),
  selector: Schema.String,
  timeout: Schema.optional(Schema.Number),
  visible: Schema.optional(Schema.Literal(true))
})),
  waitForTimeout: Schema.optional(Schema.Number)
}), Schema.Struct({
  actionTimeout: Schema.optional(Schema.Number),
  addScriptTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  addStyleTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  allowRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  allowResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  authenticate: Schema.optional(Schema.Struct({
  password: Schema.String,
  username: Schema.String
})),
  bestAttempt: Schema.optional(Schema.Boolean),
  cookies: Schema.optional(Schema.Array(Schema.Struct({
  domain: Schema.optional(Schema.String),
  expires: Schema.optional(Schema.Number),
  httpOnly: Schema.optional(Schema.Boolean),
  name: Schema.String,
  partitionKey: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Union(Schema.Literal("Low"), Schema.Literal("Medium"), Schema.Literal("High"))),
  sameParty: Schema.optional(Schema.Boolean),
  sameSite: Schema.optional(Schema.Union(Schema.Literal("Strict"), Schema.Literal("Lax"), Schema.Literal("None"))),
  secure: Schema.optional(Schema.Boolean),
  sourcePort: Schema.optional(Schema.Number),
  sourceScheme: Schema.optional(Schema.Union(Schema.Literal("Unset"), Schema.Literal("NonSecure"), Schema.Literal("Secure"))),
  url: Schema.optional(Schema.String),
  value: Schema.String
}))),
  emulateMediaType: Schema.optional(Schema.String),
  gotoOptions: Schema.optional(Schema.Struct({
  referer: Schema.optional(Schema.String),
  referrerPolicy: Schema.optional(Schema.String),
  timeout: Schema.optional(Schema.Number),
  waitUntil: Schema.optional(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2"), Schema.Array(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2")))))
})),
  html: Schema.String,
  rejectRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  rejectResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  setExtraHTTPHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  setJavaScriptEnabled: Schema.optional(Schema.Boolean),
  userAgent: Schema.optional(Schema.String),
  viewport: Schema.optional(Schema.Struct({
  deviceScaleFactor: Schema.optional(Schema.Number),
  hasTouch: Schema.optional(Schema.Boolean),
  height: Schema.Number,
  isLandscape: Schema.optional(Schema.Boolean),
  isMobile: Schema.optional(Schema.Boolean),
  width: Schema.Number
})),
  waitForSelector: Schema.optional(Schema.Struct({
  hidden: Schema.optional(Schema.Literal(true)),
  selector: Schema.String,
  timeout: Schema.optional(Schema.Number),
  visible: Schema.optional(Schema.Literal(true))
})),
  waitForTimeout: Schema.optional(Schema.Number)
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/browser-rendering/markdown" }),
).annotations({ identifier: "PostMarkdownRequest" }) as unknown as Schema.Schema<PostMarkdownRequest>;

export interface PostMarkdownResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostMarkdownResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostMarkdownResponse" }) as unknown as Schema.Schema<PostMarkdownResponse>;

export const postMarkdown: (
  input: PostMarkdownRequest
) => Effect.Effect<
  PostMarkdownResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostMarkdownRequest,
  output: PostMarkdownResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostPdfRequest {
  account_id: string;
  cacheTTL?: number;
  body: unknown;
}

export const PostPdfRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  cacheTTL: Schema.optional(Schema.Number).pipe(T.HttpQuery("cacheTTL")),
  body: Schema.Union(Schema.Struct({
  actionTimeout: Schema.optional(Schema.Number),
  addScriptTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  addStyleTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  allowRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  allowResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  authenticate: Schema.optional(Schema.Struct({
  password: Schema.String,
  username: Schema.String
})),
  bestAttempt: Schema.optional(Schema.Boolean),
  cookies: Schema.optional(Schema.Array(Schema.Struct({
  domain: Schema.optional(Schema.String),
  expires: Schema.optional(Schema.Number),
  httpOnly: Schema.optional(Schema.Boolean),
  name: Schema.String,
  partitionKey: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Union(Schema.Literal("Low"), Schema.Literal("Medium"), Schema.Literal("High"))),
  sameParty: Schema.optional(Schema.Boolean),
  sameSite: Schema.optional(Schema.Union(Schema.Literal("Strict"), Schema.Literal("Lax"), Schema.Literal("None"))),
  secure: Schema.optional(Schema.Boolean),
  sourcePort: Schema.optional(Schema.Number),
  sourceScheme: Schema.optional(Schema.Union(Schema.Literal("Unset"), Schema.Literal("NonSecure"), Schema.Literal("Secure"))),
  url: Schema.optional(Schema.String),
  value: Schema.String
}))),
  emulateMediaType: Schema.optional(Schema.String),
  gotoOptions: Schema.optional(Schema.Struct({
  referer: Schema.optional(Schema.String),
  referrerPolicy: Schema.optional(Schema.String),
  timeout: Schema.optional(Schema.Number),
  waitUntil: Schema.optional(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2"), Schema.Array(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2")))))
})),
  html: Schema.String,
  pdfOptions: Schema.optional(Schema.Struct({
  displayHeaderFooter: Schema.optional(Schema.Boolean),
  footerTemplate: Schema.optional(Schema.String),
  format: Schema.optional(Schema.Literal("letter", "legal", "tabloid", "ledger", "a0", "a1", "a2", "a3", "a4", "a5", "a6")),
  headerTemplate: Schema.optional(Schema.String),
  height: Schema.optional(Schema.Union(Schema.String, Schema.Number)),
  landscape: Schema.optional(Schema.Boolean),
  margin: Schema.optional(Schema.Struct({
  bottom: Schema.optional(Schema.Union(Schema.String, Schema.Number)),
  left: Schema.optional(Schema.Union(Schema.String, Schema.Number)),
  right: Schema.optional(Schema.Union(Schema.String, Schema.Number)),
  top: Schema.optional(Schema.Union(Schema.String, Schema.Number))
})),
  omitBackground: Schema.optional(Schema.Boolean),
  outline: Schema.optional(Schema.Boolean),
  pageRanges: Schema.optional(Schema.String),
  preferCSSPageSize: Schema.optional(Schema.Boolean),
  printBackground: Schema.optional(Schema.Boolean),
  scale: Schema.optional(Schema.Number),
  tagged: Schema.optional(Schema.Boolean),
  timeout: Schema.optional(Schema.Number),
  width: Schema.optional(Schema.Union(Schema.String, Schema.Number))
})),
  rejectRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  rejectResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  setExtraHTTPHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  setJavaScriptEnabled: Schema.optional(Schema.Boolean),
  userAgent: Schema.optional(Schema.String),
  viewport: Schema.optional(Schema.Struct({
  deviceScaleFactor: Schema.optional(Schema.Number),
  hasTouch: Schema.optional(Schema.Boolean),
  height: Schema.Number,
  isLandscape: Schema.optional(Schema.Boolean),
  isMobile: Schema.optional(Schema.Boolean),
  width: Schema.Number
})),
  waitForSelector: Schema.optional(Schema.Struct({
  hidden: Schema.optional(Schema.Literal(true)),
  selector: Schema.String,
  timeout: Schema.optional(Schema.Number),
  visible: Schema.optional(Schema.Literal(true))
})),
  waitForTimeout: Schema.optional(Schema.Number)
}), Schema.Struct({
  actionTimeout: Schema.optional(Schema.Number),
  addScriptTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  addStyleTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  allowRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  allowResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  authenticate: Schema.optional(Schema.Struct({
  password: Schema.String,
  username: Schema.String
})),
  bestAttempt: Schema.optional(Schema.Boolean),
  cookies: Schema.optional(Schema.Array(Schema.Struct({
  domain: Schema.optional(Schema.String),
  expires: Schema.optional(Schema.Number),
  httpOnly: Schema.optional(Schema.Boolean),
  name: Schema.String,
  partitionKey: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Union(Schema.Literal("Low"), Schema.Literal("Medium"), Schema.Literal("High"))),
  sameParty: Schema.optional(Schema.Boolean),
  sameSite: Schema.optional(Schema.Union(Schema.Literal("Strict"), Schema.Literal("Lax"), Schema.Literal("None"))),
  secure: Schema.optional(Schema.Boolean),
  sourcePort: Schema.optional(Schema.Number),
  sourceScheme: Schema.optional(Schema.Union(Schema.Literal("Unset"), Schema.Literal("NonSecure"), Schema.Literal("Secure"))),
  url: Schema.optional(Schema.String),
  value: Schema.String
}))),
  emulateMediaType: Schema.optional(Schema.String),
  gotoOptions: Schema.optional(Schema.Struct({
  referer: Schema.optional(Schema.String),
  referrerPolicy: Schema.optional(Schema.String),
  timeout: Schema.optional(Schema.Number),
  waitUntil: Schema.optional(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2"), Schema.Array(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2")))))
})),
  pdfOptions: Schema.optional(Schema.Struct({
  displayHeaderFooter: Schema.optional(Schema.Boolean),
  footerTemplate: Schema.optional(Schema.String),
  format: Schema.optional(Schema.Literal("letter", "legal", "tabloid", "ledger", "a0", "a1", "a2", "a3", "a4", "a5", "a6")),
  headerTemplate: Schema.optional(Schema.String),
  height: Schema.optional(Schema.Union(Schema.String, Schema.Number)),
  landscape: Schema.optional(Schema.Boolean),
  margin: Schema.optional(Schema.Struct({
  bottom: Schema.optional(Schema.Union(Schema.String, Schema.Number)),
  left: Schema.optional(Schema.Union(Schema.String, Schema.Number)),
  right: Schema.optional(Schema.Union(Schema.String, Schema.Number)),
  top: Schema.optional(Schema.Union(Schema.String, Schema.Number))
})),
  omitBackground: Schema.optional(Schema.Boolean),
  outline: Schema.optional(Schema.Boolean),
  pageRanges: Schema.optional(Schema.String),
  preferCSSPageSize: Schema.optional(Schema.Boolean),
  printBackground: Schema.optional(Schema.Boolean),
  scale: Schema.optional(Schema.Number),
  tagged: Schema.optional(Schema.Boolean),
  timeout: Schema.optional(Schema.Number),
  width: Schema.optional(Schema.Union(Schema.String, Schema.Number))
})),
  rejectRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  rejectResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  setExtraHTTPHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  setJavaScriptEnabled: Schema.optional(Schema.Boolean),
  url: Schema.String,
  userAgent: Schema.optional(Schema.String),
  viewport: Schema.optional(Schema.Struct({
  deviceScaleFactor: Schema.optional(Schema.Number),
  hasTouch: Schema.optional(Schema.Boolean),
  height: Schema.Number,
  isLandscape: Schema.optional(Schema.Boolean),
  isMobile: Schema.optional(Schema.Boolean),
  width: Schema.Number
})),
  waitForSelector: Schema.optional(Schema.Struct({
  hidden: Schema.optional(Schema.Literal(true)),
  selector: Schema.String,
  timeout: Schema.optional(Schema.Number),
  visible: Schema.optional(Schema.Literal(true))
})),
  waitForTimeout: Schema.optional(Schema.Number)
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/browser-rendering/pdf" }),
).annotations({ identifier: "PostPdfRequest" }) as unknown as Schema.Schema<PostPdfRequest>;

export interface PostPdfResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostPdfResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostPdfResponse" }) as unknown as Schema.Schema<PostPdfResponse>;

export const postPdf: (
  input: PostPdfRequest
) => Effect.Effect<
  PostPdfResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostPdfRequest,
  output: PostPdfResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostScrapeRequest {
  account_id: string;
  cacheTTL?: number;
  body: unknown;
}

export const PostScrapeRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  cacheTTL: Schema.optional(Schema.Number).pipe(T.HttpQuery("cacheTTL")),
  body: Schema.Union(Schema.Struct({
  actionTimeout: Schema.optional(Schema.Number),
  addScriptTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  addStyleTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  allowRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  allowResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  authenticate: Schema.optional(Schema.Struct({
  password: Schema.String,
  username: Schema.String
})),
  bestAttempt: Schema.optional(Schema.Boolean),
  cookies: Schema.optional(Schema.Array(Schema.Struct({
  domain: Schema.optional(Schema.String),
  expires: Schema.optional(Schema.Number),
  httpOnly: Schema.optional(Schema.Boolean),
  name: Schema.String,
  partitionKey: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Union(Schema.Literal("Low"), Schema.Literal("Medium"), Schema.Literal("High"))),
  sameParty: Schema.optional(Schema.Boolean),
  sameSite: Schema.optional(Schema.Union(Schema.Literal("Strict"), Schema.Literal("Lax"), Schema.Literal("None"))),
  secure: Schema.optional(Schema.Boolean),
  sourcePort: Schema.optional(Schema.Number),
  sourceScheme: Schema.optional(Schema.Union(Schema.Literal("Unset"), Schema.Literal("NonSecure"), Schema.Literal("Secure"))),
  url: Schema.optional(Schema.String),
  value: Schema.String
}))),
  elements: Schema.Array(Schema.Struct({
  selector: Schema.String
})),
  emulateMediaType: Schema.optional(Schema.String),
  gotoOptions: Schema.optional(Schema.Struct({
  referer: Schema.optional(Schema.String),
  referrerPolicy: Schema.optional(Schema.String),
  timeout: Schema.optional(Schema.Number),
  waitUntil: Schema.optional(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2"), Schema.Array(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2")))))
})),
  html: Schema.String,
  rejectRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  rejectResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  setExtraHTTPHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  setJavaScriptEnabled: Schema.optional(Schema.Boolean),
  userAgent: Schema.optional(Schema.String),
  viewport: Schema.optional(Schema.Struct({
  deviceScaleFactor: Schema.optional(Schema.Number),
  hasTouch: Schema.optional(Schema.Boolean),
  height: Schema.Number,
  isLandscape: Schema.optional(Schema.Boolean),
  isMobile: Schema.optional(Schema.Boolean),
  width: Schema.Number
})),
  waitForSelector: Schema.optional(Schema.Struct({
  hidden: Schema.optional(Schema.Literal(true)),
  selector: Schema.String,
  timeout: Schema.optional(Schema.Number),
  visible: Schema.optional(Schema.Literal(true))
})),
  waitForTimeout: Schema.optional(Schema.Number)
}), Schema.Struct({
  actionTimeout: Schema.optional(Schema.Number),
  addScriptTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  addStyleTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  allowRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  allowResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  authenticate: Schema.optional(Schema.Struct({
  password: Schema.String,
  username: Schema.String
})),
  bestAttempt: Schema.optional(Schema.Boolean),
  cookies: Schema.optional(Schema.Array(Schema.Struct({
  domain: Schema.optional(Schema.String),
  expires: Schema.optional(Schema.Number),
  httpOnly: Schema.optional(Schema.Boolean),
  name: Schema.String,
  partitionKey: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Union(Schema.Literal("Low"), Schema.Literal("Medium"), Schema.Literal("High"))),
  sameParty: Schema.optional(Schema.Boolean),
  sameSite: Schema.optional(Schema.Union(Schema.Literal("Strict"), Schema.Literal("Lax"), Schema.Literal("None"))),
  secure: Schema.optional(Schema.Boolean),
  sourcePort: Schema.optional(Schema.Number),
  sourceScheme: Schema.optional(Schema.Union(Schema.Literal("Unset"), Schema.Literal("NonSecure"), Schema.Literal("Secure"))),
  url: Schema.optional(Schema.String),
  value: Schema.String
}))),
  elements: Schema.Array(Schema.Struct({
  selector: Schema.String
})),
  emulateMediaType: Schema.optional(Schema.String),
  gotoOptions: Schema.optional(Schema.Struct({
  referer: Schema.optional(Schema.String),
  referrerPolicy: Schema.optional(Schema.String),
  timeout: Schema.optional(Schema.Number),
  waitUntil: Schema.optional(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2"), Schema.Array(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2")))))
})),
  rejectRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  rejectResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  setExtraHTTPHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  setJavaScriptEnabled: Schema.optional(Schema.Boolean),
  url: Schema.String,
  userAgent: Schema.optional(Schema.String),
  viewport: Schema.optional(Schema.Struct({
  deviceScaleFactor: Schema.optional(Schema.Number),
  hasTouch: Schema.optional(Schema.Boolean),
  height: Schema.Number,
  isLandscape: Schema.optional(Schema.Boolean),
  isMobile: Schema.optional(Schema.Boolean),
  width: Schema.Number
})),
  waitForSelector: Schema.optional(Schema.Struct({
  hidden: Schema.optional(Schema.Literal(true)),
  selector: Schema.String,
  timeout: Schema.optional(Schema.Number),
  visible: Schema.optional(Schema.Literal(true))
})),
  waitForTimeout: Schema.optional(Schema.Number)
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/browser-rendering/scrape" }),
).annotations({ identifier: "PostScrapeRequest" }) as unknown as Schema.Schema<PostScrapeRequest>;

export interface PostScrapeResponse {
  result: { results: { attributes: { name: string; value: string }[]; height: number; html: string; left: number; text: string; top: number; width: number }; selector: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostScrapeResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  results: Schema.Struct({
  attributes: Schema.Array(Schema.Struct({
  name: Schema.String,
  value: Schema.String
})),
  height: Schema.Number,
  html: Schema.String,
  left: Schema.Number,
  text: Schema.String,
  top: Schema.Number,
  width: Schema.Number
}),
  selector: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostScrapeResponse" }) as unknown as Schema.Schema<PostScrapeResponse>;

export const postScrape: (
  input: PostScrapeRequest
) => Effect.Effect<
  PostScrapeResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostScrapeRequest,
  output: PostScrapeResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostScreenshotRequest {
  account_id: string;
  cacheTTL?: number;
  body: unknown;
}

export const PostScreenshotRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  cacheTTL: Schema.optional(Schema.Number).pipe(T.HttpQuery("cacheTTL")),
  body: Schema.Union(Schema.Struct({
  actionTimeout: Schema.optional(Schema.Number),
  addScriptTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  addStyleTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  allowRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  allowResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  authenticate: Schema.optional(Schema.Struct({
  password: Schema.String,
  username: Schema.String
})),
  bestAttempt: Schema.optional(Schema.Boolean),
  cookies: Schema.optional(Schema.Array(Schema.Struct({
  domain: Schema.optional(Schema.String),
  expires: Schema.optional(Schema.Number),
  httpOnly: Schema.optional(Schema.Boolean),
  name: Schema.String,
  partitionKey: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Union(Schema.Literal("Low"), Schema.Literal("Medium"), Schema.Literal("High"))),
  sameParty: Schema.optional(Schema.Boolean),
  sameSite: Schema.optional(Schema.Union(Schema.Literal("Strict"), Schema.Literal("Lax"), Schema.Literal("None"))),
  secure: Schema.optional(Schema.Boolean),
  sourcePort: Schema.optional(Schema.Number),
  sourceScheme: Schema.optional(Schema.Union(Schema.Literal("Unset"), Schema.Literal("NonSecure"), Schema.Literal("Secure"))),
  url: Schema.optional(Schema.String),
  value: Schema.String
}))),
  emulateMediaType: Schema.optional(Schema.String),
  gotoOptions: Schema.optional(Schema.Struct({
  referer: Schema.optional(Schema.String),
  referrerPolicy: Schema.optional(Schema.String),
  timeout: Schema.optional(Schema.Number),
  waitUntil: Schema.optional(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2"), Schema.Array(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2")))))
})),
  html: Schema.String,
  rejectRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  rejectResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  screenshotOptions: Schema.optional(Schema.Struct({
  captureBeyondViewport: Schema.optional(Schema.Boolean),
  clip: Schema.optional(Schema.Struct({
  height: Schema.Number,
  scale: Schema.optional(Schema.Number),
  width: Schema.Number,
  x: Schema.Number,
  y: Schema.Number
})),
  encoding: Schema.optional(Schema.Union(Schema.Literal("binary"), Schema.Literal("base64"))),
  fromSurface: Schema.optional(Schema.Boolean),
  fullPage: Schema.optional(Schema.Boolean),
  omitBackground: Schema.optional(Schema.Boolean),
  optimizeForSpeed: Schema.optional(Schema.Boolean),
  quality: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Union(Schema.Literal("png"), Schema.Literal("jpeg"), Schema.Literal("webp")))
})),
  scrollPage: Schema.optional(Schema.Boolean),
  selector: Schema.optional(Schema.String),
  setExtraHTTPHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  setJavaScriptEnabled: Schema.optional(Schema.Boolean),
  userAgent: Schema.optional(Schema.String),
  viewport: Schema.optional(Schema.Struct({
  deviceScaleFactor: Schema.optional(Schema.Number),
  hasTouch: Schema.optional(Schema.Boolean),
  height: Schema.Number,
  isLandscape: Schema.optional(Schema.Boolean),
  isMobile: Schema.optional(Schema.Boolean),
  width: Schema.Number
})),
  waitForSelector: Schema.optional(Schema.Struct({
  hidden: Schema.optional(Schema.Literal(true)),
  selector: Schema.String,
  timeout: Schema.optional(Schema.Number),
  visible: Schema.optional(Schema.Literal(true))
})),
  waitForTimeout: Schema.optional(Schema.Number)
}), Schema.Struct({
  actionTimeout: Schema.optional(Schema.Number),
  addScriptTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  addStyleTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  allowRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  allowResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  authenticate: Schema.optional(Schema.Struct({
  password: Schema.String,
  username: Schema.String
})),
  bestAttempt: Schema.optional(Schema.Boolean),
  cookies: Schema.optional(Schema.Array(Schema.Struct({
  domain: Schema.optional(Schema.String),
  expires: Schema.optional(Schema.Number),
  httpOnly: Schema.optional(Schema.Boolean),
  name: Schema.String,
  partitionKey: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Union(Schema.Literal("Low"), Schema.Literal("Medium"), Schema.Literal("High"))),
  sameParty: Schema.optional(Schema.Boolean),
  sameSite: Schema.optional(Schema.Union(Schema.Literal("Strict"), Schema.Literal("Lax"), Schema.Literal("None"))),
  secure: Schema.optional(Schema.Boolean),
  sourcePort: Schema.optional(Schema.Number),
  sourceScheme: Schema.optional(Schema.Union(Schema.Literal("Unset"), Schema.Literal("NonSecure"), Schema.Literal("Secure"))),
  url: Schema.optional(Schema.String),
  value: Schema.String
}))),
  emulateMediaType: Schema.optional(Schema.String),
  gotoOptions: Schema.optional(Schema.Struct({
  referer: Schema.optional(Schema.String),
  referrerPolicy: Schema.optional(Schema.String),
  timeout: Schema.optional(Schema.Number),
  waitUntil: Schema.optional(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2"), Schema.Array(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2")))))
})),
  rejectRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  rejectResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  screenshotOptions: Schema.optional(Schema.Struct({
  captureBeyondViewport: Schema.optional(Schema.Boolean),
  clip: Schema.optional(Schema.Struct({
  height: Schema.Number,
  scale: Schema.optional(Schema.Number),
  width: Schema.Number,
  x: Schema.Number,
  y: Schema.Number
})),
  encoding: Schema.optional(Schema.Union(Schema.Literal("binary"), Schema.Literal("base64"))),
  fromSurface: Schema.optional(Schema.Boolean),
  fullPage: Schema.optional(Schema.Boolean),
  omitBackground: Schema.optional(Schema.Boolean),
  optimizeForSpeed: Schema.optional(Schema.Boolean),
  quality: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Union(Schema.Literal("png"), Schema.Literal("jpeg"), Schema.Literal("webp")))
})),
  scrollPage: Schema.optional(Schema.Boolean),
  selector: Schema.optional(Schema.String),
  setExtraHTTPHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  setJavaScriptEnabled: Schema.optional(Schema.Boolean),
  url: Schema.String,
  userAgent: Schema.optional(Schema.String),
  viewport: Schema.optional(Schema.Struct({
  deviceScaleFactor: Schema.optional(Schema.Number),
  hasTouch: Schema.optional(Schema.Boolean),
  height: Schema.Number,
  isLandscape: Schema.optional(Schema.Boolean),
  isMobile: Schema.optional(Schema.Boolean),
  width: Schema.Number
})),
  waitForSelector: Schema.optional(Schema.Struct({
  hidden: Schema.optional(Schema.Literal(true)),
  selector: Schema.String,
  timeout: Schema.optional(Schema.Number),
  visible: Schema.optional(Schema.Literal(true))
})),
  waitForTimeout: Schema.optional(Schema.Number)
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/browser-rendering/screenshot" }),
).annotations({ identifier: "PostScreenshotRequest" }) as unknown as Schema.Schema<PostScreenshotRequest>;

export interface PostScreenshotResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostScreenshotResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostScreenshotResponse" }) as unknown as Schema.Schema<PostScreenshotResponse>;

export const postScreenshot: (
  input: PostScreenshotRequest
) => Effect.Effect<
  PostScreenshotResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostScreenshotRequest,
  output: PostScreenshotResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostSnapshotRequest {
  account_id: string;
  cacheTTL?: number;
  body: unknown;
}

export const PostSnapshotRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  cacheTTL: Schema.optional(Schema.Number).pipe(T.HttpQuery("cacheTTL")),
  body: Schema.Union(Schema.Struct({
  actionTimeout: Schema.optional(Schema.Number),
  addScriptTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  addStyleTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  allowRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  allowResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  authenticate: Schema.optional(Schema.Struct({
  password: Schema.String,
  username: Schema.String
})),
  bestAttempt: Schema.optional(Schema.Boolean),
  cookies: Schema.optional(Schema.Array(Schema.Struct({
  domain: Schema.optional(Schema.String),
  expires: Schema.optional(Schema.Number),
  httpOnly: Schema.optional(Schema.Boolean),
  name: Schema.String,
  partitionKey: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Union(Schema.Literal("Low"), Schema.Literal("Medium"), Schema.Literal("High"))),
  sameParty: Schema.optional(Schema.Boolean),
  sameSite: Schema.optional(Schema.Union(Schema.Literal("Strict"), Schema.Literal("Lax"), Schema.Literal("None"))),
  secure: Schema.optional(Schema.Boolean),
  sourcePort: Schema.optional(Schema.Number),
  sourceScheme: Schema.optional(Schema.Union(Schema.Literal("Unset"), Schema.Literal("NonSecure"), Schema.Literal("Secure"))),
  url: Schema.optional(Schema.String),
  value: Schema.String
}))),
  emulateMediaType: Schema.optional(Schema.String),
  gotoOptions: Schema.optional(Schema.Struct({
  referer: Schema.optional(Schema.String),
  referrerPolicy: Schema.optional(Schema.String),
  timeout: Schema.optional(Schema.Number),
  waitUntil: Schema.optional(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2"), Schema.Array(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2")))))
})),
  html: Schema.String,
  rejectRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  rejectResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  screenshotOptions: Schema.optional(Schema.Struct({
  captureBeyondViewport: Schema.optional(Schema.Boolean),
  clip: Schema.optional(Schema.Struct({
  height: Schema.Number,
  scale: Schema.optional(Schema.Number),
  width: Schema.Number,
  x: Schema.Number,
  y: Schema.Number
})),
  fromSurface: Schema.optional(Schema.Boolean),
  fullPage: Schema.optional(Schema.Boolean),
  omitBackground: Schema.optional(Schema.Boolean),
  optimizeForSpeed: Schema.optional(Schema.Boolean),
  quality: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Union(Schema.Literal("png"), Schema.Literal("jpeg"), Schema.Literal("webp")))
})),
  setExtraHTTPHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  setJavaScriptEnabled: Schema.optional(Schema.Boolean),
  userAgent: Schema.optional(Schema.String),
  viewport: Schema.optional(Schema.Struct({
  deviceScaleFactor: Schema.optional(Schema.Number),
  hasTouch: Schema.optional(Schema.Boolean),
  height: Schema.Number,
  isLandscape: Schema.optional(Schema.Boolean),
  isMobile: Schema.optional(Schema.Boolean),
  width: Schema.Number
})),
  waitForSelector: Schema.optional(Schema.Struct({
  hidden: Schema.optional(Schema.Literal(true)),
  selector: Schema.String,
  timeout: Schema.optional(Schema.Number),
  visible: Schema.optional(Schema.Literal(true))
})),
  waitForTimeout: Schema.optional(Schema.Number)
}), Schema.Struct({
  actionTimeout: Schema.optional(Schema.Number),
  addScriptTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  addStyleTag: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}))),
  allowRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  allowResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  authenticate: Schema.optional(Schema.Struct({
  password: Schema.String,
  username: Schema.String
})),
  bestAttempt: Schema.optional(Schema.Boolean),
  cookies: Schema.optional(Schema.Array(Schema.Struct({
  domain: Schema.optional(Schema.String),
  expires: Schema.optional(Schema.Number),
  httpOnly: Schema.optional(Schema.Boolean),
  name: Schema.String,
  partitionKey: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Union(Schema.Literal("Low"), Schema.Literal("Medium"), Schema.Literal("High"))),
  sameParty: Schema.optional(Schema.Boolean),
  sameSite: Schema.optional(Schema.Union(Schema.Literal("Strict"), Schema.Literal("Lax"), Schema.Literal("None"))),
  secure: Schema.optional(Schema.Boolean),
  sourcePort: Schema.optional(Schema.Number),
  sourceScheme: Schema.optional(Schema.Union(Schema.Literal("Unset"), Schema.Literal("NonSecure"), Schema.Literal("Secure"))),
  url: Schema.optional(Schema.String),
  value: Schema.String
}))),
  emulateMediaType: Schema.optional(Schema.String),
  gotoOptions: Schema.optional(Schema.Struct({
  referer: Schema.optional(Schema.String),
  referrerPolicy: Schema.optional(Schema.String),
  timeout: Schema.optional(Schema.Number),
  waitUntil: Schema.optional(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2"), Schema.Array(Schema.Union(Schema.Literal("load"), Schema.Literal("domcontentloaded"), Schema.Literal("networkidle0"), Schema.Literal("networkidle2")))))
})),
  rejectRequestPattern: Schema.optional(Schema.Array(Schema.String)),
  rejectResourceTypes: Schema.optional(Schema.Array(Schema.Union(Schema.Literal("document"), Schema.Literal("stylesheet"), Schema.Literal("image"), Schema.Literal("media"), Schema.Literal("font"), Schema.Literal("script"), Schema.Literal("texttrack"), Schema.Literal("xhr"), Schema.Literal("fetch"), Schema.Literal("prefetch"), Schema.Literal("eventsource"), Schema.Literal("websocket"), Schema.Literal("manifest"), Schema.Literal("signedexchange"), Schema.Literal("ping"), Schema.Literal("cspviolationreport"), Schema.Literal("preflight"), Schema.Literal("other")))),
  screenshotOptions: Schema.optional(Schema.Struct({
  captureBeyondViewport: Schema.optional(Schema.Boolean),
  clip: Schema.optional(Schema.Struct({
  height: Schema.Number,
  scale: Schema.optional(Schema.Number),
  width: Schema.Number,
  x: Schema.Number,
  y: Schema.Number
})),
  fromSurface: Schema.optional(Schema.Boolean),
  fullPage: Schema.optional(Schema.Boolean),
  omitBackground: Schema.optional(Schema.Boolean),
  optimizeForSpeed: Schema.optional(Schema.Boolean),
  quality: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Union(Schema.Literal("png"), Schema.Literal("jpeg"), Schema.Literal("webp")))
})),
  setExtraHTTPHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  setJavaScriptEnabled: Schema.optional(Schema.Boolean),
  url: Schema.String,
  userAgent: Schema.optional(Schema.String),
  viewport: Schema.optional(Schema.Struct({
  deviceScaleFactor: Schema.optional(Schema.Number),
  hasTouch: Schema.optional(Schema.Boolean),
  height: Schema.Number,
  isLandscape: Schema.optional(Schema.Boolean),
  isMobile: Schema.optional(Schema.Boolean),
  width: Schema.Number
})),
  waitForSelector: Schema.optional(Schema.Struct({
  hidden: Schema.optional(Schema.Literal(true)),
  selector: Schema.String,
  timeout: Schema.optional(Schema.Number),
  visible: Schema.optional(Schema.Literal(true))
})),
  waitForTimeout: Schema.optional(Schema.Number)
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/browser-rendering/snapshot" }),
).annotations({ identifier: "PostSnapshotRequest" }) as unknown as Schema.Schema<PostSnapshotRequest>;

export interface PostSnapshotResponse {
  result: { content: string; screenshot: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostSnapshotResponse = Schema.Struct({
  result: Schema.Struct({
  content: Schema.String,
  screenshot: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostSnapshotResponse" }) as unknown as Schema.Schema<PostSnapshotResponse>;

export const postSnapshot: (
  input: PostSnapshotRequest
) => Effect.Effect<
  PostSnapshotResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostSnapshotRequest,
  output: PostSnapshotResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetaccountlimitsRequest {
}

export const GetaccountlimitsRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/builds/account/limits" }),
).annotations({ identifier: "GetaccountlimitsRequest" }) as unknown as Schema.Schema<GetaccountlimitsRequest>;

export interface GetaccountlimitsResponse {
  result: { build_minutes_refresh_on?: string; has_reached_build_minutes_limit?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetaccountlimitsResponse = Schema.Struct({
  result: Schema.Struct({
  build_minutes_refresh_on: Schema.optional(Schema.Date),
  has_reached_build_minutes_limit: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetaccountlimitsResponse" }) as unknown as Schema.Schema<GetaccountlimitsResponse>;

export const getaccountlimits: (
  input: GetaccountlimitsRequest
) => Effect.Effect<
  GetaccountlimitsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetaccountlimitsRequest,
  output: GetaccountlimitsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetbuildsbyversionidsRequest {
  version_ids: string;
}

export const GetbuildsbyversionidsRequest = Schema.Struct({
  version_ids: Schema.String.pipe(T.HttpQuery("version_ids"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/builds/builds" }),
).annotations({ identifier: "GetbuildsbyversionidsRequest" }) as unknown as Schema.Schema<GetbuildsbyversionidsRequest>;

export interface GetbuildsbyversionidsResponse {
  result: { builds?: Record<string, unknown> };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetbuildsbyversionidsResponse = Schema.Struct({
  result: Schema.Struct({
  builds: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  build_outcome: Schema.optional(Schema.Literal("success", "fail", "skipped", "cancelled", "terminated")),
  build_trigger_metadata: Schema.optional(Schema.Struct({
  author: Schema.optional(Schema.String),
  branch: Schema.optional(Schema.String),
  build_command: Schema.optional(Schema.String),
  build_token_name: Schema.optional(Schema.String),
  build_token_uuid: Schema.optional(Schema.UUID),
  build_trigger_source: Schema.optional(Schema.Literal("push", "pull_request", "manual", "api")),
  commit_hash: Schema.optional(Schema.String),
  commit_message: Schema.optional(Schema.String),
  deploy_command: Schema.optional(Schema.String),
  environment_variables: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  provider_account_name: Schema.optional(Schema.String),
  provider_type: Schema.optional(Schema.Literal("github")),
  repo_name: Schema.optional(Schema.String),
  root_directory: Schema.optional(Schema.String)
})),
  build_uuid: Schema.optional(Schema.UUID),
  created_on: Schema.optional(Schema.Date),
  initializing_on: Schema.optional(Schema.Date),
  modified_on: Schema.optional(Schema.Date),
  pull_request: Schema.optional(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  pull_request_url: Schema.optional(Schema.String)
})),
  running_on: Schema.optional(Schema.Date),
  status: Schema.optional(Schema.Literal("queued", "initializing", "running", "stopped")),
  stopped_on: Schema.optional(Schema.Date),
  trigger: Schema.optional(Schema.Struct({
  branch_excludes: Schema.optional(Schema.Array(Schema.String)),
  branch_includes: Schema.optional(Schema.Array(Schema.String)),
  build_caching_enabled: Schema.optional(Schema.Boolean),
  build_command: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  deleted_on: Schema.optional(Schema.Date),
  deploy_command: Schema.optional(Schema.String),
  external_script_id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  path_excludes: Schema.optional(Schema.Array(Schema.String)),
  path_includes: Schema.optional(Schema.Array(Schema.String)),
  repo_connection: Schema.optional(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  deleted_on: Schema.optional(Schema.Date),
  modified_on: Schema.optional(Schema.Date),
  provider_account_id: Schema.optional(Schema.String),
  provider_account_name: Schema.optional(Schema.String),
  provider_type: Schema.optional(Schema.Literal("github")),
  repo_connection_uuid: Schema.optional(Schema.UUID),
  repo_id: Schema.optional(Schema.String),
  repo_name: Schema.optional(Schema.String)
})),
  root_directory: Schema.optional(Schema.String),
  trigger_name: Schema.optional(Schema.String),
  trigger_uuid: Schema.optional(Schema.UUID)
}))
}) }))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetbuildsbyversionidsResponse" }) as unknown as Schema.Schema<GetbuildsbyversionidsResponse>;

export const getbuildsbyversionids: (
  input: GetbuildsbyversionidsRequest
) => Effect.Effect<
  GetbuildsbyversionidsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetbuildsbyversionidsRequest,
  output: GetbuildsbyversionidsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetlatestbuildsbyscriptsRequest {
  external_script_ids: string;
}

export const GetlatestbuildsbyscriptsRequest = Schema.Struct({
  external_script_ids: Schema.String.pipe(T.HttpQuery("external_script_ids"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/builds/builds/latest" }),
).annotations({ identifier: "GetlatestbuildsbyscriptsRequest" }) as unknown as Schema.Schema<GetlatestbuildsbyscriptsRequest>;

export interface GetlatestbuildsbyscriptsResponse {
  result: { builds?: Record<string, unknown> };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetlatestbuildsbyscriptsResponse = Schema.Struct({
  result: Schema.Struct({
  builds: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  build_outcome: Schema.optional(Schema.Literal("success", "fail", "skipped", "cancelled", "terminated")),
  build_trigger_metadata: Schema.optional(Schema.Struct({
  author: Schema.optional(Schema.String),
  branch: Schema.optional(Schema.String),
  build_command: Schema.optional(Schema.String),
  build_token_name: Schema.optional(Schema.String),
  build_token_uuid: Schema.optional(Schema.UUID),
  build_trigger_source: Schema.optional(Schema.Literal("push", "pull_request", "manual", "api")),
  commit_hash: Schema.optional(Schema.String),
  commit_message: Schema.optional(Schema.String),
  deploy_command: Schema.optional(Schema.String),
  environment_variables: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  provider_account_name: Schema.optional(Schema.String),
  provider_type: Schema.optional(Schema.Literal("github")),
  repo_name: Schema.optional(Schema.String),
  root_directory: Schema.optional(Schema.String)
})),
  build_uuid: Schema.optional(Schema.UUID),
  created_on: Schema.optional(Schema.Date),
  initializing_on: Schema.optional(Schema.Date),
  modified_on: Schema.optional(Schema.Date),
  pull_request: Schema.optional(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  pull_request_url: Schema.optional(Schema.String)
})),
  running_on: Schema.optional(Schema.Date),
  status: Schema.optional(Schema.Literal("queued", "initializing", "running", "stopped")),
  stopped_on: Schema.optional(Schema.Date),
  trigger: Schema.optional(Schema.Struct({
  branch_excludes: Schema.optional(Schema.Array(Schema.String)),
  branch_includes: Schema.optional(Schema.Array(Schema.String)),
  build_caching_enabled: Schema.optional(Schema.Boolean),
  build_command: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  deleted_on: Schema.optional(Schema.Date),
  deploy_command: Schema.optional(Schema.String),
  external_script_id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  path_excludes: Schema.optional(Schema.Array(Schema.String)),
  path_includes: Schema.optional(Schema.Array(Schema.String)),
  repo_connection: Schema.optional(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  deleted_on: Schema.optional(Schema.Date),
  modified_on: Schema.optional(Schema.Date),
  provider_account_id: Schema.optional(Schema.String),
  provider_account_name: Schema.optional(Schema.String),
  provider_type: Schema.optional(Schema.Literal("github")),
  repo_connection_uuid: Schema.optional(Schema.UUID),
  repo_id: Schema.optional(Schema.String),
  repo_name: Schema.optional(Schema.String)
})),
  root_directory: Schema.optional(Schema.String),
  trigger_name: Schema.optional(Schema.String),
  trigger_uuid: Schema.optional(Schema.UUID)
}))
}) }))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetlatestbuildsbyscriptsResponse" }) as unknown as Schema.Schema<GetlatestbuildsbyscriptsResponse>;

export const getlatestbuildsbyscripts: (
  input: GetlatestbuildsbyscriptsRequest
) => Effect.Effect<
  GetlatestbuildsbyscriptsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetlatestbuildsbyscriptsRequest,
  output: GetlatestbuildsbyscriptsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetbuildbyuuidRequest {
}

export const GetbuildbyuuidRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/builds/builds/{build_uuid}" }),
).annotations({ identifier: "GetbuildbyuuidRequest" }) as unknown as Schema.Schema<GetbuildbyuuidRequest>;

export interface GetbuildbyuuidResponse {
  result: { build_outcome?: "success" | "fail" | "skipped" | "cancelled" | "terminated"; build_trigger_metadata?: { author?: string; branch?: string; build_command?: string; build_token_name?: string; build_token_uuid?: string; build_trigger_source?: "push" | "pull_request" | "manual" | "api"; commit_hash?: string; commit_message?: string; deploy_command?: string; environment_variables?: Record<string, unknown>; provider_account_name?: string; provider_type?: "github"; repo_name?: string; root_directory?: string }; build_uuid?: string; created_on?: string; initializing_on?: string; modified_on?: string; pull_request?: { created_on?: string; pull_request_url?: string }; running_on?: string; status?: "queued" | "initializing" | "running" | "stopped"; stopped_on?: string; trigger?: { branch_excludes?: string[]; branch_includes?: string[]; build_caching_enabled?: boolean; build_command?: string; created_on?: string; deleted_on?: string; deploy_command?: string; external_script_id?: string; modified_on?: string; path_excludes?: string[]; path_includes?: string[]; repo_connection?: { created_on?: string; deleted_on?: string; modified_on?: string; provider_account_id?: string; provider_account_name?: string; provider_type?: "github"; repo_connection_uuid?: string; repo_id?: string; repo_name?: string }; root_directory?: string; trigger_name?: string; trigger_uuid?: string } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetbuildbyuuidResponse = Schema.Struct({
  result: Schema.Struct({
  build_outcome: Schema.optional(Schema.Literal("success", "fail", "skipped", "cancelled", "terminated")),
  build_trigger_metadata: Schema.optional(Schema.Struct({
  author: Schema.optional(Schema.String),
  branch: Schema.optional(Schema.String),
  build_command: Schema.optional(Schema.String),
  build_token_name: Schema.optional(Schema.String),
  build_token_uuid: Schema.optional(Schema.UUID),
  build_trigger_source: Schema.optional(Schema.Literal("push", "pull_request", "manual", "api")),
  commit_hash: Schema.optional(Schema.String),
  commit_message: Schema.optional(Schema.String),
  deploy_command: Schema.optional(Schema.String),
  environment_variables: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  provider_account_name: Schema.optional(Schema.String),
  provider_type: Schema.optional(Schema.Literal("github")),
  repo_name: Schema.optional(Schema.String),
  root_directory: Schema.optional(Schema.String)
})),
  build_uuid: Schema.optional(Schema.UUID),
  created_on: Schema.optional(Schema.Date),
  initializing_on: Schema.optional(Schema.Date),
  modified_on: Schema.optional(Schema.Date),
  pull_request: Schema.optional(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  pull_request_url: Schema.optional(Schema.String)
})),
  running_on: Schema.optional(Schema.Date),
  status: Schema.optional(Schema.Literal("queued", "initializing", "running", "stopped")),
  stopped_on: Schema.optional(Schema.Date),
  trigger: Schema.optional(Schema.Struct({
  branch_excludes: Schema.optional(Schema.Array(Schema.String)),
  branch_includes: Schema.optional(Schema.Array(Schema.String)),
  build_caching_enabled: Schema.optional(Schema.Boolean),
  build_command: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  deleted_on: Schema.optional(Schema.Date),
  deploy_command: Schema.optional(Schema.String),
  external_script_id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  path_excludes: Schema.optional(Schema.Array(Schema.String)),
  path_includes: Schema.optional(Schema.Array(Schema.String)),
  repo_connection: Schema.optional(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  deleted_on: Schema.optional(Schema.Date),
  modified_on: Schema.optional(Schema.Date),
  provider_account_id: Schema.optional(Schema.String),
  provider_account_name: Schema.optional(Schema.String),
  provider_type: Schema.optional(Schema.Literal("github")),
  repo_connection_uuid: Schema.optional(Schema.UUID),
  repo_id: Schema.optional(Schema.String),
  repo_name: Schema.optional(Schema.String)
})),
  root_directory: Schema.optional(Schema.String),
  trigger_name: Schema.optional(Schema.String),
  trigger_uuid: Schema.optional(Schema.UUID)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetbuildbyuuidResponse" }) as unknown as Schema.Schema<GetbuildbyuuidResponse>;

export const getbuildbyuuid: (
  input: GetbuildbyuuidRequest
) => Effect.Effect<
  GetbuildbyuuidResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetbuildbyuuidRequest,
  output: GetbuildbyuuidResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CancelbuildbyuuidRequest {
}

export const CancelbuildbyuuidRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/builds/builds/{build_uuid}/cancel" }),
).annotations({ identifier: "CancelbuildbyuuidRequest" }) as unknown as Schema.Schema<CancelbuildbyuuidRequest>;

export interface CancelbuildbyuuidResponse {
  result: { build_outcome?: "success" | "fail" | "skipped" | "cancelled" | "terminated"; build_uuid?: string; stopped_on?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CancelbuildbyuuidResponse = Schema.Struct({
  result: Schema.Struct({
  build_outcome: Schema.optional(Schema.Literal("success", "fail", "skipped", "cancelled", "terminated")),
  build_uuid: Schema.optional(Schema.UUID),
  stopped_on: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CancelbuildbyuuidResponse" }) as unknown as Schema.Schema<CancelbuildbyuuidResponse>;

export const cancelbuildbyuuid: (
  input: CancelbuildbyuuidRequest
) => Effect.Effect<
  CancelbuildbyuuidResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CancelbuildbyuuidRequest,
  output: CancelbuildbyuuidResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetbuildlogsRequest {
  cursor?: string;
}

export const GetbuildlogsRequest = Schema.Struct({
  cursor: Schema.optional(Schema.String).pipe(T.HttpQuery("cursor"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/builds/builds/{build_uuid}/logs" }),
).annotations({ identifier: "GetbuildlogsRequest" }) as unknown as Schema.Schema<GetbuildlogsRequest>;

export interface GetbuildlogsResponse {
  result: { cursor?: string; lines?: unknown[][]; truncated?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetbuildlogsResponse = Schema.Struct({
  result: Schema.Struct({
  cursor: Schema.optional(Schema.String),
  lines: Schema.optional(Schema.Array(Schema.Array(Schema.Union(Schema.Number, Schema.String)))),
  truncated: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetbuildlogsResponse" }) as unknown as Schema.Schema<GetbuildlogsResponse>;

export const getbuildlogs: (
  input: GetbuildlogsRequest
) => Effect.Effect<
  GetbuildlogsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetbuildlogsRequest,
  output: GetbuildlogsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpsertrepoconnectionRequest {
  body: { provider_account_id: string; provider_account_name: string; provider_type: "github"; repo_id: string; repo_name: string };
}

export const UpsertrepoconnectionRequest = Schema.Struct({
  body: Schema.Struct({
  provider_account_id: Schema.String,
  provider_account_name: Schema.String,
  provider_type: Schema.Literal("github"),
  repo_id: Schema.String,
  repo_name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/builds/repos/connections" }),
).annotations({ identifier: "UpsertrepoconnectionRequest" }) as unknown as Schema.Schema<UpsertrepoconnectionRequest>;

export interface UpsertrepoconnectionResponse {
  result: { created_on?: string; deleted_on?: string; modified_on?: string; provider_account_id?: string; provider_account_name?: string; provider_type?: "github"; repo_connection_uuid?: string; repo_id?: string; repo_name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpsertrepoconnectionResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  deleted_on: Schema.optional(Schema.Date),
  modified_on: Schema.optional(Schema.Date),
  provider_account_id: Schema.optional(Schema.String),
  provider_account_name: Schema.optional(Schema.String),
  provider_type: Schema.optional(Schema.Literal("github")),
  repo_connection_uuid: Schema.optional(Schema.UUID),
  repo_id: Schema.optional(Schema.String),
  repo_name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpsertrepoconnectionResponse" }) as unknown as Schema.Schema<UpsertrepoconnectionResponse>;

export const upsertrepoconnection: (
  input: UpsertrepoconnectionRequest
) => Effect.Effect<
  UpsertrepoconnectionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpsertrepoconnectionRequest,
  output: UpsertrepoconnectionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleterepoconnectionRequest {
}

export const DeleterepoconnectionRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/builds/repos/connections/{repo_connection_uuid}" }),
).annotations({ identifier: "DeleterepoconnectionRequest" }) as unknown as Schema.Schema<DeleterepoconnectionRequest>;

export interface DeleterepoconnectionResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleterepoconnectionResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleterepoconnectionResponse" }) as unknown as Schema.Schema<DeleterepoconnectionResponse>;

export const deleterepoconnection: (
  input: DeleterepoconnectionRequest
) => Effect.Effect<
  DeleterepoconnectionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleterepoconnectionRequest,
  output: DeleterepoconnectionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetworkerconfigautofillRequest {
  provider_type: "github";
  provider_account_id: string;
  repo_id: string;
  branch: string;
  root_directory?: string;
}

export const GetworkerconfigautofillRequest = Schema.Struct({
  provider_type: Schema.Literal("github").pipe(T.HttpPath("provider_type")),
  provider_account_id: Schema.String.pipe(T.HttpPath("provider_account_id")),
  repo_id: Schema.String.pipe(T.HttpPath("repo_id")),
  branch: Schema.String.pipe(T.HttpQuery("branch")),
  root_directory: Schema.optional(Schema.String).pipe(T.HttpQuery("root_directory"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/builds/repos/{provider_type}/{provider_account_id}/{repo_id}/config_autofill" }),
).annotations({ identifier: "GetworkerconfigautofillRequest" }) as unknown as Schema.Schema<GetworkerconfigautofillRequest>;

export interface GetworkerconfigautofillResponse {
  result: { config_file?: string; default_worker_name?: string; env_worker_names?: Record<string, unknown>; package_manager?: string; scripts?: Record<string, unknown> };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetworkerconfigautofillResponse = Schema.Struct({
  result: Schema.Struct({
  config_file: Schema.optional(Schema.String),
  default_worker_name: Schema.optional(Schema.String),
  env_worker_names: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  package_manager: Schema.optional(Schema.String),
  scripts: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String }))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetworkerconfigautofillResponse" }) as unknown as Schema.Schema<GetworkerconfigautofillResponse>;

export const getworkerconfigautofill: (
  input: GetworkerconfigautofillRequest
) => Effect.Effect<
  GetworkerconfigautofillResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetworkerconfigautofillRequest,
  output: GetworkerconfigautofillResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListbuildtokensRequest {
}

export const ListbuildtokensRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/builds/tokens" }),
).annotations({ identifier: "ListbuildtokensRequest" }) as unknown as Schema.Schema<ListbuildtokensRequest>;

export interface ListbuildtokensResponse {
  result: { build_token_name?: string; build_token_uuid?: string; cloudflare_token_id?: string; owner_type?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListbuildtokensResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  build_token_name: Schema.optional(Schema.String),
  build_token_uuid: Schema.optional(Schema.UUID),
  cloudflare_token_id: Schema.optional(Schema.String),
  owner_type: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListbuildtokensResponse" }) as unknown as Schema.Schema<ListbuildtokensResponse>;

export const listbuildtokens: (
  input: ListbuildtokensRequest
) => Effect.Effect<
  ListbuildtokensResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListbuildtokensRequest,
  output: ListbuildtokensResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatebuildtokenRequest {
  body: { build_token_name: string; build_token_secret: string; cloudflare_token_id: string };
}

export const CreatebuildtokenRequest = Schema.Struct({
  body: Schema.Struct({
  build_token_name: Schema.String,
  build_token_secret: Schema.String,
  cloudflare_token_id: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/builds/tokens" }),
).annotations({ identifier: "CreatebuildtokenRequest" }) as unknown as Schema.Schema<CreatebuildtokenRequest>;

export interface CreatebuildtokenResponse {
  result: { build_token_name?: string; build_token_uuid?: string; cloudflare_token_id?: string; owner_type?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatebuildtokenResponse = Schema.Struct({
  result: Schema.Struct({
  build_token_name: Schema.optional(Schema.String),
  build_token_uuid: Schema.optional(Schema.UUID),
  cloudflare_token_id: Schema.optional(Schema.String),
  owner_type: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatebuildtokenResponse" }) as unknown as Schema.Schema<CreatebuildtokenResponse>;

export const createbuildtoken: (
  input: CreatebuildtokenRequest
) => Effect.Effect<
  CreatebuildtokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatebuildtokenRequest,
  output: CreatebuildtokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletebuildtokenRequest {
  build_token_uuid: string;
}

export const DeletebuildtokenRequest = Schema.Struct({
  build_token_uuid: Schema.UUID.pipe(T.HttpPath("build_token_uuid"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/builds/tokens/{build_token_uuid}" }),
).annotations({ identifier: "DeletebuildtokenRequest" }) as unknown as Schema.Schema<DeletebuildtokenRequest>;

export interface DeletebuildtokenResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletebuildtokenResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletebuildtokenResponse" }) as unknown as Schema.Schema<DeletebuildtokenResponse>;

export const deletebuildtoken: (
  input: DeletebuildtokenRequest
) => Effect.Effect<
  DeletebuildtokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletebuildtokenRequest,
  output: DeletebuildtokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatetriggerRequest {
  body: { branch_excludes: string[]; branch_includes: string[]; build_caching_enabled?: boolean; build_command: string; build_token_uuid: string; deploy_command: string; external_script_id: string; path_excludes: string[]; path_includes: string[]; repo_connection_uuid: string; root_directory: string; trigger_name: string };
}

export const CreatetriggerRequest = Schema.Struct({
  body: Schema.Struct({
  branch_excludes: Schema.Array(Schema.String),
  branch_includes: Schema.Array(Schema.String),
  build_caching_enabled: Schema.optional(Schema.Boolean),
  build_command: Schema.String,
  build_token_uuid: Schema.UUID,
  deploy_command: Schema.String,
  external_script_id: Schema.String,
  path_excludes: Schema.Array(Schema.String),
  path_includes: Schema.Array(Schema.String),
  repo_connection_uuid: Schema.UUID,
  root_directory: Schema.String,
  trigger_name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/builds/triggers" }),
).annotations({ identifier: "CreatetriggerRequest" }) as unknown as Schema.Schema<CreatetriggerRequest>;

export interface CreatetriggerResponse {
  result: { branch_excludes?: string[]; branch_includes?: string[]; build_caching_enabled?: boolean; build_command?: string; build_token_name?: string; build_token_uuid?: string; created_on?: string; deleted_on?: string; deploy_command?: string; external_script_id?: string; modified_on?: string; path_excludes?: string[]; path_includes?: string[]; repo_connection?: { created_on?: string; deleted_on?: string; modified_on?: string; provider_account_id?: string; provider_account_name?: string; provider_type?: "github"; repo_connection_uuid?: string; repo_id?: string; repo_name?: string }; root_directory?: string; trigger_name?: string; trigger_uuid?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatetriggerResponse = Schema.Struct({
  result: Schema.Struct({
  branch_excludes: Schema.optional(Schema.Array(Schema.String)),
  branch_includes: Schema.optional(Schema.Array(Schema.String)),
  build_caching_enabled: Schema.optional(Schema.Boolean),
  build_command: Schema.optional(Schema.String),
  build_token_name: Schema.optional(Schema.String),
  build_token_uuid: Schema.optional(Schema.UUID),
  created_on: Schema.optional(Schema.Date),
  deleted_on: Schema.optional(Schema.Date),
  deploy_command: Schema.optional(Schema.String),
  external_script_id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  path_excludes: Schema.optional(Schema.Array(Schema.String)),
  path_includes: Schema.optional(Schema.Array(Schema.String)),
  repo_connection: Schema.optional(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  deleted_on: Schema.optional(Schema.Date),
  modified_on: Schema.optional(Schema.Date),
  provider_account_id: Schema.optional(Schema.String),
  provider_account_name: Schema.optional(Schema.String),
  provider_type: Schema.optional(Schema.Literal("github")),
  repo_connection_uuid: Schema.optional(Schema.UUID),
  repo_id: Schema.optional(Schema.String),
  repo_name: Schema.optional(Schema.String)
})),
  root_directory: Schema.optional(Schema.String),
  trigger_name: Schema.optional(Schema.String),
  trigger_uuid: Schema.optional(Schema.UUID)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatetriggerResponse" }) as unknown as Schema.Schema<CreatetriggerResponse>;

export const createtrigger: (
  input: CreatetriggerRequest
) => Effect.Effect<
  CreatetriggerResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatetriggerRequest,
  output: CreatetriggerResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletetriggerRequest {
}

export const DeletetriggerRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/builds/triggers/{trigger_uuid}" }),
).annotations({ identifier: "DeletetriggerRequest" }) as unknown as Schema.Schema<DeletetriggerRequest>;

export interface DeletetriggerResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletetriggerResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletetriggerResponse" }) as unknown as Schema.Schema<DeletetriggerResponse>;

export const deletetrigger: (
  input: DeletetriggerRequest
) => Effect.Effect<
  DeletetriggerResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletetriggerRequest,
  output: DeletetriggerResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatetriggerRequest {
  body: { branch_excludes?: string[]; branch_includes?: string[]; build_caching_enabled?: boolean; build_command?: string; build_token_uuid?: string; deploy_command?: string; path_excludes?: string[]; path_includes?: string[]; root_directory?: string; trigger_name?: string };
}

export const UpdatetriggerRequest = Schema.Struct({
  body: Schema.Struct({
  branch_excludes: Schema.optional(Schema.Array(Schema.String)),
  branch_includes: Schema.optional(Schema.Array(Schema.String)),
  build_caching_enabled: Schema.optional(Schema.Boolean),
  build_command: Schema.optional(Schema.String),
  build_token_uuid: Schema.optional(Schema.UUID),
  deploy_command: Schema.optional(Schema.String),
  path_excludes: Schema.optional(Schema.Array(Schema.String)),
  path_includes: Schema.optional(Schema.Array(Schema.String)),
  root_directory: Schema.optional(Schema.String),
  trigger_name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/builds/triggers/{trigger_uuid}" }),
).annotations({ identifier: "UpdatetriggerRequest" }) as unknown as Schema.Schema<UpdatetriggerRequest>;

export interface UpdatetriggerResponse {
  result: { branch_excludes?: string[]; branch_includes?: string[]; build_caching_enabled?: boolean; build_command?: string; build_token_name?: string; build_token_uuid?: string; created_on?: string; deleted_on?: string; deploy_command?: string; external_script_id?: string; modified_on?: string; path_excludes?: string[]; path_includes?: string[]; repo_connection?: { created_on?: string; deleted_on?: string; modified_on?: string; provider_account_id?: string; provider_account_name?: string; provider_type?: "github"; repo_connection_uuid?: string; repo_id?: string; repo_name?: string }; root_directory?: string; trigger_name?: string; trigger_uuid?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatetriggerResponse = Schema.Struct({
  result: Schema.Struct({
  branch_excludes: Schema.optional(Schema.Array(Schema.String)),
  branch_includes: Schema.optional(Schema.Array(Schema.String)),
  build_caching_enabled: Schema.optional(Schema.Boolean),
  build_command: Schema.optional(Schema.String),
  build_token_name: Schema.optional(Schema.String),
  build_token_uuid: Schema.optional(Schema.UUID),
  created_on: Schema.optional(Schema.Date),
  deleted_on: Schema.optional(Schema.Date),
  deploy_command: Schema.optional(Schema.String),
  external_script_id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  path_excludes: Schema.optional(Schema.Array(Schema.String)),
  path_includes: Schema.optional(Schema.Array(Schema.String)),
  repo_connection: Schema.optional(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  deleted_on: Schema.optional(Schema.Date),
  modified_on: Schema.optional(Schema.Date),
  provider_account_id: Schema.optional(Schema.String),
  provider_account_name: Schema.optional(Schema.String),
  provider_type: Schema.optional(Schema.Literal("github")),
  repo_connection_uuid: Schema.optional(Schema.UUID),
  repo_id: Schema.optional(Schema.String),
  repo_name: Schema.optional(Schema.String)
})),
  root_directory: Schema.optional(Schema.String),
  trigger_name: Schema.optional(Schema.String),
  trigger_uuid: Schema.optional(Schema.UUID)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatetriggerResponse" }) as unknown as Schema.Schema<UpdatetriggerResponse>;

export const updatetrigger: (
  input: UpdatetriggerRequest
) => Effect.Effect<
  UpdatetriggerResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatetriggerRequest,
  output: UpdatetriggerResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatemanualbuildRequest {
  body: { branch?: string; commit_hash?: string; seed_repo?: { branch: string; files?: { content: string; filename: string; isBase64?: boolean; replace?: string }[]; owner: string; path: string; provider: "github"; repository: string } };
}

export const CreatemanualbuildRequest = Schema.Struct({
  body: Schema.Struct({
  branch: Schema.optional(Schema.String),
  commit_hash: Schema.optional(Schema.String),
  seed_repo: Schema.optional(Schema.Struct({
  branch: Schema.String,
  files: Schema.optional(Schema.Array(Schema.Struct({
  content: Schema.String,
  filename: Schema.String,
  isBase64: Schema.optional(Schema.Boolean),
  replace: Schema.optional(Schema.String)
}))),
  owner: Schema.String,
  path: Schema.String,
  provider: Schema.Literal("github"),
  repository: Schema.String
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/builds/triggers/{trigger_uuid}/builds" }),
).annotations({ identifier: "CreatemanualbuildRequest" }) as unknown as Schema.Schema<CreatemanualbuildRequest>;

export interface CreatemanualbuildResponse {
  result: { build_uuid?: string; created_on?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatemanualbuildResponse = Schema.Struct({
  result: Schema.Struct({
  build_uuid: Schema.optional(Schema.UUID),
  created_on: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatemanualbuildResponse" }) as unknown as Schema.Schema<CreatemanualbuildResponse>;

export const createmanualbuild: (
  input: CreatemanualbuildRequest
) => Effect.Effect<
  CreatemanualbuildResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatemanualbuildRequest,
  output: CreatemanualbuildResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListenvironmentvariablesRequest {
}

export const ListenvironmentvariablesRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/builds/triggers/{trigger_uuid}/environment_variables" }),
).annotations({ identifier: "ListenvironmentvariablesRequest" }) as unknown as Schema.Schema<ListenvironmentvariablesRequest>;

export interface ListenvironmentvariablesResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListenvironmentvariablesResponse = Schema.Struct({
  result: Schema.Record({ key: Schema.String, value: Schema.Struct({
  created_on: Schema.Date,
  is_secret: Schema.Boolean,
  value: Schema.optional(Schema.String)
}) }),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListenvironmentvariablesResponse" }) as unknown as Schema.Schema<ListenvironmentvariablesResponse>;

export const listenvironmentvariables: (
  input: ListenvironmentvariablesRequest
) => Effect.Effect<
  ListenvironmentvariablesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListenvironmentvariablesRequest,
  output: ListenvironmentvariablesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpsertenvironmentvariablesRequest {
  body: Record<string, unknown>;
}

export const UpsertenvironmentvariablesRequest = Schema.Struct({
  body: Schema.Record({ key: Schema.String, value: Schema.Struct({
  is_secret: Schema.Boolean,
  value: Schema.optional(Schema.String)
}) }).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/builds/triggers/{trigger_uuid}/environment_variables" }),
).annotations({ identifier: "UpsertenvironmentvariablesRequest" }) as unknown as Schema.Schema<UpsertenvironmentvariablesRequest>;

export interface UpsertenvironmentvariablesResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpsertenvironmentvariablesResponse = Schema.Struct({
  result: Schema.Record({ key: Schema.String, value: Schema.Struct({
  created_on: Schema.Date,
  is_secret: Schema.Boolean,
  value: Schema.optional(Schema.String)
}) }),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpsertenvironmentvariablesResponse" }) as unknown as Schema.Schema<UpsertenvironmentvariablesResponse>;

export const upsertenvironmentvariables: (
  input: UpsertenvironmentvariablesRequest
) => Effect.Effect<
  UpsertenvironmentvariablesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpsertenvironmentvariablesRequest,
  output: UpsertenvironmentvariablesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteenvironmentvariableRequest {
  environment_variable_key: string;
}

export const DeleteenvironmentvariableRequest = Schema.Struct({
  environment_variable_key: Schema.String.pipe(T.HttpPath("environment_variable_key"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/builds/triggers/{trigger_uuid}/environment_variables/{environment_variable_key}" }),
).annotations({ identifier: "DeleteenvironmentvariableRequest" }) as unknown as Schema.Schema<DeleteenvironmentvariableRequest>;

export interface DeleteenvironmentvariableResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteenvironmentvariableResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteenvironmentvariableResponse" }) as unknown as Schema.Schema<DeleteenvironmentvariableResponse>;

export const deleteenvironmentvariable: (
  input: DeleteenvironmentvariableRequest
) => Effect.Effect<
  DeleteenvironmentvariableResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteenvironmentvariableRequest,
  output: DeleteenvironmentvariableResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PurgebuildcacheRequest {
}

export const PurgebuildcacheRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/builds/triggers/{trigger_uuid}/purge_build_cache" }),
).annotations({ identifier: "PurgebuildcacheRequest" }) as unknown as Schema.Schema<PurgebuildcacheRequest>;

export interface PurgebuildcacheResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PurgebuildcacheResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PurgebuildcacheResponse" }) as unknown as Schema.Schema<PurgebuildcacheResponse>;

export const purgebuildcache: (
  input: PurgebuildcacheRequest
) => Effect.Effect<
  PurgebuildcacheResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PurgebuildcacheRequest,
  output: PurgebuildcacheResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListbuildsbyscriptRequest {
  external_script_id: string;
}

export const ListbuildsbyscriptRequest = Schema.Struct({
  external_script_id: Schema.String.pipe(T.HttpPath("external_script_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/builds/workers/{external_script_id}/builds" }),
).annotations({ identifier: "ListbuildsbyscriptRequest" }) as unknown as Schema.Schema<ListbuildsbyscriptRequest>;

export interface ListbuildsbyscriptResponse {
  result: { build_outcome?: "success" | "fail" | "skipped" | "cancelled" | "terminated"; build_trigger_metadata?: { author?: string; branch?: string; build_command?: string; build_token_name?: string; build_token_uuid?: string; build_trigger_source?: "push" | "pull_request" | "manual" | "api"; commit_hash?: string; commit_message?: string; deploy_command?: string; environment_variables?: Record<string, unknown>; provider_account_name?: string; provider_type?: "github"; repo_name?: string; root_directory?: string }; build_uuid?: string; created_on?: string; initializing_on?: string; modified_on?: string; pull_request?: { created_on?: string; pull_request_url?: string }; running_on?: string; status?: "queued" | "initializing" | "running" | "stopped"; stopped_on?: string; trigger?: { branch_excludes?: string[]; branch_includes?: string[]; build_caching_enabled?: boolean; build_command?: string; created_on?: string; deleted_on?: string; deploy_command?: string; external_script_id?: string; modified_on?: string; path_excludes?: string[]; path_includes?: string[]; repo_connection?: { created_on?: string; deleted_on?: string; modified_on?: string; provider_account_id?: string; provider_account_name?: string; provider_type?: "github"; repo_connection_uuid?: string; repo_id?: string; repo_name?: string }; root_directory?: string; trigger_name?: string; trigger_uuid?: string } }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListbuildsbyscriptResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  build_outcome: Schema.optional(Schema.Literal("success", "fail", "skipped", "cancelled", "terminated")),
  build_trigger_metadata: Schema.optional(Schema.Struct({
  author: Schema.optional(Schema.String),
  branch: Schema.optional(Schema.String),
  build_command: Schema.optional(Schema.String),
  build_token_name: Schema.optional(Schema.String),
  build_token_uuid: Schema.optional(Schema.UUID),
  build_trigger_source: Schema.optional(Schema.Literal("push", "pull_request", "manual", "api")),
  commit_hash: Schema.optional(Schema.String),
  commit_message: Schema.optional(Schema.String),
  deploy_command: Schema.optional(Schema.String),
  environment_variables: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  provider_account_name: Schema.optional(Schema.String),
  provider_type: Schema.optional(Schema.Literal("github")),
  repo_name: Schema.optional(Schema.String),
  root_directory: Schema.optional(Schema.String)
})),
  build_uuid: Schema.optional(Schema.UUID),
  created_on: Schema.optional(Schema.Date),
  initializing_on: Schema.optional(Schema.Date),
  modified_on: Schema.optional(Schema.Date),
  pull_request: Schema.optional(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  pull_request_url: Schema.optional(Schema.String)
})),
  running_on: Schema.optional(Schema.Date),
  status: Schema.optional(Schema.Literal("queued", "initializing", "running", "stopped")),
  stopped_on: Schema.optional(Schema.Date),
  trigger: Schema.optional(Schema.Struct({
  branch_excludes: Schema.optional(Schema.Array(Schema.String)),
  branch_includes: Schema.optional(Schema.Array(Schema.String)),
  build_caching_enabled: Schema.optional(Schema.Boolean),
  build_command: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  deleted_on: Schema.optional(Schema.Date),
  deploy_command: Schema.optional(Schema.String),
  external_script_id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  path_excludes: Schema.optional(Schema.Array(Schema.String)),
  path_includes: Schema.optional(Schema.Array(Schema.String)),
  repo_connection: Schema.optional(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  deleted_on: Schema.optional(Schema.Date),
  modified_on: Schema.optional(Schema.Date),
  provider_account_id: Schema.optional(Schema.String),
  provider_account_name: Schema.optional(Schema.String),
  provider_type: Schema.optional(Schema.Literal("github")),
  repo_connection_uuid: Schema.optional(Schema.UUID),
  repo_id: Schema.optional(Schema.String),
  repo_name: Schema.optional(Schema.String)
})),
  root_directory: Schema.optional(Schema.String),
  trigger_name: Schema.optional(Schema.String),
  trigger_uuid: Schema.optional(Schema.UUID)
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListbuildsbyscriptResponse" }) as unknown as Schema.Schema<ListbuildsbyscriptResponse>;

export const listbuildsbyscript: (
  input: ListbuildsbyscriptRequest
) => Effect.Effect<
  ListbuildsbyscriptResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListbuildsbyscriptRequest,
  output: ListbuildsbyscriptResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListtriggersbyscriptRequest {
  external_script_id: string;
}

export const ListtriggersbyscriptRequest = Schema.Struct({
  external_script_id: Schema.String.pipe(T.HttpPath("external_script_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/builds/workers/{external_script_id}/triggers" }),
).annotations({ identifier: "ListtriggersbyscriptRequest" }) as unknown as Schema.Schema<ListtriggersbyscriptRequest>;

export interface ListtriggersbyscriptResponse {
  result: { branch_excludes?: string[]; branch_includes?: string[]; build_caching_enabled?: boolean; build_command?: string; build_token_name?: string; build_token_uuid?: string; created_on?: string; deleted_on?: string; deploy_command?: string; external_script_id?: string; modified_on?: string; path_excludes?: string[]; path_includes?: string[]; repo_connection?: { created_on?: string; deleted_on?: string; modified_on?: string; provider_account_id?: string; provider_account_name?: string; provider_type?: "github"; repo_connection_uuid?: string; repo_id?: string; repo_name?: string }; root_directory?: string; trigger_name?: string; trigger_uuid?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListtriggersbyscriptResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  branch_excludes: Schema.optional(Schema.Array(Schema.String)),
  branch_includes: Schema.optional(Schema.Array(Schema.String)),
  build_caching_enabled: Schema.optional(Schema.Boolean),
  build_command: Schema.optional(Schema.String),
  build_token_name: Schema.optional(Schema.String),
  build_token_uuid: Schema.optional(Schema.UUID),
  created_on: Schema.optional(Schema.Date),
  deleted_on: Schema.optional(Schema.Date),
  deploy_command: Schema.optional(Schema.String),
  external_script_id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  path_excludes: Schema.optional(Schema.Array(Schema.String)),
  path_includes: Schema.optional(Schema.Array(Schema.String)),
  repo_connection: Schema.optional(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  deleted_on: Schema.optional(Schema.Date),
  modified_on: Schema.optional(Schema.Date),
  provider_account_id: Schema.optional(Schema.String),
  provider_account_name: Schema.optional(Schema.String),
  provider_type: Schema.optional(Schema.Literal("github")),
  repo_connection_uuid: Schema.optional(Schema.UUID),
  repo_id: Schema.optional(Schema.String),
  repo_name: Schema.optional(Schema.String)
})),
  root_directory: Schema.optional(Schema.String),
  trigger_name: Schema.optional(Schema.String),
  trigger_uuid: Schema.optional(Schema.UUID)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListtriggersbyscriptResponse" }) as unknown as Schema.Schema<ListtriggersbyscriptResponse>;

export const listtriggersbyscript: (
  input: ListtriggersbyscriptRequest
) => Effect.Effect<
  ListtriggersbyscriptResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListtriggersbyscriptRequest,
  output: ListtriggersbyscriptResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListRequest {
  account_id: string;
}

export const ListRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/calls/apps" }),
).annotations({ identifier: "ListRequest" }) as unknown as Schema.Schema<ListRequest>;

export interface ListResponse {
  result: { created?: string; modified?: string; name?: string; uid?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created: Schema.optional(Schema.Date),
  modified: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  uid: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListResponse" }) as unknown as Schema.Schema<ListResponse>;

export const list: (
  input: ListRequest
) => Effect.Effect<
  ListResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListRequest,
  output: ListResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateANewAppRequest {
  account_id: string;
  body: { name?: string };
}

export const CreateANewAppRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/calls/apps" }),
).annotations({ identifier: "CreateANewAppRequest" }) as unknown as Schema.Schema<CreateANewAppRequest>;

export interface CreateANewAppResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateANewAppResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateANewAppResponse" }) as unknown as Schema.Schema<CreateANewAppResponse>;

export const createANewApp: (
  input: CreateANewAppRequest
) => Effect.Effect<
  CreateANewAppResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateANewAppRequest,
  output: CreateANewAppResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CallsAppsRetrieveAppDetailsRequest {
  app_id: string;
  account_id: string;
}

export const CallsAppsRetrieveAppDetailsRequest = Schema.Struct({
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/calls/apps/{app_id}" }),
).annotations({ identifier: "CallsAppsRetrieveAppDetailsRequest" }) as unknown as Schema.Schema<CallsAppsRetrieveAppDetailsRequest>;

export interface CallsAppsRetrieveAppDetailsResponse {
  result: { created?: string; modified?: string; name?: string; uid?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CallsAppsRetrieveAppDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  created: Schema.optional(Schema.Date),
  modified: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  uid: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CallsAppsRetrieveAppDetailsResponse" }) as unknown as Schema.Schema<CallsAppsRetrieveAppDetailsResponse>;

export const callsAppsRetrieveAppDetails: (
  input: CallsAppsRetrieveAppDetailsRequest
) => Effect.Effect<
  CallsAppsRetrieveAppDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CallsAppsRetrieveAppDetailsRequest,
  output: CallsAppsRetrieveAppDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAppDetailsRequest {
  app_id: string;
  account_id: string;
  body: { name?: string };
}

export const UpdateAppDetailsRequest = Schema.Struct({
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/calls/apps/{app_id}" }),
).annotations({ identifier: "UpdateAppDetailsRequest" }) as unknown as Schema.Schema<UpdateAppDetailsRequest>;

export interface UpdateAppDetailsResponse {
  result: { created?: string; modified?: string; name?: string; uid?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAppDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  created: Schema.optional(Schema.Date),
  modified: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  uid: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAppDetailsResponse" }) as unknown as Schema.Schema<UpdateAppDetailsResponse>;

export const updateAppDetails: (
  input: UpdateAppDetailsRequest
) => Effect.Effect<
  UpdateAppDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAppDetailsRequest,
  output: UpdateAppDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAppRequest {
  app_id: string;
  account_id: string;
}

export const DeleteAppRequest = Schema.Struct({
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/calls/apps/{app_id}" }),
).annotations({ identifier: "DeleteAppRequest" }) as unknown as Schema.Schema<DeleteAppRequest>;

export interface DeleteAppResponse {
  result: { created?: string; modified?: string; name?: string; uid?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAppResponse = Schema.Struct({
  result: Schema.Struct({
  created: Schema.optional(Schema.Date),
  modified: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  uid: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAppResponse" }) as unknown as Schema.Schema<DeleteAppResponse>;

export const deleteApp: (
  input: DeleteAppRequest
) => Effect.Effect<
  DeleteAppResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAppRequest,
  output: DeleteAppResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List1Request {
  account_id: string;
}

export const List1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/calls/turn_keys" }),
).annotations({ identifier: "List1Request" }) as unknown as Schema.Schema<List1Request>;

export interface List1Response {
  result: { created?: string; modified?: string; name?: string; uid?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List1Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created: Schema.optional(Schema.Date),
  modified: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  uid: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List1Response" }) as unknown as Schema.Schema<List1Response>;

export const list1: (
  input: List1Request
) => Effect.Effect<
  List1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List1Request,
  output: List1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateRequest {
  account_id: string;
  body: { name?: string };
}

export const CreateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/calls/turn_keys" }),
).annotations({ identifier: "CreateRequest" }) as unknown as Schema.Schema<CreateRequest>;

export interface CreateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateResponse" }) as unknown as Schema.Schema<CreateResponse>;

export const create: (
  input: CreateRequest
) => Effect.Effect<
  CreateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateRequest,
  output: CreateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CallsRetrieveTurnKeyDetailsRequest {
  key_id: string;
  account_id: string;
}

export const CallsRetrieveTurnKeyDetailsRequest = Schema.Struct({
  key_id: Schema.String.pipe(T.HttpPath("key_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/calls/turn_keys/{key_id}" }),
).annotations({ identifier: "CallsRetrieveTurnKeyDetailsRequest" }) as unknown as Schema.Schema<CallsRetrieveTurnKeyDetailsRequest>;

export interface CallsRetrieveTurnKeyDetailsResponse {
  result: { created?: string; modified?: string; name?: string; uid?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CallsRetrieveTurnKeyDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  created: Schema.optional(Schema.Date),
  modified: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  uid: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CallsRetrieveTurnKeyDetailsResponse" }) as unknown as Schema.Schema<CallsRetrieveTurnKeyDetailsResponse>;

export const callsRetrieveTurnKeyDetails: (
  input: CallsRetrieveTurnKeyDetailsRequest
) => Effect.Effect<
  CallsRetrieveTurnKeyDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CallsRetrieveTurnKeyDetailsRequest,
  output: CallsRetrieveTurnKeyDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateTurnKeyRequest {
  key_id: string;
  account_id: string;
  body: { name?: string };
}

export const UpdateTurnKeyRequest = Schema.Struct({
  key_id: Schema.String.pipe(T.HttpPath("key_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/calls/turn_keys/{key_id}" }),
).annotations({ identifier: "UpdateTurnKeyRequest" }) as unknown as Schema.Schema<UpdateTurnKeyRequest>;

export interface UpdateTurnKeyResponse {
  result: { created?: string; modified?: string; name?: string; uid?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateTurnKeyResponse = Schema.Struct({
  result: Schema.Struct({
  created: Schema.optional(Schema.Date),
  modified: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  uid: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateTurnKeyResponse" }) as unknown as Schema.Schema<UpdateTurnKeyResponse>;

export const updateTurnKey: (
  input: UpdateTurnKeyRequest
) => Effect.Effect<
  UpdateTurnKeyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateTurnKeyRequest,
  output: UpdateTurnKeyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteTurnKeyRequest {
  key_id: string;
  account_id: string;
}

export const DeleteTurnKeyRequest = Schema.Struct({
  key_id: Schema.String.pipe(T.HttpPath("key_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/calls/turn_keys/{key_id}" }),
).annotations({ identifier: "DeleteTurnKeyRequest" }) as unknown as Schema.Schema<DeleteTurnKeyRequest>;

export interface DeleteTurnKeyResponse {
  result: { created?: string; modified?: string; name?: string; uid?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteTurnKeyResponse = Schema.Struct({
  result: Schema.Struct({
  created: Schema.optional(Schema.Date),
  modified: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  uid: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteTurnKeyResponse" }) as unknown as Schema.Schema<DeleteTurnKeyResponse>;

export const deleteTurnKey: (
  input: DeleteTurnKeyRequest
) => Effect.Effect<
  DeleteTurnKeyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteTurnKeyRequest,
  output: DeleteTurnKeyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListCloudflareTunnelsRequest {
  account_id: string;
  name?: string;
  is_deleted?: boolean;
  existed_at?: string;
  uuid?: string;
  was_active_at?: string;
  was_inactive_at?: string;
  include_prefix?: string;
  exclude_prefix?: string;
  status?: "inactive" | "degraded" | "healthy" | "down";
  per_page?: number;
  page?: number;
}

export const ListCloudflareTunnelsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  is_deleted: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_deleted")),
  existed_at: Schema.optional(Schema.String).pipe(T.HttpQuery("existed_at")),
  uuid: Schema.optional(Schema.UUID).pipe(T.HttpQuery("uuid")),
  was_active_at: Schema.optional(Schema.Date).pipe(T.HttpQuery("was_active_at")),
  was_inactive_at: Schema.optional(Schema.Date).pipe(T.HttpQuery("was_inactive_at")),
  include_prefix: Schema.optional(Schema.String).pipe(T.HttpQuery("include_prefix")),
  exclude_prefix: Schema.optional(Schema.String).pipe(T.HttpQuery("exclude_prefix")),
  status: Schema.optional(Schema.Literal("inactive", "degraded", "healthy", "down")).pipe(T.HttpQuery("status")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cfd_tunnel" }),
).annotations({ identifier: "ListCloudflareTunnelsRequest" }) as unknown as Schema.Schema<ListCloudflareTunnelsRequest>;

export interface ListCloudflareTunnelsResponse {
  result: { account_tag?: string; config_src?: "local" | "cloudflare"; connections?: unknown[]; conns_active_at?: string; conns_inactive_at?: string; created_at?: string; deleted_at?: string; id?: string; metadata?: Record<string, unknown>; name?: string; remote_config?: boolean; status?: "inactive" | "degraded" | "healthy" | "down"; tun_type?: "cfd_tunnel" | "warp_connector" | "warp" | "magic" | "ip_sec" | "gre" | "cni" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListCloudflareTunnelsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  account_tag: Schema.optional(Schema.String),
  config_src: Schema.optional(Schema.Literal("local", "cloudflare")),
  connections: Schema.optional(Schema.Array(Schema.Unknown)),
  conns_active_at: Schema.optional(Schema.Date),
  conns_inactive_at: Schema.optional(Schema.Date),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.UUID),
  metadata: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  remote_config: Schema.optional(Schema.Boolean),
  status: Schema.optional(Schema.Literal("inactive", "degraded", "healthy", "down")),
  tun_type: Schema.optional(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListCloudflareTunnelsResponse" }) as unknown as Schema.Schema<ListCloudflareTunnelsResponse>;

export const listCloudflareTunnels: (
  input: ListCloudflareTunnelsRequest
) => Effect.Effect<
  ListCloudflareTunnelsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListCloudflareTunnelsRequest,
  output: ListCloudflareTunnelsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateACloudflareTunnelRequest {
  account_id: string;
  body: { config_src?: "local" | "cloudflare"; name: string; tunnel_secret?: string };
}

export const CreateACloudflareTunnelRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  config_src: Schema.optional(Schema.Literal("local", "cloudflare")),
  name: Schema.String,
  tunnel_secret: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cfd_tunnel" }),
).annotations({ identifier: "CreateACloudflareTunnelRequest" }) as unknown as Schema.Schema<CreateACloudflareTunnelRequest>;

export interface CreateACloudflareTunnelResponse {
  result: { account_tag?: string; config_src?: "local" | "cloudflare"; connections?: unknown[]; conns_active_at?: string; conns_inactive_at?: string; created_at?: string; deleted_at?: string; id?: string; metadata?: Record<string, unknown>; name?: string; remote_config?: boolean; status?: "inactive" | "degraded" | "healthy" | "down"; tun_type?: "cfd_tunnel" | "warp_connector" | "warp" | "magic" | "ip_sec" | "gre" | "cni" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateACloudflareTunnelResponse = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.optional(Schema.String),
  config_src: Schema.optional(Schema.Literal("local", "cloudflare")),
  connections: Schema.optional(Schema.Array(Schema.Unknown)),
  conns_active_at: Schema.optional(Schema.Date),
  conns_inactive_at: Schema.optional(Schema.Date),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.UUID),
  metadata: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  remote_config: Schema.optional(Schema.Boolean),
  status: Schema.optional(Schema.Literal("inactive", "degraded", "healthy", "down")),
  tun_type: Schema.optional(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateACloudflareTunnelResponse" }) as unknown as Schema.Schema<CreateACloudflareTunnelResponse>;

export const createACloudflareTunnel: (
  input: CreateACloudflareTunnelRequest
) => Effect.Effect<
  CreateACloudflareTunnelResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateACloudflareTunnelRequest,
  output: CreateACloudflareTunnelResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetACloudflareTunnelRequest {
  account_id: string;
  tunnel_id: string;
}

export const GetACloudflareTunnelRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  tunnel_id: Schema.UUID.pipe(T.HttpPath("tunnel_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cfd_tunnel/{tunnel_id}" }),
).annotations({ identifier: "GetACloudflareTunnelRequest" }) as unknown as Schema.Schema<GetACloudflareTunnelRequest>;

export interface GetACloudflareTunnelResponse {
  result: { account_tag?: string; config_src?: "local" | "cloudflare"; connections?: unknown[]; conns_active_at?: string; conns_inactive_at?: string; created_at?: string; deleted_at?: string; id?: string; metadata?: Record<string, unknown>; name?: string; remote_config?: boolean; status?: "inactive" | "degraded" | "healthy" | "down"; tun_type?: "cfd_tunnel" | "warp_connector" | "warp" | "magic" | "ip_sec" | "gre" | "cni" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetACloudflareTunnelResponse = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.optional(Schema.String),
  config_src: Schema.optional(Schema.Literal("local", "cloudflare")),
  connections: Schema.optional(Schema.Array(Schema.Unknown)),
  conns_active_at: Schema.optional(Schema.Date),
  conns_inactive_at: Schema.optional(Schema.Date),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.UUID),
  metadata: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  remote_config: Schema.optional(Schema.Boolean),
  status: Schema.optional(Schema.Literal("inactive", "degraded", "healthy", "down")),
  tun_type: Schema.optional(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetACloudflareTunnelResponse" }) as unknown as Schema.Schema<GetACloudflareTunnelResponse>;

export const getACloudflareTunnel: (
  input: GetACloudflareTunnelRequest
) => Effect.Effect<
  GetACloudflareTunnelResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetACloudflareTunnelRequest,
  output: GetACloudflareTunnelResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteACloudflareTunnelRequest {
  account_id: string;
  tunnel_id: string;
  body: Record<string, unknown>;
}

export const DeleteACloudflareTunnelRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  tunnel_id: Schema.UUID.pipe(T.HttpPath("tunnel_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cfd_tunnel/{tunnel_id}" }),
).annotations({ identifier: "DeleteACloudflareTunnelRequest" }) as unknown as Schema.Schema<DeleteACloudflareTunnelRequest>;

export interface DeleteACloudflareTunnelResponse {
  result: { account_tag?: string; config_src?: "local" | "cloudflare"; connections?: unknown[]; conns_active_at?: string; conns_inactive_at?: string; created_at?: string; deleted_at?: string; id?: string; metadata?: Record<string, unknown>; name?: string; remote_config?: boolean; status?: "inactive" | "degraded" | "healthy" | "down"; tun_type?: "cfd_tunnel" | "warp_connector" | "warp" | "magic" | "ip_sec" | "gre" | "cni" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteACloudflareTunnelResponse = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.optional(Schema.String),
  config_src: Schema.optional(Schema.Literal("local", "cloudflare")),
  connections: Schema.optional(Schema.Array(Schema.Unknown)),
  conns_active_at: Schema.optional(Schema.Date),
  conns_inactive_at: Schema.optional(Schema.Date),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.UUID),
  metadata: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  remote_config: Schema.optional(Schema.Boolean),
  status: Schema.optional(Schema.Literal("inactive", "degraded", "healthy", "down")),
  tun_type: Schema.optional(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteACloudflareTunnelResponse" }) as unknown as Schema.Schema<DeleteACloudflareTunnelResponse>;

export const deleteACloudflareTunnel: (
  input: DeleteACloudflareTunnelRequest
) => Effect.Effect<
  DeleteACloudflareTunnelResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteACloudflareTunnelRequest,
  output: DeleteACloudflareTunnelResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateACloudflareTunnelRequest {
  tunnel_id: string;
  account_id: string;
  body: { name?: string; tunnel_secret?: string };
}

export const UpdateACloudflareTunnelRequest = Schema.Struct({
  tunnel_id: Schema.UUID.pipe(T.HttpPath("tunnel_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String),
  tunnel_secret: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/cfd_tunnel/{tunnel_id}" }),
).annotations({ identifier: "UpdateACloudflareTunnelRequest" }) as unknown as Schema.Schema<UpdateACloudflareTunnelRequest>;

export interface UpdateACloudflareTunnelResponse {
  result: { account_tag?: string; config_src?: "local" | "cloudflare"; connections?: unknown[]; conns_active_at?: string; conns_inactive_at?: string; created_at?: string; deleted_at?: string; id?: string; metadata?: Record<string, unknown>; name?: string; remote_config?: boolean; status?: "inactive" | "degraded" | "healthy" | "down"; tun_type?: "cfd_tunnel" | "warp_connector" | "warp" | "magic" | "ip_sec" | "gre" | "cni" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateACloudflareTunnelResponse = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.optional(Schema.String),
  config_src: Schema.optional(Schema.Literal("local", "cloudflare")),
  connections: Schema.optional(Schema.Array(Schema.Unknown)),
  conns_active_at: Schema.optional(Schema.Date),
  conns_inactive_at: Schema.optional(Schema.Date),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.UUID),
  metadata: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  remote_config: Schema.optional(Schema.Boolean),
  status: Schema.optional(Schema.Literal("inactive", "degraded", "healthy", "down")),
  tun_type: Schema.optional(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateACloudflareTunnelResponse" }) as unknown as Schema.Schema<UpdateACloudflareTunnelResponse>;

export const updateACloudflareTunnel: (
  input: UpdateACloudflareTunnelRequest
) => Effect.Effect<
  UpdateACloudflareTunnelResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateACloudflareTunnelRequest,
  output: UpdateACloudflareTunnelResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetConfigurationRequest {
  account_id: string;
  tunnel_id: string;
}

export const GetConfigurationRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  tunnel_id: Schema.UUID.pipe(T.HttpPath("tunnel_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cfd_tunnel/{tunnel_id}/configurations" }),
).annotations({ identifier: "GetConfigurationRequest" }) as unknown as Schema.Schema<GetConfigurationRequest>;

export interface GetConfigurationResponse {
  result: { account_id?: string; config?: { ingress?: { hostname: string; originRequest?: { access?: { audTag: string[]; required?: boolean; teamName: string }; caPool?: string; connectTimeout?: number; disableChunkedEncoding?: boolean; http2Origin?: boolean; httpHostHeader?: string; keepAliveConnections?: number; keepAliveTimeout?: number; matchSNItoHost?: boolean; noHappyEyeballs?: boolean; noTLSVerify?: boolean; originServerName?: string; proxyType?: string; tcpKeepAlive?: number; tlsTimeout?: number }; path?: string; service: string }[]; originRequest?: { access?: { audTag: string[]; required?: boolean; teamName: string }; caPool?: string; connectTimeout?: number; disableChunkedEncoding?: boolean; http2Origin?: boolean; httpHostHeader?: string; keepAliveConnections?: number; keepAliveTimeout?: number; matchSNItoHost?: boolean; noHappyEyeballs?: boolean; noTLSVerify?: boolean; originServerName?: string; proxyType?: string; tcpKeepAlive?: number; tlsTimeout?: number }; "warp-routing"?: { enabled?: boolean } }; created_at?: string; source?: "local" | "cloudflare"; tunnel_id?: string; version?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.optional(Schema.String),
  config: Schema.optional(Schema.Struct({
  ingress: Schema.optional(Schema.Array(Schema.Struct({
  hostname: Schema.String,
  originRequest: Schema.optional(Schema.Struct({
  access: Schema.optional(Schema.Struct({
  audTag: Schema.Array(Schema.String),
  required: Schema.optional(Schema.Boolean),
  teamName: Schema.String
})),
  caPool: Schema.optional(Schema.String),
  connectTimeout: Schema.optional(Schema.Number),
  disableChunkedEncoding: Schema.optional(Schema.Boolean),
  http2Origin: Schema.optional(Schema.Boolean),
  httpHostHeader: Schema.optional(Schema.String),
  keepAliveConnections: Schema.optional(Schema.Number),
  keepAliveTimeout: Schema.optional(Schema.Number),
  matchSNItoHost: Schema.optional(Schema.Boolean),
  noHappyEyeballs: Schema.optional(Schema.Boolean),
  noTLSVerify: Schema.optional(Schema.Boolean),
  originServerName: Schema.optional(Schema.String),
  proxyType: Schema.optional(Schema.String),
  tcpKeepAlive: Schema.optional(Schema.Number),
  tlsTimeout: Schema.optional(Schema.Number)
})),
  path: Schema.optional(Schema.String),
  service: Schema.String
}))),
  originRequest: Schema.optional(Schema.Struct({
  access: Schema.optional(Schema.Struct({
  audTag: Schema.Array(Schema.String),
  required: Schema.optional(Schema.Boolean),
  teamName: Schema.String
})),
  caPool: Schema.optional(Schema.String),
  connectTimeout: Schema.optional(Schema.Number),
  disableChunkedEncoding: Schema.optional(Schema.Boolean),
  http2Origin: Schema.optional(Schema.Boolean),
  httpHostHeader: Schema.optional(Schema.String),
  keepAliveConnections: Schema.optional(Schema.Number),
  keepAliveTimeout: Schema.optional(Schema.Number),
  matchSNItoHost: Schema.optional(Schema.Boolean),
  noHappyEyeballs: Schema.optional(Schema.Boolean),
  noTLSVerify: Schema.optional(Schema.Boolean),
  originServerName: Schema.optional(Schema.String),
  proxyType: Schema.optional(Schema.String),
  tcpKeepAlive: Schema.optional(Schema.Number),
  tlsTimeout: Schema.optional(Schema.Number)
})),
  "warp-routing": Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
}))
})),
  created_at: Schema.optional(Schema.Date),
  source: Schema.optional(Schema.Literal("local", "cloudflare")),
  tunnel_id: Schema.optional(Schema.UUID),
  version: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetConfigurationResponse" }) as unknown as Schema.Schema<GetConfigurationResponse>;

export const getConfiguration: (
  input: GetConfigurationRequest
) => Effect.Effect<
  GetConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetConfigurationRequest,
  output: GetConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PutConfigurationRequest {
  account_id: string;
  tunnel_id: string;
  body: { config?: { ingress?: { hostname: string; originRequest?: { access?: { audTag: string[]; required?: boolean; teamName: string }; caPool?: string; connectTimeout?: number; disableChunkedEncoding?: boolean; http2Origin?: boolean; httpHostHeader?: string; keepAliveConnections?: number; keepAliveTimeout?: number; matchSNItoHost?: boolean; noHappyEyeballs?: boolean; noTLSVerify?: boolean; originServerName?: string; proxyType?: string; tcpKeepAlive?: number; tlsTimeout?: number }; path?: string; service: string }[]; originRequest?: { access?: { audTag: string[]; required?: boolean; teamName: string }; caPool?: string; connectTimeout?: number; disableChunkedEncoding?: boolean; http2Origin?: boolean; httpHostHeader?: string; keepAliveConnections?: number; keepAliveTimeout?: number; matchSNItoHost?: boolean; noHappyEyeballs?: boolean; noTLSVerify?: boolean; originServerName?: string; proxyType?: string; tcpKeepAlive?: number; tlsTimeout?: number }; "warp-routing"?: { enabled?: boolean } } };
}

export const PutConfigurationRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  tunnel_id: Schema.UUID.pipe(T.HttpPath("tunnel_id")),
  body: Schema.Struct({
  config: Schema.optional(Schema.Struct({
  ingress: Schema.optional(Schema.Array(Schema.Struct({
  hostname: Schema.String,
  originRequest: Schema.optional(Schema.Struct({
  access: Schema.optional(Schema.Struct({
  audTag: Schema.Array(Schema.String),
  required: Schema.optional(Schema.Boolean),
  teamName: Schema.String
})),
  caPool: Schema.optional(Schema.String),
  connectTimeout: Schema.optional(Schema.Number),
  disableChunkedEncoding: Schema.optional(Schema.Boolean),
  http2Origin: Schema.optional(Schema.Boolean),
  httpHostHeader: Schema.optional(Schema.String),
  keepAliveConnections: Schema.optional(Schema.Number),
  keepAliveTimeout: Schema.optional(Schema.Number),
  matchSNItoHost: Schema.optional(Schema.Boolean),
  noHappyEyeballs: Schema.optional(Schema.Boolean),
  noTLSVerify: Schema.optional(Schema.Boolean),
  originServerName: Schema.optional(Schema.String),
  proxyType: Schema.optional(Schema.String),
  tcpKeepAlive: Schema.optional(Schema.Number),
  tlsTimeout: Schema.optional(Schema.Number)
})),
  path: Schema.optional(Schema.String),
  service: Schema.String
}))),
  originRequest: Schema.optional(Schema.Struct({
  access: Schema.optional(Schema.Struct({
  audTag: Schema.Array(Schema.String),
  required: Schema.optional(Schema.Boolean),
  teamName: Schema.String
})),
  caPool: Schema.optional(Schema.String),
  connectTimeout: Schema.optional(Schema.Number),
  disableChunkedEncoding: Schema.optional(Schema.Boolean),
  http2Origin: Schema.optional(Schema.Boolean),
  httpHostHeader: Schema.optional(Schema.String),
  keepAliveConnections: Schema.optional(Schema.Number),
  keepAliveTimeout: Schema.optional(Schema.Number),
  matchSNItoHost: Schema.optional(Schema.Boolean),
  noHappyEyeballs: Schema.optional(Schema.Boolean),
  noTLSVerify: Schema.optional(Schema.Boolean),
  originServerName: Schema.optional(Schema.String),
  proxyType: Schema.optional(Schema.String),
  tcpKeepAlive: Schema.optional(Schema.Number),
  tlsTimeout: Schema.optional(Schema.Number)
})),
  "warp-routing": Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
}))
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/cfd_tunnel/{tunnel_id}/configurations" }),
).annotations({ identifier: "PutConfigurationRequest" }) as unknown as Schema.Schema<PutConfigurationRequest>;

export interface PutConfigurationResponse {
  result: { account_id?: string; config?: { ingress?: { hostname: string; originRequest?: { access?: { audTag: string[]; required?: boolean; teamName: string }; caPool?: string; connectTimeout?: number; disableChunkedEncoding?: boolean; http2Origin?: boolean; httpHostHeader?: string; keepAliveConnections?: number; keepAliveTimeout?: number; matchSNItoHost?: boolean; noHappyEyeballs?: boolean; noTLSVerify?: boolean; originServerName?: string; proxyType?: string; tcpKeepAlive?: number; tlsTimeout?: number }; path?: string; service: string }[]; originRequest?: { access?: { audTag: string[]; required?: boolean; teamName: string }; caPool?: string; connectTimeout?: number; disableChunkedEncoding?: boolean; http2Origin?: boolean; httpHostHeader?: string; keepAliveConnections?: number; keepAliveTimeout?: number; matchSNItoHost?: boolean; noHappyEyeballs?: boolean; noTLSVerify?: boolean; originServerName?: string; proxyType?: string; tcpKeepAlive?: number; tlsTimeout?: number }; "warp-routing"?: { enabled?: boolean } }; created_at?: string; source?: "local" | "cloudflare"; tunnel_id?: string; version?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PutConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.optional(Schema.String),
  config: Schema.optional(Schema.Struct({
  ingress: Schema.optional(Schema.Array(Schema.Struct({
  hostname: Schema.String,
  originRequest: Schema.optional(Schema.Struct({
  access: Schema.optional(Schema.Struct({
  audTag: Schema.Array(Schema.String),
  required: Schema.optional(Schema.Boolean),
  teamName: Schema.String
})),
  caPool: Schema.optional(Schema.String),
  connectTimeout: Schema.optional(Schema.Number),
  disableChunkedEncoding: Schema.optional(Schema.Boolean),
  http2Origin: Schema.optional(Schema.Boolean),
  httpHostHeader: Schema.optional(Schema.String),
  keepAliveConnections: Schema.optional(Schema.Number),
  keepAliveTimeout: Schema.optional(Schema.Number),
  matchSNItoHost: Schema.optional(Schema.Boolean),
  noHappyEyeballs: Schema.optional(Schema.Boolean),
  noTLSVerify: Schema.optional(Schema.Boolean),
  originServerName: Schema.optional(Schema.String),
  proxyType: Schema.optional(Schema.String),
  tcpKeepAlive: Schema.optional(Schema.Number),
  tlsTimeout: Schema.optional(Schema.Number)
})),
  path: Schema.optional(Schema.String),
  service: Schema.String
}))),
  originRequest: Schema.optional(Schema.Struct({
  access: Schema.optional(Schema.Struct({
  audTag: Schema.Array(Schema.String),
  required: Schema.optional(Schema.Boolean),
  teamName: Schema.String
})),
  caPool: Schema.optional(Schema.String),
  connectTimeout: Schema.optional(Schema.Number),
  disableChunkedEncoding: Schema.optional(Schema.Boolean),
  http2Origin: Schema.optional(Schema.Boolean),
  httpHostHeader: Schema.optional(Schema.String),
  keepAliveConnections: Schema.optional(Schema.Number),
  keepAliveTimeout: Schema.optional(Schema.Number),
  matchSNItoHost: Schema.optional(Schema.Boolean),
  noHappyEyeballs: Schema.optional(Schema.Boolean),
  noTLSVerify: Schema.optional(Schema.Boolean),
  originServerName: Schema.optional(Schema.String),
  proxyType: Schema.optional(Schema.String),
  tcpKeepAlive: Schema.optional(Schema.Number),
  tlsTimeout: Schema.optional(Schema.Number)
})),
  "warp-routing": Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
}))
})),
  created_at: Schema.optional(Schema.Date),
  source: Schema.optional(Schema.Literal("local", "cloudflare")),
  tunnel_id: Schema.optional(Schema.UUID),
  version: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PutConfigurationResponse" }) as unknown as Schema.Schema<PutConfigurationResponse>;

export const putConfiguration: (
  input: PutConfigurationRequest
) => Effect.Effect<
  PutConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutConfigurationRequest,
  output: PutConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListCloudflareTunnelConnectionsRequest {
  account_id: string;
  tunnel_id: string;
}

export const ListCloudflareTunnelConnectionsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  tunnel_id: Schema.UUID.pipe(T.HttpPath("tunnel_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cfd_tunnel/{tunnel_id}/connections" }),
).annotations({ identifier: "ListCloudflareTunnelConnectionsRequest" }) as unknown as Schema.Schema<ListCloudflareTunnelConnectionsRequest>;

export interface ListCloudflareTunnelConnectionsResponse {
  result: { arch?: string; config_version?: number; conns?: unknown[]; features?: string[]; id?: string; run_at?: string; version?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListCloudflareTunnelConnectionsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  arch: Schema.optional(Schema.String),
  config_version: Schema.optional(Schema.Number),
  conns: Schema.optional(Schema.Array(Schema.Unknown)),
  features: Schema.optional(Schema.Array(Schema.String)),
  id: Schema.optional(Schema.UUID),
  run_at: Schema.optional(Schema.Date),
  version: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListCloudflareTunnelConnectionsResponse" }) as unknown as Schema.Schema<ListCloudflareTunnelConnectionsResponse>;

export const listCloudflareTunnelConnections: (
  input: ListCloudflareTunnelConnectionsRequest
) => Effect.Effect<
  ListCloudflareTunnelConnectionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListCloudflareTunnelConnectionsRequest,
  output: ListCloudflareTunnelConnectionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CloudflareTunnelCleanUpCloudflareTunnelConnectionsRequest {
  account_id: string;
  tunnel_id: string;
  client_id?: string;
  body: Record<string, unknown>;
}

export const CloudflareTunnelCleanUpCloudflareTunnelConnectionsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  tunnel_id: Schema.UUID.pipe(T.HttpPath("tunnel_id")),
  client_id: Schema.optional(Schema.UUID).pipe(T.HttpQuery("client_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cfd_tunnel/{tunnel_id}/connections" }),
).annotations({ identifier: "CloudflareTunnelCleanUpCloudflareTunnelConnectionsRequest" }) as unknown as Schema.Schema<CloudflareTunnelCleanUpCloudflareTunnelConnectionsRequest>;

export interface CloudflareTunnelCleanUpCloudflareTunnelConnectionsResponse {
  result: null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CloudflareTunnelCleanUpCloudflareTunnelConnectionsResponse = Schema.Struct({
  result: Schema.Literal(null),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CloudflareTunnelCleanUpCloudflareTunnelConnectionsResponse" }) as unknown as Schema.Schema<CloudflareTunnelCleanUpCloudflareTunnelConnectionsResponse>;

export const cloudflareTunnelCleanUpCloudflareTunnelConnections: (
  input: CloudflareTunnelCleanUpCloudflareTunnelConnectionsRequest
) => Effect.Effect<
  CloudflareTunnelCleanUpCloudflareTunnelConnectionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CloudflareTunnelCleanUpCloudflareTunnelConnectionsRequest,
  output: CloudflareTunnelCleanUpCloudflareTunnelConnectionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetCloudflareTunnelConnectorRequest {
  account_id: string;
  tunnel_id: string;
  connector_id: string;
}

export const GetCloudflareTunnelConnectorRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  tunnel_id: Schema.UUID.pipe(T.HttpPath("tunnel_id")),
  connector_id: Schema.UUID.pipe(T.HttpPath("connector_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cfd_tunnel/{tunnel_id}/connectors/{connector_id}" }),
).annotations({ identifier: "GetCloudflareTunnelConnectorRequest" }) as unknown as Schema.Schema<GetCloudflareTunnelConnectorRequest>;

export interface GetCloudflareTunnelConnectorResponse {
  result: { arch?: string; config_version?: number; conns?: unknown[]; features?: string[]; id?: string; run_at?: string; version?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetCloudflareTunnelConnectorResponse = Schema.Struct({
  result: Schema.Struct({
  arch: Schema.optional(Schema.String),
  config_version: Schema.optional(Schema.Number),
  conns: Schema.optional(Schema.Array(Schema.Unknown)),
  features: Schema.optional(Schema.Array(Schema.String)),
  id: Schema.optional(Schema.UUID),
  run_at: Schema.optional(Schema.Date),
  version: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetCloudflareTunnelConnectorResponse" }) as unknown as Schema.Schema<GetCloudflareTunnelConnectorResponse>;

export const getCloudflareTunnelConnector: (
  input: GetCloudflareTunnelConnectorRequest
) => Effect.Effect<
  GetCloudflareTunnelConnectorResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCloudflareTunnelConnectorRequest,
  output: GetCloudflareTunnelConnectorResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetACloudflareTunnelManagementTokenRequest {
  account_id: string;
  tunnel_id: string;
  body: { resources: "logs"[] };
}

export const GetACloudflareTunnelManagementTokenRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  tunnel_id: Schema.UUID.pipe(T.HttpPath("tunnel_id")),
  body: Schema.Struct({
  resources: Schema.Array(Schema.Literal("logs"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cfd_tunnel/{tunnel_id}/management" }),
).annotations({ identifier: "GetACloudflareTunnelManagementTokenRequest" }) as unknown as Schema.Schema<GetACloudflareTunnelManagementTokenRequest>;

export interface GetACloudflareTunnelManagementTokenResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetACloudflareTunnelManagementTokenResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetACloudflareTunnelManagementTokenResponse" }) as unknown as Schema.Schema<GetACloudflareTunnelManagementTokenResponse>;

export const getACloudflareTunnelManagementToken: (
  input: GetACloudflareTunnelManagementTokenRequest
) => Effect.Effect<
  GetACloudflareTunnelManagementTokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetACloudflareTunnelManagementTokenRequest,
  output: GetACloudflareTunnelManagementTokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetACloudflareTunnelTokenRequest {
  account_id: string;
  tunnel_id: string;
}

export const GetACloudflareTunnelTokenRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  tunnel_id: Schema.UUID.pipe(T.HttpPath("tunnel_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cfd_tunnel/{tunnel_id}/token" }),
).annotations({ identifier: "GetACloudflareTunnelTokenRequest" }) as unknown as Schema.Schema<GetACloudflareTunnelTokenRequest>;

export interface GetACloudflareTunnelTokenResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetACloudflareTunnelTokenResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetACloudflareTunnelTokenResponse" }) as unknown as Schema.Schema<GetACloudflareTunnelTokenResponse>;

export const getACloudflareTunnelToken: (
  input: GetACloudflareTunnelTokenRequest
) => Effect.Effect<
  GetACloudflareTunnelTokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetACloudflareTunnelTokenRequest,
  output: GetACloudflareTunnelTokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List2Request {
}

export const List2Request = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/challenges/widgets" }),
).annotations({ identifier: "List2Request" }) as unknown as Schema.Schema<List2Request>;

export interface List2Response {
  result: { bot_fight_mode: boolean; clearance_level: "no_clearance" | "jschallenge" | "managed" | "interactive"; created_on: string; domains: string[]; ephemeral_id: boolean; mode: "non-interactive" | "invisible" | "managed"; modified_on: string; name: string; offlabel: boolean; region: "world" | "china"; sitekey: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List2Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  bot_fight_mode: Schema.Boolean,
  clearance_level: Schema.Literal("no_clearance", "jschallenge", "managed", "interactive"),
  created_on: Schema.Date,
  domains: Schema.Array(Schema.String),
  ephemeral_id: Schema.Boolean,
  mode: Schema.Literal("non-interactive", "invisible", "managed"),
  modified_on: Schema.Date,
  name: Schema.String,
  offlabel: Schema.Boolean,
  region: Schema.Literal("world", "china"),
  sitekey: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List2Response" }) as unknown as Schema.Schema<List2Response>;

export const list2: (
  input: List2Request
) => Effect.Effect<
  List2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List2Request,
  output: List2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create1Request {
  body: { bot_fight_mode?: boolean; clearance_level?: "no_clearance" | "jschallenge" | "managed" | "interactive"; domains: string[]; ephemeral_id?: boolean; mode: "non-interactive" | "invisible" | "managed"; name: string; offlabel?: boolean; region?: "world" | "china" };
}

export const Create1Request = Schema.Struct({
  body: Schema.Struct({
  bot_fight_mode: Schema.optional(Schema.Boolean),
  clearance_level: Schema.optional(Schema.Literal("no_clearance", "jschallenge", "managed", "interactive")),
  domains: Schema.Array(Schema.String),
  ephemeral_id: Schema.optional(Schema.Boolean),
  mode: Schema.Literal("non-interactive", "invisible", "managed"),
  name: Schema.String,
  offlabel: Schema.optional(Schema.Boolean),
  region: Schema.optional(Schema.Literal("world", "china"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/challenges/widgets" }),
).annotations({ identifier: "Create1Request" }) as unknown as Schema.Schema<Create1Request>;

export interface Create1Response {
  result: { bot_fight_mode: boolean; clearance_level: "no_clearance" | "jschallenge" | "managed" | "interactive"; created_on: string; domains: string[]; ephemeral_id: boolean; mode: "non-interactive" | "invisible" | "managed"; modified_on: string; name: string; offlabel: boolean; region: "world" | "china"; secret: string; sitekey: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create1Response = Schema.Struct({
  result: Schema.Struct({
  bot_fight_mode: Schema.Boolean,
  clearance_level: Schema.Literal("no_clearance", "jschallenge", "managed", "interactive"),
  created_on: Schema.Date,
  domains: Schema.Array(Schema.String),
  ephemeral_id: Schema.Boolean,
  mode: Schema.Literal("non-interactive", "invisible", "managed"),
  modified_on: Schema.Date,
  name: Schema.String,
  offlabel: Schema.Boolean,
  region: Schema.Literal("world", "china"),
  secret: Schema.String,
  sitekey: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create1Response" }) as unknown as Schema.Schema<Create1Response>;

export const create1: (
  input: Create1Request
) => Effect.Effect<
  Create1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create1Request,
  output: Create1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_Request {
}

export const Get_Request = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/challenges/widgets/{sitekey}" }),
).annotations({ identifier: "Get_Request" }) as unknown as Schema.Schema<Get_Request>;

export interface Get_Response {
  result: { bot_fight_mode: boolean; clearance_level: "no_clearance" | "jschallenge" | "managed" | "interactive"; created_on: string; domains: string[]; ephemeral_id: boolean; mode: "non-interactive" | "invisible" | "managed"; modified_on: string; name: string; offlabel: boolean; region: "world" | "china"; secret: string; sitekey: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_Response = Schema.Struct({
  result: Schema.Struct({
  bot_fight_mode: Schema.Boolean,
  clearance_level: Schema.Literal("no_clearance", "jschallenge", "managed", "interactive"),
  created_on: Schema.Date,
  domains: Schema.Array(Schema.String),
  ephemeral_id: Schema.Boolean,
  mode: Schema.Literal("non-interactive", "invisible", "managed"),
  modified_on: Schema.Date,
  name: Schema.String,
  offlabel: Schema.Boolean,
  region: Schema.Literal("world", "china"),
  secret: Schema.String,
  sitekey: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_Response" }) as unknown as Schema.Schema<Get_Response>;

export const get_: (
  input: Get_Request
) => Effect.Effect<
  Get_Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_Request,
  output: Get_Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateRequest {
  body: { bot_fight_mode?: boolean; clearance_level?: "no_clearance" | "jschallenge" | "managed" | "interactive"; domains: string[]; ephemeral_id?: boolean; mode: "non-interactive" | "invisible" | "managed"; name: string; offlabel?: boolean; region?: "world" | "china" };
}

export const UpdateRequest = Schema.Struct({
  body: Schema.Struct({
  bot_fight_mode: Schema.optional(Schema.Boolean),
  clearance_level: Schema.optional(Schema.Literal("no_clearance", "jschallenge", "managed", "interactive")),
  domains: Schema.Array(Schema.String),
  ephemeral_id: Schema.optional(Schema.Boolean),
  mode: Schema.Literal("non-interactive", "invisible", "managed"),
  name: Schema.String,
  offlabel: Schema.optional(Schema.Boolean),
  region: Schema.optional(Schema.Literal("world", "china"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/challenges/widgets/{sitekey}" }),
).annotations({ identifier: "UpdateRequest" }) as unknown as Schema.Schema<UpdateRequest>;

export interface UpdateResponse {
  result: { bot_fight_mode: boolean; clearance_level: "no_clearance" | "jschallenge" | "managed" | "interactive"; created_on: string; domains: string[]; ephemeral_id: boolean; mode: "non-interactive" | "invisible" | "managed"; modified_on: string; name: string; offlabel: boolean; region: "world" | "china"; secret: string; sitekey: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateResponse = Schema.Struct({
  result: Schema.Struct({
  bot_fight_mode: Schema.Boolean,
  clearance_level: Schema.Literal("no_clearance", "jschallenge", "managed", "interactive"),
  created_on: Schema.Date,
  domains: Schema.Array(Schema.String),
  ephemeral_id: Schema.Boolean,
  mode: Schema.Literal("non-interactive", "invisible", "managed"),
  modified_on: Schema.Date,
  name: Schema.String,
  offlabel: Schema.Boolean,
  region: Schema.Literal("world", "china"),
  secret: Schema.String,
  sitekey: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateResponse" }) as unknown as Schema.Schema<UpdateResponse>;

export const update: (
  input: UpdateRequest
) => Effect.Effect<
  UpdateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateRequest,
  output: UpdateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_Request {
}

export const Delete_Request = Schema.Struct({

}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/challenges/widgets/{sitekey}" }),
).annotations({ identifier: "Delete_Request" }) as unknown as Schema.Schema<Delete_Request>;

export interface Delete_Response {
  result: { bot_fight_mode: boolean; clearance_level: "no_clearance" | "jschallenge" | "managed" | "interactive"; created_on: string; domains: string[]; ephemeral_id: boolean; mode: "non-interactive" | "invisible" | "managed"; modified_on: string; name: string; offlabel: boolean; region: "world" | "china"; secret: string; sitekey: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_Response = Schema.Struct({
  result: Schema.Struct({
  bot_fight_mode: Schema.Boolean,
  clearance_level: Schema.Literal("no_clearance", "jschallenge", "managed", "interactive"),
  created_on: Schema.Date,
  domains: Schema.Array(Schema.String),
  ephemeral_id: Schema.Boolean,
  mode: Schema.Literal("non-interactive", "invisible", "managed"),
  modified_on: Schema.Date,
  name: Schema.String,
  offlabel: Schema.Boolean,
  region: Schema.Literal("world", "china"),
  secret: Schema.String,
  sitekey: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_Response" }) as unknown as Schema.Schema<Delete_Response>;

export const delete_: (
  input: Delete_Request
) => Effect.Effect<
  Delete_Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_Request,
  output: Delete_Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountsTurnstileWidgetRotateSecretRequest {
  body: { invalidate_immediately?: boolean };
}

export const AccountsTurnstileWidgetRotateSecretRequest = Schema.Struct({
  body: Schema.Struct({
  invalidate_immediately: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/challenges/widgets/{sitekey}/rotate_secret" }),
).annotations({ identifier: "AccountsTurnstileWidgetRotateSecretRequest" }) as unknown as Schema.Schema<AccountsTurnstileWidgetRotateSecretRequest>;

export interface AccountsTurnstileWidgetRotateSecretResponse {
  result: { bot_fight_mode: boolean; clearance_level: "no_clearance" | "jschallenge" | "managed" | "interactive"; created_on: string; domains: string[]; ephemeral_id: boolean; mode: "non-interactive" | "invisible" | "managed"; modified_on: string; name: string; offlabel: boolean; region: "world" | "china"; secret: string; sitekey: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountsTurnstileWidgetRotateSecretResponse = Schema.Struct({
  result: Schema.Struct({
  bot_fight_mode: Schema.Boolean,
  clearance_level: Schema.Literal("no_clearance", "jschallenge", "managed", "interactive"),
  created_on: Schema.Date,
  domains: Schema.Array(Schema.String),
  ephemeral_id: Schema.Boolean,
  mode: Schema.Literal("non-interactive", "invisible", "managed"),
  modified_on: Schema.Date,
  name: Schema.String,
  offlabel: Schema.Boolean,
  region: Schema.Literal("world", "china"),
  secret: Schema.String,
  sitekey: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountsTurnstileWidgetRotateSecretResponse" }) as unknown as Schema.Schema<AccountsTurnstileWidgetRotateSecretResponse>;

export const accountsTurnstileWidgetRotateSecret: (
  input: AccountsTurnstileWidgetRotateSecretRequest
) => Effect.Effect<
  AccountsTurnstileWidgetRotateSecretResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountsTurnstileWidgetRotateSecretRequest,
  output: AccountsTurnstileWidgetRotateSecretResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostBindbpostRequest {
  account_id: number;
  body: FormData;
}

export const PostBindbpostRequest = Schema.Struct({
  account_id: Schema.Number.pipe(T.HttpPath("account_id")),
  body: Schema.instanceOf(FormData).pipe(T.HttpFormData())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/binary" }),
).annotations({ identifier: "PostBindbpostRequest" }) as unknown as Schema.Schema<PostBindbpostRequest>;

export interface PostBindbpostResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostBindbpostResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostBindbpostResponse" }) as unknown as Schema.Schema<PostBindbpostResponse>;

export const postBindbpost: (
  input: PostBindbpostRequest
) => Effect.Effect<
  PostBindbpostResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostBindbpostRequest,
  output: PostBindbpostResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetBindbgetbinaryRequest {
  account_id: number;
  hash: string;
}

export const GetBindbgetbinaryRequest = Schema.Struct({
  account_id: Schema.Number.pipe(T.HttpPath("account_id")),
  hash: Schema.String.pipe(T.HttpPath("hash"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/binary/{hash}" }),
).annotations({ identifier: "GetBindbgetbinaryRequest" }) as unknown as Schema.Schema<GetBindbgetbinaryRequest>;

export interface GetBindbgetbinaryResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetBindbgetbinaryResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetBindbgetbinaryResponse" }) as unknown as Schema.Schema<GetBindbgetbinaryResponse>;

export const getBindbgetbinary: (
  input: GetBindbgetbinaryRequest
) => Effect.Effect<
  GetBindbgetbinaryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBindbgetbinaryRequest,
  output: GetBindbgetbinaryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetEventlistgetRequest {
  account_id: string;
  search?: { field?: string; op?: "equals" | "not" | "gt" | "gte" | "lt" | "lte" | "like" | "contains" | "startsWith" | "endsWith" | "in" | "find"; value?: unknown }[];
  page?: number;
  pageSize?: number;
  orderBy?: string;
  order?: "asc" | "desc";
  datasetId?: string[];
  forceRefresh?: boolean;
  format?: "json" | "stix2";
}

export const GetEventlistgetRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  search: Schema.optional(Schema.Array(Schema.Struct({
  field: Schema.optional(Schema.String),
  op: Schema.optional(Schema.Literal("equals", "not", "gt", "gte", "lt", "lte", "like", "contains", "startsWith", "endsWith", "in", "find")),
  value: Schema.optional(Schema.Union(Schema.String, Schema.Number, Schema.Array(Schema.Union(Schema.String, Schema.Number))))
}))).pipe(T.HttpQuery("search")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
  order: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("order")),
  datasetId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("datasetId")),
  forceRefresh: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("forceRefresh")),
  format: Schema.optional(Schema.Literal("json", "stix2")).pipe(T.HttpQuery("format"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events" }),
).annotations({ identifier: "GetEventlistgetRequest" }) as unknown as Schema.Schema<GetEventlistgetRequest>;

export interface GetEventlistgetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetEventlistgetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetEventlistgetResponse" }) as unknown as Schema.Schema<GetEventlistgetResponse>;

export const getEventlistget: (
  input: GetEventlistgetRequest
) => Effect.Effect<
  GetEventlistgetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEventlistgetRequest,
  output: GetEventlistgetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetEventaggregateRequest {
  account_id: string;
  aggregateBy: string;
  datasetId?: unknown;
  startDate?: string;
  endDate?: string;
  groupByDate?: boolean;
  limit?: number;
}

export const GetEventaggregateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  aggregateBy: Schema.String.pipe(T.HttpQuery("aggregateBy")),
  datasetId: Schema.optional(Schema.Union(Schema.String, Schema.Array(Schema.String))).pipe(T.HttpQuery("datasetId")),
  startDate: Schema.optional(Schema.String).pipe(T.HttpQuery("startDate")),
  endDate: Schema.optional(Schema.String).pipe(T.HttpQuery("endDate")),
  groupByDate: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("groupByDate")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/aggregate" }),
).annotations({ identifier: "GetEventaggregateRequest" }) as unknown as Schema.Schema<GetEventaggregateRequest>;

export interface GetEventaggregateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetEventaggregateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetEventaggregateResponse" }) as unknown as Schema.Schema<GetEventaggregateResponse>;

export const getEventaggregate: (
  input: GetEventaggregateRequest
) => Effect.Effect<
  GetEventaggregateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEventaggregateRequest,
  output: GetEventaggregateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAttackerlistRequest {
  account_id: string;
  datasetIds?: string[];
}

export const GetAttackerlistRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  datasetIds: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("datasetIds"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/attackers" }),
).annotations({ identifier: "GetAttackerlistRequest" }) as unknown as Schema.Schema<GetAttackerlistRequest>;

export interface GetAttackerlistResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAttackerlistResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAttackerlistResponse" }) as unknown as Schema.Schema<GetAttackerlistResponse>;

export const getAttackerlist: (
  input: GetAttackerlistRequest
) => Effect.Effect<
  GetAttackerlistResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAttackerlistRequest,
  output: GetAttackerlistResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetCategorylistRequest {
  account_id: string;
  datasetIds?: string[];
}

export const GetCategorylistRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  datasetIds: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("datasetIds"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/categories" }),
).annotations({ identifier: "GetCategorylistRequest" }) as unknown as Schema.Schema<GetCategorylistRequest>;

export interface GetCategorylistResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetCategorylistResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetCategorylistResponse" }) as unknown as Schema.Schema<GetCategorylistResponse>;

export const getCategorylist: (
  input: GetCategorylistRequest
) => Effect.Effect<
  GetCategorylistResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCategorylistRequest,
  output: GetCategorylistResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetCategorylistcompleteRequest {
  account_id: string;
}

export const GetCategorylistcompleteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/categories/catalog" }),
).annotations({ identifier: "GetCategorylistcompleteRequest" }) as unknown as Schema.Schema<GetCategorylistcompleteRequest>;

export interface GetCategorylistcompleteResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetCategorylistcompleteResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetCategorylistcompleteResponse" }) as unknown as Schema.Schema<GetCategorylistcompleteResponse>;

export const getCategorylistcomplete: (
  input: GetCategorylistcompleteRequest
) => Effect.Effect<
  GetCategorylistcompleteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCategorylistcompleteRequest,
  output: GetCategorylistcompleteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostCategorycreateRequest {
  account_id: string;
  body: { killChain: number; mitreAttack?: string[]; name: string; shortname?: string };
}

export const PostCategorycreateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  killChain: Schema.Number,
  mitreAttack: Schema.optional(Schema.Array(Schema.String)),
  name: Schema.String,
  shortname: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/categories/create" }),
).annotations({ identifier: "PostCategorycreateRequest" }) as unknown as Schema.Schema<PostCategorycreateRequest>;

export interface PostCategorycreateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostCategorycreateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostCategorycreateResponse" }) as unknown as Schema.Schema<PostCategorycreateResponse>;

export const postCategorycreate: (
  input: PostCategorycreateRequest
) => Effect.Effect<
  PostCategorycreateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostCategorycreateRequest,
  output: PostCategorycreateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetCategoryreadRequest {
  account_id: string;
  category_id: string;
}

export const GetCategoryreadRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  category_id: Schema.UUID.pipe(T.HttpPath("category_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/categories/{category_id}" }),
).annotations({ identifier: "GetCategoryreadRequest" }) as unknown as Schema.Schema<GetCategoryreadRequest>;

export interface GetCategoryreadResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetCategoryreadResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetCategoryreadResponse" }) as unknown as Schema.Schema<GetCategoryreadResponse>;

export const getCategoryread: (
  input: GetCategoryreadRequest
) => Effect.Effect<
  GetCategoryreadResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCategoryreadRequest,
  output: GetCategoryreadResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostCategoryupdateRequest {
  account_id: string;
  category_id: string;
  body: { killChain?: number; mitreAttack?: string[]; name?: string; shortname?: string };
}

export const PostCategoryupdateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  category_id: Schema.UUID.pipe(T.HttpPath("category_id")),
  body: Schema.Struct({
  killChain: Schema.optional(Schema.Number),
  mitreAttack: Schema.optional(Schema.Array(Schema.String)),
  name: Schema.optional(Schema.String),
  shortname: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/categories/{category_id}" }),
).annotations({ identifier: "PostCategoryupdateRequest" }) as unknown as Schema.Schema<PostCategoryupdateRequest>;

export interface PostCategoryupdateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostCategoryupdateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostCategoryupdateResponse" }) as unknown as Schema.Schema<PostCategoryupdateResponse>;

export const postCategoryupdate: (
  input: PostCategoryupdateRequest
) => Effect.Effect<
  PostCategoryupdateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostCategoryupdateRequest,
  output: PostCategoryupdateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteCategorydeleteRequest {
  account_id: string;
  category_id: string;
}

export const DeleteCategorydeleteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  category_id: Schema.UUID.pipe(T.HttpPath("category_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cloudforce-one/events/categories/{category_id}" }),
).annotations({ identifier: "DeleteCategorydeleteRequest" }) as unknown as Schema.Schema<DeleteCategorydeleteRequest>;

export interface DeleteCategorydeleteResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteCategorydeleteResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteCategorydeleteResponse" }) as unknown as Schema.Schema<DeleteCategorydeleteResponse>;

export const deleteCategorydelete: (
  input: DeleteCategorydeleteRequest
) => Effect.Effect<
  DeleteCategorydeleteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteCategorydeleteRequest,
  output: DeleteCategorydeleteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchCategoryupdateRequest {
  account_id: string;
  category_id: string;
  body: { killChain?: number; mitreAttack?: string[]; name?: string; shortname?: string };
}

export const PatchCategoryupdateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  category_id: Schema.UUID.pipe(T.HttpPath("category_id")),
  body: Schema.Struct({
  killChain: Schema.optional(Schema.Number),
  mitreAttack: Schema.optional(Schema.Array(Schema.String)),
  name: Schema.optional(Schema.String),
  shortname: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/cloudforce-one/events/categories/{category_id}" }),
).annotations({ identifier: "PatchCategoryupdateRequest" }) as unknown as Schema.Schema<PatchCategoryupdateRequest>;

export interface PatchCategoryupdateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchCategoryupdateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchCategoryupdateResponse" }) as unknown as Schema.Schema<PatchCategoryupdateResponse>;

export const patchCategoryupdate: (
  input: PatchCategoryupdateRequest
) => Effect.Effect<
  PatchCategoryupdateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchCategoryupdateRequest,
  output: PatchCategoryupdateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetCountryreadRequest {
  account_id: string;
}

export const GetCountryreadRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/countries" }),
).annotations({ identifier: "GetCountryreadRequest" }) as unknown as Schema.Schema<GetCountryreadRequest>;

export interface GetCountryreadResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetCountryreadResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetCountryreadResponse" }) as unknown as Schema.Schema<GetCountryreadResponse>;

export const getCountryread: (
  input: GetCountryreadRequest
) => Effect.Effect<
  GetCountryreadResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCountryreadRequest,
  output: GetCountryreadResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostEventcreateRequest {
  account_id: string;
  body: { accountId?: number; attacker?: string; attackerCountry?: string; category: string; datasetId?: string; date: string; event: string; indicator?: string; indicatorType?: string; indicators?: { indicatorType: string; value: string }[]; insight?: string; raw: { data: Record<string, unknown>; source?: string; tlp?: string }; tags?: string[]; targetCountry?: string; targetIndustry?: string; tlp: string; uuid?: string };
}

export const PostEventcreateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  accountId: Schema.optional(Schema.Number),
  attacker: Schema.optional(Schema.String),
  attackerCountry: Schema.optional(Schema.String),
  category: Schema.String,
  datasetId: Schema.optional(Schema.String),
  date: Schema.Date,
  event: Schema.String,
  indicator: Schema.optional(Schema.String),
  indicatorType: Schema.optional(Schema.String),
  indicators: Schema.optional(Schema.Array(Schema.Struct({
  indicatorType: Schema.String,
  value: Schema.String
}))),
  insight: Schema.optional(Schema.String),
  raw: Schema.Struct({
  data: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  source: Schema.optional(Schema.String),
  tlp: Schema.optional(Schema.String)
}),
  tags: Schema.optional(Schema.Array(Schema.String)),
  targetCountry: Schema.optional(Schema.String),
  targetIndustry: Schema.optional(Schema.String),
  tlp: Schema.String,
  uuid: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/create" }),
).annotations({ identifier: "PostEventcreateRequest" }) as unknown as Schema.Schema<PostEventcreateRequest>;

export interface PostEventcreateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostEventcreateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostEventcreateResponse" }) as unknown as Schema.Schema<PostEventcreateResponse>;

export const postEventcreate: (
  input: PostEventcreateRequest
) => Effect.Effect<
  PostEventcreateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostEventcreateRequest,
  output: PostEventcreateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostEventcreatebulkRequest {
  account_id: string;
  body: { data: { accountId?: number; attacker?: string; attackerCountry?: string; category: string; datasetId?: string; date: string; event: string; indicator?: string; indicatorType?: string; indicators?: { indicatorType: string; value: string }[]; insight?: string; raw: { data: Record<string, unknown>; source?: string; tlp?: string }; tags?: string[]; targetCountry?: string; targetIndustry?: string; tlp: string; uuid?: string }[]; datasetId: string; preserveUuid?: boolean };
}

export const PostEventcreatebulkRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  data: Schema.Array(Schema.Struct({
  accountId: Schema.optional(Schema.Number),
  attacker: Schema.optional(Schema.String),
  attackerCountry: Schema.optional(Schema.String),
  category: Schema.String,
  datasetId: Schema.optional(Schema.String),
  date: Schema.Date,
  event: Schema.String,
  indicator: Schema.optional(Schema.String),
  indicatorType: Schema.optional(Schema.String),
  indicators: Schema.optional(Schema.Array(Schema.Struct({
  indicatorType: Schema.String,
  value: Schema.String
}))),
  insight: Schema.optional(Schema.String),
  raw: Schema.Struct({
  data: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  source: Schema.optional(Schema.String),
  tlp: Schema.optional(Schema.String)
}),
  tags: Schema.optional(Schema.Array(Schema.String)),
  targetCountry: Schema.optional(Schema.String),
  targetIndustry: Schema.optional(Schema.String),
  tlp: Schema.String,
  uuid: Schema.optional(Schema.String)
})),
  datasetId: Schema.String,
  preserveUuid: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/create/bulk" }),
).annotations({ identifier: "PostEventcreatebulkRequest" }) as unknown as Schema.Schema<PostEventcreatebulkRequest>;

export interface PostEventcreatebulkResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostEventcreatebulkResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostEventcreatebulkResponse" }) as unknown as Schema.Schema<PostEventcreatebulkResponse>;

export const postEventcreatebulk: (
  input: PostEventcreatebulkRequest
) => Effect.Effect<
  PostEventcreatebulkResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostEventcreatebulkRequest,
  output: PostEventcreatebulkResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostDoseventcreatebulkwithrelationshipsRequest {
  account_id: string;
  body: { data: { accountId?: number; attacker?: string; attackerCountry?: string; category: string; datasetId?: string; date: string; event: string; indicator?: string; indicatorType?: string; indicators?: { indicatorType: string; value: string }[]; insight?: string; raw: { data: Record<string, unknown>; source?: string; tlp?: string }; tags?: string[]; targetCountry?: string; targetIndustry?: string; tlp: string; uuid?: string }[]; datasetId: string };
}

export const PostDoseventcreatebulkwithrelationshipsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  data: Schema.Array(Schema.Struct({
  accountId: Schema.optional(Schema.Number),
  attacker: Schema.optional(Schema.String),
  attackerCountry: Schema.optional(Schema.String),
  category: Schema.String,
  datasetId: Schema.optional(Schema.String),
  date: Schema.Date,
  event: Schema.String,
  indicator: Schema.optional(Schema.String),
  indicatorType: Schema.optional(Schema.String),
  indicators: Schema.optional(Schema.Array(Schema.Struct({
  indicatorType: Schema.String,
  value: Schema.String
}))),
  insight: Schema.optional(Schema.String),
  raw: Schema.Struct({
  data: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  source: Schema.optional(Schema.String),
  tlp: Schema.optional(Schema.String)
}),
  tags: Schema.optional(Schema.Array(Schema.String)),
  targetCountry: Schema.optional(Schema.String),
  targetIndustry: Schema.optional(Schema.String),
  tlp: Schema.String,
  uuid: Schema.optional(Schema.String)
})),
  datasetId: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/create/bulk/relationships" }),
).annotations({ identifier: "PostDoseventcreatebulkwithrelationshipsRequest" }) as unknown as Schema.Schema<PostDoseventcreatebulkwithrelationshipsRequest>;

export interface PostDoseventcreatebulkwithrelationshipsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostDoseventcreatebulkwithrelationshipsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostDoseventcreatebulkwithrelationshipsResponse" }) as unknown as Schema.Schema<PostDoseventcreatebulkwithrelationshipsResponse>;

export const postDoseventcreatebulkwithrelationships: (
  input: PostDoseventcreatebulkwithrelationshipsRequest
) => Effect.Effect<
  PostDoseventcreatebulkwithrelationshipsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostDoseventcreatebulkwithrelationshipsRequest,
  output: PostDoseventcreatebulkwithrelationshipsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDatasetlistRequest {
  account_id: string;
}

export const GetDatasetlistRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/dataset" }),
).annotations({ identifier: "GetDatasetlistRequest" }) as unknown as Schema.Schema<GetDatasetlistRequest>;

export interface GetDatasetlistResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDatasetlistResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDatasetlistResponse" }) as unknown as Schema.Schema<GetDatasetlistResponse>;

export const getDatasetlist: (
  input: GetDatasetlistRequest
) => Effect.Effect<
  GetDatasetlistResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDatasetlistRequest,
  output: GetDatasetlistResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostDatasetcreateRequest {
  account_id: string;
  body: { isPublic: boolean; name: string };
}

export const PostDatasetcreateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  isPublic: Schema.Boolean,
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/dataset/create" }),
).annotations({ identifier: "PostDatasetcreateRequest" }) as unknown as Schema.Schema<PostDatasetcreateRequest>;

export interface PostDatasetcreateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostDatasetcreateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostDatasetcreateResponse" }) as unknown as Schema.Schema<PostDatasetcreateResponse>;

export const postDatasetcreate: (
  input: PostDatasetcreateRequest
) => Effect.Effect<
  PostDatasetcreateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostDatasetcreateRequest,
  output: PostDatasetcreateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDatasetreadRequest {
  account_id: string;
  dataset_id: string;
}

export const GetDatasetreadRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/dataset/{dataset_id}" }),
).annotations({ identifier: "GetDatasetreadRequest" }) as unknown as Schema.Schema<GetDatasetreadRequest>;

export interface GetDatasetreadResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDatasetreadResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDatasetreadResponse" }) as unknown as Schema.Schema<GetDatasetreadResponse>;

export const getDatasetread: (
  input: GetDatasetreadRequest
) => Effect.Effect<
  GetDatasetreadResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDatasetreadRequest,
  output: GetDatasetreadResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostDatasetupdateRequest {
  account_id: string;
  dataset_id: string;
  body: { isPublic: boolean; name: string };
}

export const PostDatasetupdateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id")),
  body: Schema.Struct({
  isPublic: Schema.Boolean,
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/dataset/{dataset_id}" }),
).annotations({ identifier: "PostDatasetupdateRequest" }) as unknown as Schema.Schema<PostDatasetupdateRequest>;

export interface PostDatasetupdateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostDatasetupdateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostDatasetupdateResponse" }) as unknown as Schema.Schema<PostDatasetupdateResponse>;

export const postDatasetupdate: (
  input: PostDatasetupdateRequest
) => Effect.Effect<
  PostDatasetupdateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostDatasetupdateRequest,
  output: PostDatasetupdateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDatasetdeleteRequest {
  account_id: string;
  dataset_id: string;
}

export const DeleteDatasetdeleteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.String.pipe(T.HttpPath("dataset_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cloudforce-one/events/dataset/{dataset_id}" }),
).annotations({ identifier: "DeleteDatasetdeleteRequest" }) as unknown as Schema.Schema<DeleteDatasetdeleteRequest>;

export interface DeleteDatasetdeleteResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDatasetdeleteResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDatasetdeleteResponse" }) as unknown as Schema.Schema<DeleteDatasetdeleteResponse>;

export const deleteDatasetdelete: (
  input: DeleteDatasetdeleteRequest
) => Effect.Effect<
  DeleteDatasetdeleteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDatasetdeleteRequest,
  output: DeleteDatasetdeleteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchDatasetupdateRequest {
  account_id: string;
  dataset_id: string;
  body: { isPublic: boolean; name: string };
}

export const PatchDatasetupdateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id")),
  body: Schema.Struct({
  isPublic: Schema.Boolean,
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/cloudforce-one/events/dataset/{dataset_id}" }),
).annotations({ identifier: "PatchDatasetupdateRequest" }) as unknown as Schema.Schema<PatchDatasetupdateRequest>;

export interface PatchDatasetupdateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchDatasetupdateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchDatasetupdateResponse" }) as unknown as Schema.Schema<PatchDatasetupdateResponse>;

export const patchDatasetupdate: (
  input: PatchDatasetupdateRequest
) => Effect.Effect<
  PatchDatasetupdateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchDatasetupdateRequest,
  output: PatchDatasetupdateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetEventreadRequest {
  account_id: string;
  dataset_id: string;
  event_id: string;
}

export const GetEventreadRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.String.pipe(T.HttpPath("dataset_id")),
  event_id: Schema.String.pipe(T.HttpPath("event_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/dataset/{dataset_id}/events/{event_id}" }),
).annotations({ identifier: "GetEventreadRequest" }) as unknown as Schema.Schema<GetEventreadRequest>;

export interface GetEventreadResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetEventreadResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetEventreadResponse" }) as unknown as Schema.Schema<GetEventreadResponse>;

export const getEventread: (
  input: GetEventreadRequest
) => Effect.Effect<
  GetEventreadResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEventreadRequest,
  output: GetEventreadResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostIndicatortypecreateRequest {
  account_id: string;
  dataset_id: string;
  body: { description?: string; indicatorType: string };
}

export const PostIndicatortypecreateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.String.pipe(T.HttpPath("dataset_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  indicatorType: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/dataset/{dataset_id}/indicatorTypes/create" }),
).annotations({ identifier: "PostIndicatortypecreateRequest" }) as unknown as Schema.Schema<PostIndicatortypecreateRequest>;

export interface PostIndicatortypecreateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostIndicatortypecreateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostIndicatortypecreateResponse" }) as unknown as Schema.Schema<PostIndicatortypecreateResponse>;

export const postIndicatortypecreate: (
  input: PostIndicatortypecreateRequest
) => Effect.Effect<
  PostIndicatortypecreateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostIndicatortypecreateRequest,
  output: PostIndicatortypecreateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetIndicatorlistlegacyRequest {
  account_id: string;
  dataset_id: string;
  page?: number;
  pageSize?: number;
  search?: string;
  indicatorType?: string;
  relatedEvent?: string[];
}

export const GetIndicatorlistlegacyRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
  indicatorType: Schema.optional(Schema.String).pipe(T.HttpQuery("indicatorType")),
  relatedEvent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("relatedEvent"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/dataset/{dataset_id}/indicators" }),
).annotations({ identifier: "GetIndicatorlistlegacyRequest" }) as unknown as Schema.Schema<GetIndicatorlistlegacyRequest>;

export interface GetIndicatorlistlegacyResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetIndicatorlistlegacyResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetIndicatorlistlegacyResponse" }) as unknown as Schema.Schema<GetIndicatorlistlegacyResponse>;

export const getIndicatorlistlegacy: (
  input: GetIndicatorlistlegacyRequest
) => Effect.Effect<
  GetIndicatorlistlegacyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetIndicatorlistlegacyRequest,
  output: GetIndicatorlistlegacyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostIndicatorcreatebulkRequest {
  account_id: string;
  dataset_id: string;
  body: { autoCreateType?: boolean; indicators: { autoCreateType?: boolean; indicatorType: string; relatedEvents?: { datasetId: string; eventId: string }[]; tags?: unknown[]; value: string }[] };
}

export const PostIndicatorcreatebulkRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id")),
  body: Schema.Struct({
  autoCreateType: Schema.optional(Schema.Boolean),
  indicators: Schema.Array(Schema.Struct({
  autoCreateType: Schema.optional(Schema.Boolean),
  indicatorType: Schema.String,
  relatedEvents: Schema.optional(Schema.Array(Schema.Struct({
  datasetId: Schema.String,
  eventId: Schema.String
}))),
  tags: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.Struct({
  categoryName: Schema.optional(Schema.String),
  value: Schema.String
})))),
  value: Schema.String
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/dataset/{dataset_id}/indicators/bulk" }),
).annotations({ identifier: "PostIndicatorcreatebulkRequest" }) as unknown as Schema.Schema<PostIndicatorcreatebulkRequest>;

export interface PostIndicatorcreatebulkResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostIndicatorcreatebulkResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostIndicatorcreatebulkResponse" }) as unknown as Schema.Schema<PostIndicatorcreatebulkResponse>;

export const postIndicatorcreatebulk: (
  input: PostIndicatorcreatebulkRequest
) => Effect.Effect<
  PostIndicatorcreatebulkResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostIndicatorcreatebulkRequest,
  output: PostIndicatorcreatebulkResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostIndicatorcreateRequest {
  account_id: string;
  dataset_id: string;
  body: { autoCreateType?: boolean; indicatorType: string; relatedEvents?: { datasetId: string; eventId: string }[]; tags?: unknown[]; value: string };
}

export const PostIndicatorcreateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id")),
  body: Schema.Struct({
  autoCreateType: Schema.optional(Schema.Boolean),
  indicatorType: Schema.String,
  relatedEvents: Schema.optional(Schema.Array(Schema.Struct({
  datasetId: Schema.String,
  eventId: Schema.String
}))),
  tags: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.Struct({
  categoryName: Schema.optional(Schema.String),
  value: Schema.String
})))),
  value: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/dataset/{dataset_id}/indicators/create" }),
).annotations({ identifier: "PostIndicatorcreateRequest" }) as unknown as Schema.Schema<PostIndicatorcreateRequest>;

export interface PostIndicatorcreateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostIndicatorcreateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostIndicatorcreateResponse" }) as unknown as Schema.Schema<PostIndicatorcreateResponse>;

export const postIndicatorcreate: (
  input: PostIndicatorcreateRequest
) => Effect.Effect<
  PostIndicatorcreateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostIndicatorcreateRequest,
  output: PostIndicatorcreateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetIndicatortagslistRequest {
  account_id: string;
  dataset_id: string;
}

export const GetIndicatortagslistRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.String.pipe(T.HttpPath("dataset_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/dataset/{dataset_id}/indicators/tags" }),
).annotations({ identifier: "GetIndicatortagslistRequest" }) as unknown as Schema.Schema<GetIndicatortagslistRequest>;

export interface GetIndicatortagslistResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetIndicatortagslistResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetIndicatortagslistResponse" }) as unknown as Schema.Schema<GetIndicatortagslistResponse>;

export const getIndicatortagslist: (
  input: GetIndicatortagslistRequest
) => Effect.Effect<
  GetIndicatortagslistResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetIndicatortagslistRequest,
  output: GetIndicatortagslistResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetIndicatorreadRequest {
  account_id: string;
  dataset_id: string;
  indicator_id: string;
}

export const GetIndicatorreadRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.String.pipe(T.HttpPath("dataset_id")),
  indicator_id: Schema.String.pipe(T.HttpPath("indicator_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/dataset/{dataset_id}/indicators/{indicator_id}" }),
).annotations({ identifier: "GetIndicatorreadRequest" }) as unknown as Schema.Schema<GetIndicatorreadRequest>;

export interface GetIndicatorreadResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetIndicatorreadResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetIndicatorreadResponse" }) as unknown as Schema.Schema<GetIndicatorreadResponse>;

export const getIndicatorread: (
  input: GetIndicatorreadRequest
) => Effect.Effect<
  GetIndicatorreadResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetIndicatorreadRequest,
  output: GetIndicatorreadResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteIndicatordeleteRequest {
  account_id: string;
  dataset_id: string;
  indicator_id: string;
}

export const DeleteIndicatordeleteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.String.pipe(T.HttpPath("dataset_id")),
  indicator_id: Schema.String.pipe(T.HttpPath("indicator_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cloudforce-one/events/dataset/{dataset_id}/indicators/{indicator_id}" }),
).annotations({ identifier: "DeleteIndicatordeleteRequest" }) as unknown as Schema.Schema<DeleteIndicatordeleteRequest>;

export interface DeleteIndicatordeleteResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteIndicatordeleteResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteIndicatordeleteResponse" }) as unknown as Schema.Schema<DeleteIndicatordeleteResponse>;

export const deleteIndicatordelete: (
  input: DeleteIndicatordeleteRequest
) => Effect.Effect<
  DeleteIndicatordeleteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteIndicatordeleteRequest,
  output: DeleteIndicatordeleteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchIndicatorupdateRequest {
  account_id: string;
  dataset_id: string;
  indicator_id: string;
  body: { indicatorType?: string; relatedEvents?: { datasetId: string; eventId: string }[]; tags?: unknown[]; value?: string };
}

export const PatchIndicatorupdateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.String.pipe(T.HttpPath("dataset_id")),
  indicator_id: Schema.String.pipe(T.HttpPath("indicator_id")),
  body: Schema.Struct({
  indicatorType: Schema.optional(Schema.String),
  relatedEvents: Schema.optional(Schema.Array(Schema.Struct({
  datasetId: Schema.String,
  eventId: Schema.String
}))),
  tags: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.Struct({
  categoryName: Schema.optional(Schema.String),
  value: Schema.String
})))),
  value: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/cloudforce-one/events/dataset/{dataset_id}/indicators/{indicator_id}" }),
).annotations({ identifier: "PatchIndicatorupdateRequest" }) as unknown as Schema.Schema<PatchIndicatorupdateRequest>;

export interface PatchIndicatorupdateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchIndicatorupdateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchIndicatorupdateResponse" }) as unknown as Schema.Schema<PatchIndicatorupdateResponse>;

export const patchIndicatorupdate: (
  input: PatchIndicatorupdateRequest
) => Effect.Effect<
  PatchIndicatorupdateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchIndicatorupdateRequest,
  output: PatchIndicatorupdateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostEventmovetonewdsRequest {
  account_id: string;
  dataset_id: string;
  body: { destDatasetId: string; eventIds?: string[] };
}

export const PostEventmovetonewdsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id")),
  body: Schema.Struct({
  destDatasetId: Schema.String,
  eventIds: Schema.optional(Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/dataset/{dataset_id}/move" }),
).annotations({ identifier: "PostEventmovetonewdsRequest" }) as unknown as Schema.Schema<PostEventmovetonewdsRequest>;

export interface PostEventmovetonewdsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostEventmovetonewdsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostEventmovetonewdsResponse" }) as unknown as Schema.Schema<PostEventmovetonewdsResponse>;

export const postEventmovetonewds: (
  input: PostEventmovetonewdsRequest
) => Effect.Effect<
  PostEventmovetonewdsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostEventmovetonewdsRequest,
  output: PostEventmovetonewdsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetTagindicatorslistRequest {
  account_id: string;
  tag_uuid: string;
  dataset_id: string;
  page?: number;
  pageSize?: number;
  indicatorType?: string;
  relatedEvent?: string[];
}

export const GetTagindicatorslistRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  tag_uuid: Schema.String.pipe(T.HttpPath("tag_uuid")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  indicatorType: Schema.optional(Schema.String).pipe(T.HttpQuery("indicatorType")),
  relatedEvent: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("relatedEvent"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/dataset/{dataset_id}/tags/{tag_uuid}/indicators" }),
).annotations({ identifier: "GetTagindicatorslistRequest" }) as unknown as Schema.Schema<GetTagindicatorslistRequest>;

export interface GetTagindicatorslistResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetTagindicatorslistResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetTagindicatorslistResponse" }) as unknown as Schema.Schema<GetTagindicatorslistResponse>;

export const getTagindicatorslist: (
  input: GetTagindicatorslistRequest
) => Effect.Effect<
  GetTagindicatorslistResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTagindicatorslistRequest,
  output: GetTagindicatorslistResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetTargetindustrylistbydatasetRequest {
  account_id: string;
  dataset_id: string;
}

export const GetTargetindustrylistbydatasetRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/dataset/{dataset_id}/targetIndustries" }),
).annotations({ identifier: "GetTargetindustrylistbydatasetRequest" }) as unknown as Schema.Schema<GetTargetindustrylistbydatasetRequest>;

export interface GetTargetindustrylistbydatasetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetTargetindustrylistbydatasetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetTargetindustrylistbydatasetResponse" }) as unknown as Schema.Schema<GetTargetindustrylistbydatasetResponse>;

export const getTargetindustrylistbydataset: (
  input: GetTargetindustrylistbydatasetRequest
) => Effect.Effect<
  GetTargetindustrylistbydatasetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTargetindustrylistbydatasetRequest,
  output: GetTargetindustrylistbydatasetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostDatasetpopulateRequest {
  account_id: string;
}

export const PostDatasetpopulateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/datasets/populate" }),
).annotations({ identifier: "PostDatasetpopulateRequest" }) as unknown as Schema.Schema<PostDatasetpopulateRequest>;

export interface PostDatasetpopulateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostDatasetpopulateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostDatasetpopulateResponse" }) as unknown as Schema.Schema<PostDatasetpopulateResponse>;

export const postDatasetpopulate: (
  input: PostDatasetpopulateRequest
) => Effect.Effect<
  PostDatasetpopulateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostDatasetpopulateRequest,
  output: PostDatasetpopulateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteEventtagdeleteRequest {
  account_id: string;
  event_id: string;
  body: { tags: string[] };
}

export const DeleteEventtagdeleteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  event_id: Schema.String.pipe(T.HttpPath("event_id")),
  body: Schema.Struct({
  tags: Schema.Array(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cloudforce-one/events/event_tag/{event_id}" }),
).annotations({ identifier: "DeleteEventtagdeleteRequest" }) as unknown as Schema.Schema<DeleteEventtagdeleteRequest>;

export interface DeleteEventtagdeleteResponse {
  result: { success: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteEventtagdeleteResponse = Schema.Struct({
  result: Schema.Struct({
  success: Schema.Boolean
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteEventtagdeleteResponse" }) as unknown as Schema.Schema<DeleteEventtagdeleteResponse>;

export const deleteEventtagdelete: (
  input: DeleteEventtagdeleteRequest
) => Effect.Effect<
  DeleteEventtagdeleteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteEventtagdeleteRequest,
  output: DeleteEventtagdeleteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostEventtagcreateRequest {
  account_id: string;
  event_id: string;
  body: { tags: string[] };
}

export const PostEventtagcreateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  event_id: Schema.String.pipe(T.HttpPath("event_id")),
  body: Schema.Struct({
  tags: Schema.Array(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/event_tag/{event_id}/create" }),
).annotations({ identifier: "PostEventtagcreateRequest" }) as unknown as Schema.Schema<PostEventtagcreateRequest>;

export interface PostEventtagcreateResponse {
  result: { success: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostEventtagcreateResponse = Schema.Struct({
  result: Schema.Struct({
  success: Schema.Boolean
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostEventtagcreateResponse" }) as unknown as Schema.Schema<PostEventtagcreateResponse>;

export const postEventtagcreate: (
  input: PostEventtagcreateRequest
) => Effect.Effect<
  PostEventtagcreateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostEventtagcreateRequest,
  output: PostEventtagcreateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetIndicatortypeslistRequest {
  account_id: string;
  datasetIds?: string[];
}

export const GetIndicatortypeslistRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  datasetIds: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("datasetIds"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/indicator-types" }),
).annotations({ identifier: "GetIndicatortypeslistRequest" }) as unknown as Schema.Schema<GetIndicatortypeslistRequest>;

export interface GetIndicatortypeslistResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetIndicatortypeslistResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetIndicatortypeslistResponse" }) as unknown as Schema.Schema<GetIndicatortypeslistResponse>;

export const getIndicatortypeslist: (
  input: GetIndicatortypeslistRequest
) => Effect.Effect<
  GetIndicatortypeslistResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetIndicatortypeslistRequest,
  output: GetIndicatortypeslistResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetLegacyindicatortypeslistRequest {
  account_id: string;
}

export const GetLegacyindicatortypeslistRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/indicatorTypes" }),
).annotations({ identifier: "GetLegacyindicatortypeslistRequest" }) as unknown as Schema.Schema<GetLegacyindicatortypeslistRequest>;

export interface GetLegacyindicatortypeslistResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetLegacyindicatortypeslistResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetLegacyindicatortypeslistResponse" }) as unknown as Schema.Schema<GetLegacyindicatortypeslistResponse>;

export const getLegacyindicatortypeslist: (
  input: GetLegacyindicatortypeslistRequest
) => Effect.Effect<
  GetLegacyindicatortypeslistResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetLegacyindicatortypeslistRequest,
  output: GetLegacyindicatortypeslistResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetIndicatorlistRequest {
  account_id: string;
  datasetIds?: string[];
  page?: number;
  pageSize?: number;
  search?: string;
  indicatorType?: string;
  relatedEvents?: string[];
  tags?: string[];
  createdAfter?: string;
  createdBefore?: string;
  relatedEventsLimit?: number;
  includeTags?: boolean;
  includeTotalCount?: boolean;
  format?: "json" | "stix2";
}

export const GetIndicatorlistRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  datasetIds: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("datasetIds")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
  indicatorType: Schema.optional(Schema.String).pipe(T.HttpQuery("indicatorType")),
  relatedEvents: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("relatedEvents")),
  tags: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("tags")),
  createdAfter: Schema.optional(Schema.Date).pipe(T.HttpQuery("createdAfter")),
  createdBefore: Schema.optional(Schema.Date).pipe(T.HttpQuery("createdBefore")),
  relatedEventsLimit: Schema.optional(Schema.Number).pipe(T.HttpQuery("relatedEventsLimit")),
  includeTags: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("includeTags")),
  includeTotalCount: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("includeTotalCount")),
  format: Schema.optional(Schema.Literal("json", "stix2")).pipe(T.HttpQuery("format"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/indicators" }),
).annotations({ identifier: "GetIndicatorlistRequest" }) as unknown as Schema.Schema<GetIndicatorlistRequest>;

export interface GetIndicatorlistResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetIndicatorlistResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetIndicatorlistResponse" }) as unknown as Schema.Schema<GetIndicatorlistResponse>;

export const getIndicatorlist: (
  input: GetIndicatorlistRequest
) => Effect.Effect<
  GetIndicatorlistResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetIndicatorlistRequest,
  output: GetIndicatorlistResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetEventrawreaddsRequest {
  account_id: string;
  event_id: string;
  dataset_id: string;
}

export const GetEventrawreaddsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  event_id: Schema.String.pipe(T.HttpPath("event_id")),
  dataset_id: Schema.String.pipe(T.HttpPath("dataset_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/raw/{dataset_id}/{event_id}" }),
).annotations({ identifier: "GetEventrawreaddsRequest" }) as unknown as Schema.Schema<GetEventrawreaddsRequest>;

export interface GetEventrawreaddsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetEventrawreaddsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetEventrawreaddsResponse" }) as unknown as Schema.Schema<GetEventrawreaddsResponse>;

export const getEventrawreadds: (
  input: GetEventrawreaddsRequest
) => Effect.Effect<
  GetEventrawreaddsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEventrawreaddsRequest,
  output: GetEventrawreaddsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteEventreferencedeleteRequest {
  account_id: string;
  event_id: string;
  body: { events: string[] };
}

export const DeleteEventreferencedeleteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  event_id: Schema.String.pipe(T.HttpPath("event_id")),
  body: Schema.Struct({
  events: Schema.Array(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cloudforce-one/events/relate/{event_id}" }),
).annotations({ identifier: "DeleteEventreferencedeleteRequest" }) as unknown as Schema.Schema<DeleteEventreferencedeleteRequest>;

export interface DeleteEventreferencedeleteResponse {
  result: { success: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteEventreferencedeleteResponse = Schema.Struct({
  result: Schema.Struct({
  success: Schema.Boolean
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteEventreferencedeleteResponse" }) as unknown as Schema.Schema<DeleteEventreferencedeleteResponse>;

export const deleteEventreferencedelete: (
  input: DeleteEventreferencedeleteRequest
) => Effect.Effect<
  DeleteEventreferencedeleteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteEventreferencedeleteRequest,
  output: DeleteEventreferencedeleteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostEventreferencecreateRequest {
  account_id: string;
  event_id: string;
  body: { events: string[] };
}

export const PostEventreferencecreateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  event_id: Schema.String.pipe(T.HttpPath("event_id")),
  body: Schema.Struct({
  events: Schema.Array(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/relate/{event_id}/create" }),
).annotations({ identifier: "PostEventreferencecreateRequest" }) as unknown as Schema.Schema<PostEventreferencecreateRequest>;

export interface PostEventreferencecreateResponse {
  result: { success: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostEventreferencecreateResponse = Schema.Struct({
  result: Schema.Struct({
  success: Schema.Boolean
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostEventreferencecreateResponse" }) as unknown as Schema.Schema<PostEventreferencecreateResponse>;

export const postEventreferencecreate: (
  input: PostEventreferencecreateRequest
) => Effect.Effect<
  PostEventreferencecreateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostEventreferencecreateRequest,
  output: PostEventreferencecreateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostCreateeventrelationshipRequest {
  account_id: string;
  body: { childIds: string[]; datasetId: string; parentId: string; relationshipType: "related_to" | "caused_by" | "attributed_to" };
}

export const PostCreateeventrelationshipRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  childIds: Schema.Array(Schema.UUID),
  datasetId: Schema.String,
  parentId: Schema.UUID,
  relationshipType: Schema.Literal("related_to", "caused_by", "attributed_to")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/relationships/create" }),
).annotations({ identifier: "PostCreateeventrelationshipRequest" }) as unknown as Schema.Schema<PostCreateeventrelationshipRequest>;

export interface PostCreateeventrelationshipResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostCreateeventrelationshipResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostCreateeventrelationshipResponse" }) as unknown as Schema.Schema<PostCreateeventrelationshipResponse>;

export const postCreateeventrelationship: (
  input: PostCreateeventrelationshipRequest
) => Effect.Effect<
  PostCreateeventrelationshipResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostCreateeventrelationshipRequest,
  output: PostCreateeventrelationshipResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetTaglistRequest {
  account_id: string;
  page?: number;
  pageSize?: number;
  search?: string;
  categoryUuid?: string;
}

export const GetTaglistRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
  categoryUuid: Schema.optional(Schema.String).pipe(T.HttpQuery("categoryUuid"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/tags" }),
).annotations({ identifier: "GetTaglistRequest" }) as unknown as Schema.Schema<GetTaglistRequest>;

export interface GetTaglistResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetTaglistResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetTaglistResponse" }) as unknown as Schema.Schema<GetTaglistResponse>;

export const getTaglist: (
  input: GetTaglistRequest
) => Effect.Effect<
  GetTaglistResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTaglistRequest,
  output: GetTaglistResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetTagcategorylistRequest {
  account_id: string;
  search?: string;
}

export const GetTagcategorylistRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/tags/categories" }),
).annotations({ identifier: "GetTagcategorylistRequest" }) as unknown as Schema.Schema<GetTagcategorylistRequest>;

export interface GetTagcategorylistResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetTagcategorylistResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetTagcategorylistResponse" }) as unknown as Schema.Schema<GetTagcategorylistResponse>;

export const getTagcategorylist: (
  input: GetTagcategorylistRequest
) => Effect.Effect<
  GetTagcategorylistResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTagcategorylistRequest,
  output: GetTagcategorylistResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostTagcategorycreateRequest {
  account_id: string;
  body: { description?: string; name: string };
}

export const PostTagcategorycreateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/tags/categories/create" }),
).annotations({ identifier: "PostTagcategorycreateRequest" }) as unknown as Schema.Schema<PostTagcategorycreateRequest>;

export interface PostTagcategorycreateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostTagcategorycreateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostTagcategorycreateResponse" }) as unknown as Schema.Schema<PostTagcategorycreateResponse>;

export const postTagcategorycreate: (
  input: PostTagcategorycreateRequest
) => Effect.Effect<
  PostTagcategorycreateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostTagcategorycreateRequest,
  output: PostTagcategorycreateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteTagcategorydeleteRequest {
  account_id: string;
  category_uuid: string;
}

export const DeleteTagcategorydeleteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  category_uuid: Schema.String.pipe(T.HttpPath("category_uuid"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cloudforce-one/events/tags/categories/{category_uuid}" }),
).annotations({ identifier: "DeleteTagcategorydeleteRequest" }) as unknown as Schema.Schema<DeleteTagcategorydeleteRequest>;

export interface DeleteTagcategorydeleteResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteTagcategorydeleteResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteTagcategorydeleteResponse" }) as unknown as Schema.Schema<DeleteTagcategorydeleteResponse>;

export const deleteTagcategorydelete: (
  input: DeleteTagcategorydeleteRequest
) => Effect.Effect<
  DeleteTagcategorydeleteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteTagcategorydeleteRequest,
  output: DeleteTagcategorydeleteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchTagcategoryupdateRequest {
  account_id: string;
  category_uuid: string;
  body: { description?: string; name?: string };
}

export const PatchTagcategoryupdateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  category_uuid: Schema.String.pipe(T.HttpPath("category_uuid")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/cloudforce-one/events/tags/categories/{category_uuid}" }),
).annotations({ identifier: "PatchTagcategoryupdateRequest" }) as unknown as Schema.Schema<PatchTagcategoryupdateRequest>;

export interface PatchTagcategoryupdateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchTagcategoryupdateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchTagcategoryupdateResponse" }) as unknown as Schema.Schema<PatchTagcategoryupdateResponse>;

export const patchTagcategoryupdate: (
  input: PatchTagcategoryupdateRequest
) => Effect.Effect<
  PatchTagcategoryupdateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchTagcategoryupdateRequest,
  output: PatchTagcategoryupdateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostTagcreateRequest {
  account_id: string;
  body: { activeDuration?: string; actorCategory?: string; aliasGroupNames?: string[]; aliasGroupNamesInternal?: string[]; analyticPriority?: number; attributionConfidence?: string; attributionOrganization?: string; categoryUuid?: string; externalReferenceLinks?: string[]; internalDescription?: string; motive?: string; opsecLevel?: string; originCountryISO?: string; priority?: number; sophisticationLevel?: string; value: string };
}

export const PostTagcreateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  activeDuration: Schema.optional(Schema.String),
  actorCategory: Schema.optional(Schema.String),
  aliasGroupNames: Schema.optional(Schema.Array(Schema.String)),
  aliasGroupNamesInternal: Schema.optional(Schema.Array(Schema.String)),
  analyticPriority: Schema.optional(Schema.Number),
  attributionConfidence: Schema.optional(Schema.String),
  attributionOrganization: Schema.optional(Schema.String),
  categoryUuid: Schema.optional(Schema.String),
  externalReferenceLinks: Schema.optional(Schema.Array(Schema.String)),
  internalDescription: Schema.optional(Schema.String),
  motive: Schema.optional(Schema.String),
  opsecLevel: Schema.optional(Schema.String),
  originCountryISO: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Number),
  sophisticationLevel: Schema.optional(Schema.String),
  value: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/tags/create" }),
).annotations({ identifier: "PostTagcreateRequest" }) as unknown as Schema.Schema<PostTagcreateRequest>;

export interface PostTagcreateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostTagcreateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostTagcreateResponse" }) as unknown as Schema.Schema<PostTagcreateResponse>;

export const postTagcreate: (
  input: PostTagcreateRequest
) => Effect.Effect<
  PostTagcreateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostTagcreateRequest,
  output: PostTagcreateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteTagdeleteRequest {
  account_id: string;
  tag_uuid: string;
}

export const DeleteTagdeleteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  tag_uuid: Schema.String.pipe(T.HttpPath("tag_uuid"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cloudforce-one/events/tags/{tag_uuid}" }),
).annotations({ identifier: "DeleteTagdeleteRequest" }) as unknown as Schema.Schema<DeleteTagdeleteRequest>;

export interface DeleteTagdeleteResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteTagdeleteResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteTagdeleteResponse" }) as unknown as Schema.Schema<DeleteTagdeleteResponse>;

export const deleteTagdelete: (
  input: DeleteTagdeleteRequest
) => Effect.Effect<
  DeleteTagdeleteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteTagdeleteRequest,
  output: DeleteTagdeleteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchTagupdateRequest {
  account_id: string;
  tag_uuid: string;
  body: { activeDuration?: string; actorCategory?: string; aliasGroupNames?: string[]; aliasGroupNamesInternal?: string[]; analyticPriority?: number; attributionConfidence?: string; attributionOrganization?: string; categoryUuid?: string; externalReferenceLinks?: string[]; internalDescription?: string; motive?: string; opsecLevel?: string; originCountryISO?: string; priority?: number; sophisticationLevel?: string; value?: string };
}

export const PatchTagupdateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  tag_uuid: Schema.String.pipe(T.HttpPath("tag_uuid")),
  body: Schema.Struct({
  activeDuration: Schema.optional(Schema.String),
  actorCategory: Schema.optional(Schema.String),
  aliasGroupNames: Schema.optional(Schema.Array(Schema.String)),
  aliasGroupNamesInternal: Schema.optional(Schema.Array(Schema.String)),
  analyticPriority: Schema.optional(Schema.Number),
  attributionConfidence: Schema.optional(Schema.String),
  attributionOrganization: Schema.optional(Schema.String),
  categoryUuid: Schema.optional(Schema.String),
  externalReferenceLinks: Schema.optional(Schema.Array(Schema.String)),
  internalDescription: Schema.optional(Schema.String),
  motive: Schema.optional(Schema.String),
  opsecLevel: Schema.optional(Schema.String),
  originCountryISO: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.Number),
  sophisticationLevel: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/cloudforce-one/events/tags/{tag_uuid}" }),
).annotations({ identifier: "PatchTagupdateRequest" }) as unknown as Schema.Schema<PatchTagupdateRequest>;

export interface PatchTagupdateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchTagupdateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchTagupdateResponse" }) as unknown as Schema.Schema<PatchTagupdateResponse>;

export const patchTagupdate: (
  input: PatchTagupdateRequest
) => Effect.Effect<
  PatchTagupdateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchTagupdateRequest,
  output: PatchTagupdateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetTargetindustrylistRequest {
  account_id: string;
  datasetIds?: string[];
}

export const GetTargetindustrylistRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  datasetIds: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("datasetIds"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/targetIndustries" }),
).annotations({ identifier: "GetTargetindustrylistRequest" }) as unknown as Schema.Schema<GetTargetindustrylistRequest>;

export interface GetTargetindustrylistResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetTargetindustrylistResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetTargetindustrylistResponse" }) as unknown as Schema.Schema<GetTargetindustrylistResponse>;

export const getTargetindustrylist: (
  input: GetTargetindustrylistRequest
) => Effect.Effect<
  GetTargetindustrylistResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTargetindustrylistRequest,
  output: GetTargetindustrylistResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetTargetindustrylistcompleteRequest {
  account_id: string;
}

export const GetTargetindustrylistcompleteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/targetIndustries/catalog" }),
).annotations({ identifier: "GetTargetindustrylistcompleteRequest" }) as unknown as Schema.Schema<GetTargetindustrylistcompleteRequest>;

export interface GetTargetindustrylistcompleteResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetTargetindustrylistcompleteResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetTargetindustrylistcompleteResponse" }) as unknown as Schema.Schema<GetTargetindustrylistcompleteResponse>;

export const getTargetindustrylistcomplete: (
  input: GetTargetindustrylistcompleteRequest
) => Effect.Effect<
  GetTargetindustrylistcompleteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTargetindustrylistcompleteRequest,
  output: GetTargetindustrylistcompleteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteEventdeletedoRequest {
  account_id: string;
  dataset_id: string;
  eventIds: string[];
}

export const DeleteEventdeletedoRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id")),
  eventIds: Schema.Array(Schema.String).pipe(T.HttpQuery("eventIds"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cloudforce-one/events/{dataset_id}/delete" }),
).annotations({ identifier: "DeleteEventdeletedoRequest" }) as unknown as Schema.Schema<DeleteEventdeletedoRequest>;

export interface DeleteEventdeletedoResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteEventdeletedoResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteEventdeletedoResponse" }) as unknown as Schema.Schema<DeleteEventdeletedoResponse>;

export const deleteEventdeletedo: (
  input: DeleteEventdeletedoRequest
) => Effect.Effect<
  DeleteEventdeletedoResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteEventdeletedoRequest,
  output: DeleteEventdeletedoResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostEventdorevertRequest {
  account_id: string;
  dataset_id: string;
  body: { minutesAgo: number };
}

export const PostEventdorevertRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id")),
  body: Schema.Struct({
  minutesAgo: Schema.Number
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/{dataset_id}/revert-do" }),
).annotations({ identifier: "PostEventdorevertRequest" }) as unknown as Schema.Schema<PostEventdorevertRequest>;

export interface PostEventdorevertResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostEventdorevertResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostEventdorevertResponse" }) as unknown as Schema.Schema<PostEventdorevertResponse>;

export const postEventdorevert: (
  input: PostEventdorevertRequest
) => Effect.Effect<
  PostEventdorevertResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostEventdorevertRequest,
  output: PostEventdorevertResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetEventreaddeprecatedRequest {
  account_id: string;
  event_id: string;
}

export const GetEventreaddeprecatedRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  event_id: Schema.String.pipe(T.HttpPath("event_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/{event_id}" }),
).annotations({ identifier: "GetEventreaddeprecatedRequest" }) as unknown as Schema.Schema<GetEventreaddeprecatedRequest>;

export interface GetEventreaddeprecatedResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetEventreaddeprecatedResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetEventreaddeprecatedResponse" }) as unknown as Schema.Schema<GetEventreaddeprecatedResponse>;

export const getEventreaddeprecated: (
  input: GetEventreaddeprecatedRequest
) => Effect.Effect<
  GetEventreaddeprecatedResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEventreaddeprecatedRequest,
  output: GetEventreaddeprecatedResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostEventupdateRequest {
  account_id: string;
  event_id: string;
  body: { attacker?: string; attackerCountry?: string; category?: string; createdAt?: string; datasetId?: string; date?: string; event?: string; indicator?: string; indicatorType?: string; insight?: string; raw?: { data?: Record<string, unknown>; source?: string; tlp?: string }; targetCountry?: string; targetIndustry?: string; tlp?: string };
}

export const PostEventupdateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  event_id: Schema.String.pipe(T.HttpPath("event_id")),
  body: Schema.Struct({
  attacker: Schema.optional(Schema.String),
  attackerCountry: Schema.optional(Schema.String),
  category: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.Date),
  datasetId: Schema.optional(Schema.String),
  date: Schema.optional(Schema.Date),
  event: Schema.optional(Schema.String),
  indicator: Schema.optional(Schema.String),
  indicatorType: Schema.optional(Schema.String),
  insight: Schema.optional(Schema.String),
  raw: Schema.optional(Schema.Struct({
  data: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Unknown })),
  source: Schema.optional(Schema.String),
  tlp: Schema.optional(Schema.String)
})),
  targetCountry: Schema.optional(Schema.String),
  targetIndustry: Schema.optional(Schema.String),
  tlp: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/{event_id}" }),
).annotations({ identifier: "PostEventupdateRequest" }) as unknown as Schema.Schema<PostEventupdateRequest>;

export interface PostEventupdateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostEventupdateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostEventupdateResponse" }) as unknown as Schema.Schema<PostEventupdateResponse>;

export const postEventupdate: (
  input: PostEventupdateRequest
) => Effect.Effect<
  PostEventupdateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostEventupdateRequest,
  output: PostEventupdateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteEventdeleteRequest {
  account_id: string;
  event_id: string;
}

export const DeleteEventdeleteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  event_id: Schema.String.pipe(T.HttpPath("event_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cloudforce-one/events/{event_id}" }),
).annotations({ identifier: "DeleteEventdeleteRequest" }) as unknown as Schema.Schema<DeleteEventdeleteRequest>;

export interface DeleteEventdeleteResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteEventdeleteResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteEventdeleteResponse" }) as unknown as Schema.Schema<DeleteEventdeleteResponse>;

export const deleteEventdelete: (
  input: DeleteEventdeleteRequest
) => Effect.Effect<
  DeleteEventdeleteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteEventdeleteRequest,
  output: DeleteEventdeleteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchEventupdateRequest {
  account_id: string;
  event_id: string;
  body: { attacker?: string; attackerCountry?: string; category?: string; createdAt?: string; datasetId?: string; date?: string; event?: string; indicator?: string; indicatorType?: string; insight?: string; raw?: { data?: Record<string, unknown>; source?: string; tlp?: string }; targetCountry?: string; targetIndustry?: string; tlp?: string };
}

export const PatchEventupdateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  event_id: Schema.String.pipe(T.HttpPath("event_id")),
  body: Schema.Struct({
  attacker: Schema.optional(Schema.String),
  attackerCountry: Schema.optional(Schema.String),
  category: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.Date),
  datasetId: Schema.optional(Schema.String),
  date: Schema.optional(Schema.Date),
  event: Schema.optional(Schema.String),
  indicator: Schema.optional(Schema.String),
  indicatorType: Schema.optional(Schema.String),
  insight: Schema.optional(Schema.String),
  raw: Schema.optional(Schema.Struct({
  data: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Unknown })),
  source: Schema.optional(Schema.String),
  tlp: Schema.optional(Schema.String)
})),
  targetCountry: Schema.optional(Schema.String),
  targetIndustry: Schema.optional(Schema.String),
  tlp: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/cloudforce-one/events/{event_id}" }),
).annotations({ identifier: "PatchEventupdateRequest" }) as unknown as Schema.Schema<PatchEventupdateRequest>;

export interface PatchEventupdateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchEventupdateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchEventupdateResponse" }) as unknown as Schema.Schema<PatchEventupdateResponse>;

export const patchEventupdate: (
  input: PatchEventupdateRequest
) => Effect.Effect<
  PatchEventupdateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchEventupdateRequest,
  output: PatchEventupdateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetEventrawreadRequest {
  account_id: string;
  event_id: string;
  raw_id: string;
}

export const GetEventrawreadRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  event_id: Schema.String.pipe(T.HttpPath("event_id")),
  raw_id: Schema.String.pipe(T.HttpPath("raw_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/{event_id}/raw/{raw_id}" }),
).annotations({ identifier: "GetEventrawreadRequest" }) as unknown as Schema.Schema<GetEventrawreadRequest>;

export interface GetEventrawreadResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetEventrawreadResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetEventrawreadResponse" }) as unknown as Schema.Schema<GetEventrawreadResponse>;

export const getEventrawread: (
  input: GetEventrawreadRequest
) => Effect.Effect<
  GetEventrawreadResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEventrawreadRequest,
  output: GetEventrawreadResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostEventrawupdateRequest {
  account_id: string;
  event_id: string;
  raw_id: string;
  body: { data?: Record<string, unknown>; source?: string; tlp?: string };
}

export const PostEventrawupdateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  event_id: Schema.String.pipe(T.HttpPath("event_id")),
  raw_id: Schema.String.pipe(T.HttpPath("raw_id")),
  body: Schema.Struct({
  data: Schema.optional(Schema.Struct({})),
  source: Schema.optional(Schema.String),
  tlp: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/events/{event_id}/raw/{raw_id}" }),
).annotations({ identifier: "PostEventrawupdateRequest" }) as unknown as Schema.Schema<PostEventrawupdateRequest>;

export interface PostEventrawupdateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostEventrawupdateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostEventrawupdateResponse" }) as unknown as Schema.Schema<PostEventrawupdateResponse>;

export const postEventrawupdate: (
  input: PostEventrawupdateRequest
) => Effect.Effect<
  PostEventrawupdateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostEventrawupdateRequest,
  output: PostEventrawupdateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchEventrawupdateRequest {
  account_id: string;
  event_id: string;
  raw_id: string;
  body: { data?: Record<string, unknown>; source?: string; tlp?: string };
}

export const PatchEventrawupdateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  event_id: Schema.String.pipe(T.HttpPath("event_id")),
  raw_id: Schema.String.pipe(T.HttpPath("raw_id")),
  body: Schema.Struct({
  data: Schema.optional(Schema.Struct({})),
  source: Schema.optional(Schema.String),
  tlp: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/cloudforce-one/events/{event_id}/raw/{raw_id}" }),
).annotations({ identifier: "PatchEventrawupdateRequest" }) as unknown as Schema.Schema<PatchEventrawupdateRequest>;

export interface PatchEventrawupdateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchEventrawupdateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchEventrawupdateResponse" }) as unknown as Schema.Schema<PatchEventrawupdateResponse>;

export const patchEventrawupdate: (
  input: PatchEventrawupdateRequest
) => Effect.Effect<
  PatchEventrawupdateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchEventrawupdateRequest,
  output: PatchEventrawupdateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetEventrelationshipsRequest {
  account_id: string;
  event_id: string;
  direction?: "ancestors" | "descendants" | "both";
  maxDepth?: number;
  relationshipTypes?: unknown;
  indicatorTypeIds?: string[];
  datasetId: string;
  includeParent?: boolean;
  page?: number;
  pageSize?: number;
}

export const GetEventrelationshipsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  event_id: Schema.String.pipe(T.HttpPath("event_id")),
  direction: Schema.optional(Schema.Literal("ancestors", "descendants", "both")).pipe(T.HttpQuery("direction")),
  maxDepth: Schema.optional(Schema.Number).pipe(T.HttpQuery("maxDepth")),
  relationshipTypes: Schema.optional(Schema.Union(Schema.String, Schema.Array(Schema.String))).pipe(T.HttpQuery("relationshipTypes")),
  indicatorTypeIds: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("indicatorTypeIds")),
  datasetId: Schema.String.pipe(T.HttpQuery("datasetId")),
  includeParent: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("includeParent")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/events/{event_id}/relationships" }),
).annotations({ identifier: "GetEventrelationshipsRequest" }) as unknown as Schema.Schema<GetEventrelationshipsRequest>;

export interface GetEventrelationshipsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetEventrelationshipsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetEventrelationshipsResponse" }) as unknown as Schema.Schema<GetEventrelationshipsResponse>;

export const getEventrelationships: (
  input: GetEventrelationshipsRequest
) => Effect.Effect<
  GetEventrelationshipsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEventrelationshipsRequest,
  output: GetEventrelationshipsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List3Request {
  account_id: string;
  body: { completed_after?: unknown; completed_before?: unknown; created_after?: unknown; created_before?: unknown; page: number; per_page: number; request_type?: string; sort_by?: string; sort_order?: "asc" | "desc"; status?: "open" | "accepted" | "reported" | "approved" | "completed" | "declined" };
}

export const List3Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  completed_after: Schema.optional(Schema.Date),
  completed_before: Schema.optional(Schema.Date),
  created_after: Schema.optional(Schema.Date),
  created_before: Schema.optional(Schema.Date),
  page: Schema.Number,
  per_page: Schema.Number,
  request_type: Schema.optional(Schema.String),
  sort_by: Schema.optional(Schema.String),
  sort_order: Schema.optional(Schema.Literal("asc", "desc")),
  status: Schema.optional(Schema.Literal("open", "accepted", "reported", "approved", "completed", "declined"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/requests" }),
).annotations({ identifier: "List3Request" }) as unknown as Schema.Schema<List3Request>;

export interface List3Response {
  result: { completed?: unknown; created: unknown; id: string; message_tokens?: number; priority: "routine" | "high" | "urgent"; readable_id?: string; request: string; status?: "open" | "accepted" | "reported" | "approved" | "completed" | "declined"; summary: string; tlp: "clear" | "amber" | "amber-strict" | "green" | "red"; tokens?: number; updated: unknown }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List3Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  completed: Schema.optional(Schema.Date),
  created: Schema.Date,
  id: Schema.String,
  message_tokens: Schema.optional(Schema.Number),
  priority: Schema.Literal("routine", "high", "urgent"),
  readable_id: Schema.optional(Schema.String),
  request: Schema.String,
  status: Schema.optional(Schema.Literal("open", "accepted", "reported", "approved", "completed", "declined")),
  summary: Schema.String,
  tlp: Schema.Literal("clear", "amber", "amber-strict", "green", "red"),
  tokens: Schema.optional(Schema.Number),
  updated: Schema.Date
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List3Response" }) as unknown as Schema.Schema<List3Response>;

export const list3: (
  input: List3Request
) => Effect.Effect<
  List3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List3Request,
  output: List3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CloudforceOneRequestConstantsRequest {
  account_id: string;
}

export const CloudforceOneRequestConstantsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/requests/constants" }),
).annotations({ identifier: "CloudforceOneRequestConstantsRequest" }) as unknown as Schema.Schema<CloudforceOneRequestConstantsRequest>;

export interface CloudforceOneRequestConstantsResponse {
  result: { priority?: "routine" | "high" | "urgent"[]; status?: "open" | "accepted" | "reported" | "approved" | "completed" | "declined"[]; tlp?: "clear" | "amber" | "amber-strict" | "green" | "red"[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CloudforceOneRequestConstantsResponse = Schema.Struct({
  result: Schema.Struct({
  priority: Schema.optional(Schema.Array(Schema.Literal("routine", "high", "urgent"))),
  status: Schema.optional(Schema.Array(Schema.Literal("open", "accepted", "reported", "approved", "completed", "declined"))),
  tlp: Schema.optional(Schema.Array(Schema.Literal("clear", "amber", "amber-strict", "green", "red")))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CloudforceOneRequestConstantsResponse" }) as unknown as Schema.Schema<CloudforceOneRequestConstantsResponse>;

export const cloudforceOneRequestConstants: (
  input: CloudforceOneRequestConstantsRequest
) => Effect.Effect<
  CloudforceOneRequestConstantsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CloudforceOneRequestConstantsRequest,
  output: CloudforceOneRequestConstantsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CloudforceOneRequestNewRequest {
  account_id: string;
  body: { content?: string; priority?: string; request_type?: string; summary?: string; tlp?: "clear" | "amber" | "amber-strict" | "green" | "red" };
}

export const CloudforceOneRequestNewRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  content: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.String),
  request_type: Schema.optional(Schema.String),
  summary: Schema.optional(Schema.String),
  tlp: Schema.optional(Schema.Literal("clear", "amber", "amber-strict", "green", "red"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/requests/new" }),
).annotations({ identifier: "CloudforceOneRequestNewRequest" }) as unknown as Schema.Schema<CloudforceOneRequestNewRequest>;

export interface CloudforceOneRequestNewResponse {
  result: { completed?: string; content: string; created: string; id: string; message_tokens?: number; priority: string; readable_id?: string; request: string; status?: "open" | "accepted" | "reported" | "approved" | "completed" | "declined"; summary: string; tlp: "clear" | "amber" | "amber-strict" | "green" | "red"; tokens?: number; updated: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CloudforceOneRequestNewResponse = Schema.Struct({
  result: Schema.Struct({
  completed: Schema.optional(Schema.Date),
  content: Schema.String,
  created: Schema.Date,
  id: Schema.String,
  message_tokens: Schema.optional(Schema.Number),
  priority: Schema.Date,
  readable_id: Schema.optional(Schema.String),
  request: Schema.String,
  status: Schema.optional(Schema.Literal("open", "accepted", "reported", "approved", "completed", "declined")),
  summary: Schema.String,
  tlp: Schema.Literal("clear", "amber", "amber-strict", "green", "red"),
  tokens: Schema.optional(Schema.Number),
  updated: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CloudforceOneRequestNewResponse" }) as unknown as Schema.Schema<CloudforceOneRequestNewResponse>;

export const cloudforceOneRequestNew: (
  input: CloudforceOneRequestNewRequest
) => Effect.Effect<
  CloudforceOneRequestNewResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CloudforceOneRequestNewRequest,
  output: CloudforceOneRequestNewResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List4Request {
  account_id: string;
  body: { page: number; per_page: number };
}

export const List4Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  page: Schema.Number,
  per_page: Schema.Number
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/requests/priority" }),
).annotations({ identifier: "List4Request" }) as unknown as Schema.Schema<List4Request>;

export interface List4Response {
  result: { created: unknown; id: string; labels: string[]; priority: number; requirement: string; tlp: "clear" | "amber" | "amber-strict" | "green" | "red"; updated: unknown }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List4Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created: Schema.Date,
  id: Schema.String,
  labels: Schema.Array(Schema.String),
  priority: Schema.Number,
  requirement: Schema.String,
  tlp: Schema.Literal("clear", "amber", "amber-strict", "green", "red"),
  updated: Schema.Date
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List4Response" }) as unknown as Schema.Schema<List4Response>;

export const list4: (
  input: List4Request
) => Effect.Effect<
  List4Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List4Request,
  output: List4Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CloudforceOnePriorityNewRequest {
  account_id: string;
  body: { labels: string[]; priority: number; requirement: string; tlp: "clear" | "amber" | "amber-strict" | "green" | "red" };
}

export const CloudforceOnePriorityNewRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  labels: Schema.Array(Schema.String),
  priority: Schema.Number,
  requirement: Schema.String,
  tlp: Schema.Literal("clear", "amber", "amber-strict", "green", "red")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/requests/priority/new" }),
).annotations({ identifier: "CloudforceOnePriorityNewRequest" }) as unknown as Schema.Schema<CloudforceOnePriorityNewRequest>;

export interface CloudforceOnePriorityNewResponse {
  result: { created: unknown; id: string; labels: string[]; priority: number; requirement: string; tlp: "clear" | "amber" | "amber-strict" | "green" | "red"; updated: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CloudforceOnePriorityNewResponse = Schema.Struct({
  result: Schema.Struct({
  created: Schema.Date,
  id: Schema.String,
  labels: Schema.Array(Schema.String),
  priority: Schema.Number,
  requirement: Schema.String,
  tlp: Schema.Literal("clear", "amber", "amber-strict", "green", "red"),
  updated: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CloudforceOnePriorityNewResponse" }) as unknown as Schema.Schema<CloudforceOnePriorityNewResponse>;

export const cloudforceOnePriorityNew: (
  input: CloudforceOnePriorityNewRequest
) => Effect.Effect<
  CloudforceOnePriorityNewResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CloudforceOnePriorityNewRequest,
  output: CloudforceOnePriorityNewResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CloudforceOnePriorityQuotaRequest {
  account_id: string;
}

export const CloudforceOnePriorityQuotaRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/requests/priority/quota" }),
).annotations({ identifier: "CloudforceOnePriorityQuotaRequest" }) as unknown as Schema.Schema<CloudforceOnePriorityQuotaRequest>;

export interface CloudforceOnePriorityQuotaResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CloudforceOnePriorityQuotaResponse = Schema.Struct({
  result: Schema.Struct({
  anniversary_date: Schema.optional(Schema.Date),
  quarter_anniversary_date: Schema.optional(Schema.Date),
  quota: Schema.optional(Schema.Number),
  remaining: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CloudforceOnePriorityQuotaResponse" }) as unknown as Schema.Schema<CloudforceOnePriorityQuotaResponse>;

export const cloudforceOnePriorityQuota: (
  input: CloudforceOnePriorityQuotaRequest
) => Effect.Effect<
  CloudforceOnePriorityQuotaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CloudforceOnePriorityQuotaRequest,
  output: CloudforceOnePriorityQuotaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_1Request {
  account_id: string;
  priority_id: string;
}

export const Get_1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  priority_id: Schema.String.pipe(T.HttpPath("priority_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/requests/priority/{priority_id}" }),
).annotations({ identifier: "Get_1Request" }) as unknown as Schema.Schema<Get_1Request>;

export interface Get_1Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_1Response = Schema.Struct({
  result: Schema.Struct({
  completed: Schema.optional(Schema.Date),
  content: Schema.String,
  created: Schema.Date,
  id: Schema.String,
  message_tokens: Schema.optional(Schema.Number),
  priority: Schema.Date,
  readable_id: Schema.optional(Schema.String),
  request: Schema.String,
  status: Schema.optional(Schema.Literal("open", "accepted", "reported", "approved", "completed", "declined")),
  summary: Schema.String,
  tlp: Schema.Literal("clear", "amber", "amber-strict", "green", "red"),
  tokens: Schema.optional(Schema.Number),
  updated: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_1Response" }) as unknown as Schema.Schema<Get_1Response>;

export const get_1: (
  input: Get_1Request
) => Effect.Effect<
  Get_1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_1Request,
  output: Get_1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update1Request {
  account_id: string;
  priority_id: string;
  body: { labels: string[]; priority: number; requirement: string; tlp: "clear" | "amber" | "amber-strict" | "green" | "red" };
}

export const Update1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  priority_id: Schema.String.pipe(T.HttpPath("priority_id")),
  body: Schema.Struct({
  labels: Schema.Array(Schema.String),
  priority: Schema.Number,
  requirement: Schema.String,
  tlp: Schema.Literal("clear", "amber", "amber-strict", "green", "red")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/cloudforce-one/requests/priority/{priority_id}" }),
).annotations({ identifier: "Update1Request" }) as unknown as Schema.Schema<Update1Request>;

export interface Update1Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update1Response = Schema.Struct({
  result: Schema.Struct({
  completed: Schema.optional(Schema.Date),
  content: Schema.String,
  created: Schema.Date,
  id: Schema.String,
  message_tokens: Schema.optional(Schema.Number),
  priority: Schema.Date,
  readable_id: Schema.optional(Schema.String),
  request: Schema.String,
  status: Schema.optional(Schema.Literal("open", "accepted", "reported", "approved", "completed", "declined")),
  summary: Schema.String,
  tlp: Schema.Literal("clear", "amber", "amber-strict", "green", "red"),
  tokens: Schema.optional(Schema.Number),
  updated: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update1Response" }) as unknown as Schema.Schema<Update1Response>;

export const update1: (
  input: Update1Request
) => Effect.Effect<
  Update1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update1Request,
  output: Update1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_1Request {
  account_id: string;
  priority_id: string;
}

export const Delete_1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  priority_id: Schema.String.pipe(T.HttpPath("priority_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cloudforce-one/requests/priority/{priority_id}" }),
).annotations({ identifier: "Delete_1Request" }) as unknown as Schema.Schema<Delete_1Request>;

export interface Delete_1Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_1Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_1Response" }) as unknown as Schema.Schema<Delete_1Response>;

export const delete_1: (
  input: Delete_1Request
) => Effect.Effect<
  Delete_1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_1Request,
  output: Delete_1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CloudforceOneRequestQuotaRequest {
  account_id: string;
}

export const CloudforceOneRequestQuotaRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/requests/quota" }),
).annotations({ identifier: "CloudforceOneRequestQuotaRequest" }) as unknown as Schema.Schema<CloudforceOneRequestQuotaRequest>;

export interface CloudforceOneRequestQuotaResponse {
  result: { anniversary_date?: unknown; quarter_anniversary_date?: unknown; quota?: number; remaining?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CloudforceOneRequestQuotaResponse = Schema.Struct({
  result: Schema.Struct({
  anniversary_date: Schema.optional(Schema.Date),
  quarter_anniversary_date: Schema.optional(Schema.Date),
  quota: Schema.optional(Schema.Number),
  remaining: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CloudforceOneRequestQuotaResponse" }) as unknown as Schema.Schema<CloudforceOneRequestQuotaResponse>;

export const cloudforceOneRequestQuota: (
  input: CloudforceOneRequestQuotaRequest
) => Effect.Effect<
  CloudforceOneRequestQuotaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CloudforceOneRequestQuotaRequest,
  output: CloudforceOneRequestQuotaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CloudforceOneRequestTypesRequest {
  account_id: string;
}

export const CloudforceOneRequestTypesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/requests/types" }),
).annotations({ identifier: "CloudforceOneRequestTypesRequest" }) as unknown as Schema.Schema<CloudforceOneRequestTypesRequest>;

export interface CloudforceOneRequestTypesResponse {
  result: string[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CloudforceOneRequestTypesResponse = Schema.Struct({
  result: Schema.Array(Schema.String),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CloudforceOneRequestTypesResponse" }) as unknown as Schema.Schema<CloudforceOneRequestTypesResponse>;

export const cloudforceOneRequestTypes: (
  input: CloudforceOneRequestTypesRequest
) => Effect.Effect<
  CloudforceOneRequestTypesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CloudforceOneRequestTypesRequest,
  output: CloudforceOneRequestTypesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_2Request {
  account_id: string;
  request_id: string;
}

export const Get_2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  request_id: Schema.String.pipe(T.HttpPath("request_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/requests/{request_id}" }),
).annotations({ identifier: "Get_2Request" }) as unknown as Schema.Schema<Get_2Request>;

export interface Get_2Response {
  result: { completed?: string; content: string; created: string; id: string; message_tokens?: number; priority: string; readable_id?: string; request: string; status?: "open" | "accepted" | "reported" | "approved" | "completed" | "declined"; summary: string; tlp: "clear" | "amber" | "amber-strict" | "green" | "red"; tokens?: number; updated: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_2Response = Schema.Struct({
  result: Schema.Struct({
  completed: Schema.optional(Schema.Date),
  content: Schema.String,
  created: Schema.Date,
  id: Schema.String,
  message_tokens: Schema.optional(Schema.Number),
  priority: Schema.Date,
  readable_id: Schema.optional(Schema.String),
  request: Schema.String,
  status: Schema.optional(Schema.Literal("open", "accepted", "reported", "approved", "completed", "declined")),
  summary: Schema.String,
  tlp: Schema.Literal("clear", "amber", "amber-strict", "green", "red"),
  tokens: Schema.optional(Schema.Number),
  updated: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_2Response" }) as unknown as Schema.Schema<Get_2Response>;

export const get_2: (
  input: Get_2Request
) => Effect.Effect<
  Get_2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_2Request,
  output: Get_2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update2Request {
  account_id: string;
  request_id: string;
  body: { content?: string; priority?: string; request_type?: string; summary?: string; tlp?: "clear" | "amber" | "amber-strict" | "green" | "red" };
}

export const Update2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  request_id: Schema.String.pipe(T.HttpPath("request_id")),
  body: Schema.Struct({
  content: Schema.optional(Schema.String),
  priority: Schema.optional(Schema.String),
  request_type: Schema.optional(Schema.String),
  summary: Schema.optional(Schema.String),
  tlp: Schema.optional(Schema.Literal("clear", "amber", "amber-strict", "green", "red"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/cloudforce-one/requests/{request_id}" }),
).annotations({ identifier: "Update2Request" }) as unknown as Schema.Schema<Update2Request>;

export interface Update2Response {
  result: { completed?: string; content: string; created: string; id: string; message_tokens?: number; priority: string; readable_id?: string; request: string; status?: "open" | "accepted" | "reported" | "approved" | "completed" | "declined"; summary: string; tlp: "clear" | "amber" | "amber-strict" | "green" | "red"; tokens?: number; updated: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update2Response = Schema.Struct({
  result: Schema.Struct({
  completed: Schema.optional(Schema.Date),
  content: Schema.String,
  created: Schema.Date,
  id: Schema.String,
  message_tokens: Schema.optional(Schema.Number),
  priority: Schema.Date,
  readable_id: Schema.optional(Schema.String),
  request: Schema.String,
  status: Schema.optional(Schema.Literal("open", "accepted", "reported", "approved", "completed", "declined")),
  summary: Schema.String,
  tlp: Schema.Literal("clear", "amber", "amber-strict", "green", "red"),
  tokens: Schema.optional(Schema.Number),
  updated: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update2Response" }) as unknown as Schema.Schema<Update2Response>;

export const update2: (
  input: Update2Request
) => Effect.Effect<
  Update2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update2Request,
  output: Update2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_2Request {
  account_id: string;
  request_id: string;
}

export const Delete_2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  request_id: Schema.String.pipe(T.HttpPath("request_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cloudforce-one/requests/{request_id}" }),
).annotations({ identifier: "Delete_2Request" }) as unknown as Schema.Schema<Delete_2Request>;

export interface Delete_2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_2Response" }) as unknown as Schema.Schema<Delete_2Response>;

export const delete_2: (
  input: Delete_2Request
) => Effect.Effect<
  Delete_2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_2Request,
  output: Delete_2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List5Request {
  account_id: string;
  request_id: string;
  body: { page: number; per_page: number };
}

export const List5Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  request_id: Schema.String.pipe(T.HttpPath("request_id")),
  body: Schema.Struct({
  page: Schema.Number,
  per_page: Schema.Number
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/requests/{request_id}/asset" }),
).annotations({ identifier: "List5Request" }) as unknown as Schema.Schema<List5Request>;

export interface List5Response {
  result: { created?: unknown; description?: string; file_type?: string; id: number; name: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List5Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  file_type: Schema.optional(Schema.String),
  id: Schema.Number,
  name: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List5Response" }) as unknown as Schema.Schema<List5Response>;

export const list5: (
  input: List5Request
) => Effect.Effect<
  List5Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List5Request,
  output: List5Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CloudforceOneRequestAssetNewRequest {
  account_id: string;
  request_id: string;
  body: FormData;
}

export const CloudforceOneRequestAssetNewRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  request_id: Schema.String.pipe(T.HttpPath("request_id")),
  body: Schema.instanceOf(FormData).pipe(T.HttpFormData())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/requests/{request_id}/asset/new" }),
).annotations({ identifier: "CloudforceOneRequestAssetNewRequest" }) as unknown as Schema.Schema<CloudforceOneRequestAssetNewRequest>;

export interface CloudforceOneRequestAssetNewResponse {
  result: { created?: unknown; description?: string; file_type?: string; id: number; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CloudforceOneRequestAssetNewResponse = Schema.Struct({
  result: Schema.Struct({
  created: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  file_type: Schema.optional(Schema.String),
  id: Schema.Number,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CloudforceOneRequestAssetNewResponse" }) as unknown as Schema.Schema<CloudforceOneRequestAssetNewResponse>;

export const cloudforceOneRequestAssetNew: (
  input: CloudforceOneRequestAssetNewRequest
) => Effect.Effect<
  CloudforceOneRequestAssetNewResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CloudforceOneRequestAssetNewRequest,
  output: CloudforceOneRequestAssetNewResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_3Request {
  account_id: string;
  request_id: string;
  asset_id: string;
}

export const Get_3Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  request_id: Schema.String.pipe(T.HttpPath("request_id")),
  asset_id: Schema.String.pipe(T.HttpPath("asset_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/requests/{request_id}/asset/{asset_id}" }),
).annotations({ identifier: "Get_3Request" }) as unknown as Schema.Schema<Get_3Request>;

export interface Get_3Response {
  result: { created?: unknown; description?: string; file_type?: string; id: number; name: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_3Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  file_type: Schema.optional(Schema.String),
  id: Schema.Number,
  name: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_3Response" }) as unknown as Schema.Schema<Get_3Response>;

export const get_3: (
  input: Get_3Request
) => Effect.Effect<
  Get_3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_3Request,
  output: Get_3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update3Request {
  account_id: string;
  request_id: string;
  asset_id: string;
  body: { source?: string };
}

export const Update3Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  request_id: Schema.String.pipe(T.HttpPath("request_id")),
  asset_id: Schema.String.pipe(T.HttpPath("asset_id")),
  body: Schema.Struct({
  source: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/cloudforce-one/requests/{request_id}/asset/{asset_id}" }),
).annotations({ identifier: "Update3Request" }) as unknown as Schema.Schema<Update3Request>;

export interface Update3Response {
  result: { created?: unknown; description?: string; file_type?: string; id: number; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update3Response = Schema.Struct({
  result: Schema.Struct({
  created: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  file_type: Schema.optional(Schema.String),
  id: Schema.Number,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update3Response" }) as unknown as Schema.Schema<Update3Response>;

export const update3: (
  input: Update3Request
) => Effect.Effect<
  Update3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update3Request,
  output: Update3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_3Request {
  account_id: string;
  request_id: string;
  asset_id: string;
}

export const Delete_3Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  request_id: Schema.String.pipe(T.HttpPath("request_id")),
  asset_id: Schema.String.pipe(T.HttpPath("asset_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cloudforce-one/requests/{request_id}/asset/{asset_id}" }),
).annotations({ identifier: "Delete_3Request" }) as unknown as Schema.Schema<Delete_3Request>;

export interface Delete_3Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_3Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_3Response" }) as unknown as Schema.Schema<Delete_3Response>;

export const delete_3: (
  input: Delete_3Request
) => Effect.Effect<
  Delete_3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_3Request,
  output: Delete_3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List6Request {
  account_id: string;
  request_id: string;
  body: { after?: unknown; before?: unknown; page: number; per_page: number; sort_by?: string; sort_order?: "asc" | "desc" };
}

export const List6Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  request_id: Schema.String.pipe(T.HttpPath("request_id")),
  body: Schema.Struct({
  after: Schema.optional(Schema.Date),
  before: Schema.optional(Schema.Date),
  page: Schema.Number,
  per_page: Schema.Number,
  sort_by: Schema.optional(Schema.String),
  sort_order: Schema.optional(Schema.Literal("asc", "desc"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/requests/{request_id}/message" }),
).annotations({ identifier: "List6Request" }) as unknown as Schema.Schema<List6Request>;

export interface List6Response {
  result: { author: string; content: string; created?: unknown; id: number; is_follow_on_request: boolean; updated: unknown }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List6Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  author: Schema.String,
  content: Schema.String,
  created: Schema.optional(Schema.Date),
  id: Schema.Number,
  is_follow_on_request: Schema.Boolean,
  updated: Schema.Date
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List6Response" }) as unknown as Schema.Schema<List6Response>;

export const list6: (
  input: List6Request
) => Effect.Effect<
  List6Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List6Request,
  output: List6Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CloudforceOneRequestMessageNewRequest {
  account_id: string;
  request_id: string;
  body: { content?: string };
}

export const CloudforceOneRequestMessageNewRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  request_id: Schema.String.pipe(T.HttpPath("request_id")),
  body: Schema.Struct({
  content: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/requests/{request_id}/message/new" }),
).annotations({ identifier: "CloudforceOneRequestMessageNewRequest" }) as unknown as Schema.Schema<CloudforceOneRequestMessageNewRequest>;

export interface CloudforceOneRequestMessageNewResponse {
  result: { author: string; content: string; created?: unknown; id: number; is_follow_on_request: boolean; updated: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CloudforceOneRequestMessageNewResponse = Schema.Struct({
  result: Schema.Struct({
  author: Schema.String,
  content: Schema.String,
  created: Schema.optional(Schema.Date),
  id: Schema.Number,
  is_follow_on_request: Schema.Boolean,
  updated: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CloudforceOneRequestMessageNewResponse" }) as unknown as Schema.Schema<CloudforceOneRequestMessageNewResponse>;

export const cloudforceOneRequestMessageNew: (
  input: CloudforceOneRequestMessageNewRequest
) => Effect.Effect<
  CloudforceOneRequestMessageNewResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CloudforceOneRequestMessageNewRequest,
  output: CloudforceOneRequestMessageNewResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update4Request {
  account_id: string;
  request_id: string;
  message_id: number;
  body: { content?: string };
}

export const Update4Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  request_id: Schema.String.pipe(T.HttpPath("request_id")),
  message_id: Schema.Number.pipe(T.HttpPath("message_id")),
  body: Schema.Struct({
  content: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/cloudforce-one/requests/{request_id}/message/{message_id}" }),
).annotations({ identifier: "Update4Request" }) as unknown as Schema.Schema<Update4Request>;

export interface Update4Response {
  result: { author: string; content: string; created?: unknown; id: number; is_follow_on_request: boolean; updated: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update4Response = Schema.Struct({
  result: Schema.Struct({
  author: Schema.String,
  content: Schema.String,
  created: Schema.optional(Schema.Date),
  id: Schema.Number,
  is_follow_on_request: Schema.Boolean,
  updated: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update4Response" }) as unknown as Schema.Schema<Update4Response>;

export const update4: (
  input: Update4Request
) => Effect.Effect<
  Update4Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update4Request,
  output: Update4Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_4Request {
  account_id: string;
  request_id: string;
  message_id: number;
}

export const Delete_4Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  request_id: Schema.String.pipe(T.HttpPath("request_id")),
  message_id: Schema.Number.pipe(T.HttpPath("message_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cloudforce-one/requests/{request_id}/message/{message_id}" }),
).annotations({ identifier: "Delete_4Request" }) as unknown as Schema.Schema<Delete_4Request>;

export interface Delete_4Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_4Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_4Response" }) as unknown as Schema.Schema<Delete_4Response>;

export const delete_4: (
  input: Delete_4Request
) => Effect.Effect<
  Delete_4Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_4Request,
  output: Delete_4Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetConfigfetchRequest {
  account_id: string;
}

export const GetConfigfetchRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/scans/config" }),
).annotations({ identifier: "GetConfigfetchRequest" }) as unknown as Schema.Schema<GetConfigfetchRequest>;

export interface GetConfigfetchResponse {
  result: { account_id: string; frequency: number; id: string; ips: string[]; ports: string[] }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetConfigfetchResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  account_id: Schema.String,
  frequency: Schema.Number,
  id: Schema.String,
  ips: Schema.Array(Schema.String),
  ports: Schema.Array(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetConfigfetchResponse" }) as unknown as Schema.Schema<GetConfigfetchResponse>;

export const getConfigfetch: (
  input: GetConfigfetchRequest
) => Effect.Effect<
  GetConfigfetchResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetConfigfetchRequest,
  output: GetConfigfetchResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostConfigcreateRequest {
  account_id: string;
  body: { frequency?: number; ips: string[]; ports?: string[] };
}

export const PostConfigcreateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  frequency: Schema.optional(Schema.Number),
  ips: Schema.Array(Schema.String),
  ports: Schema.optional(Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/scans/config" }),
).annotations({ identifier: "PostConfigcreateRequest" }) as unknown as Schema.Schema<PostConfigcreateRequest>;

export interface PostConfigcreateResponse {
  result: { account_id: string; frequency: number; id: string; ips: string[]; ports: string[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostConfigcreateResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  frequency: Schema.Number,
  id: Schema.String,
  ips: Schema.Array(Schema.String),
  ports: Schema.Array(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostConfigcreateResponse" }) as unknown as Schema.Schema<PostConfigcreateResponse>;

export const postConfigcreate: (
  input: PostConfigcreateRequest
) => Effect.Effect<
  PostConfigcreateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostConfigcreateRequest,
  output: PostConfigcreateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDeletescansRequest {
  account_id: string;
  config_id: string;
}

export const DeleteDeletescansRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  config_id: Schema.String.pipe(T.HttpPath("config_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cloudforce-one/scans/config/{config_id}" }),
).annotations({ identifier: "DeleteDeletescansRequest" }) as unknown as Schema.Schema<DeleteDeletescansRequest>;

export interface DeleteDeletescansResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDeletescansResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDeletescansResponse" }) as unknown as Schema.Schema<DeleteDeletescansResponse>;

export const deleteDeletescans: (
  input: DeleteDeletescansRequest
) => Effect.Effect<
  DeleteDeletescansResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDeletescansRequest,
  output: DeleteDeletescansResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostConfigupdateRequest {
  account_id: string;
  config_id: string;
  body: { frequency?: number; ips?: string[]; ports?: string[] };
}

export const PostConfigupdateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  config_id: Schema.String.pipe(T.HttpPath("config_id")),
  body: Schema.Struct({
  frequency: Schema.optional(Schema.Number),
  ips: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/cloudforce-one/scans/config/{config_id}" }),
).annotations({ identifier: "PostConfigupdateRequest" }) as unknown as Schema.Schema<PostConfigupdateRequest>;

export interface PostConfigupdateResponse {
  result: { account_id: string; frequency: number; id: string; ips: string[]; ports: string[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostConfigupdateResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  frequency: Schema.Number,
  id: Schema.String,
  ips: Schema.Array(Schema.String),
  ports: Schema.Array(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostConfigupdateResponse" }) as unknown as Schema.Schema<PostConfigupdateResponse>;

export const postConfigupdate: (
  input: PostConfigupdateRequest
) => Effect.Effect<
  PostConfigupdateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostConfigupdateRequest,
  output: PostConfigupdateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetGetopenportsRequest {
  account_id: string;
  config_id: string;
}

export const GetGetopenportsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  config_id: Schema.String.pipe(T.HttpPath("config_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cloudforce-one/scans/results/{config_id}" }),
).annotations({ identifier: "GetGetopenportsRequest" }) as unknown as Schema.Schema<GetGetopenportsRequest>;

export interface GetGetopenportsResponse {
  result: { "1.1.1.1": { number?: number; proto?: string; status?: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetGetopenportsResponse = Schema.Struct({
  result: Schema.Struct({
  "1.1.1.1": Schema.Array(Schema.Struct({
  number: Schema.optional(Schema.Number),
  proto: Schema.optional(Schema.String),
  status: Schema.optional(Schema.String)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetGetopenportsResponse" }) as unknown as Schema.Schema<GetGetopenportsResponse>;

export const getGetopenports: (
  input: GetGetopenportsRequest
) => Effect.Effect<
  GetGetopenportsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGetopenportsRequest,
  output: GetGetopenportsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostEventgraphqlRequest {
  account_id: string;
}

export const PostEventgraphqlRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cloudforce-one/v2/events/graphql" }),
).annotations({ identifier: "PostEventgraphqlRequest" }) as unknown as Schema.Schema<PostEventgraphqlRequest>;

export interface PostEventgraphqlResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostEventgraphqlResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostEventgraphqlResponse" }) as unknown as Schema.Schema<PostEventgraphqlResponse>;

export const postEventgraphql: (
  input: PostEventgraphqlRequest
) => Effect.Effect<
  PostEventgraphqlResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostEventgraphqlRequest,
  output: PostEventgraphqlResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListCnisRequest {
  slot?: string;
  tunnel_id?: string;
  cursor?: number;
  limit?: number;
  account_id: string;
}

export const ListCnisRequest = Schema.Struct({
  slot: Schema.optional(Schema.String).pipe(T.HttpQuery("slot")),
  tunnel_id: Schema.optional(Schema.String).pipe(T.HttpQuery("tunnel_id")),
  cursor: Schema.optional(Schema.Number).pipe(T.HttpQuery("cursor")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cni/cnis" }),
).annotations({ identifier: "ListCnisRequest" }) as unknown as Schema.Schema<ListCnisRequest>;

export interface ListCnisResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListCnisResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListCnisResponse" }) as unknown as Schema.Schema<ListCnisResponse>;

export const listCnis: (
  input: ListCnisRequest
) => Effect.Effect<
  ListCnisResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListCnisRequest,
  output: ListCnisResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateCniRequest {
  account_id: string;
  body: { account: string; bgp?: { customer_asn: number; extra_prefixes: string[]; md5_key?: string }; interconnect: string; magic: { conduit_name: string; description: string; mtu: number } };
}

export const CreateCniRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  account: Schema.String,
  bgp: Schema.optional(Schema.Struct({
  customer_asn: Schema.Number,
  extra_prefixes: Schema.Array(Schema.String),
  md5_key: Schema.optional(Schema.String)
})),
  interconnect: Schema.String,
  magic: Schema.Struct({
  conduit_name: Schema.String,
  description: Schema.String,
  mtu: Schema.Number
})
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cni/cnis" }),
).annotations({ identifier: "CreateCniRequest" }) as unknown as Schema.Schema<CreateCniRequest>;

export interface CreateCniResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateCniResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateCniResponse" }) as unknown as Schema.Schema<CreateCniResponse>;

export const createCni: (
  input: CreateCniRequest
) => Effect.Effect<
  CreateCniResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateCniRequest,
  output: CreateCniResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetCniRequest {
  cni: string;
  account_id: string;
}

export const GetCniRequest = Schema.Struct({
  cni: Schema.UUID.pipe(T.HttpPath("cni")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cni/cnis/{cni}" }),
).annotations({ identifier: "GetCniRequest" }) as unknown as Schema.Schema<GetCniRequest>;

export interface GetCniResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetCniResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetCniResponse" }) as unknown as Schema.Schema<GetCniResponse>;

export const getCni: (
  input: GetCniRequest
) => Effect.Effect<
  GetCniResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCniRequest,
  output: GetCniResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateCniRequest {
  cni: string;
  account_id: string;
  body: { account: string; bgp?: { customer_asn: number; extra_prefixes: string[]; md5_key?: string }; cust_ip: string; id: string; interconnect: string; magic: { conduit_name: string; description: string; mtu: number }; p2p_ip: string };
}

export const UpdateCniRequest = Schema.Struct({
  cni: Schema.UUID.pipe(T.HttpPath("cni")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  account: Schema.String,
  bgp: Schema.optional(Schema.Struct({
  customer_asn: Schema.Number,
  extra_prefixes: Schema.Array(Schema.String),
  md5_key: Schema.optional(Schema.String)
})),
  cust_ip: Schema.String,
  id: Schema.UUID,
  interconnect: Schema.String,
  magic: Schema.Struct({
  conduit_name: Schema.String,
  description: Schema.String,
  mtu: Schema.Number
}),
  p2p_ip: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/cni/cnis/{cni}" }),
).annotations({ identifier: "UpdateCniRequest" }) as unknown as Schema.Schema<UpdateCniRequest>;

export interface UpdateCniResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateCniResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateCniResponse" }) as unknown as Schema.Schema<UpdateCniResponse>;

export const updateCni: (
  input: UpdateCniRequest
) => Effect.Effect<
  UpdateCniResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateCniRequest,
  output: UpdateCniResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteCniRequest {
  cni: string;
  account_id: string;
}

export const DeleteCniRequest = Schema.Struct({
  cni: Schema.UUID.pipe(T.HttpPath("cni")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cni/cnis/{cni}" }),
).annotations({ identifier: "DeleteCniRequest" }) as unknown as Schema.Schema<DeleteCniRequest>;

export interface DeleteCniResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteCniResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteCniResponse" }) as unknown as Schema.Schema<DeleteCniResponse>;

export const deleteCni: (
  input: DeleteCniRequest
) => Effect.Effect<
  DeleteCniResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteCniRequest,
  output: DeleteCniResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListInterconnectsRequest {
  site?: string;
  type?: string;
  cursor?: number;
  limit?: number;
  account_id: string;
}

export const ListInterconnectsRequest = Schema.Struct({
  site: Schema.optional(Schema.String).pipe(T.HttpQuery("site")),
  type: Schema.optional(Schema.String).pipe(T.HttpQuery("type")),
  cursor: Schema.optional(Schema.Number).pipe(T.HttpQuery("cursor")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cni/interconnects" }),
).annotations({ identifier: "ListInterconnectsRequest" }) as unknown as Schema.Schema<ListInterconnectsRequest>;

export interface ListInterconnectsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListInterconnectsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListInterconnectsResponse" }) as unknown as Schema.Schema<ListInterconnectsResponse>;

export const listInterconnects: (
  input: ListInterconnectsRequest
) => Effect.Effect<
  ListInterconnectsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListInterconnectsRequest,
  output: ListInterconnectsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateInterconnectRequest {
  account_id: string;
  body: Record<string, unknown>;
}

export const CreateInterconnectRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/cni/interconnects" }),
).annotations({ identifier: "CreateInterconnectRequest" }) as unknown as Schema.Schema<CreateInterconnectRequest>;

export interface CreateInterconnectResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateInterconnectResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateInterconnectResponse" }) as unknown as Schema.Schema<CreateInterconnectResponse>;

export const createInterconnect: (
  input: CreateInterconnectRequest
) => Effect.Effect<
  CreateInterconnectResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateInterconnectRequest,
  output: CreateInterconnectResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetInterconnectRequest {
  icon: string;
  account_id: string;
}

export const GetInterconnectRequest = Schema.Struct({
  icon: Schema.String.pipe(T.HttpPath("icon")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cni/interconnects/{icon}" }),
).annotations({ identifier: "GetInterconnectRequest" }) as unknown as Schema.Schema<GetInterconnectRequest>;

export interface GetInterconnectResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetInterconnectResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetInterconnectResponse" }) as unknown as Schema.Schema<GetInterconnectResponse>;

export const getInterconnect: (
  input: GetInterconnectRequest
) => Effect.Effect<
  GetInterconnectResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetInterconnectRequest,
  output: GetInterconnectResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteInterconnectRequest {
  icon: string;
  account_id: string;
}

export const DeleteInterconnectRequest = Schema.Struct({
  icon: Schema.String.pipe(T.HttpPath("icon")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/cni/interconnects/{icon}" }),
).annotations({ identifier: "DeleteInterconnectRequest" }) as unknown as Schema.Schema<DeleteInterconnectRequest>;

export interface DeleteInterconnectResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteInterconnectResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteInterconnectResponse" }) as unknown as Schema.Schema<DeleteInterconnectResponse>;

export const deleteInterconnect: (
  input: DeleteInterconnectRequest
) => Effect.Effect<
  DeleteInterconnectResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteInterconnectRequest,
  output: DeleteInterconnectResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetInterconnectLoaRequest {
  icon: string;
  account_id: string;
}

export const GetInterconnectLoaRequest = Schema.Struct({
  icon: Schema.String.pipe(T.HttpPath("icon")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cni/interconnects/{icon}/loa" }),
).annotations({ identifier: "GetInterconnectLoaRequest" }) as unknown as Schema.Schema<GetInterconnectLoaRequest>;

export interface GetInterconnectLoaResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetInterconnectLoaResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetInterconnectLoaResponse" }) as unknown as Schema.Schema<GetInterconnectLoaResponse>;

export const getInterconnectLoa: (
  input: GetInterconnectLoaRequest
) => Effect.Effect<
  GetInterconnectLoaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetInterconnectLoaRequest,
  output: GetInterconnectLoaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetInterconnectStatusRequest {
  icon: string;
  account_id: string;
}

export const GetInterconnectStatusRequest = Schema.Struct({
  icon: Schema.String.pipe(T.HttpPath("icon")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cni/interconnects/{icon}/status" }),
).annotations({ identifier: "GetInterconnectStatusRequest" }) as unknown as Schema.Schema<GetInterconnectStatusRequest>;

export interface GetInterconnectStatusResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetInterconnectStatusResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetInterconnectStatusResponse" }) as unknown as Schema.Schema<GetInterconnectStatusResponse>;

export const getInterconnectStatus: (
  input: GetInterconnectStatusRequest
) => Effect.Effect<
  GetInterconnectStatusResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetInterconnectStatusRequest,
  output: GetInterconnectStatusResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSettingsRequest {
  account_id: string;
}

export const GetSettingsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cni/settings" }),
).annotations({ identifier: "GetSettingsRequest" }) as unknown as Schema.Schema<GetSettingsRequest>;

export interface GetSettingsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSettingsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSettingsResponse" }) as unknown as Schema.Schema<GetSettingsResponse>;

export const getSettings: (
  input: GetSettingsRequest
) => Effect.Effect<
  GetSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSettingsRequest,
  output: GetSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateSettingsRequest {
  account_id: string;
  body: { default_asn?: number };
}

export const UpdateSettingsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  default_asn: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/cni/settings" }),
).annotations({ identifier: "UpdateSettingsRequest" }) as unknown as Schema.Schema<UpdateSettingsRequest>;

export interface UpdateSettingsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateSettingsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateSettingsResponse" }) as unknown as Schema.Schema<UpdateSettingsResponse>;

export const updateSettings: (
  input: UpdateSettingsRequest
) => Effect.Effect<
  UpdateSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateSettingsRequest,
  output: UpdateSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListSlotsRequest {
  address_contains?: string;
  site?: string;
  speed?: string;
  occupied?: boolean;
  cursor?: number;
  limit?: number;
  account_id: string;
}

export const ListSlotsRequest = Schema.Struct({
  address_contains: Schema.optional(Schema.String).pipe(T.HttpQuery("address_contains")),
  site: Schema.optional(Schema.String).pipe(T.HttpQuery("site")),
  speed: Schema.optional(Schema.String).pipe(T.HttpQuery("speed")),
  occupied: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("occupied")),
  cursor: Schema.optional(Schema.Number).pipe(T.HttpQuery("cursor")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cni/slots" }),
).annotations({ identifier: "ListSlotsRequest" }) as unknown as Schema.Schema<ListSlotsRequest>;

export interface ListSlotsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListSlotsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListSlotsResponse" }) as unknown as Schema.Schema<ListSlotsResponse>;

export const listSlots: (
  input: ListSlotsRequest
) => Effect.Effect<
  ListSlotsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListSlotsRequest,
  output: ListSlotsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSlotRequest {
  slot: string;
  account_id: string;
}

export const GetSlotRequest = Schema.Struct({
  slot: Schema.UUID.pipe(T.HttpPath("slot")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cni/slots/{slot}" }),
).annotations({ identifier: "GetSlotRequest" }) as unknown as Schema.Schema<GetSlotRequest>;

export interface GetSlotResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSlotResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSlotResponse" }) as unknown as Schema.Schema<GetSlotResponse>;

export const getSlot: (
  input: GetSlotRequest
) => Effect.Effect<
  GetSlotResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSlotRequest,
  output: GetSlotResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List7Request {
  account_id: string;
  type?: string;
  page?: number;
  per_page?: number;
}

export const List7Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  type: Schema.optional(Schema.String).pipe(T.HttpQuery("type")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/connectivity/directory/services" }),
).annotations({ identifier: "List7Request" }) as unknown as Schema.Schema<List7Request>;

export interface List7Response {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List7Response = Schema.Struct({
  result: Schema.Array(Schema.Union(Schema.Struct({
  http_port: Schema.optional(Schema.Number),
  https_port: Schema.optional(Schema.Number)
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List7Response" }) as unknown as Schema.Schema<List7Response>;

export const list7: (
  input: List7Request
) => Effect.Effect<
  List7Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List7Request,
  output: List7Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostRequest {
  account_id: string;
  body: unknown;
}

export const PostRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Union(Schema.Struct({
  http_port: Schema.optional(Schema.Number),
  https_port: Schema.optional(Schema.Number)
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/connectivity/directory/services" }),
).annotations({ identifier: "PostRequest" }) as unknown as Schema.Schema<PostRequest>;

export interface PostResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  http_port: Schema.optional(Schema.Number),
  https_port: Schema.optional(Schema.Number)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostResponse" }) as unknown as Schema.Schema<PostResponse>;

export const post: (
  input: PostRequest
) => Effect.Effect<
  PostResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostRequest,
  output: PostResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_4Request {
  account_id: string;
  service_id: string;
}

export const Get_4Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  service_id: Schema.UUID.pipe(T.HttpPath("service_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/connectivity/directory/services/{service_id}" }),
).annotations({ identifier: "Get_4Request" }) as unknown as Schema.Schema<Get_4Request>;

export interface Get_4Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_4Response = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  http_port: Schema.optional(Schema.Number),
  https_port: Schema.optional(Schema.Number)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_4Response" }) as unknown as Schema.Schema<Get_4Response>;

export const get_4: (
  input: Get_4Request
) => Effect.Effect<
  Get_4Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_4Request,
  output: Get_4Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PutRequest {
  account_id: string;
  service_id: string;
  body: unknown;
}

export const PutRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  service_id: Schema.UUID.pipe(T.HttpPath("service_id")),
  body: Schema.Union(Schema.Struct({
  http_port: Schema.optional(Schema.Number),
  https_port: Schema.optional(Schema.Number)
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/connectivity/directory/services/{service_id}" }),
).annotations({ identifier: "PutRequest" }) as unknown as Schema.Schema<PutRequest>;

export interface PutResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PutResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  http_port: Schema.optional(Schema.Number),
  https_port: Schema.optional(Schema.Number)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PutResponse" }) as unknown as Schema.Schema<PutResponse>;

export const put: (
  input: PutRequest
) => Effect.Effect<
  PutResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutRequest,
  output: PutResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_5Request {
  account_id: string;
  service_id: string;
}

export const Delete_5Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  service_id: Schema.UUID.pipe(T.HttpPath("service_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/connectivity/directory/services/{service_id}" }),
).annotations({ identifier: "Delete_5Request" }) as unknown as Schema.Schema<Delete_5Request>;

export interface Delete_5Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_5Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_5Response" }) as unknown as Schema.Schema<Delete_5Response>;

export const delete_5: (
  input: Delete_5Request
) => Effect.Effect<
  Delete_5Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_5Request,
  output: Delete_5Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAccountCustomNameserversRequest {
  account_id: string;
}

export const ListAccountCustomNameserversRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/custom_ns" }),
).annotations({ identifier: "ListAccountCustomNameserversRequest" }) as unknown as Schema.Schema<ListAccountCustomNameserversRequest>;

export interface ListAccountCustomNameserversResponse {
  result: { dns_records: { type?: "A" | "AAAA"; value?: string }[]; ns_name: string; ns_set?: number; status: "moved" | "pending" | "verified"; zone_tag: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAccountCustomNameserversResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  dns_records: Schema.Array(Schema.Struct({
  type: Schema.optional(Schema.Literal("A", "AAAA")),
  value: Schema.optional(Schema.String)
})),
  ns_name: Schema.String,
  ns_set: Schema.optional(Schema.Number),
  status: Schema.Literal("moved", "pending", "verified"),
  zone_tag: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAccountCustomNameserversResponse" }) as unknown as Schema.Schema<ListAccountCustomNameserversResponse>;

export const listAccountCustomNameservers: (
  input: ListAccountCustomNameserversRequest
) => Effect.Effect<
  ListAccountCustomNameserversResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccountCustomNameserversRequest,
  output: ListAccountCustomNameserversResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountLevelCustomNameserversAddAccountCustomNameserverRequest {
  account_id: string;
  body: { ns_name: string; ns_set?: number };
}

export const AccountLevelCustomNameserversAddAccountCustomNameserverRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  ns_name: Schema.String,
  ns_set: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/custom_ns" }),
).annotations({ identifier: "AccountLevelCustomNameserversAddAccountCustomNameserverRequest" }) as unknown as Schema.Schema<AccountLevelCustomNameserversAddAccountCustomNameserverRequest>;

export interface AccountLevelCustomNameserversAddAccountCustomNameserverResponse {
  result: { dns_records: { type?: "A" | "AAAA"; value?: string }[]; ns_name: string; ns_set?: number; status: "moved" | "pending" | "verified"; zone_tag: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountLevelCustomNameserversAddAccountCustomNameserverResponse = Schema.Struct({
  result: Schema.Struct({
  dns_records: Schema.Array(Schema.Struct({
  type: Schema.optional(Schema.Literal("A", "AAAA")),
  value: Schema.optional(Schema.String)
})),
  ns_name: Schema.String,
  ns_set: Schema.optional(Schema.Number),
  status: Schema.Literal("moved", "pending", "verified"),
  zone_tag: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountLevelCustomNameserversAddAccountCustomNameserverResponse" }) as unknown as Schema.Schema<AccountLevelCustomNameserversAddAccountCustomNameserverResponse>;

export const accountLevelCustomNameserversAddAccountCustomNameserver: (
  input: AccountLevelCustomNameserversAddAccountCustomNameserverRequest
) => Effect.Effect<
  AccountLevelCustomNameserversAddAccountCustomNameserverResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountLevelCustomNameserversAddAccountCustomNameserverRequest,
  output: AccountLevelCustomNameserversAddAccountCustomNameserverResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAccountCustomNameserverRequest {
  custom_ns_id: string;
  account_id: string;
}

export const DeleteAccountCustomNameserverRequest = Schema.Struct({
  custom_ns_id: Schema.String.pipe(T.HttpPath("custom_ns_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/custom_ns/{custom_ns_id}" }),
).annotations({ identifier: "DeleteAccountCustomNameserverRequest" }) as unknown as Schema.Schema<DeleteAccountCustomNameserverRequest>;

export interface DeleteAccountCustomNameserverResponse {
  result: string[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAccountCustomNameserverResponse = Schema.Struct({
  result: Schema.Array(Schema.String),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAccountCustomNameserverResponse" }) as unknown as Schema.Schema<DeleteAccountCustomNameserverResponse>;

export const deleteAccountCustomNameserver: (
  input: DeleteAccountCustomNameserverRequest
) => Effect.Effect<
  DeleteAccountCustomNameserverResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccountCustomNameserverRequest,
  output: DeleteAccountCustomNameserverResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDevicesRequest {
  account_id: unknown;
}

export const ListDevicesRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices" }),
).annotations({ identifier: "ListDevicesRequest" }) as unknown as Schema.Schema<ListDevicesRequest>;

export interface ListDevicesResponse {
  result: { created?: string; deleted?: boolean; device_type?: "windows" | "mac" | "linux" | "android" | "ios" | "chromeos"; id?: string; ip?: string; key?: string; last_seen?: string; mac_address?: string; manufacturer?: string; model?: string; name?: string; os_distro_name?: string; os_distro_revision?: string; os_version?: string; os_version_extra?: string; revoked_at?: string; serial_number?: string; updated?: string; user?: { email?: string; id?: string; name?: string }; version?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDevicesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created: Schema.optional(Schema.Date),
  deleted: Schema.optional(Schema.Boolean),
  device_type: Schema.optional(Schema.Literal("windows", "mac", "linux", "android", "ios", "chromeos")),
  id: Schema.optional(Schema.String),
  ip: Schema.optional(Schema.String),
  key: Schema.optional(Schema.String),
  last_seen: Schema.optional(Schema.Date),
  mac_address: Schema.optional(Schema.String),
  manufacturer: Schema.optional(Schema.String),
  model: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  os_distro_name: Schema.optional(Schema.String),
  os_distro_revision: Schema.optional(Schema.String),
  os_version: Schema.optional(Schema.String),
  os_version_extra: Schema.optional(Schema.String),
  revoked_at: Schema.optional(Schema.Date),
  serial_number: Schema.optional(Schema.String),
  updated: Schema.optional(Schema.Date),
  user: Schema.optional(Schema.Struct({
  email: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
})),
  version: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDevicesResponse" }) as unknown as Schema.Schema<ListDevicesResponse>;

export const listDevices: (
  input: ListDevicesRequest
) => Effect.Effect<
  ListDevicesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDevicesRequest,
  output: ListDevicesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDeviceManagedNetworksRequest {
  account_id: unknown;
}

export const ListDeviceManagedNetworksRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/networks" }),
).annotations({ identifier: "ListDeviceManagedNetworksRequest" }) as unknown as Schema.Schema<ListDeviceManagedNetworksRequest>;

export interface ListDeviceManagedNetworksResponse {
  result: { config?: Record<string, unknown>; name?: string; network_id?: string; type?: "tls" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDeviceManagedNetworksResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  config: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  network_id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("tls"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDeviceManagedNetworksResponse" }) as unknown as Schema.Schema<ListDeviceManagedNetworksResponse>;

export const listDeviceManagedNetworks: (
  input: ListDeviceManagedNetworksRequest
) => Effect.Effect<
  ListDeviceManagedNetworksResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDeviceManagedNetworksRequest,
  output: ListDeviceManagedNetworksResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateDeviceManagedNetworkRequest {
  account_id: unknown;
  body: { config: Record<string, unknown>; name: string; type: "tls" };
}

export const CreateDeviceManagedNetworkRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  config: Schema.Struct({}),
  name: Schema.String,
  type: Schema.Literal("tls")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/devices/networks" }),
).annotations({ identifier: "CreateDeviceManagedNetworkRequest" }) as unknown as Schema.Schema<CreateDeviceManagedNetworkRequest>;

export interface CreateDeviceManagedNetworkResponse {
  result: { config?: Record<string, unknown>; name?: string; network_id?: string; type?: "tls" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateDeviceManagedNetworkResponse = Schema.Struct({
  result: Schema.Struct({
  config: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  network_id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("tls"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateDeviceManagedNetworkResponse" }) as unknown as Schema.Schema<CreateDeviceManagedNetworkResponse>;

export const createDeviceManagedNetwork: (
  input: CreateDeviceManagedNetworkRequest
) => Effect.Effect<
  CreateDeviceManagedNetworkResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDeviceManagedNetworkRequest,
  output: CreateDeviceManagedNetworkResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeviceManagedNetworksDeviceManagedNetworkDetailsRequest {
  network_id: string;
  account_id: unknown;
}

export const DeviceManagedNetworksDeviceManagedNetworkDetailsRequest = Schema.Struct({
  network_id: Schema.String.pipe(T.HttpPath("network_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/networks/{network_id}" }),
).annotations({ identifier: "DeviceManagedNetworksDeviceManagedNetworkDetailsRequest" }) as unknown as Schema.Schema<DeviceManagedNetworksDeviceManagedNetworkDetailsRequest>;

export interface DeviceManagedNetworksDeviceManagedNetworkDetailsResponse {
  result: { config?: Record<string, unknown>; name?: string; network_id?: string; type?: "tls" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeviceManagedNetworksDeviceManagedNetworkDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  config: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  network_id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("tls"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeviceManagedNetworksDeviceManagedNetworkDetailsResponse" }) as unknown as Schema.Schema<DeviceManagedNetworksDeviceManagedNetworkDetailsResponse>;

export const deviceManagedNetworksDeviceManagedNetworkDetails: (
  input: DeviceManagedNetworksDeviceManagedNetworkDetailsRequest
) => Effect.Effect<
  DeviceManagedNetworksDeviceManagedNetworkDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeviceManagedNetworksDeviceManagedNetworkDetailsRequest,
  output: DeviceManagedNetworksDeviceManagedNetworkDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateDeviceManagedNetworkRequest {
  network_id: string;
  account_id: unknown;
  body: { config?: Record<string, unknown>; name?: string; type?: "tls" };
}

export const UpdateDeviceManagedNetworkRequest = Schema.Struct({
  network_id: Schema.String.pipe(T.HttpPath("network_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  config: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("tls"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/devices/networks/{network_id}" }),
).annotations({ identifier: "UpdateDeviceManagedNetworkRequest" }) as unknown as Schema.Schema<UpdateDeviceManagedNetworkRequest>;

export interface UpdateDeviceManagedNetworkResponse {
  result: { config?: Record<string, unknown>; name?: string; network_id?: string; type?: "tls" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateDeviceManagedNetworkResponse = Schema.Struct({
  result: Schema.Struct({
  config: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  network_id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("tls"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateDeviceManagedNetworkResponse" }) as unknown as Schema.Schema<UpdateDeviceManagedNetworkResponse>;

export const updateDeviceManagedNetwork: (
  input: UpdateDeviceManagedNetworkRequest
) => Effect.Effect<
  UpdateDeviceManagedNetworkResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDeviceManagedNetworkRequest,
  output: UpdateDeviceManagedNetworkResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDeviceManagedNetworkRequest {
  network_id: string;
  account_id: unknown;
}

export const DeleteDeviceManagedNetworkRequest = Schema.Struct({
  network_id: Schema.String.pipe(T.HttpPath("network_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/devices/networks/{network_id}" }),
).annotations({ identifier: "DeleteDeviceManagedNetworkRequest" }) as unknown as Schema.Schema<DeleteDeviceManagedNetworkRequest>;

export interface DeleteDeviceManagedNetworkResponse {
  result: { config?: Record<string, unknown>; name?: string; network_id?: string; type?: "tls" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDeviceManagedNetworkResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  config: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  network_id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("tls"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDeviceManagedNetworkResponse" }) as unknown as Schema.Schema<DeleteDeviceManagedNetworkResponse>;

export const deleteDeviceManagedNetwork: (
  input: DeleteDeviceManagedNetworkRequest
) => Effect.Effect<
  DeleteDeviceManagedNetworkResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDeviceManagedNetworkRequest,
  output: DeleteDeviceManagedNetworkResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDevices1Request {
  account_id: string;
}

export const ListDevices1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/physical-devices" }),
).annotations({ identifier: "ListDevices1Request" }) as unknown as Schema.Schema<ListDevices1Request>;

export interface ListDevices1Response {
  result: { active_registrations: number; client_version?: string; created_at: string; deleted_at?: string; device_type?: string; hardware_id?: string; id: string; last_seen_at: string; last_seen_registration?: Record<string, unknown>; last_seen_user?: Record<string, unknown>; mac_address?: string; manufacturer?: string; model?: string; name: string; os_version?: string; os_version_extra?: string; public_ip?: string; serial_number?: string; updated_at: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDevices1Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  active_registrations: Schema.Number,
  client_version: Schema.optional(Schema.String),
  created_at: Schema.String,
  deleted_at: Schema.optional(Schema.String),
  device_type: Schema.optional(Schema.String),
  hardware_id: Schema.optional(Schema.String),
  id: Schema.String,
  last_seen_at: Schema.String,
  last_seen_registration: Schema.optional(Schema.Struct({})),
  last_seen_user: Schema.optional(Schema.Struct({})),
  mac_address: Schema.optional(Schema.String),
  manufacturer: Schema.optional(Schema.String),
  model: Schema.optional(Schema.String),
  name: Schema.String,
  os_version: Schema.optional(Schema.String),
  os_version_extra: Schema.optional(Schema.String),
  public_ip: Schema.optional(Schema.String),
  serial_number: Schema.optional(Schema.String),
  updated_at: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDevices1Response" }) as unknown as Schema.Schema<ListDevices1Response>;

export const listDevices1: (
  input: ListDevices1Request
) => Effect.Effect<
  ListDevices1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDevices1Request,
  output: ListDevices1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDeviceRequest {
  device_id: string;
  account_id: string;
}

export const GetDeviceRequest = Schema.Struct({
  device_id: Schema.String.pipe(T.HttpPath("device_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/physical-devices/{device_id}" }),
).annotations({ identifier: "GetDeviceRequest" }) as unknown as Schema.Schema<GetDeviceRequest>;

export interface GetDeviceResponse {
  result: { active_registrations: number; client_version?: string; created_at: string; deleted_at?: string; device_type?: string; hardware_id?: string; id: string; last_seen_at: string; last_seen_registration?: Record<string, unknown>; last_seen_user?: Record<string, unknown>; mac_address?: string; manufacturer?: string; model?: string; name: string; os_version?: string; os_version_extra?: string; public_ip?: string; serial_number?: string; updated_at: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDeviceResponse = Schema.Struct({
  result: Schema.Struct({
  active_registrations: Schema.Number,
  client_version: Schema.optional(Schema.String),
  created_at: Schema.String,
  deleted_at: Schema.optional(Schema.String),
  device_type: Schema.optional(Schema.String),
  hardware_id: Schema.optional(Schema.String),
  id: Schema.String,
  last_seen_at: Schema.String,
  last_seen_registration: Schema.optional(Schema.Struct({})),
  last_seen_user: Schema.optional(Schema.Struct({})),
  mac_address: Schema.optional(Schema.String),
  manufacturer: Schema.optional(Schema.String),
  model: Schema.optional(Schema.String),
  name: Schema.String,
  os_version: Schema.optional(Schema.String),
  os_version_extra: Schema.optional(Schema.String),
  public_ip: Schema.optional(Schema.String),
  serial_number: Schema.optional(Schema.String),
  updated_at: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDeviceResponse" }) as unknown as Schema.Schema<GetDeviceResponse>;

export const getDevice: (
  input: GetDeviceRequest
) => Effect.Effect<
  GetDeviceResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDeviceRequest,
  output: GetDeviceResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDeviceRequest {
  device_id: string;
  account_id: string;
}

export const DeleteDeviceRequest = Schema.Struct({
  device_id: Schema.String.pipe(T.HttpPath("device_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/devices/physical-devices/{device_id}" }),
).annotations({ identifier: "DeleteDeviceRequest" }) as unknown as Schema.Schema<DeleteDeviceRequest>;

export interface DeleteDeviceResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDeviceResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDeviceResponse" }) as unknown as Schema.Schema<DeleteDeviceResponse>;

export const deleteDevice: (
  input: DeleteDeviceRequest
) => Effect.Effect<
  DeleteDeviceResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDeviceRequest,
  output: DeleteDeviceResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface RevokeDeviceRequest {
  account_id: string;
  device_id: string;
}

export const RevokeDeviceRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  device_id: Schema.String.pipe(T.HttpPath("device_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/devices/physical-devices/{device_id}/revoke" }),
).annotations({ identifier: "RevokeDeviceRequest" }) as unknown as Schema.Schema<RevokeDeviceRequest>;

export interface RevokeDeviceResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const RevokeDeviceResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "RevokeDeviceResponse" }) as unknown as Schema.Schema<RevokeDeviceResponse>;

export const revokeDevice: (
  input: RevokeDeviceRequest
) => Effect.Effect<
  RevokeDeviceResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: RevokeDeviceRequest,
  output: RevokeDeviceResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDeviceSettingsPoliciesRequest {
  account_id: unknown;
}

export const ListDeviceSettingsPoliciesRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/policies" }),
).annotations({ identifier: "ListDeviceSettingsPoliciesRequest" }) as unknown as Schema.Schema<ListDeviceSettingsPoliciesRequest>;

export interface ListDeviceSettingsPoliciesResponse {
  result: { allow_mode_switch?: boolean; allow_updates?: boolean; allowed_to_leave?: boolean; auto_connect?: number; captive_portal?: number; default?: boolean; description?: string; disable_auto_fallback?: boolean; enabled?: boolean; exclude?: Record<string, unknown>[]; exclude_office_ips?: boolean; fallback_domains?: { description?: string; dns_server?: string[]; suffix: string }[]; gateway_unique_id?: string; include?: Record<string, unknown>[]; lan_allow_minutes?: number; lan_allow_subnet_size?: number; match?: string; name?: string; policy_id?: string; precedence?: number; register_interface_ip_with_dns?: boolean; sccm_vpn_boundary_support?: boolean; service_mode_v2?: { mode?: string; port?: number }; support_url?: string; switch_locked?: boolean; target_tests?: { id?: string; name?: string }[]; tunnel_protocol?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDeviceSettingsPoliciesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  allow_mode_switch: Schema.optional(Schema.Boolean),
  allow_updates: Schema.optional(Schema.Boolean),
  allowed_to_leave: Schema.optional(Schema.Boolean),
  auto_connect: Schema.optional(Schema.Number),
  captive_portal: Schema.optional(Schema.Number),
  default: Schema.optional(Schema.Boolean),
  description: Schema.optional(Schema.String),
  disable_auto_fallback: Schema.optional(Schema.Boolean),
  enabled: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Struct({}))),
  exclude_office_ips: Schema.optional(Schema.Boolean),
  fallback_domains: Schema.optional(Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.Array(Schema.String)),
  suffix: Schema.String
}))),
  gateway_unique_id: Schema.optional(Schema.String),
  include: Schema.optional(Schema.Array(Schema.Struct({}))),
  lan_allow_minutes: Schema.optional(Schema.Number),
  lan_allow_subnet_size: Schema.optional(Schema.Number),
  match: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  policy_id: Schema.optional(Schema.String),
  precedence: Schema.optional(Schema.Number),
  register_interface_ip_with_dns: Schema.optional(Schema.Boolean),
  sccm_vpn_boundary_support: Schema.optional(Schema.Boolean),
  service_mode_v2: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  support_url: Schema.optional(Schema.String),
  switch_locked: Schema.optional(Schema.Boolean),
  target_tests: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))),
  tunnel_protocol: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDeviceSettingsPoliciesResponse" }) as unknown as Schema.Schema<ListDeviceSettingsPoliciesResponse>;

export const listDeviceSettingsPolicies: (
  input: ListDeviceSettingsPoliciesRequest
) => Effect.Effect<
  ListDeviceSettingsPoliciesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDeviceSettingsPoliciesRequest,
  output: ListDeviceSettingsPoliciesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDefaultDeviceSettingsPolicyRequest {
  account_id: unknown;
}

export const GetDefaultDeviceSettingsPolicyRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/policy" }),
).annotations({ identifier: "GetDefaultDeviceSettingsPolicyRequest" }) as unknown as Schema.Schema<GetDefaultDeviceSettingsPolicyRequest>;

export interface GetDefaultDeviceSettingsPolicyResponse {
  result: { allow_mode_switch?: boolean; allow_updates?: boolean; allowed_to_leave?: boolean; auto_connect?: number; captive_portal?: number; default?: boolean; disable_auto_fallback?: boolean; enabled?: boolean; exclude?: Record<string, unknown>[]; exclude_office_ips?: boolean; fallback_domains?: { description?: string; dns_server?: string[]; suffix: string }[]; gateway_unique_id?: string; include?: Record<string, unknown>[]; register_interface_ip_with_dns?: boolean; sccm_vpn_boundary_support?: boolean; service_mode_v2?: { mode?: string; port?: number }; support_url?: string; switch_locked?: boolean; tunnel_protocol?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDefaultDeviceSettingsPolicyResponse = Schema.Struct({
  result: Schema.Struct({
  allow_mode_switch: Schema.optional(Schema.Boolean),
  allow_updates: Schema.optional(Schema.Boolean),
  allowed_to_leave: Schema.optional(Schema.Boolean),
  auto_connect: Schema.optional(Schema.Number),
  captive_portal: Schema.optional(Schema.Number),
  default: Schema.optional(Schema.Boolean),
  disable_auto_fallback: Schema.optional(Schema.Boolean),
  enabled: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Struct({}))),
  exclude_office_ips: Schema.optional(Schema.Boolean),
  fallback_domains: Schema.optional(Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.Array(Schema.String)),
  suffix: Schema.String
}))),
  gateway_unique_id: Schema.optional(Schema.String),
  include: Schema.optional(Schema.Array(Schema.Struct({}))),
  register_interface_ip_with_dns: Schema.optional(Schema.Boolean),
  sccm_vpn_boundary_support: Schema.optional(Schema.Boolean),
  service_mode_v2: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  support_url: Schema.optional(Schema.String),
  switch_locked: Schema.optional(Schema.Boolean),
  tunnel_protocol: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDefaultDeviceSettingsPolicyResponse" }) as unknown as Schema.Schema<GetDefaultDeviceSettingsPolicyResponse>;

export const getDefaultDeviceSettingsPolicy: (
  input: GetDefaultDeviceSettingsPolicyRequest
) => Effect.Effect<
  GetDefaultDeviceSettingsPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDefaultDeviceSettingsPolicyRequest,
  output: GetDefaultDeviceSettingsPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateDeviceSettingsPolicyRequest {
  account_id: unknown;
  body: { allow_mode_switch?: boolean; allow_updates?: boolean; allowed_to_leave?: boolean; auto_connect?: number; captive_portal?: number; description?: string; disable_auto_fallback?: boolean; enabled?: boolean; exclude?: Record<string, unknown>[]; exclude_office_ips?: boolean; include?: Record<string, unknown>[]; lan_allow_minutes?: number; lan_allow_subnet_size?: number; match: string; name: string; precedence: number; register_interface_ip_with_dns?: boolean; sccm_vpn_boundary_support?: boolean; service_mode_v2?: { mode?: string; port?: number }; support_url?: string; switch_locked?: boolean; tunnel_protocol?: string };
}

export const CreateDeviceSettingsPolicyRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  allow_mode_switch: Schema.optional(Schema.Boolean),
  allow_updates: Schema.optional(Schema.Boolean),
  allowed_to_leave: Schema.optional(Schema.Boolean),
  auto_connect: Schema.optional(Schema.Number),
  captive_portal: Schema.optional(Schema.Number),
  description: Schema.optional(Schema.String),
  disable_auto_fallback: Schema.optional(Schema.Boolean),
  enabled: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Struct({}))),
  exclude_office_ips: Schema.optional(Schema.Boolean),
  include: Schema.optional(Schema.Array(Schema.Struct({}))),
  lan_allow_minutes: Schema.optional(Schema.Number),
  lan_allow_subnet_size: Schema.optional(Schema.Number),
  match: Schema.String,
  name: Schema.String,
  precedence: Schema.Number,
  register_interface_ip_with_dns: Schema.optional(Schema.Boolean),
  sccm_vpn_boundary_support: Schema.optional(Schema.Boolean),
  service_mode_v2: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  support_url: Schema.optional(Schema.String),
  switch_locked: Schema.optional(Schema.Boolean),
  tunnel_protocol: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/devices/policy" }),
).annotations({ identifier: "CreateDeviceSettingsPolicyRequest" }) as unknown as Schema.Schema<CreateDeviceSettingsPolicyRequest>;

export interface CreateDeviceSettingsPolicyResponse {
  result: { allow_mode_switch?: boolean; allow_updates?: boolean; allowed_to_leave?: boolean; auto_connect?: number; captive_portal?: number; default?: boolean; description?: string; disable_auto_fallback?: boolean; enabled?: boolean; exclude?: Record<string, unknown>[]; exclude_office_ips?: boolean; fallback_domains?: { description?: string; dns_server?: string[]; suffix: string }[]; gateway_unique_id?: string; include?: Record<string, unknown>[]; lan_allow_minutes?: number; lan_allow_subnet_size?: number; match?: string; name?: string; policy_id?: string; precedence?: number; register_interface_ip_with_dns?: boolean; sccm_vpn_boundary_support?: boolean; service_mode_v2?: { mode?: string; port?: number }; support_url?: string; switch_locked?: boolean; target_tests?: { id?: string; name?: string }[]; tunnel_protocol?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateDeviceSettingsPolicyResponse = Schema.Struct({
  result: Schema.Struct({
  allow_mode_switch: Schema.optional(Schema.Boolean),
  allow_updates: Schema.optional(Schema.Boolean),
  allowed_to_leave: Schema.optional(Schema.Boolean),
  auto_connect: Schema.optional(Schema.Number),
  captive_portal: Schema.optional(Schema.Number),
  default: Schema.optional(Schema.Boolean),
  description: Schema.optional(Schema.String),
  disable_auto_fallback: Schema.optional(Schema.Boolean),
  enabled: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Struct({}))),
  exclude_office_ips: Schema.optional(Schema.Boolean),
  fallback_domains: Schema.optional(Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.Array(Schema.String)),
  suffix: Schema.String
}))),
  gateway_unique_id: Schema.optional(Schema.String),
  include: Schema.optional(Schema.Array(Schema.Struct({}))),
  lan_allow_minutes: Schema.optional(Schema.Number),
  lan_allow_subnet_size: Schema.optional(Schema.Number),
  match: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  policy_id: Schema.optional(Schema.String),
  precedence: Schema.optional(Schema.Number),
  register_interface_ip_with_dns: Schema.optional(Schema.Boolean),
  sccm_vpn_boundary_support: Schema.optional(Schema.Boolean),
  service_mode_v2: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  support_url: Schema.optional(Schema.String),
  switch_locked: Schema.optional(Schema.Boolean),
  target_tests: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))),
  tunnel_protocol: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateDeviceSettingsPolicyResponse" }) as unknown as Schema.Schema<CreateDeviceSettingsPolicyResponse>;

export const createDeviceSettingsPolicy: (
  input: CreateDeviceSettingsPolicyRequest
) => Effect.Effect<
  CreateDeviceSettingsPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDeviceSettingsPolicyRequest,
  output: CreateDeviceSettingsPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateDefaultDeviceSettingsPolicyRequest {
  account_id: unknown;
  body: { allow_mode_switch?: boolean; allow_updates?: boolean; allowed_to_leave?: boolean; auto_connect?: number; captive_portal?: number; disable_auto_fallback?: boolean; exclude?: Record<string, unknown>[]; exclude_office_ips?: boolean; include?: Record<string, unknown>[]; lan_allow_minutes?: number; lan_allow_subnet_size?: number; register_interface_ip_with_dns?: boolean; sccm_vpn_boundary_support?: boolean; service_mode_v2?: { mode?: string; port?: number }; support_url?: string; switch_locked?: boolean; tunnel_protocol?: string };
}

export const UpdateDefaultDeviceSettingsPolicyRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  allow_mode_switch: Schema.optional(Schema.Boolean),
  allow_updates: Schema.optional(Schema.Boolean),
  allowed_to_leave: Schema.optional(Schema.Boolean),
  auto_connect: Schema.optional(Schema.Number),
  captive_portal: Schema.optional(Schema.Number),
  disable_auto_fallback: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Struct({}))),
  exclude_office_ips: Schema.optional(Schema.Boolean),
  include: Schema.optional(Schema.Array(Schema.Struct({}))),
  lan_allow_minutes: Schema.optional(Schema.Number),
  lan_allow_subnet_size: Schema.optional(Schema.Number),
  register_interface_ip_with_dns: Schema.optional(Schema.Boolean),
  sccm_vpn_boundary_support: Schema.optional(Schema.Boolean),
  service_mode_v2: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  support_url: Schema.optional(Schema.String),
  switch_locked: Schema.optional(Schema.Boolean),
  tunnel_protocol: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/devices/policy" }),
).annotations({ identifier: "UpdateDefaultDeviceSettingsPolicyRequest" }) as unknown as Schema.Schema<UpdateDefaultDeviceSettingsPolicyRequest>;

export interface UpdateDefaultDeviceSettingsPolicyResponse {
  result: { allow_mode_switch?: boolean; allow_updates?: boolean; allowed_to_leave?: boolean; auto_connect?: number; captive_portal?: number; default?: boolean; disable_auto_fallback?: boolean; enabled?: boolean; exclude?: Record<string, unknown>[]; exclude_office_ips?: boolean; fallback_domains?: { description?: string; dns_server?: string[]; suffix: string }[]; gateway_unique_id?: string; include?: Record<string, unknown>[]; register_interface_ip_with_dns?: boolean; sccm_vpn_boundary_support?: boolean; service_mode_v2?: { mode?: string; port?: number }; support_url?: string; switch_locked?: boolean; tunnel_protocol?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateDefaultDeviceSettingsPolicyResponse = Schema.Struct({
  result: Schema.Struct({
  allow_mode_switch: Schema.optional(Schema.Boolean),
  allow_updates: Schema.optional(Schema.Boolean),
  allowed_to_leave: Schema.optional(Schema.Boolean),
  auto_connect: Schema.optional(Schema.Number),
  captive_portal: Schema.optional(Schema.Number),
  default: Schema.optional(Schema.Boolean),
  disable_auto_fallback: Schema.optional(Schema.Boolean),
  enabled: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Struct({}))),
  exclude_office_ips: Schema.optional(Schema.Boolean),
  fallback_domains: Schema.optional(Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.Array(Schema.String)),
  suffix: Schema.String
}))),
  gateway_unique_id: Schema.optional(Schema.String),
  include: Schema.optional(Schema.Array(Schema.Struct({}))),
  register_interface_ip_with_dns: Schema.optional(Schema.Boolean),
  sccm_vpn_boundary_support: Schema.optional(Schema.Boolean),
  service_mode_v2: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  support_url: Schema.optional(Schema.String),
  switch_locked: Schema.optional(Schema.Boolean),
  tunnel_protocol: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateDefaultDeviceSettingsPolicyResponse" }) as unknown as Schema.Schema<UpdateDefaultDeviceSettingsPolicyResponse>;

export const updateDefaultDeviceSettingsPolicy: (
  input: UpdateDefaultDeviceSettingsPolicyRequest
) => Effect.Effect<
  UpdateDefaultDeviceSettingsPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDefaultDeviceSettingsPolicyRequest,
  output: UpdateDefaultDeviceSettingsPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List8Request {
  account_id: unknown;
}

export const List8Request = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/policy/exclude" }),
).annotations({ identifier: "List8Request" }) as unknown as Schema.Schema<List8Request>;

export interface List8Response {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List8Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List8Response" }) as unknown as Schema.Schema<List8Response>;

export const list8: (
  input: List8Request
) => Effect.Effect<
  List8Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List8Request,
  output: List8Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List9Request {
  account_id: unknown;
  body: Record<string, unknown>[];
}

export const List9Request = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Struct({})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/devices/policy/exclude" }),
).annotations({ identifier: "List9Request" }) as unknown as Schema.Schema<List9Request>;

export interface List9Response {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List9Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List9Response" }) as unknown as Schema.Schema<List9Response>;

export const list9: (
  input: List9Request
) => Effect.Effect<
  List9Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List9Request,
  output: List9Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List10Request {
  account_id: unknown;
}

export const List10Request = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/policy/fallback_domains" }),
).annotations({ identifier: "List10Request" }) as unknown as Schema.Schema<List10Request>;

export interface List10Response {
  result: { description?: string; dns_server?: string[]; suffix: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List10Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.Array(Schema.String)),
  suffix: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List10Response" }) as unknown as Schema.Schema<List10Response>;

export const list10: (
  input: List10Request
) => Effect.Effect<
  List10Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List10Request,
  output: List10Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List11Request {
  account_id: unknown;
  body: { description?: string; dns_server?: string[]; suffix: string }[];
}

export const List11Request = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.Array(Schema.String)),
  suffix: Schema.String
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/devices/policy/fallback_domains" }),
).annotations({ identifier: "List11Request" }) as unknown as Schema.Schema<List11Request>;

export interface List11Response {
  result: { description?: string; dns_server?: string[]; suffix: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List11Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.Array(Schema.String)),
  suffix: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List11Response" }) as unknown as Schema.Schema<List11Response>;

export const list11: (
  input: List11Request
) => Effect.Effect<
  List11Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List11Request,
  output: List11Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List12Request {
  account_id: unknown;
}

export const List12Request = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/policy/include" }),
).annotations({ identifier: "List12Request" }) as unknown as Schema.Schema<List12Request>;

export interface List12Response {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List12Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List12Response" }) as unknown as Schema.Schema<List12Response>;

export const list12: (
  input: List12Request
) => Effect.Effect<
  List12Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List12Request,
  output: List12Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List13Request {
  account_id: unknown;
  body: Record<string, unknown>[];
}

export const List13Request = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Struct({})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/devices/policy/include" }),
).annotations({ identifier: "List13Request" }) as unknown as Schema.Schema<List13Request>;

export interface List13Response {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List13Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List13Response" }) as unknown as Schema.Schema<List13Response>;

export const list13: (
  input: List13Request
) => Effect.Effect<
  List13Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List13Request,
  output: List13Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDeviceSettingsPolicyByIdRequest {
  policy_id: string;
  account_id: unknown;
}

export const GetDeviceSettingsPolicyByIdRequest = Schema.Struct({
  policy_id: Schema.String.pipe(T.HttpPath("policy_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/policy/{policy_id}" }),
).annotations({ identifier: "GetDeviceSettingsPolicyByIdRequest" }) as unknown as Schema.Schema<GetDeviceSettingsPolicyByIdRequest>;

export interface GetDeviceSettingsPolicyByIdResponse {
  result: { allow_mode_switch?: boolean; allow_updates?: boolean; allowed_to_leave?: boolean; auto_connect?: number; captive_portal?: number; default?: boolean; description?: string; disable_auto_fallback?: boolean; enabled?: boolean; exclude?: Record<string, unknown>[]; exclude_office_ips?: boolean; fallback_domains?: { description?: string; dns_server?: string[]; suffix: string }[]; gateway_unique_id?: string; include?: Record<string, unknown>[]; lan_allow_minutes?: number; lan_allow_subnet_size?: number; match?: string; name?: string; policy_id?: string; precedence?: number; register_interface_ip_with_dns?: boolean; sccm_vpn_boundary_support?: boolean; service_mode_v2?: { mode?: string; port?: number }; support_url?: string; switch_locked?: boolean; target_tests?: { id?: string; name?: string }[]; tunnel_protocol?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDeviceSettingsPolicyByIdResponse = Schema.Struct({
  result: Schema.Struct({
  allow_mode_switch: Schema.optional(Schema.Boolean),
  allow_updates: Schema.optional(Schema.Boolean),
  allowed_to_leave: Schema.optional(Schema.Boolean),
  auto_connect: Schema.optional(Schema.Number),
  captive_portal: Schema.optional(Schema.Number),
  default: Schema.optional(Schema.Boolean),
  description: Schema.optional(Schema.String),
  disable_auto_fallback: Schema.optional(Schema.Boolean),
  enabled: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Struct({}))),
  exclude_office_ips: Schema.optional(Schema.Boolean),
  fallback_domains: Schema.optional(Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.Array(Schema.String)),
  suffix: Schema.String
}))),
  gateway_unique_id: Schema.optional(Schema.String),
  include: Schema.optional(Schema.Array(Schema.Struct({}))),
  lan_allow_minutes: Schema.optional(Schema.Number),
  lan_allow_subnet_size: Schema.optional(Schema.Number),
  match: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  policy_id: Schema.optional(Schema.String),
  precedence: Schema.optional(Schema.Number),
  register_interface_ip_with_dns: Schema.optional(Schema.Boolean),
  sccm_vpn_boundary_support: Schema.optional(Schema.Boolean),
  service_mode_v2: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  support_url: Schema.optional(Schema.String),
  switch_locked: Schema.optional(Schema.Boolean),
  target_tests: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))),
  tunnel_protocol: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDeviceSettingsPolicyByIdResponse" }) as unknown as Schema.Schema<GetDeviceSettingsPolicyByIdResponse>;

export const getDeviceSettingsPolicyById: (
  input: GetDeviceSettingsPolicyByIdRequest
) => Effect.Effect<
  GetDeviceSettingsPolicyByIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDeviceSettingsPolicyByIdRequest,
  output: GetDeviceSettingsPolicyByIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDeviceSettingsPolicyRequest {
  policy_id: string;
  account_id: unknown;
}

export const DeleteDeviceSettingsPolicyRequest = Schema.Struct({
  policy_id: Schema.String.pipe(T.HttpPath("policy_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/devices/policy/{policy_id}" }),
).annotations({ identifier: "DeleteDeviceSettingsPolicyRequest" }) as unknown as Schema.Schema<DeleteDeviceSettingsPolicyRequest>;

export interface DeleteDeviceSettingsPolicyResponse {
  result: { allow_mode_switch?: boolean; allow_updates?: boolean; allowed_to_leave?: boolean; auto_connect?: number; captive_portal?: number; default?: boolean; description?: string; disable_auto_fallback?: boolean; enabled?: boolean; exclude?: Record<string, unknown>[]; exclude_office_ips?: boolean; fallback_domains?: { description?: string; dns_server?: string[]; suffix: string }[]; gateway_unique_id?: string; include?: Record<string, unknown>[]; lan_allow_minutes?: number; lan_allow_subnet_size?: number; match?: string; name?: string; policy_id?: string; precedence?: number; register_interface_ip_with_dns?: boolean; sccm_vpn_boundary_support?: boolean; service_mode_v2?: { mode?: string; port?: number }; support_url?: string; switch_locked?: boolean; target_tests?: { id?: string; name?: string }[]; tunnel_protocol?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDeviceSettingsPolicyResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  allow_mode_switch: Schema.optional(Schema.Boolean),
  allow_updates: Schema.optional(Schema.Boolean),
  allowed_to_leave: Schema.optional(Schema.Boolean),
  auto_connect: Schema.optional(Schema.Number),
  captive_portal: Schema.optional(Schema.Number),
  default: Schema.optional(Schema.Boolean),
  description: Schema.optional(Schema.String),
  disable_auto_fallback: Schema.optional(Schema.Boolean),
  enabled: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Struct({}))),
  exclude_office_ips: Schema.optional(Schema.Boolean),
  fallback_domains: Schema.optional(Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.Array(Schema.String)),
  suffix: Schema.String
}))),
  gateway_unique_id: Schema.optional(Schema.String),
  include: Schema.optional(Schema.Array(Schema.Struct({}))),
  lan_allow_minutes: Schema.optional(Schema.Number),
  lan_allow_subnet_size: Schema.optional(Schema.Number),
  match: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  policy_id: Schema.optional(Schema.String),
  precedence: Schema.optional(Schema.Number),
  register_interface_ip_with_dns: Schema.optional(Schema.Boolean),
  sccm_vpn_boundary_support: Schema.optional(Schema.Boolean),
  service_mode_v2: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  support_url: Schema.optional(Schema.String),
  switch_locked: Schema.optional(Schema.Boolean),
  target_tests: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))),
  tunnel_protocol: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDeviceSettingsPolicyResponse" }) as unknown as Schema.Schema<DeleteDeviceSettingsPolicyResponse>;

export const deleteDeviceSettingsPolicy: (
  input: DeleteDeviceSettingsPolicyRequest
) => Effect.Effect<
  DeleteDeviceSettingsPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDeviceSettingsPolicyRequest,
  output: DeleteDeviceSettingsPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateDeviceSettingsPolicyRequest {
  policy_id: string;
  account_id: unknown;
  body: { allow_mode_switch?: boolean; allow_updates?: boolean; allowed_to_leave?: boolean; auto_connect?: number; captive_portal?: number; description?: string; disable_auto_fallback?: boolean; enabled?: boolean; exclude?: Record<string, unknown>[]; exclude_office_ips?: boolean; include?: Record<string, unknown>[]; lan_allow_minutes?: number; lan_allow_subnet_size?: number; match?: string; name?: string; precedence?: number; register_interface_ip_with_dns?: boolean; sccm_vpn_boundary_support?: boolean; service_mode_v2?: { mode?: string; port?: number }; support_url?: string; switch_locked?: boolean; tunnel_protocol?: string };
}

export const UpdateDeviceSettingsPolicyRequest = Schema.Struct({
  policy_id: Schema.String.pipe(T.HttpPath("policy_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  allow_mode_switch: Schema.optional(Schema.Boolean),
  allow_updates: Schema.optional(Schema.Boolean),
  allowed_to_leave: Schema.optional(Schema.Boolean),
  auto_connect: Schema.optional(Schema.Number),
  captive_portal: Schema.optional(Schema.Number),
  description: Schema.optional(Schema.String),
  disable_auto_fallback: Schema.optional(Schema.Boolean),
  enabled: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Struct({}))),
  exclude_office_ips: Schema.optional(Schema.Boolean),
  include: Schema.optional(Schema.Array(Schema.Struct({}))),
  lan_allow_minutes: Schema.optional(Schema.Number),
  lan_allow_subnet_size: Schema.optional(Schema.Number),
  match: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  precedence: Schema.optional(Schema.Number),
  register_interface_ip_with_dns: Schema.optional(Schema.Boolean),
  sccm_vpn_boundary_support: Schema.optional(Schema.Boolean),
  service_mode_v2: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  support_url: Schema.optional(Schema.String),
  switch_locked: Schema.optional(Schema.Boolean),
  tunnel_protocol: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/devices/policy/{policy_id}" }),
).annotations({ identifier: "UpdateDeviceSettingsPolicyRequest" }) as unknown as Schema.Schema<UpdateDeviceSettingsPolicyRequest>;

export interface UpdateDeviceSettingsPolicyResponse {
  result: { allow_mode_switch?: boolean; allow_updates?: boolean; allowed_to_leave?: boolean; auto_connect?: number; captive_portal?: number; default?: boolean; description?: string; disable_auto_fallback?: boolean; enabled?: boolean; exclude?: Record<string, unknown>[]; exclude_office_ips?: boolean; fallback_domains?: { description?: string; dns_server?: string[]; suffix: string }[]; gateway_unique_id?: string; include?: Record<string, unknown>[]; lan_allow_minutes?: number; lan_allow_subnet_size?: number; match?: string; name?: string; policy_id?: string; precedence?: number; register_interface_ip_with_dns?: boolean; sccm_vpn_boundary_support?: boolean; service_mode_v2?: { mode?: string; port?: number }; support_url?: string; switch_locked?: boolean; target_tests?: { id?: string; name?: string }[]; tunnel_protocol?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateDeviceSettingsPolicyResponse = Schema.Struct({
  result: Schema.Struct({
  allow_mode_switch: Schema.optional(Schema.Boolean),
  allow_updates: Schema.optional(Schema.Boolean),
  allowed_to_leave: Schema.optional(Schema.Boolean),
  auto_connect: Schema.optional(Schema.Number),
  captive_portal: Schema.optional(Schema.Number),
  default: Schema.optional(Schema.Boolean),
  description: Schema.optional(Schema.String),
  disable_auto_fallback: Schema.optional(Schema.Boolean),
  enabled: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Struct({}))),
  exclude_office_ips: Schema.optional(Schema.Boolean),
  fallback_domains: Schema.optional(Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.Array(Schema.String)),
  suffix: Schema.String
}))),
  gateway_unique_id: Schema.optional(Schema.String),
  include: Schema.optional(Schema.Array(Schema.Struct({}))),
  lan_allow_minutes: Schema.optional(Schema.Number),
  lan_allow_subnet_size: Schema.optional(Schema.Number),
  match: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  policy_id: Schema.optional(Schema.String),
  precedence: Schema.optional(Schema.Number),
  register_interface_ip_with_dns: Schema.optional(Schema.Boolean),
  sccm_vpn_boundary_support: Schema.optional(Schema.Boolean),
  service_mode_v2: Schema.optional(Schema.Struct({
  mode: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  support_url: Schema.optional(Schema.String),
  switch_locked: Schema.optional(Schema.Boolean),
  target_tests: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))),
  tunnel_protocol: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateDeviceSettingsPolicyResponse" }) as unknown as Schema.Schema<UpdateDeviceSettingsPolicyResponse>;

export const updateDeviceSettingsPolicy: (
  input: UpdateDeviceSettingsPolicyRequest
) => Effect.Effect<
  UpdateDeviceSettingsPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDeviceSettingsPolicyRequest,
  output: UpdateDeviceSettingsPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListForADeviceSettingsPolicyRequest {
  policy_id: string;
  account_id: unknown;
}

export const ListForADeviceSettingsPolicyRequest = Schema.Struct({
  policy_id: Schema.String.pipe(T.HttpPath("policy_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/policy/{policy_id}/exclude" }),
).annotations({ identifier: "ListForADeviceSettingsPolicyRequest" }) as unknown as Schema.Schema<ListForADeviceSettingsPolicyRequest>;

export interface ListForADeviceSettingsPolicyResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListForADeviceSettingsPolicyResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListForADeviceSettingsPolicyResponse" }) as unknown as Schema.Schema<ListForADeviceSettingsPolicyResponse>;

export const listForADeviceSettingsPolicy: (
  input: ListForADeviceSettingsPolicyRequest
) => Effect.Effect<
  ListForADeviceSettingsPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListForADeviceSettingsPolicyRequest,
  output: ListForADeviceSettingsPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListForADeviceSettingsPolicy1Request {
  policy_id: string;
  account_id: unknown;
  body: Record<string, unknown>[];
}

export const ListForADeviceSettingsPolicy1Request = Schema.Struct({
  policy_id: Schema.String.pipe(T.HttpPath("policy_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Struct({})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/devices/policy/{policy_id}/exclude" }),
).annotations({ identifier: "ListForADeviceSettingsPolicy1Request" }) as unknown as Schema.Schema<ListForADeviceSettingsPolicy1Request>;

export interface ListForADeviceSettingsPolicy1Response {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListForADeviceSettingsPolicy1Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListForADeviceSettingsPolicy1Response" }) as unknown as Schema.Schema<ListForADeviceSettingsPolicy1Response>;

export const listForADeviceSettingsPolicy1: (
  input: ListForADeviceSettingsPolicy1Request
) => Effect.Effect<
  ListForADeviceSettingsPolicy1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListForADeviceSettingsPolicy1Request,
  output: ListForADeviceSettingsPolicy1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListForADeviceSettingsPolicy2Request {
  policy_id: string;
  account_id: unknown;
}

export const ListForADeviceSettingsPolicy2Request = Schema.Struct({
  policy_id: Schema.String.pipe(T.HttpPath("policy_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/policy/{policy_id}/fallback_domains" }),
).annotations({ identifier: "ListForADeviceSettingsPolicy2Request" }) as unknown as Schema.Schema<ListForADeviceSettingsPolicy2Request>;

export interface ListForADeviceSettingsPolicy2Response {
  result: { description?: string; dns_server?: string[]; suffix: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListForADeviceSettingsPolicy2Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.Array(Schema.String)),
  suffix: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListForADeviceSettingsPolicy2Response" }) as unknown as Schema.Schema<ListForADeviceSettingsPolicy2Response>;

export const listForADeviceSettingsPolicy2: (
  input: ListForADeviceSettingsPolicy2Request
) => Effect.Effect<
  ListForADeviceSettingsPolicy2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListForADeviceSettingsPolicy2Request,
  output: ListForADeviceSettingsPolicy2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListForADeviceSettingsPolicy3Request {
  policy_id: string;
  account_id: unknown;
  body: { description?: string; dns_server?: string[]; suffix: string }[];
}

export const ListForADeviceSettingsPolicy3Request = Schema.Struct({
  policy_id: Schema.String.pipe(T.HttpPath("policy_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.Array(Schema.String)),
  suffix: Schema.String
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/devices/policy/{policy_id}/fallback_domains" }),
).annotations({ identifier: "ListForADeviceSettingsPolicy3Request" }) as unknown as Schema.Schema<ListForADeviceSettingsPolicy3Request>;

export interface ListForADeviceSettingsPolicy3Response {
  result: { description?: string; dns_server?: string[]; suffix: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListForADeviceSettingsPolicy3Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.Array(Schema.String)),
  suffix: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListForADeviceSettingsPolicy3Response" }) as unknown as Schema.Schema<ListForADeviceSettingsPolicy3Response>;

export const listForADeviceSettingsPolicy3: (
  input: ListForADeviceSettingsPolicy3Request
) => Effect.Effect<
  ListForADeviceSettingsPolicy3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListForADeviceSettingsPolicy3Request,
  output: ListForADeviceSettingsPolicy3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListForADeviceSettingsPolicy4Request {
  policy_id: string;
  account_id: unknown;
}

export const ListForADeviceSettingsPolicy4Request = Schema.Struct({
  policy_id: Schema.String.pipe(T.HttpPath("policy_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/policy/{policy_id}/include" }),
).annotations({ identifier: "ListForADeviceSettingsPolicy4Request" }) as unknown as Schema.Schema<ListForADeviceSettingsPolicy4Request>;

export interface ListForADeviceSettingsPolicy4Response {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListForADeviceSettingsPolicy4Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListForADeviceSettingsPolicy4Response" }) as unknown as Schema.Schema<ListForADeviceSettingsPolicy4Response>;

export const listForADeviceSettingsPolicy4: (
  input: ListForADeviceSettingsPolicy4Request
) => Effect.Effect<
  ListForADeviceSettingsPolicy4Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListForADeviceSettingsPolicy4Request,
  output: ListForADeviceSettingsPolicy4Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListForADeviceSettingsPolicy5Request {
  policy_id: string;
  account_id: unknown;
  body: Record<string, unknown>[];
}

export const ListForADeviceSettingsPolicy5Request = Schema.Struct({
  policy_id: Schema.String.pipe(T.HttpPath("policy_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Struct({})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/devices/policy/{policy_id}/include" }),
).annotations({ identifier: "ListForADeviceSettingsPolicy5Request" }) as unknown as Schema.Schema<ListForADeviceSettingsPolicy5Request>;

export interface ListForADeviceSettingsPolicy5Response {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListForADeviceSettingsPolicy5Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListForADeviceSettingsPolicy5Response" }) as unknown as Schema.Schema<ListForADeviceSettingsPolicy5Response>;

export const listForADeviceSettingsPolicy5: (
  input: ListForADeviceSettingsPolicy5Request
) => Effect.Effect<
  ListForADeviceSettingsPolicy5Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListForADeviceSettingsPolicy5Request,
  output: ListForADeviceSettingsPolicy5Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDevicePostureRulesRequest {
  account_id: unknown;
}

export const ListDevicePostureRulesRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/posture" }),
).annotations({ identifier: "ListDevicePostureRulesRequest" }) as unknown as Schema.Schema<ListDevicePostureRulesRequest>;

export interface ListDevicePostureRulesResponse {
  result: { description?: string; expiration?: string; id?: string; input?: Record<string, unknown>; match?: { platform?: "windows" | "mac" | "linux" | "android" | "ios" | "chromeos" }[]; name?: string; schedule?: string; type?: "file" | "application" | "tanium" | "gateway" | "warp" | "disk_encryption" | "serial_number" | "sentinelone" | "carbonblack" | "firewall" | "os_version" | "domain_joined" | "client_certificate" | "client_certificate_v2" | "antivirus" | "unique_client_id" | "kolide" | "tanium_s2s" | "crowdstrike_s2s" | "intune" | "workspace_one" | "sentinelone_s2s" | "custom_s2s" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDevicePostureRulesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  expiration: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  input: Schema.optional(Schema.Struct({})),
  match: Schema.optional(Schema.Array(Schema.Struct({
  platform: Schema.optional(Schema.Literal("windows", "mac", "linux", "android", "ios", "chromeos"))
}))),
  name: Schema.optional(Schema.String),
  schedule: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("file", "application", "tanium", "gateway", "warp", "disk_encryption", "serial_number", "sentinelone", "carbonblack", "firewall", "os_version", "domain_joined", "client_certificate", "client_certificate_v2", "antivirus", "unique_client_id", "kolide", "tanium_s2s", "crowdstrike_s2s", "intune", "workspace_one", "sentinelone_s2s", "custom_s2s"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDevicePostureRulesResponse" }) as unknown as Schema.Schema<ListDevicePostureRulesResponse>;

export const listDevicePostureRules: (
  input: ListDevicePostureRulesRequest
) => Effect.Effect<
  ListDevicePostureRulesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDevicePostureRulesRequest,
  output: ListDevicePostureRulesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateDevicePostureRuleRequest {
  account_id: unknown;
  body: { description?: string; expiration?: string; input?: Record<string, unknown>; match?: { platform?: "windows" | "mac" | "linux" | "android" | "ios" | "chromeos" }[]; name: string; schedule?: string; type: "file" | "application" | "tanium" | "gateway" | "warp" | "disk_encryption" | "serial_number" | "sentinelone" | "carbonblack" | "firewall" | "os_version" | "domain_joined" | "client_certificate" | "client_certificate_v2" | "antivirus" | "unique_client_id" | "kolide" | "tanium_s2s" | "crowdstrike_s2s" | "intune" | "workspace_one" | "sentinelone_s2s" | "custom_s2s" };
}

export const CreateDevicePostureRuleRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  expiration: Schema.optional(Schema.String),
  input: Schema.optional(Schema.Struct({})),
  match: Schema.optional(Schema.Array(Schema.Struct({
  platform: Schema.optional(Schema.Literal("windows", "mac", "linux", "android", "ios", "chromeos"))
}))),
  name: Schema.String,
  schedule: Schema.optional(Schema.String),
  type: Schema.Literal("file", "application", "tanium", "gateway", "warp", "disk_encryption", "serial_number", "sentinelone", "carbonblack", "firewall", "os_version", "domain_joined", "client_certificate", "client_certificate_v2", "antivirus", "unique_client_id", "kolide", "tanium_s2s", "crowdstrike_s2s", "intune", "workspace_one", "sentinelone_s2s", "custom_s2s")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/devices/posture" }),
).annotations({ identifier: "CreateDevicePostureRuleRequest" }) as unknown as Schema.Schema<CreateDevicePostureRuleRequest>;

export interface CreateDevicePostureRuleResponse {
  result: { description?: string; expiration?: string; id?: string; input?: Record<string, unknown>; match?: { platform?: "windows" | "mac" | "linux" | "android" | "ios" | "chromeos" }[]; name?: string; schedule?: string; type?: "file" | "application" | "tanium" | "gateway" | "warp" | "disk_encryption" | "serial_number" | "sentinelone" | "carbonblack" | "firewall" | "os_version" | "domain_joined" | "client_certificate" | "client_certificate_v2" | "antivirus" | "unique_client_id" | "kolide" | "tanium_s2s" | "crowdstrike_s2s" | "intune" | "workspace_one" | "sentinelone_s2s" | "custom_s2s" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateDevicePostureRuleResponse = Schema.Struct({
  result: Schema.Struct({
  description: Schema.optional(Schema.String),
  expiration: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  input: Schema.optional(Schema.Struct({})),
  match: Schema.optional(Schema.Array(Schema.Struct({
  platform: Schema.optional(Schema.Literal("windows", "mac", "linux", "android", "ios", "chromeos"))
}))),
  name: Schema.optional(Schema.String),
  schedule: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("file", "application", "tanium", "gateway", "warp", "disk_encryption", "serial_number", "sentinelone", "carbonblack", "firewall", "os_version", "domain_joined", "client_certificate", "client_certificate_v2", "antivirus", "unique_client_id", "kolide", "tanium_s2s", "crowdstrike_s2s", "intune", "workspace_one", "sentinelone_s2s", "custom_s2s"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateDevicePostureRuleResponse" }) as unknown as Schema.Schema<CreateDevicePostureRuleResponse>;

export const createDevicePostureRule: (
  input: CreateDevicePostureRuleRequest
) => Effect.Effect<
  CreateDevicePostureRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDevicePostureRuleRequest,
  output: CreateDevicePostureRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDevicePostureIntegrationsRequest {
  account_id: unknown;
}

export const ListDevicePostureIntegrationsRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/posture/integration" }),
).annotations({ identifier: "ListDevicePostureIntegrationsRequest" }) as unknown as Schema.Schema<ListDevicePostureIntegrationsRequest>;

export interface ListDevicePostureIntegrationsResponse {
  result: { config?: Record<string, unknown>; id?: string; interval?: string; name?: string; type?: "workspace_one" | "crowdstrike_s2s" | "uptycs" | "intune" | "kolide" | "tanium_s2s" | "sentinelone_s2s" | "custom_s2s" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDevicePostureIntegrationsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  config: Schema.optional(Schema.Struct({})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("workspace_one", "crowdstrike_s2s", "uptycs", "intune", "kolide", "tanium_s2s", "sentinelone_s2s", "custom_s2s"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDevicePostureIntegrationsResponse" }) as unknown as Schema.Schema<ListDevicePostureIntegrationsResponse>;

export const listDevicePostureIntegrations: (
  input: ListDevicePostureIntegrationsRequest
) => Effect.Effect<
  ListDevicePostureIntegrationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDevicePostureIntegrationsRequest,
  output: ListDevicePostureIntegrationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateDevicePostureIntegrationRequest {
  account_id: unknown;
  body: { config: Record<string, unknown>; interval: string; name: string; type: "workspace_one" | "crowdstrike_s2s" | "uptycs" | "intune" | "kolide" | "tanium_s2s" | "sentinelone_s2s" | "custom_s2s" };
}

export const CreateDevicePostureIntegrationRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  config: Schema.Struct({}),
  interval: Schema.String,
  name: Schema.String,
  type: Schema.Literal("workspace_one", "crowdstrike_s2s", "uptycs", "intune", "kolide", "tanium_s2s", "sentinelone_s2s", "custom_s2s")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/devices/posture/integration" }),
).annotations({ identifier: "CreateDevicePostureIntegrationRequest" }) as unknown as Schema.Schema<CreateDevicePostureIntegrationRequest>;

export interface CreateDevicePostureIntegrationResponse {
  result: { config?: Record<string, unknown>; id?: string; interval?: string; name?: string; type?: "workspace_one" | "crowdstrike_s2s" | "uptycs" | "intune" | "kolide" | "tanium_s2s" | "sentinelone_s2s" | "custom_s2s" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateDevicePostureIntegrationResponse = Schema.Struct({
  result: Schema.Struct({
  config: Schema.optional(Schema.Struct({})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("workspace_one", "crowdstrike_s2s", "uptycs", "intune", "kolide", "tanium_s2s", "sentinelone_s2s", "custom_s2s"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateDevicePostureIntegrationResponse" }) as unknown as Schema.Schema<CreateDevicePostureIntegrationResponse>;

export const createDevicePostureIntegration: (
  input: CreateDevicePostureIntegrationRequest
) => Effect.Effect<
  CreateDevicePostureIntegrationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDevicePostureIntegrationRequest,
  output: CreateDevicePostureIntegrationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DevicePostureIntegrationsDevicePostureIntegrationDetailsRequest {
  integration_id: string;
  account_id: unknown;
}

export const DevicePostureIntegrationsDevicePostureIntegrationDetailsRequest = Schema.Struct({
  integration_id: Schema.String.pipe(T.HttpPath("integration_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/posture/integration/{integration_id}" }),
).annotations({ identifier: "DevicePostureIntegrationsDevicePostureIntegrationDetailsRequest" }) as unknown as Schema.Schema<DevicePostureIntegrationsDevicePostureIntegrationDetailsRequest>;

export interface DevicePostureIntegrationsDevicePostureIntegrationDetailsResponse {
  result: { config?: Record<string, unknown>; id?: string; interval?: string; name?: string; type?: "workspace_one" | "crowdstrike_s2s" | "uptycs" | "intune" | "kolide" | "tanium_s2s" | "sentinelone_s2s" | "custom_s2s" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DevicePostureIntegrationsDevicePostureIntegrationDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  config: Schema.optional(Schema.Struct({})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("workspace_one", "crowdstrike_s2s", "uptycs", "intune", "kolide", "tanium_s2s", "sentinelone_s2s", "custom_s2s"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DevicePostureIntegrationsDevicePostureIntegrationDetailsResponse" }) as unknown as Schema.Schema<DevicePostureIntegrationsDevicePostureIntegrationDetailsResponse>;

export const devicePostureIntegrationsDevicePostureIntegrationDetails: (
  input: DevicePostureIntegrationsDevicePostureIntegrationDetailsRequest
) => Effect.Effect<
  DevicePostureIntegrationsDevicePostureIntegrationDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DevicePostureIntegrationsDevicePostureIntegrationDetailsRequest,
  output: DevicePostureIntegrationsDevicePostureIntegrationDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDevicePostureIntegrationRequest {
  integration_id: string;
  account_id: unknown;
}

export const DeleteDevicePostureIntegrationRequest = Schema.Struct({
  integration_id: Schema.String.pipe(T.HttpPath("integration_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/devices/posture/integration/{integration_id}" }),
).annotations({ identifier: "DeleteDevicePostureIntegrationRequest" }) as unknown as Schema.Schema<DeleteDevicePostureIntegrationRequest>;

export interface DeleteDevicePostureIntegrationResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDevicePostureIntegrationResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDevicePostureIntegrationResponse" }) as unknown as Schema.Schema<DeleteDevicePostureIntegrationResponse>;

export const deleteDevicePostureIntegration: (
  input: DeleteDevicePostureIntegrationRequest
) => Effect.Effect<
  DeleteDevicePostureIntegrationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDevicePostureIntegrationRequest,
  output: DeleteDevicePostureIntegrationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateDevicePostureIntegrationRequest {
  integration_id: string;
  account_id: unknown;
  body: { config?: Record<string, unknown>; interval?: string; name?: string; type?: "workspace_one" | "crowdstrike_s2s" | "uptycs" | "intune" | "kolide" | "tanium_s2s" | "sentinelone_s2s" | "custom_s2s" };
}

export const UpdateDevicePostureIntegrationRequest = Schema.Struct({
  integration_id: Schema.String.pipe(T.HttpPath("integration_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  config: Schema.optional(Schema.Struct({})),
  interval: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("workspace_one", "crowdstrike_s2s", "uptycs", "intune", "kolide", "tanium_s2s", "sentinelone_s2s", "custom_s2s"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/devices/posture/integration/{integration_id}" }),
).annotations({ identifier: "UpdateDevicePostureIntegrationRequest" }) as unknown as Schema.Schema<UpdateDevicePostureIntegrationRequest>;

export interface UpdateDevicePostureIntegrationResponse {
  result: { config?: Record<string, unknown>; id?: string; interval?: string; name?: string; type?: "workspace_one" | "crowdstrike_s2s" | "uptycs" | "intune" | "kolide" | "tanium_s2s" | "sentinelone_s2s" | "custom_s2s" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateDevicePostureIntegrationResponse = Schema.Struct({
  result: Schema.Struct({
  config: Schema.optional(Schema.Struct({})),
  id: Schema.optional(Schema.String),
  interval: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("workspace_one", "crowdstrike_s2s", "uptycs", "intune", "kolide", "tanium_s2s", "sentinelone_s2s", "custom_s2s"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateDevicePostureIntegrationResponse" }) as unknown as Schema.Schema<UpdateDevicePostureIntegrationResponse>;

export const updateDevicePostureIntegration: (
  input: UpdateDevicePostureIntegrationRequest
) => Effect.Effect<
  UpdateDevicePostureIntegrationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDevicePostureIntegrationRequest,
  output: UpdateDevicePostureIntegrationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DevicePostureRulesDevicePostureRulesDetailsRequest {
  rule_id: string;
  account_id: unknown;
}

export const DevicePostureRulesDevicePostureRulesDetailsRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/posture/{rule_id}" }),
).annotations({ identifier: "DevicePostureRulesDevicePostureRulesDetailsRequest" }) as unknown as Schema.Schema<DevicePostureRulesDevicePostureRulesDetailsRequest>;

export interface DevicePostureRulesDevicePostureRulesDetailsResponse {
  result: { description?: string; expiration?: string; id?: string; input?: Record<string, unknown>; match?: { platform?: "windows" | "mac" | "linux" | "android" | "ios" | "chromeos" }[]; name?: string; schedule?: string; type?: "file" | "application" | "tanium" | "gateway" | "warp" | "disk_encryption" | "serial_number" | "sentinelone" | "carbonblack" | "firewall" | "os_version" | "domain_joined" | "client_certificate" | "client_certificate_v2" | "antivirus" | "unique_client_id" | "kolide" | "tanium_s2s" | "crowdstrike_s2s" | "intune" | "workspace_one" | "sentinelone_s2s" | "custom_s2s" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DevicePostureRulesDevicePostureRulesDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  description: Schema.optional(Schema.String),
  expiration: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  input: Schema.optional(Schema.Struct({})),
  match: Schema.optional(Schema.Array(Schema.Struct({
  platform: Schema.optional(Schema.Literal("windows", "mac", "linux", "android", "ios", "chromeos"))
}))),
  name: Schema.optional(Schema.String),
  schedule: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("file", "application", "tanium", "gateway", "warp", "disk_encryption", "serial_number", "sentinelone", "carbonblack", "firewall", "os_version", "domain_joined", "client_certificate", "client_certificate_v2", "antivirus", "unique_client_id", "kolide", "tanium_s2s", "crowdstrike_s2s", "intune", "workspace_one", "sentinelone_s2s", "custom_s2s"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DevicePostureRulesDevicePostureRulesDetailsResponse" }) as unknown as Schema.Schema<DevicePostureRulesDevicePostureRulesDetailsResponse>;

export const devicePostureRulesDevicePostureRulesDetails: (
  input: DevicePostureRulesDevicePostureRulesDetailsRequest
) => Effect.Effect<
  DevicePostureRulesDevicePostureRulesDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DevicePostureRulesDevicePostureRulesDetailsRequest,
  output: DevicePostureRulesDevicePostureRulesDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateDevicePostureRuleRequest {
  rule_id: string;
  account_id: unknown;
  body: { description?: string; expiration?: string; input?: Record<string, unknown>; match?: { platform?: "windows" | "mac" | "linux" | "android" | "ios" | "chromeos" }[]; name: string; schedule?: string; type: "file" | "application" | "tanium" | "gateway" | "warp" | "disk_encryption" | "serial_number" | "sentinelone" | "carbonblack" | "firewall" | "os_version" | "domain_joined" | "client_certificate" | "client_certificate_v2" | "antivirus" | "unique_client_id" | "kolide" | "tanium_s2s" | "crowdstrike_s2s" | "intune" | "workspace_one" | "sentinelone_s2s" | "custom_s2s" };
}

export const UpdateDevicePostureRuleRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  expiration: Schema.optional(Schema.String),
  input: Schema.optional(Schema.Struct({})),
  match: Schema.optional(Schema.Array(Schema.Struct({
  platform: Schema.optional(Schema.Literal("windows", "mac", "linux", "android", "ios", "chromeos"))
}))),
  name: Schema.String,
  schedule: Schema.optional(Schema.String),
  type: Schema.Literal("file", "application", "tanium", "gateway", "warp", "disk_encryption", "serial_number", "sentinelone", "carbonblack", "firewall", "os_version", "domain_joined", "client_certificate", "client_certificate_v2", "antivirus", "unique_client_id", "kolide", "tanium_s2s", "crowdstrike_s2s", "intune", "workspace_one", "sentinelone_s2s", "custom_s2s")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/devices/posture/{rule_id}" }),
).annotations({ identifier: "UpdateDevicePostureRuleRequest" }) as unknown as Schema.Schema<UpdateDevicePostureRuleRequest>;

export interface UpdateDevicePostureRuleResponse {
  result: { description?: string; expiration?: string; id?: string; input?: Record<string, unknown>; match?: { platform?: "windows" | "mac" | "linux" | "android" | "ios" | "chromeos" }[]; name?: string; schedule?: string; type?: "file" | "application" | "tanium" | "gateway" | "warp" | "disk_encryption" | "serial_number" | "sentinelone" | "carbonblack" | "firewall" | "os_version" | "domain_joined" | "client_certificate" | "client_certificate_v2" | "antivirus" | "unique_client_id" | "kolide" | "tanium_s2s" | "crowdstrike_s2s" | "intune" | "workspace_one" | "sentinelone_s2s" | "custom_s2s" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateDevicePostureRuleResponse = Schema.Struct({
  result: Schema.Struct({
  description: Schema.optional(Schema.String),
  expiration: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  input: Schema.optional(Schema.Struct({})),
  match: Schema.optional(Schema.Array(Schema.Struct({
  platform: Schema.optional(Schema.Literal("windows", "mac", "linux", "android", "ios", "chromeos"))
}))),
  name: Schema.optional(Schema.String),
  schedule: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("file", "application", "tanium", "gateway", "warp", "disk_encryption", "serial_number", "sentinelone", "carbonblack", "firewall", "os_version", "domain_joined", "client_certificate", "client_certificate_v2", "antivirus", "unique_client_id", "kolide", "tanium_s2s", "crowdstrike_s2s", "intune", "workspace_one", "sentinelone_s2s", "custom_s2s"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateDevicePostureRuleResponse" }) as unknown as Schema.Schema<UpdateDevicePostureRuleResponse>;

export const updateDevicePostureRule: (
  input: UpdateDevicePostureRuleRequest
) => Effect.Effect<
  UpdateDevicePostureRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDevicePostureRuleRequest,
  output: UpdateDevicePostureRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDevicePostureRuleRequest {
  rule_id: string;
  account_id: unknown;
}

export const DeleteDevicePostureRuleRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/devices/posture/{rule_id}" }),
).annotations({ identifier: "DeleteDevicePostureRuleRequest" }) as unknown as Schema.Schema<DeleteDevicePostureRuleRequest>;

export interface DeleteDevicePostureRuleResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDevicePostureRuleResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDevicePostureRuleResponse" }) as unknown as Schema.Schema<DeleteDevicePostureRuleResponse>;

export const deleteDevicePostureRule: (
  input: DeleteDevicePostureRuleRequest
) => Effect.Effect<
  DeleteDevicePostureRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDevicePostureRuleRequest,
  output: DeleteDevicePostureRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListRegistrationsRequest {
  account_id: string;
}

export const ListRegistrationsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/registrations" }),
).annotations({ identifier: "ListRegistrationsRequest" }) as unknown as Schema.Schema<ListRegistrationsRequest>;

export interface ListRegistrationsResponse {
  result: { created_at: string; deleted_at?: string; device: { client_version?: string; id: string; name: string }; id: string; key: string; key_type?: string; last_seen_at: string; policy?: { default: boolean; deleted: boolean; id: string; name: string; updated_at: string }; revoked_at?: string; tunnel_type?: string; updated_at: string; user?: { email?: string; id?: string; name?: string } }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListRegistrationsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.String,
  deleted_at: Schema.optional(Schema.String),
  device: Schema.Struct({
  client_version: Schema.optional(Schema.String),
  id: Schema.String,
  name: Schema.String
}),
  id: Schema.String,
  key: Schema.String,
  key_type: Schema.optional(Schema.String),
  last_seen_at: Schema.String,
  policy: Schema.optional(Schema.Struct({
  default: Schema.Boolean,
  deleted: Schema.Boolean,
  id: Schema.String,
  name: Schema.String,
  updated_at: Schema.String
})),
  revoked_at: Schema.optional(Schema.String),
  tunnel_type: Schema.optional(Schema.String),
  updated_at: Schema.String,
  user: Schema.optional(Schema.Struct({
  email: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListRegistrationsResponse" }) as unknown as Schema.Schema<ListRegistrationsResponse>;

export const listRegistrations: (
  input: ListRegistrationsRequest
) => Effect.Effect<
  ListRegistrationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListRegistrationsRequest,
  output: ListRegistrationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteRegistrationsRequest {
  account_id: string;
  id: string[];
}

export const DeleteRegistrationsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.Array(Schema.String).pipe(T.HttpQuery("id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/devices/registrations" }),
).annotations({ identifier: "DeleteRegistrationsRequest" }) as unknown as Schema.Schema<DeleteRegistrationsRequest>;

export interface DeleteRegistrationsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteRegistrationsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteRegistrationsResponse" }) as unknown as Schema.Schema<DeleteRegistrationsResponse>;

export const deleteRegistrations: (
  input: DeleteRegistrationsRequest
) => Effect.Effect<
  DeleteRegistrationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteRegistrationsRequest,
  output: DeleteRegistrationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface RevokeRegistrationsRequest {
  account_id: string;
  id: string[];
}

export const RevokeRegistrationsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.Array(Schema.String).pipe(T.HttpQuery("id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/devices/registrations/revoke" }),
).annotations({ identifier: "RevokeRegistrationsRequest" }) as unknown as Schema.Schema<RevokeRegistrationsRequest>;

export interface RevokeRegistrationsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const RevokeRegistrationsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "RevokeRegistrationsResponse" }) as unknown as Schema.Schema<RevokeRegistrationsResponse>;

export const revokeRegistrations: (
  input: RevokeRegistrationsRequest
) => Effect.Effect<
  RevokeRegistrationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: RevokeRegistrationsRequest,
  output: RevokeRegistrationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UnrevokeRegistrationsRequest {
  account_id: string;
  id: string[];
}

export const UnrevokeRegistrationsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.Array(Schema.String).pipe(T.HttpQuery("id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/devices/registrations/unrevoke" }),
).annotations({ identifier: "UnrevokeRegistrationsRequest" }) as unknown as Schema.Schema<UnrevokeRegistrationsRequest>;

export interface UnrevokeRegistrationsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UnrevokeRegistrationsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UnrevokeRegistrationsResponse" }) as unknown as Schema.Schema<UnrevokeRegistrationsResponse>;

export const unrevokeRegistrations: (
  input: UnrevokeRegistrationsRequest
) => Effect.Effect<
  UnrevokeRegistrationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UnrevokeRegistrationsRequest,
  output: UnrevokeRegistrationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetRegistrationRequest {
  registration_id: string;
  account_id: string;
}

export const GetRegistrationRequest = Schema.Struct({
  registration_id: Schema.String.pipe(T.HttpPath("registration_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/registrations/{registration_id}" }),
).annotations({ identifier: "GetRegistrationRequest" }) as unknown as Schema.Schema<GetRegistrationRequest>;

export interface GetRegistrationResponse {
  result: { created_at: string; deleted_at?: string; device: { client_version?: string; id: string; name: string }; id: string; key: string; key_type?: string; last_seen_at: string; policy?: { default: boolean; deleted: boolean; id: string; name: string; updated_at: string }; revoked_at?: string; tunnel_type?: string; updated_at: string; user?: { email?: string; id?: string; name?: string } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetRegistrationResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.String,
  deleted_at: Schema.optional(Schema.String),
  device: Schema.Struct({
  client_version: Schema.optional(Schema.String),
  id: Schema.String,
  name: Schema.String
}),
  id: Schema.String,
  key: Schema.String,
  key_type: Schema.optional(Schema.String),
  last_seen_at: Schema.String,
  policy: Schema.optional(Schema.Struct({
  default: Schema.Boolean,
  deleted: Schema.Boolean,
  id: Schema.String,
  name: Schema.String,
  updated_at: Schema.String
})),
  revoked_at: Schema.optional(Schema.String),
  tunnel_type: Schema.optional(Schema.String),
  updated_at: Schema.String,
  user: Schema.optional(Schema.Struct({
  email: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetRegistrationResponse" }) as unknown as Schema.Schema<GetRegistrationResponse>;

export const getRegistration: (
  input: GetRegistrationRequest
) => Effect.Effect<
  GetRegistrationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRegistrationRequest,
  output: GetRegistrationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteRegistrationRequest {
  registration_id: string;
  account_id: string;
}

export const DeleteRegistrationRequest = Schema.Struct({
  registration_id: Schema.String.pipe(T.HttpPath("registration_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/devices/registrations/{registration_id}" }),
).annotations({ identifier: "DeleteRegistrationRequest" }) as unknown as Schema.Schema<DeleteRegistrationRequest>;

export interface DeleteRegistrationResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteRegistrationResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteRegistrationResponse" }) as unknown as Schema.Schema<DeleteRegistrationResponse>;

export const deleteRegistration: (
  input: DeleteRegistrationRequest
) => Effect.Effect<
  DeleteRegistrationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteRegistrationRequest,
  output: DeleteRegistrationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetRegistrationOverrideCodesRequest {
  account_id: string;
  registration_id: string;
}

export const GetRegistrationOverrideCodesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  registration_id: Schema.String.pipe(T.HttpPath("registration_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/registrations/{registration_id}/override_codes" }),
).annotations({ identifier: "GetRegistrationOverrideCodesRequest" }) as unknown as Schema.Schema<GetRegistrationOverrideCodesRequest>;

export interface GetRegistrationOverrideCodesResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetRegistrationOverrideCodesResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetRegistrationOverrideCodesResponse" }) as unknown as Schema.Schema<GetRegistrationOverrideCodesResponse>;

export const getRegistrationOverrideCodes: (
  input: GetRegistrationOverrideCodesRequest
) => Effect.Effect<
  GetRegistrationOverrideCodesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRegistrationOverrideCodesRequest,
  output: GetRegistrationOverrideCodesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DevicesResilienceRetrieveGlobalWarpOverrideRequest {
  account_id: unknown;
}

export const DevicesResilienceRetrieveGlobalWarpOverrideRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/resilience/disconnect" }),
).annotations({ identifier: "DevicesResilienceRetrieveGlobalWarpOverrideRequest" }) as unknown as Schema.Schema<DevicesResilienceRetrieveGlobalWarpOverrideRequest>;

export interface DevicesResilienceRetrieveGlobalWarpOverrideResponse {
  result: { disconnect?: boolean; timestamp?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DevicesResilienceRetrieveGlobalWarpOverrideResponse = Schema.Struct({
  result: Schema.Struct({
  disconnect: Schema.optional(Schema.Boolean),
  timestamp: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DevicesResilienceRetrieveGlobalWarpOverrideResponse" }) as unknown as Schema.Schema<DevicesResilienceRetrieveGlobalWarpOverrideResponse>;

export const devicesResilienceRetrieveGlobalWarpOverride: (
  input: DevicesResilienceRetrieveGlobalWarpOverrideRequest
) => Effect.Effect<
  DevicesResilienceRetrieveGlobalWarpOverrideResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DevicesResilienceRetrieveGlobalWarpOverrideRequest,
  output: DevicesResilienceRetrieveGlobalWarpOverrideResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DevicesResilienceSetGlobalWarpOverrideRequest {
  account_id: unknown;
  body: { disconnect: boolean; justification?: string };
}

export const DevicesResilienceSetGlobalWarpOverrideRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  disconnect: Schema.Boolean,
  justification: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/devices/resilience/disconnect" }),
).annotations({ identifier: "DevicesResilienceSetGlobalWarpOverrideRequest" }) as unknown as Schema.Schema<DevicesResilienceSetGlobalWarpOverrideRequest>;

export interface DevicesResilienceSetGlobalWarpOverrideResponse {
  result: { disconnect?: boolean; timestamp?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DevicesResilienceSetGlobalWarpOverrideResponse = Schema.Struct({
  result: Schema.Struct({
  disconnect: Schema.optional(Schema.Boolean),
  timestamp: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DevicesResilienceSetGlobalWarpOverrideResponse" }) as unknown as Schema.Schema<DevicesResilienceSetGlobalWarpOverrideResponse>;

export const devicesResilienceSetGlobalWarpOverride: (
  input: DevicesResilienceSetGlobalWarpOverrideRequest
) => Effect.Effect<
  DevicesResilienceSetGlobalWarpOverrideResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DevicesResilienceSetGlobalWarpOverrideRequest,
  output: DevicesResilienceSetGlobalWarpOverrideResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DevicesRevokeDevicesRequest {
  account_id: unknown;
  body: string[];
}

export const DevicesRevokeDevicesRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.String).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/devices/revoke" }),
).annotations({ identifier: "DevicesRevokeDevicesRequest" }) as unknown as Schema.Schema<DevicesRevokeDevicesRequest>;

export interface DevicesRevokeDevicesResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DevicesRevokeDevicesResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DevicesRevokeDevicesResponse" }) as unknown as Schema.Schema<DevicesRevokeDevicesResponse>;

export const devicesRevokeDevices: (
  input: DevicesRevokeDevicesRequest
) => Effect.Effect<
  DevicesRevokeDevicesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DevicesRevokeDevicesRequest,
  output: DevicesRevokeDevicesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDeviceSettingsForZeroTrustAccountRequest {
  account_id: unknown;
}

export const GetDeviceSettingsForZeroTrustAccountRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/settings" }),
).annotations({ identifier: "GetDeviceSettingsForZeroTrustAccountRequest" }) as unknown as Schema.Schema<GetDeviceSettingsForZeroTrustAccountRequest>;

export interface GetDeviceSettingsForZeroTrustAccountResponse {
  result: { disable_for_time?: number; external_emergency_signal_enabled?: boolean; external_emergency_signal_fingerprint?: string; external_emergency_signal_interval?: string; external_emergency_signal_url?: string; gateway_proxy_enabled?: boolean; gateway_udp_proxy_enabled?: boolean; root_certificate_installation_enabled?: boolean; use_zt_virtual_ip?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDeviceSettingsForZeroTrustAccountResponse = Schema.Struct({
  result: Schema.Struct({
  disable_for_time: Schema.optional(Schema.Number),
  external_emergency_signal_enabled: Schema.optional(Schema.Boolean),
  external_emergency_signal_fingerprint: Schema.optional(Schema.String),
  external_emergency_signal_interval: Schema.optional(Schema.String),
  external_emergency_signal_url: Schema.optional(Schema.String),
  gateway_proxy_enabled: Schema.optional(Schema.Boolean),
  gateway_udp_proxy_enabled: Schema.optional(Schema.Boolean),
  root_certificate_installation_enabled: Schema.optional(Schema.Boolean),
  use_zt_virtual_ip: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDeviceSettingsForZeroTrustAccountResponse" }) as unknown as Schema.Schema<GetDeviceSettingsForZeroTrustAccountResponse>;

export const getDeviceSettingsForZeroTrustAccount: (
  input: GetDeviceSettingsForZeroTrustAccountRequest
) => Effect.Effect<
  GetDeviceSettingsForZeroTrustAccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDeviceSettingsForZeroTrustAccountRequest,
  output: GetDeviceSettingsForZeroTrustAccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateDeviceSettingsForTheZeroTrustAccountRequest {
  account_id: unknown;
  body: { disable_for_time?: number; external_emergency_signal_enabled?: boolean; external_emergency_signal_fingerprint?: string; external_emergency_signal_interval?: string; external_emergency_signal_url?: string; gateway_proxy_enabled?: boolean; gateway_udp_proxy_enabled?: boolean; root_certificate_installation_enabled?: boolean; use_zt_virtual_ip?: boolean };
}

export const UpdateDeviceSettingsForTheZeroTrustAccountRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  disable_for_time: Schema.optional(Schema.Number),
  external_emergency_signal_enabled: Schema.optional(Schema.Boolean),
  external_emergency_signal_fingerprint: Schema.optional(Schema.String),
  external_emergency_signal_interval: Schema.optional(Schema.String),
  external_emergency_signal_url: Schema.optional(Schema.String),
  gateway_proxy_enabled: Schema.optional(Schema.Boolean),
  gateway_udp_proxy_enabled: Schema.optional(Schema.Boolean),
  root_certificate_installation_enabled: Schema.optional(Schema.Boolean),
  use_zt_virtual_ip: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/devices/settings" }),
).annotations({ identifier: "UpdateDeviceSettingsForTheZeroTrustAccountRequest" }) as unknown as Schema.Schema<UpdateDeviceSettingsForTheZeroTrustAccountRequest>;

export interface UpdateDeviceSettingsForTheZeroTrustAccountResponse {
  result: { disable_for_time?: number; external_emergency_signal_enabled?: boolean; external_emergency_signal_fingerprint?: string; external_emergency_signal_interval?: string; external_emergency_signal_url?: string; gateway_proxy_enabled?: boolean; gateway_udp_proxy_enabled?: boolean; root_certificate_installation_enabled?: boolean; use_zt_virtual_ip?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateDeviceSettingsForTheZeroTrustAccountResponse = Schema.Struct({
  result: Schema.Struct({
  disable_for_time: Schema.optional(Schema.Number),
  external_emergency_signal_enabled: Schema.optional(Schema.Boolean),
  external_emergency_signal_fingerprint: Schema.optional(Schema.String),
  external_emergency_signal_interval: Schema.optional(Schema.String),
  external_emergency_signal_url: Schema.optional(Schema.String),
  gateway_proxy_enabled: Schema.optional(Schema.Boolean),
  gateway_udp_proxy_enabled: Schema.optional(Schema.Boolean),
  root_certificate_installation_enabled: Schema.optional(Schema.Boolean),
  use_zt_virtual_ip: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateDeviceSettingsForTheZeroTrustAccountResponse" }) as unknown as Schema.Schema<UpdateDeviceSettingsForTheZeroTrustAccountResponse>;

export const updateDeviceSettingsForTheZeroTrustAccount: (
  input: UpdateDeviceSettingsForTheZeroTrustAccountRequest
) => Effect.Effect<
  UpdateDeviceSettingsForTheZeroTrustAccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDeviceSettingsForTheZeroTrustAccountRequest,
  output: UpdateDeviceSettingsForTheZeroTrustAccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDeviceSettingsForZeroTrustAccountRequest {
  account_id: unknown;
}

export const DeleteDeviceSettingsForZeroTrustAccountRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/devices/settings" }),
).annotations({ identifier: "DeleteDeviceSettingsForZeroTrustAccountRequest" }) as unknown as Schema.Schema<DeleteDeviceSettingsForZeroTrustAccountRequest>;

export interface DeleteDeviceSettingsForZeroTrustAccountResponse {
  result: { disable_for_time?: number; external_emergency_signal_enabled?: boolean; external_emergency_signal_fingerprint?: string; external_emergency_signal_interval?: string; external_emergency_signal_url?: string; gateway_proxy_enabled?: boolean; gateway_udp_proxy_enabled?: boolean; root_certificate_installation_enabled?: boolean; use_zt_virtual_ip?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDeviceSettingsForZeroTrustAccountResponse = Schema.Struct({
  result: Schema.Struct({
  disable_for_time: Schema.optional(Schema.Number),
  external_emergency_signal_enabled: Schema.optional(Schema.Boolean),
  external_emergency_signal_fingerprint: Schema.optional(Schema.String),
  external_emergency_signal_interval: Schema.optional(Schema.String),
  external_emergency_signal_url: Schema.optional(Schema.String),
  gateway_proxy_enabled: Schema.optional(Schema.Boolean),
  gateway_udp_proxy_enabled: Schema.optional(Schema.Boolean),
  root_certificate_installation_enabled: Schema.optional(Schema.Boolean),
  use_zt_virtual_ip: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDeviceSettingsForZeroTrustAccountResponse" }) as unknown as Schema.Schema<DeleteDeviceSettingsForZeroTrustAccountResponse>;

export const deleteDeviceSettingsForZeroTrustAccount: (
  input: DeleteDeviceSettingsForZeroTrustAccountRequest
) => Effect.Effect<
  DeleteDeviceSettingsForZeroTrustAccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDeviceSettingsForZeroTrustAccountRequest,
  output: DeleteDeviceSettingsForZeroTrustAccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchDeviceSettingsForTheZeroTrustAccountRequest {
  account_id: unknown;
  body: { disable_for_time?: number; external_emergency_signal_enabled?: boolean; external_emergency_signal_fingerprint?: string; external_emergency_signal_interval?: string; external_emergency_signal_url?: string; gateway_proxy_enabled?: boolean; gateway_udp_proxy_enabled?: boolean; root_certificate_installation_enabled?: boolean; use_zt_virtual_ip?: boolean };
}

export const PatchDeviceSettingsForTheZeroTrustAccountRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  disable_for_time: Schema.optional(Schema.Number),
  external_emergency_signal_enabled: Schema.optional(Schema.Boolean),
  external_emergency_signal_fingerprint: Schema.optional(Schema.String),
  external_emergency_signal_interval: Schema.optional(Schema.String),
  external_emergency_signal_url: Schema.optional(Schema.String),
  gateway_proxy_enabled: Schema.optional(Schema.Boolean),
  gateway_udp_proxy_enabled: Schema.optional(Schema.Boolean),
  root_certificate_installation_enabled: Schema.optional(Schema.Boolean),
  use_zt_virtual_ip: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/devices/settings" }),
).annotations({ identifier: "PatchDeviceSettingsForTheZeroTrustAccountRequest" }) as unknown as Schema.Schema<PatchDeviceSettingsForTheZeroTrustAccountRequest>;

export interface PatchDeviceSettingsForTheZeroTrustAccountResponse {
  result: { disable_for_time?: number; external_emergency_signal_enabled?: boolean; external_emergency_signal_fingerprint?: string; external_emergency_signal_interval?: string; external_emergency_signal_url?: string; gateway_proxy_enabled?: boolean; gateway_udp_proxy_enabled?: boolean; root_certificate_installation_enabled?: boolean; use_zt_virtual_ip?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchDeviceSettingsForTheZeroTrustAccountResponse = Schema.Struct({
  result: Schema.Struct({
  disable_for_time: Schema.optional(Schema.Number),
  external_emergency_signal_enabled: Schema.optional(Schema.Boolean),
  external_emergency_signal_fingerprint: Schema.optional(Schema.String),
  external_emergency_signal_interval: Schema.optional(Schema.String),
  external_emergency_signal_url: Schema.optional(Schema.String),
  gateway_proxy_enabled: Schema.optional(Schema.Boolean),
  gateway_udp_proxy_enabled: Schema.optional(Schema.Boolean),
  root_certificate_installation_enabled: Schema.optional(Schema.Boolean),
  use_zt_virtual_ip: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchDeviceSettingsForTheZeroTrustAccountResponse" }) as unknown as Schema.Schema<PatchDeviceSettingsForTheZeroTrustAccountResponse>;

export const patchDeviceSettingsForTheZeroTrustAccount: (
  input: PatchDeviceSettingsForTheZeroTrustAccountRequest
) => Effect.Effect<
  PatchDeviceSettingsForTheZeroTrustAccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchDeviceSettingsForTheZeroTrustAccountRequest,
  output: PatchDeviceSettingsForTheZeroTrustAccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DevicesUnrevokeDevicesRequest {
  account_id: unknown;
  body: string[];
}

export const DevicesUnrevokeDevicesRequest = Schema.Struct({
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.String).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/devices/unrevoke" }),
).annotations({ identifier: "DevicesUnrevokeDevicesRequest" }) as unknown as Schema.Schema<DevicesUnrevokeDevicesRequest>;

export interface DevicesUnrevokeDevicesResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DevicesUnrevokeDevicesResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DevicesUnrevokeDevicesResponse" }) as unknown as Schema.Schema<DevicesUnrevokeDevicesResponse>;

export const devicesUnrevokeDevices: (
  input: DevicesUnrevokeDevicesRequest
) => Effect.Effect<
  DevicesUnrevokeDevicesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DevicesUnrevokeDevicesRequest,
  output: DevicesUnrevokeDevicesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DevicesDeviceDetailsRequest {
  device_id: string;
  account_id: unknown;
}

export const DevicesDeviceDetailsRequest = Schema.Struct({
  device_id: Schema.String.pipe(T.HttpPath("device_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/{device_id}" }),
).annotations({ identifier: "DevicesDeviceDetailsRequest" }) as unknown as Schema.Schema<DevicesDeviceDetailsRequest>;

export interface DevicesDeviceDetailsResponse {
  result: { account?: { account_type?: string; id?: string; name?: string }; created?: string; deleted?: boolean; device_type?: string; gateway_device_id?: string; id?: string; ip?: string; key?: string; key_type?: string; last_seen?: string; mac_address?: string; model?: string; name?: string; os_version?: string; serial_number?: string; tunnel_type?: string; updated?: string; user?: { email?: string; id?: string; name?: string }; version?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DevicesDeviceDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  account: Schema.optional(Schema.Struct({
  account_type: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
})),
  created: Schema.optional(Schema.Date),
  deleted: Schema.optional(Schema.Boolean),
  device_type: Schema.optional(Schema.String),
  gateway_device_id: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  ip: Schema.optional(Schema.String),
  key: Schema.optional(Schema.String),
  key_type: Schema.optional(Schema.String),
  last_seen: Schema.optional(Schema.Date),
  mac_address: Schema.optional(Schema.String),
  model: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  os_version: Schema.optional(Schema.String),
  serial_number: Schema.optional(Schema.String),
  tunnel_type: Schema.optional(Schema.String),
  updated: Schema.optional(Schema.Date),
  user: Schema.optional(Schema.Struct({
  email: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
})),
  version: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DevicesDeviceDetailsResponse" }) as unknown as Schema.Schema<DevicesDeviceDetailsResponse>;

export const devicesDeviceDetails: (
  input: DevicesDeviceDetailsRequest
) => Effect.Effect<
  DevicesDeviceDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DevicesDeviceDetailsRequest,
  output: DevicesDeviceDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAdminOverrideCodeForDeviceRequest {
  device_id: string;
  account_id: unknown;
}

export const ListAdminOverrideCodeForDeviceRequest = Schema.Struct({
  device_id: Schema.String.pipe(T.HttpPath("device_id")),
  account_id: Schema.Unknown.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/{device_id}/override_codes" }),
).annotations({ identifier: "ListAdminOverrideCodeForDeviceRequest" }) as unknown as Schema.Schema<ListAdminOverrideCodeForDeviceRequest>;

export interface ListAdminOverrideCodeForDeviceResponse {
  result: { disable_for_time?: { "1"?: string; "3"?: string; "6"?: string; "12"?: string; "24"?: string } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAdminOverrideCodeForDeviceResponse = Schema.Struct({
  result: Schema.Struct({
  disable_for_time: Schema.optional(Schema.Struct({
  "1": Schema.optional(Schema.String),
  "3": Schema.optional(Schema.String),
  "6": Schema.optional(Schema.String),
  "12": Schema.optional(Schema.String),
  "24": Schema.optional(Schema.String)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAdminOverrideCodeForDeviceResponse" }) as unknown as Schema.Schema<ListAdminOverrideCodeForDeviceResponse>;

export const listAdminOverrideCodeForDevice: (
  input: ListAdminOverrideCodeForDeviceRequest
) => Effect.Effect<
  ListAdminOverrideCodeForDeviceResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAdminOverrideCodeForDeviceRequest,
  output: ListAdminOverrideCodeForDeviceResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListColosRequest {
  account_id: string;
  from: string;
  to: string;
  sortBy?: "fleet-status-usage" | "application-tests-usage";
}

export const ListColosRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  sortBy: Schema.optional(Schema.Literal("fleet-status-usage", "application-tests-usage")).pipe(T.HttpQuery("sortBy"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/colos" }),
).annotations({ identifier: "ListColosRequest" }) as unknown as Schema.Schema<ListColosRequest>;

export interface ListColosResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListColosResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListColosResponse" }) as unknown as Schema.Schema<ListColosResponse>;

export const listColos: (
  input: ListColosRequest
) => Effect.Effect<
  ListColosResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListColosRequest,
  output: ListColosResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetCommandsRequest {
  account_id: string;
  page: number;
  per_page: number;
  from?: string;
  to?: string;
  device_id?: string;
  user_email?: string;
  command_type?: string;
  status?: "PENDING_EXEC" | "PENDING_UPLOAD" | "SUCCESS" | "FAILED";
}

export const GetCommandsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.Number.pipe(T.HttpQuery("page")),
  per_page: Schema.Number.pipe(T.HttpQuery("per_page")),
  from: Schema.optional(Schema.Date).pipe(T.HttpQuery("from")),
  to: Schema.optional(Schema.Date).pipe(T.HttpQuery("to")),
  device_id: Schema.optional(Schema.String).pipe(T.HttpQuery("device_id")),
  user_email: Schema.optional(Schema.String).pipe(T.HttpQuery("user_email")),
  command_type: Schema.optional(Schema.String).pipe(T.HttpQuery("command_type")),
  status: Schema.optional(Schema.Literal("PENDING_EXEC", "PENDING_UPLOAD", "SUCCESS", "FAILED")).pipe(T.HttpQuery("status"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/commands" }),
).annotations({ identifier: "GetCommandsRequest" }) as unknown as Schema.Schema<GetCommandsRequest>;

export interface GetCommandsResponse {
  result: { commands?: { completed_date?: string; created_date?: string; device_id?: string; filename?: string; id?: string; status?: string; type?: string; user_email?: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetCommandsResponse = Schema.Struct({
  result: Schema.Struct({
  commands: Schema.optional(Schema.Array(Schema.Struct({
  completed_date: Schema.optional(Schema.Date),
  created_date: Schema.optional(Schema.Date),
  device_id: Schema.optional(Schema.String),
  filename: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  status: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  user_email: Schema.optional(Schema.String)
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetCommandsResponse" }) as unknown as Schema.Schema<GetCommandsResponse>;

export const getCommands: (
  input: GetCommandsRequest
) => Effect.Effect<
  GetCommandsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCommandsRequest,
  output: GetCommandsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostCommandsRequest {
  account_id: string;
  body: { commands: { command_args?: { interfaces?: "default" | "tunnel"[]; "max-file-size-mb"?: number; "packet-size-bytes"?: number; "test-all-routes"?: boolean; "time-limit-min"?: number }; command_type: "pcap" | "warp-diag"; device_id: string; user_email: string }[] };
}

export const PostCommandsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  commands: Schema.Array(Schema.Struct({
  command_args: Schema.optional(Schema.Struct({
  interfaces: Schema.optional(Schema.Array(Schema.Literal("default", "tunnel"))),
  "max-file-size-mb": Schema.optional(Schema.Number),
  "packet-size-bytes": Schema.optional(Schema.Number),
  "test-all-routes": Schema.optional(Schema.Boolean),
  "time-limit-min": Schema.optional(Schema.Number)
})),
  command_type: Schema.Literal("pcap", "warp-diag"),
  device_id: Schema.String,
  user_email: Schema.String
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dex/commands" }),
).annotations({ identifier: "PostCommandsRequest" }) as unknown as Schema.Schema<PostCommandsRequest>;

export interface PostCommandsResponse {
  result: { commands?: { args?: Record<string, unknown>; device_id?: string; id?: string; status?: "PENDING_EXEC" | "PENDING_UPLOAD" | "SUCCESS" | "FAILED"; type?: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostCommandsResponse = Schema.Struct({
  result: Schema.Struct({
  commands: Schema.optional(Schema.Array(Schema.Struct({
  args: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  device_id: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("PENDING_EXEC", "PENDING_UPLOAD", "SUCCESS", "FAILED")),
  type: Schema.optional(Schema.String)
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostCommandsResponse" }) as unknown as Schema.Schema<PostCommandsResponse>;

export const postCommands: (
  input: PostCommandsRequest
) => Effect.Effect<
  PostCommandsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostCommandsRequest,
  output: PostCommandsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetCommandsEligibleDevicesRequest {
  account_id: string;
  page: number;
  per_page: number;
  search?: string;
}

export const GetCommandsEligibleDevicesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.Number.pipe(T.HttpQuery("page")),
  per_page: Schema.Number.pipe(T.HttpQuery("per_page")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/commands/devices" }),
).annotations({ identifier: "GetCommandsEligibleDevicesRequest" }) as unknown as Schema.Schema<GetCommandsEligibleDevicesRequest>;

export interface GetCommandsEligibleDevicesResponse {
  result: { devices?: { deviceId?: string; deviceName?: string; eligible?: boolean; ineligibleReason?: string; personEmail?: string; platform?: string; status?: string; timestamp?: string; version?: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetCommandsEligibleDevicesResponse = Schema.Struct({
  result: Schema.Struct({
  devices: Schema.optional(Schema.Array(Schema.Struct({
  deviceId: Schema.optional(Schema.String),
  deviceName: Schema.optional(Schema.String),
  eligible: Schema.optional(Schema.Boolean),
  ineligibleReason: Schema.optional(Schema.String),
  personEmail: Schema.optional(Schema.String),
  platform: Schema.optional(Schema.String),
  status: Schema.optional(Schema.String),
  timestamp: Schema.optional(Schema.String),
  version: Schema.optional(Schema.String)
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetCommandsEligibleDevicesResponse" }) as unknown as Schema.Schema<GetCommandsEligibleDevicesResponse>;

export const getCommandsEligibleDevices: (
  input: GetCommandsEligibleDevicesRequest
) => Effect.Effect<
  GetCommandsEligibleDevicesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCommandsEligibleDevicesRequest,
  output: GetCommandsEligibleDevicesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetCommandsQuotaRequest {
  account_id: string;
}

export const GetCommandsQuotaRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/commands/quota" }),
).annotations({ identifier: "GetCommandsQuotaRequest" }) as unknown as Schema.Schema<GetCommandsQuotaRequest>;

export interface GetCommandsQuotaResponse {
  result: { quota: number; quota_usage: number; reset_time: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetCommandsQuotaResponse = Schema.Struct({
  result: Schema.Struct({
  quota: Schema.Number,
  quota_usage: Schema.Number,
  reset_time: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetCommandsQuotaResponse" }) as unknown as Schema.Schema<GetCommandsQuotaResponse>;

export const getCommandsQuota: (
  input: GetCommandsQuotaRequest
) => Effect.Effect<
  GetCommandsQuotaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCommandsQuotaRequest,
  output: GetCommandsQuotaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetCommandsCommandIdDownloadsFilenameRequest {
  account_id: string;
  command_id: string;
  filename: string;
}

export const GetCommandsCommandIdDownloadsFilenameRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  command_id: Schema.String.pipe(T.HttpPath("command_id")),
  filename: Schema.String.pipe(T.HttpPath("filename"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/commands/{command_id}/downloads/{filename}" }),
).annotations({ identifier: "GetCommandsCommandIdDownloadsFilenameRequest" }) as unknown as Schema.Schema<GetCommandsCommandIdDownloadsFilenameRequest>;

export interface GetCommandsCommandIdDownloadsFilenameResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetCommandsCommandIdDownloadsFilenameResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetCommandsCommandIdDownloadsFilenameResponse" }) as unknown as Schema.Schema<GetCommandsCommandIdDownloadsFilenameResponse>;

export const getCommandsCommandIdDownloadsFilename: (
  input: GetCommandsCommandIdDownloadsFilenameRequest
) => Effect.Effect<
  GetCommandsCommandIdDownloadsFilenameResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCommandsCommandIdDownloadsFilenameRequest,
  output: GetCommandsCommandIdDownloadsFilenameResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeviceDexTestDetailsRequest {
  account_id: string;
}

export const DeviceDexTestDetailsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/devices/dex_tests" }),
).annotations({ identifier: "DeviceDexTestDetailsRequest" }) as unknown as Schema.Schema<DeviceDexTestDetailsRequest>;

export interface DeviceDexTestDetailsResponse {
  result: { data: { host?: string; kind?: string; method?: string }; description?: string; enabled: boolean; interval: string; name: string; target_policies?: { default?: boolean; id?: string; name?: string }[]; targeted?: boolean; test_id?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeviceDexTestDetailsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  data: Schema.Struct({
  host: Schema.optional(Schema.String),
  kind: Schema.optional(Schema.String),
  method: Schema.optional(Schema.String)
}),
  description: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  interval: Schema.String,
  name: Schema.String,
  target_policies: Schema.optional(Schema.Array(Schema.Struct({
  default: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))),
  targeted: Schema.optional(Schema.Boolean),
  test_id: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeviceDexTestDetailsResponse" }) as unknown as Schema.Schema<DeviceDexTestDetailsResponse>;

export const deviceDexTestDetails: (
  input: DeviceDexTestDetailsRequest
) => Effect.Effect<
  DeviceDexTestDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeviceDexTestDetailsRequest,
  output: DeviceDexTestDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateDeviceDexTestRequest {
  account_id: string;
  body: { data: { host?: string; kind?: string; method?: string }; description?: string; enabled: boolean; interval: string; name: string; target_policies?: { default?: boolean; id?: string; name?: string }[]; targeted?: boolean; test_id?: string };
}

export const CreateDeviceDexTestRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  data: Schema.Struct({
  host: Schema.optional(Schema.String),
  kind: Schema.optional(Schema.String),
  method: Schema.optional(Schema.String)
}),
  description: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  interval: Schema.String,
  name: Schema.String,
  target_policies: Schema.optional(Schema.Array(Schema.Struct({
  default: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))),
  targeted: Schema.optional(Schema.Boolean),
  test_id: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dex/devices/dex_tests" }),
).annotations({ identifier: "CreateDeviceDexTestRequest" }) as unknown as Schema.Schema<CreateDeviceDexTestRequest>;

export interface CreateDeviceDexTestResponse {
  result: { data: { host?: string; kind?: string; method?: string }; description?: string; enabled: boolean; interval: string; name: string; target_policies?: { default?: boolean; id?: string; name?: string }[]; targeted?: boolean; test_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateDeviceDexTestResponse = Schema.Struct({
  result: Schema.Struct({
  data: Schema.Struct({
  host: Schema.optional(Schema.String),
  kind: Schema.optional(Schema.String),
  method: Schema.optional(Schema.String)
}),
  description: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  interval: Schema.String,
  name: Schema.String,
  target_policies: Schema.optional(Schema.Array(Schema.Struct({
  default: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))),
  targeted: Schema.optional(Schema.Boolean),
  test_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateDeviceDexTestResponse" }) as unknown as Schema.Schema<CreateDeviceDexTestResponse>;

export const createDeviceDexTest: (
  input: CreateDeviceDexTestRequest
) => Effect.Effect<
  CreateDeviceDexTestResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDeviceDexTestRequest,
  output: CreateDeviceDexTestResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDeviceDexTestRequest {
  account_id: string;
  dex_test_id: string;
}

export const GetDeviceDexTestRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dex_test_id: Schema.String.pipe(T.HttpPath("dex_test_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/devices/dex_tests/{dex_test_id}" }),
).annotations({ identifier: "GetDeviceDexTestRequest" }) as unknown as Schema.Schema<GetDeviceDexTestRequest>;

export interface GetDeviceDexTestResponse {
  result: { data: { host?: string; kind?: string; method?: string }; description?: string; enabled: boolean; interval: string; name: string; target_policies?: { default?: boolean; id?: string; name?: string }[]; targeted?: boolean; test_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDeviceDexTestResponse = Schema.Struct({
  result: Schema.Struct({
  data: Schema.Struct({
  host: Schema.optional(Schema.String),
  kind: Schema.optional(Schema.String),
  method: Schema.optional(Schema.String)
}),
  description: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  interval: Schema.String,
  name: Schema.String,
  target_policies: Schema.optional(Schema.Array(Schema.Struct({
  default: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))),
  targeted: Schema.optional(Schema.Boolean),
  test_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDeviceDexTestResponse" }) as unknown as Schema.Schema<GetDeviceDexTestResponse>;

export const getDeviceDexTest: (
  input: GetDeviceDexTestRequest
) => Effect.Effect<
  GetDeviceDexTestResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDeviceDexTestRequest,
  output: GetDeviceDexTestResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateDeviceDexTestRequest {
  account_id: string;
  dex_test_id: string;
  body: { data: { host?: string; kind?: string; method?: string }; description?: string; enabled: boolean; interval: string; name: string; target_policies?: { default?: boolean; id?: string; name?: string }[]; targeted?: boolean; test_id?: string };
}

export const UpdateDeviceDexTestRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dex_test_id: Schema.String.pipe(T.HttpPath("dex_test_id")),
  body: Schema.Struct({
  data: Schema.Struct({
  host: Schema.optional(Schema.String),
  kind: Schema.optional(Schema.String),
  method: Schema.optional(Schema.String)
}),
  description: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  interval: Schema.String,
  name: Schema.String,
  target_policies: Schema.optional(Schema.Array(Schema.Struct({
  default: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))),
  targeted: Schema.optional(Schema.Boolean),
  test_id: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/dex/devices/dex_tests/{dex_test_id}" }),
).annotations({ identifier: "UpdateDeviceDexTestRequest" }) as unknown as Schema.Schema<UpdateDeviceDexTestRequest>;

export interface UpdateDeviceDexTestResponse {
  result: { data: { host?: string; kind?: string; method?: string }; description?: string; enabled: boolean; interval: string; name: string; target_policies?: { default?: boolean; id?: string; name?: string }[]; targeted?: boolean; test_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateDeviceDexTestResponse = Schema.Struct({
  result: Schema.Struct({
  data: Schema.Struct({
  host: Schema.optional(Schema.String),
  kind: Schema.optional(Schema.String),
  method: Schema.optional(Schema.String)
}),
  description: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  interval: Schema.String,
  name: Schema.String,
  target_policies: Schema.optional(Schema.Array(Schema.Struct({
  default: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))),
  targeted: Schema.optional(Schema.Boolean),
  test_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateDeviceDexTestResponse" }) as unknown as Schema.Schema<UpdateDeviceDexTestResponse>;

export const updateDeviceDexTest: (
  input: UpdateDeviceDexTestRequest
) => Effect.Effect<
  UpdateDeviceDexTestResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDeviceDexTestRequest,
  output: UpdateDeviceDexTestResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDeviceDexTestRequest {
  account_id: string;
  dex_test_id: string;
}

export const DeleteDeviceDexTestRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dex_test_id: Schema.String.pipe(T.HttpPath("dex_test_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/dex/devices/dex_tests/{dex_test_id}" }),
).annotations({ identifier: "DeleteDeviceDexTestRequest" }) as unknown as Schema.Schema<DeleteDeviceDexTestRequest>;

export interface DeleteDeviceDexTestResponse {
  result: { dex_tests?: { data: { host?: string; kind?: string; method?: string }; description?: string; enabled: boolean; interval: string; name: string; target_policies?: { default?: boolean; id?: string; name?: string }[]; targeted?: boolean; test_id?: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDeviceDexTestResponse = Schema.Struct({
  result: Schema.Struct({
  dex_tests: Schema.optional(Schema.Array(Schema.Struct({
  data: Schema.Struct({
  host: Schema.optional(Schema.String),
  kind: Schema.optional(Schema.String),
  method: Schema.optional(Schema.String)
}),
  description: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  interval: Schema.String,
  name: Schema.String,
  target_policies: Schema.optional(Schema.Array(Schema.Struct({
  default: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))),
  targeted: Schema.optional(Schema.Boolean),
  test_id: Schema.optional(Schema.String)
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDeviceDexTestResponse" }) as unknown as Schema.Schema<DeleteDeviceDexTestResponse>;

export const deleteDeviceDexTest: (
  input: DeleteDeviceDexTestRequest
) => Effect.Effect<
  DeleteDeviceDexTestResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDeviceDexTestRequest,
  output: DeleteDeviceDexTestResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DevicesLiveStatusRequest {
  account_id: string;
  device_id: string;
  since_minutes: number;
  time_now?: string;
  colo?: string;
}

export const DevicesLiveStatusRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  device_id: Schema.String.pipe(T.HttpPath("device_id")),
  since_minutes: Schema.Number.pipe(T.HttpQuery("since_minutes")),
  time_now: Schema.optional(Schema.String).pipe(T.HttpQuery("time_now")),
  colo: Schema.optional(Schema.String).pipe(T.HttpQuery("colo"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/devices/{device_id}/fleet-status/live" }),
).annotations({ identifier: "DevicesLiveStatusRequest" }) as unknown as Schema.Schema<DevicesLiveStatusRequest>;

export interface DevicesLiveStatusResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DevicesLiveStatusResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DevicesLiveStatusResponse" }) as unknown as Schema.Schema<DevicesLiveStatusResponse>;

export const devicesLiveStatus: (
  input: DevicesLiveStatusRequest
) => Effect.Effect<
  DevicesLiveStatusResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DevicesLiveStatusRequest,
  output: DevicesLiveStatusResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DexFleetStatusDevicesRequest {
  account_id: string;
  to: string;
  from: string;
  page: number;
  per_page: number;
  sort_by?: "colo" | "device_id" | "mode" | "platform" | "status" | "timestamp" | "version";
  colo?: string;
  device_id?: string;
  mode?: string;
  status?: string;
  platform?: string;
  version?: string;
  source?: "last_seen" | "hourly" | "raw";
}

export const DexFleetStatusDevicesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  page: Schema.Number.pipe(T.HttpQuery("page")),
  per_page: Schema.Number.pipe(T.HttpQuery("per_page")),
  sort_by: Schema.optional(Schema.Literal("colo", "device_id", "mode", "platform", "status", "timestamp", "version")).pipe(T.HttpQuery("sort_by")),
  colo: Schema.optional(Schema.String).pipe(T.HttpQuery("colo")),
  device_id: Schema.optional(Schema.String).pipe(T.HttpQuery("device_id")),
  mode: Schema.optional(Schema.String).pipe(T.HttpQuery("mode")),
  status: Schema.optional(Schema.String).pipe(T.HttpQuery("status")),
  platform: Schema.optional(Schema.String).pipe(T.HttpQuery("platform")),
  version: Schema.optional(Schema.String).pipe(T.HttpQuery("version")),
  source: Schema.optional(Schema.Literal("last_seen", "hourly", "raw")).pipe(T.HttpQuery("source"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/fleet-status/devices" }),
).annotations({ identifier: "DexFleetStatusDevicesRequest" }) as unknown as Schema.Schema<DexFleetStatusDevicesRequest>;

export interface DexFleetStatusDevicesResponse {
  result: { alwaysOn?: boolean; batteryCharging?: boolean; batteryCycles?: number; batteryPct?: number; colo: string; connectionType?: string; cpuPct?: number; cpuPctByApp?: { cpu_pct?: number; name?: string }[][]; deviceId: string; deviceIpv4?: { address?: string; asn?: number; aso?: string; location?: { city?: string; country_iso?: string; state_iso?: string; zip?: string }; netmask?: string; version?: string }; deviceIpv6?: { address?: string; asn?: number; aso?: string; location?: { city?: string; country_iso?: string; state_iso?: string; zip?: string }; netmask?: string; version?: string }; deviceName?: string; diskReadBps?: number; diskUsagePct?: number; diskWriteBps?: number; dohSubdomain?: string; estimatedLossPct?: number; firewallEnabled?: boolean; gatewayIpv4?: { address?: string; asn?: number; aso?: string; location?: { city?: string; country_iso?: string; state_iso?: string; zip?: string }; netmask?: string; version?: string }; gatewayIpv6?: { address?: string; asn?: number; aso?: string; location?: { city?: string; country_iso?: string; state_iso?: string; zip?: string }; netmask?: string; version?: string }; handshakeLatencyMs?: number; ispIpv4?: { address?: string; asn?: number; aso?: string; location?: { city?: string; country_iso?: string; state_iso?: string; zip?: string }; netmask?: string; version?: string }; ispIpv6?: { address?: string; asn?: number; aso?: string; location?: { city?: string; country_iso?: string; state_iso?: string; zip?: string }; netmask?: string; version?: string }; metal?: string; mode: string; networkRcvdBps?: number; networkSentBps?: number; networkSsid?: string; personEmail?: string; platform: string; ramAvailableKb?: number; ramUsedPct?: number; ramUsedPctByApp?: { name?: string; ram_used_pct?: number }[][]; status: string; switchLocked?: boolean; timestamp: string; version: string; wifiStrengthDbm?: number }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DexFleetStatusDevicesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  alwaysOn: Schema.optional(Schema.Boolean),
  batteryCharging: Schema.optional(Schema.Boolean),
  batteryCycles: Schema.optional(Schema.Number),
  batteryPct: Schema.optional(Schema.Number),
  colo: Schema.String,
  connectionType: Schema.optional(Schema.String),
  cpuPct: Schema.optional(Schema.Number),
  cpuPctByApp: Schema.optional(Schema.Array(Schema.Array(Schema.Struct({
  cpu_pct: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String)
})))),
  deviceId: Schema.String,
  deviceIpv4: Schema.optional(Schema.Struct({
  address: Schema.optional(Schema.String),
  asn: Schema.optional(Schema.Number),
  aso: Schema.optional(Schema.String),
  location: Schema.optional(Schema.Struct({
  city: Schema.optional(Schema.String),
  country_iso: Schema.optional(Schema.String),
  state_iso: Schema.optional(Schema.String),
  zip: Schema.optional(Schema.String)
})),
  netmask: Schema.optional(Schema.String),
  version: Schema.optional(Schema.String)
})),
  deviceIpv6: Schema.optional(Schema.Struct({
  address: Schema.optional(Schema.String),
  asn: Schema.optional(Schema.Number),
  aso: Schema.optional(Schema.String),
  location: Schema.optional(Schema.Struct({
  city: Schema.optional(Schema.String),
  country_iso: Schema.optional(Schema.String),
  state_iso: Schema.optional(Schema.String),
  zip: Schema.optional(Schema.String)
})),
  netmask: Schema.optional(Schema.String),
  version: Schema.optional(Schema.String)
})),
  deviceName: Schema.optional(Schema.String),
  diskReadBps: Schema.optional(Schema.Number),
  diskUsagePct: Schema.optional(Schema.Number),
  diskWriteBps: Schema.optional(Schema.Number),
  dohSubdomain: Schema.optional(Schema.String),
  estimatedLossPct: Schema.optional(Schema.Number),
  firewallEnabled: Schema.optional(Schema.Boolean),
  gatewayIpv4: Schema.optional(Schema.Struct({
  address: Schema.optional(Schema.String),
  asn: Schema.optional(Schema.Number),
  aso: Schema.optional(Schema.String),
  location: Schema.optional(Schema.Struct({
  city: Schema.optional(Schema.String),
  country_iso: Schema.optional(Schema.String),
  state_iso: Schema.optional(Schema.String),
  zip: Schema.optional(Schema.String)
})),
  netmask: Schema.optional(Schema.String),
  version: Schema.optional(Schema.String)
})),
  gatewayIpv6: Schema.optional(Schema.Struct({
  address: Schema.optional(Schema.String),
  asn: Schema.optional(Schema.Number),
  aso: Schema.optional(Schema.String),
  location: Schema.optional(Schema.Struct({
  city: Schema.optional(Schema.String),
  country_iso: Schema.optional(Schema.String),
  state_iso: Schema.optional(Schema.String),
  zip: Schema.optional(Schema.String)
})),
  netmask: Schema.optional(Schema.String),
  version: Schema.optional(Schema.String)
})),
  handshakeLatencyMs: Schema.optional(Schema.Number),
  ispIpv4: Schema.optional(Schema.Struct({
  address: Schema.optional(Schema.String),
  asn: Schema.optional(Schema.Number),
  aso: Schema.optional(Schema.String),
  location: Schema.optional(Schema.Struct({
  city: Schema.optional(Schema.String),
  country_iso: Schema.optional(Schema.String),
  state_iso: Schema.optional(Schema.String),
  zip: Schema.optional(Schema.String)
})),
  netmask: Schema.optional(Schema.String),
  version: Schema.optional(Schema.String)
})),
  ispIpv6: Schema.optional(Schema.Struct({
  address: Schema.optional(Schema.String),
  asn: Schema.optional(Schema.Number),
  aso: Schema.optional(Schema.String),
  location: Schema.optional(Schema.Struct({
  city: Schema.optional(Schema.String),
  country_iso: Schema.optional(Schema.String),
  state_iso: Schema.optional(Schema.String),
  zip: Schema.optional(Schema.String)
})),
  netmask: Schema.optional(Schema.String),
  version: Schema.optional(Schema.String)
})),
  metal: Schema.optional(Schema.String),
  mode: Schema.String,
  networkRcvdBps: Schema.optional(Schema.Number),
  networkSentBps: Schema.optional(Schema.Number),
  networkSsid: Schema.optional(Schema.String),
  personEmail: Schema.optional(Schema.String),
  platform: Schema.String,
  ramAvailableKb: Schema.optional(Schema.Number),
  ramUsedPct: Schema.optional(Schema.Number),
  ramUsedPctByApp: Schema.optional(Schema.Array(Schema.Array(Schema.Struct({
  name: Schema.optional(Schema.String),
  ram_used_pct: Schema.optional(Schema.Number)
})))),
  status: Schema.String,
  switchLocked: Schema.optional(Schema.Boolean),
  timestamp: Schema.String,
  version: Schema.String,
  wifiStrengthDbm: Schema.optional(Schema.Number)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DexFleetStatusDevicesResponse" }) as unknown as Schema.Schema<DexFleetStatusDevicesResponse>;

export const dexFleetStatusDevices: (
  input: DexFleetStatusDevicesRequest
) => Effect.Effect<
  DexFleetStatusDevicesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DexFleetStatusDevicesRequest,
  output: DexFleetStatusDevicesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DexFleetStatusLiveRequest {
  account_id: string;
  since_minutes: number;
}

export const DexFleetStatusLiveRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  since_minutes: Schema.Number.pipe(T.HttpQuery("since_minutes"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/fleet-status/live" }),
).annotations({ identifier: "DexFleetStatusLiveRequest" }) as unknown as Schema.Schema<DexFleetStatusLiveRequest>;

export interface DexFleetStatusLiveResponse {
  result: { deviceStats?: { byColo?: { uniqueDevicesTotal?: number; value?: string }[]; byMode?: { uniqueDevicesTotal?: number; value?: string }[]; byPlatform?: { uniqueDevicesTotal?: number; value?: string }[]; byStatus?: { uniqueDevicesTotal?: number; value?: string }[]; byVersion?: { uniqueDevicesTotal?: number; value?: string }[]; uniqueDevicesTotal?: number } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DexFleetStatusLiveResponse = Schema.Struct({
  result: Schema.Struct({
  deviceStats: Schema.optional(Schema.Struct({
  byColo: Schema.optional(Schema.Array(Schema.Struct({
  uniqueDevicesTotal: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.String)
}))),
  byMode: Schema.optional(Schema.Array(Schema.Struct({
  uniqueDevicesTotal: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.String)
}))),
  byPlatform: Schema.optional(Schema.Array(Schema.Struct({
  uniqueDevicesTotal: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.String)
}))),
  byStatus: Schema.optional(Schema.Array(Schema.Struct({
  uniqueDevicesTotal: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.String)
}))),
  byVersion: Schema.optional(Schema.Array(Schema.Struct({
  uniqueDevicesTotal: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.String)
}))),
  uniqueDevicesTotal: Schema.optional(Schema.Number)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DexFleetStatusLiveResponse" }) as unknown as Schema.Schema<DexFleetStatusLiveResponse>;

export const dexFleetStatusLive: (
  input: DexFleetStatusLiveRequest
) => Effect.Effect<
  DexFleetStatusLiveResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DexFleetStatusLiveRequest,
  output: DexFleetStatusLiveResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DexFleetStatusOverTimeRequest {
  account_id: string;
  to: string;
  from: string;
  colo?: string;
  device_id?: string;
}

export const DexFleetStatusOverTimeRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  colo: Schema.optional(Schema.String).pipe(T.HttpQuery("colo")),
  device_id: Schema.optional(Schema.String).pipe(T.HttpQuery("device_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/fleet-status/over-time" }),
).annotations({ identifier: "DexFleetStatusOverTimeRequest" }) as unknown as Schema.Schema<DexFleetStatusOverTimeRequest>;

export interface DexFleetStatusOverTimeResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DexFleetStatusOverTimeResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DexFleetStatusOverTimeResponse" }) as unknown as Schema.Schema<DexFleetStatusOverTimeResponse>;

export const dexFleetStatusOverTime: (
  input: DexFleetStatusOverTimeRequest
) => Effect.Effect<
  DexFleetStatusOverTimeResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DexFleetStatusOverTimeRequest,
  output: DexFleetStatusOverTimeResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DexEndpointsHttpTestDetailsRequest {
  account_id: string;
  test_id: string;
  deviceId?: string[];
  from: string;
  to: string;
  interval: "minute" | "hour";
  colo?: string;
}

export const DexEndpointsHttpTestDetailsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  test_id: Schema.String.pipe(T.HttpPath("test_id")),
  deviceId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("deviceId")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  interval: Schema.Literal("minute", "hour").pipe(T.HttpQuery("interval")),
  colo: Schema.optional(Schema.String).pipe(T.HttpQuery("colo"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/http-tests/{test_id}" }),
).annotations({ identifier: "DexEndpointsHttpTestDetailsRequest" }) as unknown as Schema.Schema<DexEndpointsHttpTestDetailsRequest>;

export interface DexEndpointsHttpTestDetailsResponse {
  result: { host?: string; httpStats?: { availabilityPct: { avg?: number; max?: number; min?: number; slots: { timestamp: string; value: number }[] }; dnsResponseTimeMs: { avg?: number; max?: number; min?: number; slots: { timestamp: string; value: number }[] }; httpStatusCode: { status200: number; status300: number; status400: number; status500: number; timestamp: string }[]; resourceFetchTimeMs: { avg?: number; max?: number; min?: number; slots: { timestamp: string; value: number }[] }; serverResponseTimeMs: { avg?: number; max?: number; min?: number; slots: { timestamp: string; value: number }[] }; uniqueDevicesTotal: number }; httpStatsByColo?: { availabilityPct: { avg?: number; max?: number; min?: number; slots: { timestamp: string; value: number }[] }; colo: string; dnsResponseTimeMs: { avg?: number; max?: number; min?: number; slots: { timestamp: string; value: number }[] }; httpStatusCode: { status200: number; status300: number; status400: number; status500: number; timestamp: string }[]; resourceFetchTimeMs: { avg?: number; max?: number; min?: number; slots: { timestamp: string; value: number }[] }; serverResponseTimeMs: { avg?: number; max?: number; min?: number; slots: { timestamp: string; value: number }[] }; uniqueDevicesTotal: number }[]; interval?: string; kind?: "http"; method?: string; name?: string; target_policies?: { default: boolean; id: string; name: string }[]; targeted?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DexEndpointsHttpTestDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  host: Schema.optional(Schema.String),
  httpStats: Schema.optional(Schema.Struct({
  availabilityPct: Schema.Struct({
  avg: Schema.optional(Schema.Number),
  max: Schema.optional(Schema.Number),
  min: Schema.optional(Schema.Number),
  slots: Schema.Array(Schema.Struct({
  timestamp: Schema.String,
  value: Schema.Number
}))
}),
  dnsResponseTimeMs: Schema.Struct({
  avg: Schema.optional(Schema.Number),
  max: Schema.optional(Schema.Number),
  min: Schema.optional(Schema.Number),
  slots: Schema.Array(Schema.Struct({
  timestamp: Schema.String,
  value: Schema.Number
}))
}),
  httpStatusCode: Schema.Array(Schema.Struct({
  status200: Schema.Number,
  status300: Schema.Number,
  status400: Schema.Number,
  status500: Schema.Number,
  timestamp: Schema.String
})),
  resourceFetchTimeMs: Schema.Struct({
  avg: Schema.optional(Schema.Number),
  max: Schema.optional(Schema.Number),
  min: Schema.optional(Schema.Number),
  slots: Schema.Array(Schema.Struct({
  timestamp: Schema.String,
  value: Schema.Number
}))
}),
  serverResponseTimeMs: Schema.Struct({
  avg: Schema.optional(Schema.Number),
  max: Schema.optional(Schema.Number),
  min: Schema.optional(Schema.Number),
  slots: Schema.Array(Schema.Struct({
  timestamp: Schema.String,
  value: Schema.Number
}))
}),
  uniqueDevicesTotal: Schema.Number
})),
  httpStatsByColo: Schema.optional(Schema.Array(Schema.Struct({
  availabilityPct: Schema.Struct({
  avg: Schema.optional(Schema.Number),
  max: Schema.optional(Schema.Number),
  min: Schema.optional(Schema.Number),
  slots: Schema.Array(Schema.Struct({
  timestamp: Schema.String,
  value: Schema.Number
}))
}),
  colo: Schema.String,
  dnsResponseTimeMs: Schema.Struct({
  avg: Schema.optional(Schema.Number),
  max: Schema.optional(Schema.Number),
  min: Schema.optional(Schema.Number),
  slots: Schema.Array(Schema.Struct({
  timestamp: Schema.String,
  value: Schema.Number
}))
}),
  httpStatusCode: Schema.Array(Schema.Struct({
  status200: Schema.Number,
  status300: Schema.Number,
  status400: Schema.Number,
  status500: Schema.Number,
  timestamp: Schema.String
})),
  resourceFetchTimeMs: Schema.Struct({
  avg: Schema.optional(Schema.Number),
  max: Schema.optional(Schema.Number),
  min: Schema.optional(Schema.Number),
  slots: Schema.Array(Schema.Struct({
  timestamp: Schema.String,
  value: Schema.Number
}))
}),
  serverResponseTimeMs: Schema.Struct({
  avg: Schema.optional(Schema.Number),
  max: Schema.optional(Schema.Number),
  min: Schema.optional(Schema.Number),
  slots: Schema.Array(Schema.Struct({
  timestamp: Schema.String,
  value: Schema.Number
}))
}),
  uniqueDevicesTotal: Schema.Number
}))),
  interval: Schema.optional(Schema.String),
  kind: Schema.optional(Schema.Literal("http")),
  method: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  target_policies: Schema.optional(Schema.Array(Schema.Struct({
  default: Schema.Boolean,
  id: Schema.String,
  name: Schema.String
}))),
  targeted: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DexEndpointsHttpTestDetailsResponse" }) as unknown as Schema.Schema<DexEndpointsHttpTestDetailsResponse>;

export const dexEndpointsHttpTestDetails: (
  input: DexEndpointsHttpTestDetailsRequest
) => Effect.Effect<
  DexEndpointsHttpTestDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DexEndpointsHttpTestDetailsRequest,
  output: DexEndpointsHttpTestDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DexEndpointsHttpTestPercentilesRequest {
  account_id: string;
  test_id: string;
  deviceId?: string[];
  from: string;
  to: string;
  colo?: string;
}

export const DexEndpointsHttpTestPercentilesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  test_id: Schema.String.pipe(T.HttpPath("test_id")),
  deviceId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("deviceId")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  colo: Schema.optional(Schema.String).pipe(T.HttpQuery("colo"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/http-tests/{test_id}/percentiles" }),
).annotations({ identifier: "DexEndpointsHttpTestPercentilesRequest" }) as unknown as Schema.Schema<DexEndpointsHttpTestPercentilesRequest>;

export interface DexEndpointsHttpTestPercentilesResponse {
  result: { dnsResponseTimeMs?: { p50?: number; p90?: number; p95?: number; p99?: number }; resourceFetchTimeMs?: { p50?: number; p90?: number; p95?: number; p99?: number }; serverResponseTimeMs?: { p50?: number; p90?: number; p95?: number; p99?: number } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DexEndpointsHttpTestPercentilesResponse = Schema.Struct({
  result: Schema.Struct({
  dnsResponseTimeMs: Schema.optional(Schema.Struct({
  p50: Schema.optional(Schema.Number),
  p90: Schema.optional(Schema.Number),
  p95: Schema.optional(Schema.Number),
  p99: Schema.optional(Schema.Number)
})),
  resourceFetchTimeMs: Schema.optional(Schema.Struct({
  p50: Schema.optional(Schema.Number),
  p90: Schema.optional(Schema.Number),
  p95: Schema.optional(Schema.Number),
  p99: Schema.optional(Schema.Number)
})),
  serverResponseTimeMs: Schema.optional(Schema.Struct({
  p50: Schema.optional(Schema.Number),
  p90: Schema.optional(Schema.Number),
  p95: Schema.optional(Schema.Number),
  p99: Schema.optional(Schema.Number)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DexEndpointsHttpTestPercentilesResponse" }) as unknown as Schema.Schema<DexEndpointsHttpTestPercentilesResponse>;

export const dexEndpointsHttpTestPercentiles: (
  input: DexEndpointsHttpTestPercentilesRequest
) => Effect.Effect<
  DexEndpointsHttpTestPercentilesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DexEndpointsHttpTestPercentilesRequest,
  output: DexEndpointsHttpTestPercentilesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListTestsOverviewRequest {
  account_id: string;
  colo?: string;
  testName?: string;
  deviceId?: string[];
  page?: number;
  per_page?: number;
}

export const ListTestsOverviewRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  colo: Schema.optional(Schema.String).pipe(T.HttpQuery("colo")),
  testName: Schema.optional(Schema.String).pipe(T.HttpQuery("testName")),
  deviceId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("deviceId")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/tests/overview" }),
).annotations({ identifier: "ListTestsOverviewRequest" }) as unknown as Schema.Schema<ListTestsOverviewRequest>;

export interface ListTestsOverviewResponse {
  result: { overviewMetrics: { avgHttpAvailabilityPct?: number; avgTracerouteAvailabilityPct?: number; testsTotal: number }; tests: { created: string; description: string; enabled: boolean; host: string; httpResults?: { resourceFetchTime: { avgMs?: number; history: { avgMs?: number; deltaPct?: number; timePeriod: { units: "hours" | "days" | "testRuns"; value: number } }[]; overTime?: { timePeriod: { units: "hours" | "days" | "testRuns"; value: number }; values: { avgMs: number; timestamp: string }[] } } }; httpResultsByColo?: { colo: string; resourceFetchTime: { avgMs?: number; history: { avgMs?: number; deltaPct?: number; timePeriod: { units: "hours" | "days" | "testRuns"; value: number } }[]; overTime?: { timePeriod: { units: "hours" | "days" | "testRuns"; value: number }; values: { avgMs: number; timestamp: string }[] } } }[]; id: string; interval: string; kind: "http" | "traceroute"; method?: string; name: string; target_policies?: { default: boolean; id: string; name: string }[]; targeted?: boolean; tracerouteResults?: { roundTripTime: { avgMs?: number; history: { avgMs?: number; deltaPct?: number; timePeriod: { units: "hours" | "days" | "testRuns"; value: number } }[]; overTime?: { timePeriod: { units: "hours" | "days" | "testRuns"; value: number }; values: { avgMs: number; timestamp: string }[] } } }; tracerouteResultsByColo?: { colo: string; roundTripTime: { avgMs?: number; history: { avgMs?: number; deltaPct?: number; timePeriod: { units: "hours" | "days" | "testRuns"; value: number } }[]; overTime?: { timePeriod: { units: "hours" | "days" | "testRuns"; value: number }; values: { avgMs: number; timestamp: string }[] } } }[]; updated: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListTestsOverviewResponse = Schema.Struct({
  result: Schema.Struct({
  overviewMetrics: Schema.Struct({
  avgHttpAvailabilityPct: Schema.optional(Schema.Number),
  avgTracerouteAvailabilityPct: Schema.optional(Schema.Number),
  testsTotal: Schema.Number
}),
  tests: Schema.Array(Schema.Struct({
  created: Schema.String,
  description: Schema.String,
  enabled: Schema.Boolean,
  host: Schema.String,
  httpResults: Schema.optional(Schema.Struct({
  resourceFetchTime: Schema.Struct({
  avgMs: Schema.optional(Schema.Number),
  history: Schema.Array(Schema.Struct({
  avgMs: Schema.optional(Schema.Number),
  deltaPct: Schema.optional(Schema.Number),
  timePeriod: Schema.Struct({
  units: Schema.Literal("hours", "days", "testRuns"),
  value: Schema.Number
})
})),
  overTime: Schema.optional(Schema.Struct({
  timePeriod: Schema.Struct({
  units: Schema.Literal("hours", "days", "testRuns"),
  value: Schema.Number
}),
  values: Schema.Array(Schema.Struct({
  avgMs: Schema.Number,
  timestamp: Schema.String
}))
}))
})
})),
  httpResultsByColo: Schema.optional(Schema.Array(Schema.Struct({
  colo: Schema.String,
  resourceFetchTime: Schema.Struct({
  avgMs: Schema.optional(Schema.Number),
  history: Schema.Array(Schema.Struct({
  avgMs: Schema.optional(Schema.Number),
  deltaPct: Schema.optional(Schema.Number),
  timePeriod: Schema.Struct({
  units: Schema.Literal("hours", "days", "testRuns"),
  value: Schema.Number
})
})),
  overTime: Schema.optional(Schema.Struct({
  timePeriod: Schema.Struct({
  units: Schema.Literal("hours", "days", "testRuns"),
  value: Schema.Number
}),
  values: Schema.Array(Schema.Struct({
  avgMs: Schema.Number,
  timestamp: Schema.String
}))
}))
})
}))),
  id: Schema.String,
  interval: Schema.String,
  kind: Schema.Literal("http", "traceroute"),
  method: Schema.optional(Schema.String),
  name: Schema.String,
  target_policies: Schema.optional(Schema.Array(Schema.Struct({
  default: Schema.Boolean,
  id: Schema.String,
  name: Schema.String
}))),
  targeted: Schema.optional(Schema.Boolean),
  tracerouteResults: Schema.optional(Schema.Struct({
  roundTripTime: Schema.Struct({
  avgMs: Schema.optional(Schema.Number),
  history: Schema.Array(Schema.Struct({
  avgMs: Schema.optional(Schema.Number),
  deltaPct: Schema.optional(Schema.Number),
  timePeriod: Schema.Struct({
  units: Schema.Literal("hours", "days", "testRuns"),
  value: Schema.Number
})
})),
  overTime: Schema.optional(Schema.Struct({
  timePeriod: Schema.Struct({
  units: Schema.Literal("hours", "days", "testRuns"),
  value: Schema.Number
}),
  values: Schema.Array(Schema.Struct({
  avgMs: Schema.Number,
  timestamp: Schema.String
}))
}))
})
})),
  tracerouteResultsByColo: Schema.optional(Schema.Array(Schema.Struct({
  colo: Schema.String,
  roundTripTime: Schema.Struct({
  avgMs: Schema.optional(Schema.Number),
  history: Schema.Array(Schema.Struct({
  avgMs: Schema.optional(Schema.Number),
  deltaPct: Schema.optional(Schema.Number),
  timePeriod: Schema.Struct({
  units: Schema.Literal("hours", "days", "testRuns"),
  value: Schema.Number
})
})),
  overTime: Schema.optional(Schema.Struct({
  timePeriod: Schema.Struct({
  units: Schema.Literal("hours", "days", "testRuns"),
  value: Schema.Number
}),
  values: Schema.Array(Schema.Struct({
  avgMs: Schema.Number,
  timestamp: Schema.String
}))
}))
})
}))),
  updated: Schema.String
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListTestsOverviewResponse" }) as unknown as Schema.Schema<ListTestsOverviewResponse>;

export const listTestsOverview: (
  input: ListTestsOverviewRequest
) => Effect.Effect<
  ListTestsOverviewResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListTestsOverviewRequest,
  output: ListTestsOverviewResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DexEndpointsTestsUniqueDevicesRequest {
  account_id: string;
  testName?: string;
  deviceId?: string[];
}

export const DexEndpointsTestsUniqueDevicesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  testName: Schema.optional(Schema.String).pipe(T.HttpQuery("testName")),
  deviceId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("deviceId"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/tests/unique-devices" }),
).annotations({ identifier: "DexEndpointsTestsUniqueDevicesRequest" }) as unknown as Schema.Schema<DexEndpointsTestsUniqueDevicesRequest>;

export interface DexEndpointsTestsUniqueDevicesResponse {
  result: { uniqueDevicesTotal: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DexEndpointsTestsUniqueDevicesResponse = Schema.Struct({
  result: Schema.Struct({
  uniqueDevicesTotal: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DexEndpointsTestsUniqueDevicesResponse" }) as unknown as Schema.Schema<DexEndpointsTestsUniqueDevicesResponse>;

export const dexEndpointsTestsUniqueDevices: (
  input: DexEndpointsTestsUniqueDevicesRequest
) => Effect.Effect<
  DexEndpointsTestsUniqueDevicesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DexEndpointsTestsUniqueDevicesRequest,
  output: DexEndpointsTestsUniqueDevicesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DexEndpointsTracerouteTestResultNetworkPathRequest {
  account_id: string;
  test_result_id: string;
}

export const DexEndpointsTracerouteTestResultNetworkPathRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  test_result_id: Schema.String.pipe(T.HttpPath("test_result_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/traceroute-test-results/{test_result_id}/network-path" }),
).annotations({ identifier: "DexEndpointsTracerouteTestResultNetworkPathRequest" }) as unknown as Schema.Schema<DexEndpointsTracerouteTestResultNetworkPathRequest>;

export interface DexEndpointsTracerouteTestResultNetworkPathResponse {
  result: { deviceName?: string; hops: { asn?: number; aso?: string; ipAddress?: string; location?: { city?: string; state?: string; zip?: string }; mile?: "client-to-app" | "client-to-cf-egress" | "client-to-cf-ingress" | "client-to-isp"; name?: string; packetLossPct?: number; rttMs?: number; ttl: number }[]; resultId: string; testId?: string; testName?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DexEndpointsTracerouteTestResultNetworkPathResponse = Schema.Struct({
  result: Schema.Struct({
  deviceName: Schema.optional(Schema.String),
  hops: Schema.Array(Schema.Struct({
  asn: Schema.optional(Schema.Number),
  aso: Schema.optional(Schema.String),
  ipAddress: Schema.optional(Schema.String),
  location: Schema.optional(Schema.Struct({
  city: Schema.optional(Schema.String),
  state: Schema.optional(Schema.String),
  zip: Schema.optional(Schema.String)
})),
  mile: Schema.optional(Schema.Literal("client-to-app", "client-to-cf-egress", "client-to-cf-ingress", "client-to-isp")),
  name: Schema.optional(Schema.String),
  packetLossPct: Schema.optional(Schema.Number),
  rttMs: Schema.optional(Schema.Number),
  ttl: Schema.Number
})),
  resultId: Schema.String,
  testId: Schema.optional(Schema.String),
  testName: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DexEndpointsTracerouteTestResultNetworkPathResponse" }) as unknown as Schema.Schema<DexEndpointsTracerouteTestResultNetworkPathResponse>;

export const dexEndpointsTracerouteTestResultNetworkPath: (
  input: DexEndpointsTracerouteTestResultNetworkPathRequest
) => Effect.Effect<
  DexEndpointsTracerouteTestResultNetworkPathResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DexEndpointsTracerouteTestResultNetworkPathRequest,
  output: DexEndpointsTracerouteTestResultNetworkPathResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DexEndpointsTracerouteTestDetailsRequest {
  account_id: string;
  test_id: string;
  deviceId?: string[];
  from: string;
  to: string;
  interval: "minute" | "hour";
  colo?: string;
}

export const DexEndpointsTracerouteTestDetailsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  test_id: Schema.String.pipe(T.HttpPath("test_id")),
  deviceId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("deviceId")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  interval: Schema.Literal("minute", "hour").pipe(T.HttpQuery("interval")),
  colo: Schema.optional(Schema.String).pipe(T.HttpQuery("colo"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/traceroute-tests/{test_id}" }),
).annotations({ identifier: "DexEndpointsTracerouteTestDetailsRequest" }) as unknown as Schema.Schema<DexEndpointsTracerouteTestDetailsRequest>;

export interface DexEndpointsTracerouteTestDetailsResponse {
  result: { host: string; interval: string; kind: "traceroute"; name: string; target_policies?: { default: boolean; id: string; name: string }[]; targeted?: boolean; tracerouteStats?: { availabilityPct: { avg?: number; max?: number; min?: number; slots: { timestamp: string; value: number }[] }; hopsCount: { avg?: number; max?: number; min?: number; slots: { timestamp: string; value: number }[] }; packetLossPct: { avg?: number; max?: number; min?: number; slots: { timestamp: string; value: number }[] }; roundTripTimeMs: { avg?: number; max?: number; min?: number; slots: { timestamp: string; value: number }[] }; uniqueDevicesTotal: number }; tracerouteStatsByColo?: { availabilityPct: { avg?: number; max?: number; min?: number; slots: { timestamp: string; value: number }[] }; colo: string; hopsCount: { avg?: number; max?: number; min?: number; slots: { timestamp: string; value: number }[] }; packetLossPct: { avg?: number; max?: number; min?: number; slots: { timestamp: string; value: number }[] }; roundTripTimeMs: { avg?: number; max?: number; min?: number; slots: { timestamp: string; value: number }[] }; uniqueDevicesTotal: number }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DexEndpointsTracerouteTestDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  host: Schema.String,
  interval: Schema.String,
  kind: Schema.Literal("traceroute"),
  name: Schema.String,
  target_policies: Schema.optional(Schema.Array(Schema.Struct({
  default: Schema.Boolean,
  id: Schema.String,
  name: Schema.String
}))),
  targeted: Schema.optional(Schema.Boolean),
  tracerouteStats: Schema.optional(Schema.Struct({
  availabilityPct: Schema.Struct({
  avg: Schema.optional(Schema.Number),
  max: Schema.optional(Schema.Number),
  min: Schema.optional(Schema.Number),
  slots: Schema.Array(Schema.Struct({
  timestamp: Schema.String,
  value: Schema.Number
}))
}),
  hopsCount: Schema.Struct({
  avg: Schema.optional(Schema.Number),
  max: Schema.optional(Schema.Number),
  min: Schema.optional(Schema.Number),
  slots: Schema.Array(Schema.Struct({
  timestamp: Schema.String,
  value: Schema.Number
}))
}),
  packetLossPct: Schema.Struct({
  avg: Schema.optional(Schema.Number),
  max: Schema.optional(Schema.Number),
  min: Schema.optional(Schema.Number),
  slots: Schema.Array(Schema.Struct({
  timestamp: Schema.String,
  value: Schema.Number
}))
}),
  roundTripTimeMs: Schema.Struct({
  avg: Schema.optional(Schema.Number),
  max: Schema.optional(Schema.Number),
  min: Schema.optional(Schema.Number),
  slots: Schema.Array(Schema.Struct({
  timestamp: Schema.String,
  value: Schema.Number
}))
}),
  uniqueDevicesTotal: Schema.Number
})),
  tracerouteStatsByColo: Schema.optional(Schema.Array(Schema.Struct({
  availabilityPct: Schema.Struct({
  avg: Schema.optional(Schema.Number),
  max: Schema.optional(Schema.Number),
  min: Schema.optional(Schema.Number),
  slots: Schema.Array(Schema.Struct({
  timestamp: Schema.String,
  value: Schema.Number
}))
}),
  colo: Schema.String,
  hopsCount: Schema.Struct({
  avg: Schema.optional(Schema.Number),
  max: Schema.optional(Schema.Number),
  min: Schema.optional(Schema.Number),
  slots: Schema.Array(Schema.Struct({
  timestamp: Schema.String,
  value: Schema.Number
}))
}),
  packetLossPct: Schema.Struct({
  avg: Schema.optional(Schema.Number),
  max: Schema.optional(Schema.Number),
  min: Schema.optional(Schema.Number),
  slots: Schema.Array(Schema.Struct({
  timestamp: Schema.String,
  value: Schema.Number
}))
}),
  roundTripTimeMs: Schema.Struct({
  avg: Schema.optional(Schema.Number),
  max: Schema.optional(Schema.Number),
  min: Schema.optional(Schema.Number),
  slots: Schema.Array(Schema.Struct({
  timestamp: Schema.String,
  value: Schema.Number
}))
}),
  uniqueDevicesTotal: Schema.Number
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DexEndpointsTracerouteTestDetailsResponse" }) as unknown as Schema.Schema<DexEndpointsTracerouteTestDetailsResponse>;

export const dexEndpointsTracerouteTestDetails: (
  input: DexEndpointsTracerouteTestDetailsRequest
) => Effect.Effect<
  DexEndpointsTracerouteTestDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DexEndpointsTracerouteTestDetailsRequest,
  output: DexEndpointsTracerouteTestDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DexEndpointsTracerouteTestNetworkPathRequest {
  account_id: string;
  test_id: string;
  deviceId: string;
  from: string;
  to: string;
  interval: "minute" | "hour";
}

export const DexEndpointsTracerouteTestNetworkPathRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  test_id: Schema.String.pipe(T.HttpPath("test_id")),
  deviceId: Schema.String.pipe(T.HttpQuery("deviceId")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  interval: Schema.Literal("minute", "hour").pipe(T.HttpQuery("interval"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/traceroute-tests/{test_id}/network-path" }),
).annotations({ identifier: "DexEndpointsTracerouteTestNetworkPathRequest" }) as unknown as Schema.Schema<DexEndpointsTracerouteTestNetworkPathRequest>;

export interface DexEndpointsTracerouteTestNetworkPathResponse {
  result: { deviceName?: string; id: string; interval?: string; kind?: "traceroute"; name?: string; networkPath?: { sampling?: { unit: "hours"; value: number }; slots: { clientToAppRttMs: number; clientToCfEgressRttMs: number; clientToCfIngressRttMs: number; clientToIspRttMs?: number; id: string; timestamp: string }[] }; url?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DexEndpointsTracerouteTestNetworkPathResponse = Schema.Struct({
  result: Schema.Struct({
  deviceName: Schema.optional(Schema.String),
  id: Schema.String,
  interval: Schema.optional(Schema.String),
  kind: Schema.optional(Schema.Literal("traceroute")),
  name: Schema.optional(Schema.String),
  networkPath: Schema.optional(Schema.Struct({
  sampling: Schema.optional(Schema.Struct({
  unit: Schema.Literal("hours"),
  value: Schema.Number
})),
  slots: Schema.Array(Schema.Struct({
  clientToAppRttMs: Schema.Number,
  clientToCfEgressRttMs: Schema.Number,
  clientToCfIngressRttMs: Schema.Number,
  clientToIspRttMs: Schema.optional(Schema.Number),
  id: Schema.String,
  timestamp: Schema.String
}))
})),
  url: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DexEndpointsTracerouteTestNetworkPathResponse" }) as unknown as Schema.Schema<DexEndpointsTracerouteTestNetworkPathResponse>;

export const dexEndpointsTracerouteTestNetworkPath: (
  input: DexEndpointsTracerouteTestNetworkPathRequest
) => Effect.Effect<
  DexEndpointsTracerouteTestNetworkPathResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DexEndpointsTracerouteTestNetworkPathRequest,
  output: DexEndpointsTracerouteTestNetworkPathResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DexEndpointsTracerouteTestPercentilesRequest {
  account_id: string;
  test_id: string;
  deviceId?: string[];
  from: string;
  to: string;
  colo?: string;
}

export const DexEndpointsTracerouteTestPercentilesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  test_id: Schema.String.pipe(T.HttpPath("test_id")),
  deviceId: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("deviceId")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  colo: Schema.optional(Schema.String).pipe(T.HttpQuery("colo"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/traceroute-tests/{test_id}/percentiles" }),
).annotations({ identifier: "DexEndpointsTracerouteTestPercentilesRequest" }) as unknown as Schema.Schema<DexEndpointsTracerouteTestPercentilesRequest>;

export interface DexEndpointsTracerouteTestPercentilesResponse {
  result: { hopsCount?: { p50?: number; p90?: number; p95?: number; p99?: number }; packetLossPct?: { p50?: number; p90?: number; p95?: number; p99?: number }; roundTripTimeMs?: { p50?: number; p90?: number; p95?: number; p99?: number } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DexEndpointsTracerouteTestPercentilesResponse = Schema.Struct({
  result: Schema.Struct({
  hopsCount: Schema.optional(Schema.Struct({
  p50: Schema.optional(Schema.Number),
  p90: Schema.optional(Schema.Number),
  p95: Schema.optional(Schema.Number),
  p99: Schema.optional(Schema.Number)
})),
  packetLossPct: Schema.optional(Schema.Struct({
  p50: Schema.optional(Schema.Number),
  p90: Schema.optional(Schema.Number),
  p95: Schema.optional(Schema.Number),
  p99: Schema.optional(Schema.Number)
})),
  roundTripTimeMs: Schema.optional(Schema.Struct({
  p50: Schema.optional(Schema.Number),
  p90: Schema.optional(Schema.Number),
  p95: Schema.optional(Schema.Number),
  p99: Schema.optional(Schema.Number)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DexEndpointsTracerouteTestPercentilesResponse" }) as unknown as Schema.Schema<DexEndpointsTracerouteTestPercentilesResponse>;

export const dexEndpointsTracerouteTestPercentiles: (
  input: DexEndpointsTracerouteTestPercentilesRequest
) => Effect.Effect<
  DexEndpointsTracerouteTestPercentilesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DexEndpointsTracerouteTestPercentilesRequest,
  output: DexEndpointsTracerouteTestPercentilesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListWarpChangeEventsRequest {
  account_id: string;
  page: number;
  per_page: number;
  from: string;
  to: string;
  type?: "config" | "toggle";
  toggle?: "on" | "off";
  config_name?: string;
  account_name?: string;
  sort_order?: "ASC" | "DESC";
}

export const ListWarpChangeEventsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.Number.pipe(T.HttpQuery("page")),
  per_page: Schema.Number.pipe(T.HttpQuery("per_page")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  type: Schema.optional(Schema.Literal("config", "toggle")).pipe(T.HttpQuery("type")),
  toggle: Schema.optional(Schema.Literal("on", "off")).pipe(T.HttpQuery("toggle")),
  config_name: Schema.optional(Schema.String).pipe(T.HttpQuery("config_name")),
  account_name: Schema.optional(Schema.String).pipe(T.HttpQuery("account_name")),
  sort_order: Schema.optional(Schema.Literal("ASC", "DESC")).pipe(T.HttpQuery("sort_order"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/warp-change-events" }),
).annotations({ identifier: "ListWarpChangeEventsRequest" }) as unknown as Schema.Schema<ListWarpChangeEventsRequest>;

export interface ListWarpChangeEventsResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListWarpChangeEventsResponse = Schema.Struct({
  result: Schema.Array(Schema.Union(Schema.Struct({
  account_name: Schema.optional(Schema.String),
  account_tag: Schema.optional(Schema.String),
  device_id: Schema.optional(Schema.String),
  device_registration: Schema.optional(Schema.String),
  hostname: Schema.optional(Schema.String),
  serial_number: Schema.optional(Schema.String),
  timestamp: Schema.optional(Schema.String),
  toggle: Schema.optional(Schema.Literal("on", "off")),
  user_email: Schema.optional(Schema.String)
}), Schema.Struct({
  device_id: Schema.optional(Schema.String),
  device_registration: Schema.optional(Schema.String),
  from: Schema.optional(Schema.Struct({
  account_name: Schema.optional(Schema.String),
  account_tag: Schema.optional(Schema.String),
  config_name: Schema.optional(Schema.String)
})),
  hostname: Schema.optional(Schema.String),
  serial_number: Schema.optional(Schema.String),
  timestamp: Schema.optional(Schema.String),
  to: Schema.optional(Schema.Struct({
  account_name: Schema.optional(Schema.String),
  account_tag: Schema.optional(Schema.String),
  config_name: Schema.optional(Schema.String)
})),
  user_email: Schema.optional(Schema.String)
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListWarpChangeEventsResponse" }) as unknown as Schema.Schema<ListWarpChangeEventsResponse>;

export const listWarpChangeEvents: (
  input: ListWarpChangeEventsRequest
) => Effect.Effect<
  ListWarpChangeEventsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListWarpChangeEventsRequest,
  output: ListWarpChangeEventsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List14Request {
  account_id: string;
}

export const List14Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/diagnostics/endpoint-healthchecks" }),
).annotations({ identifier: "List14Request" }) as unknown as Schema.Schema<List14Request>;

export interface List14Response {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List14Response = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List14Response" }) as unknown as Schema.Schema<List14Response>;

export const list14: (
  input: List14Request
) => Effect.Effect<
  List14Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List14Request,
  output: List14Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create2Request {
  account_id: string;
  body: { check_type: "icmp"; endpoint: string; name?: string };
}

export const Create2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  check_type: Schema.Literal("icmp"),
  endpoint: Schema.String,
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/diagnostics/endpoint-healthchecks" }),
).annotations({ identifier: "Create2Request" }) as unknown as Schema.Schema<Create2Request>;

export interface Create2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create2Response" }) as unknown as Schema.Schema<Create2Response>;

export const create2: (
  input: Create2Request
) => Effect.Effect<
  Create2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create2Request,
  output: Create2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_5Request {
  account_id: string;
  id: string;
}

export const Get_5Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.String.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/diagnostics/endpoint-healthchecks/{id}" }),
).annotations({ identifier: "Get_5Request" }) as unknown as Schema.Schema<Get_5Request>;

export interface Get_5Response {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_5Response = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_5Response" }) as unknown as Schema.Schema<Get_5Response>;

export const get_5: (
  input: Get_5Request
) => Effect.Effect<
  Get_5Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_5Request,
  output: Get_5Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update5Request {
  account_id: string;
  id: string;
  body: { check_type: "icmp"; endpoint: string; name?: string };
}

export const Update5Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.String.pipe(T.HttpPath("id")),
  body: Schema.Struct({
  check_type: Schema.Literal("icmp"),
  endpoint: Schema.String,
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/diagnostics/endpoint-healthchecks/{id}" }),
).annotations({ identifier: "Update5Request" }) as unknown as Schema.Schema<Update5Request>;

export interface Update5Response {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update5Response = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update5Response" }) as unknown as Schema.Schema<Update5Response>;

export const update5: (
  input: Update5Request
) => Effect.Effect<
  Update5Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update5Request,
  output: Update5Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_6Request {
  account_id: string;
  id: string;
}

export const Delete_6Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.String.pipe(T.HttpPath("id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/diagnostics/endpoint-healthchecks/{id}" }),
).annotations({ identifier: "Delete_6Request" }) as unknown as Schema.Schema<Delete_6Request>;

export interface Delete_6Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_6Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_6Response" }) as unknown as Schema.Schema<Delete_6Response>;

export const delete_6: (
  input: Delete_6Request
) => Effect.Effect<
  Delete_6Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_6Request,
  output: Delete_6Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DiagnosticsTracerouteRequest {
  account_id: string;
  body: unknown;
}

export const DiagnosticsTracerouteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/diagnostics/traceroute" }),
).annotations({ identifier: "DiagnosticsTracerouteRequest" }) as unknown as Schema.Schema<DiagnosticsTracerouteRequest>;

export interface DiagnosticsTracerouteResponse {
  result: { colos?: { colo?: { city?: string; name?: string }; error?: "" | "Could not gather traceroute data: Code 1" | "Could not gather traceroute data: Code 2" | "Could not gather traceroute data: Code 3" | "Could not gather traceroute data: Code 4"; hops?: { nodes?: { asn?: string; ip?: string; labels?: string[]; max_rtt_ms?: number; mean_rtt_ms?: number; min_rtt_ms?: number; name?: string; packet_count?: number; std_dev_rtt_ms?: number }[]; packets_lost?: number; packets_sent?: number; packets_ttl?: number }[]; target_summary?: Record<string, unknown>; traceroute_time_ms?: number }[]; target?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DiagnosticsTracerouteResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  colos: Schema.optional(Schema.Array(Schema.Struct({
  colo: Schema.optional(Schema.Struct({
  city: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
})),
  error: Schema.optional(Schema.Literal("", "Could not gather traceroute data: Code 1", "Could not gather traceroute data: Code 2", "Could not gather traceroute data: Code 3", "Could not gather traceroute data: Code 4")),
  hops: Schema.optional(Schema.Array(Schema.Struct({
  nodes: Schema.optional(Schema.Array(Schema.Struct({
  asn: Schema.optional(Schema.String),
  ip: Schema.optional(Schema.String),
  labels: Schema.optional(Schema.Array(Schema.String)),
  max_rtt_ms: Schema.optional(Schema.Number),
  mean_rtt_ms: Schema.optional(Schema.Number),
  min_rtt_ms: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  packet_count: Schema.optional(Schema.Number),
  std_dev_rtt_ms: Schema.optional(Schema.Number)
}))),
  packets_lost: Schema.optional(Schema.Number),
  packets_sent: Schema.optional(Schema.Number),
  packets_ttl: Schema.optional(Schema.Number)
}))),
  target_summary: Schema.optional(Schema.Struct({})),
  traceroute_time_ms: Schema.optional(Schema.Number)
}))),
  target: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DiagnosticsTracerouteResponse" }) as unknown as Schema.Schema<DiagnosticsTracerouteResponse>;

export const diagnosticsTraceroute: (
  input: DiagnosticsTracerouteRequest
) => Effect.Effect<
  DiagnosticsTracerouteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DiagnosticsTracerouteRequest,
  output: DiagnosticsTracerouteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DlpDatasetsReadAllRequest {
  account_id: string;
}

export const DlpDatasetsReadAllRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/datasets" }),
).annotations({ identifier: "DlpDatasetsReadAllRequest" }) as unknown as Schema.Schema<DlpDatasetsReadAllRequest>;

export interface DlpDatasetsReadAllResponse {
  result: { case_sensitive?: boolean; columns: { entry_id: string; header_name: string; num_cells: number; upload_status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete" }[]; created_at: string; description?: string; encoding_version: number; id: string; name: string; num_cells: number; secret: boolean; status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete"; updated_at: string; uploads: { num_cells: number; status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete"; version: number }[] }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DlpDatasetsReadAllResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  case_sensitive: Schema.optional(Schema.Boolean),
  columns: Schema.Array(Schema.Struct({
  entry_id: Schema.UUID,
  header_name: Schema.String,
  num_cells: Schema.Number,
  upload_status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete")
})),
  created_at: Schema.Date,
  description: Schema.optional(Schema.String),
  encoding_version: Schema.Number,
  id: Schema.UUID,
  name: Schema.String,
  num_cells: Schema.Number,
  secret: Schema.Boolean,
  status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete"),
  updated_at: Schema.Date,
  uploads: Schema.Array(Schema.Struct({
  num_cells: Schema.Number,
  status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete"),
  version: Schema.Number
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DlpDatasetsReadAllResponse" }) as unknown as Schema.Schema<DlpDatasetsReadAllResponse>;

export const dlpDatasetsReadAll: (
  input: DlpDatasetsReadAllRequest
) => Effect.Effect<
  DlpDatasetsReadAllResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DlpDatasetsReadAllRequest,
  output: DlpDatasetsReadAllResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create3Request {
  account_id: string;
  body: { case_sensitive?: boolean; description?: string; encoding_version?: number; name: string; secret?: boolean };
}

export const Create3Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  case_sensitive: Schema.optional(Schema.Boolean),
  description: Schema.optional(Schema.String),
  encoding_version: Schema.optional(Schema.Number),
  name: Schema.String,
  secret: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/datasets" }),
).annotations({ identifier: "Create3Request" }) as unknown as Schema.Schema<Create3Request>;

export interface Create3Response {
  result: { dataset: { case_sensitive?: boolean; columns: { entry_id: string; header_name: string; num_cells: number; upload_status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete" }[]; created_at: string; description?: string; encoding_version: number; id: string; name: string; num_cells: number; secret: boolean; status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete"; updated_at: string; uploads: { num_cells: number; status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete"; version: number }[] }; encoding_version: number; max_cells: number; secret?: string; version: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create3Response = Schema.Struct({
  result: Schema.Struct({
  dataset: Schema.Struct({
  case_sensitive: Schema.optional(Schema.Boolean),
  columns: Schema.Array(Schema.Struct({
  entry_id: Schema.UUID,
  header_name: Schema.String,
  num_cells: Schema.Number,
  upload_status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete")
})),
  created_at: Schema.Date,
  description: Schema.optional(Schema.String),
  encoding_version: Schema.Number,
  id: Schema.UUID,
  name: Schema.String,
  num_cells: Schema.Number,
  secret: Schema.Boolean,
  status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete"),
  updated_at: Schema.Date,
  uploads: Schema.Array(Schema.Struct({
  num_cells: Schema.Number,
  status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete"),
  version: Schema.Number
}))
}),
  encoding_version: Schema.Number,
  max_cells: Schema.Number,
  secret: Schema.optional(Schema.String),
  version: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create3Response" }) as unknown as Schema.Schema<Create3Response>;

export const create3: (
  input: Create3Request
) => Effect.Effect<
  Create3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create3Request,
  output: Create3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DlpDatasetsReadRequest {
  account_id: string;
  dataset_id: string;
}

export const DlpDatasetsReadRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/datasets/{dataset_id}" }),
).annotations({ identifier: "DlpDatasetsReadRequest" }) as unknown as Schema.Schema<DlpDatasetsReadRequest>;

export interface DlpDatasetsReadResponse {
  result: { case_sensitive?: boolean; columns: { entry_id: string; header_name: string; num_cells: number; upload_status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete" }[]; created_at: string; description?: string; encoding_version: number; id: string; name: string; num_cells: number; secret: boolean; status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete"; updated_at: string; uploads: { num_cells: number; status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete"; version: number }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DlpDatasetsReadResponse = Schema.Struct({
  result: Schema.Struct({
  case_sensitive: Schema.optional(Schema.Boolean),
  columns: Schema.Array(Schema.Struct({
  entry_id: Schema.UUID,
  header_name: Schema.String,
  num_cells: Schema.Number,
  upload_status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete")
})),
  created_at: Schema.Date,
  description: Schema.optional(Schema.String),
  encoding_version: Schema.Number,
  id: Schema.UUID,
  name: Schema.String,
  num_cells: Schema.Number,
  secret: Schema.Boolean,
  status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete"),
  updated_at: Schema.Date,
  uploads: Schema.Array(Schema.Struct({
  num_cells: Schema.Number,
  status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete"),
  version: Schema.Number
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DlpDatasetsReadResponse" }) as unknown as Schema.Schema<DlpDatasetsReadResponse>;

export const dlpDatasetsRead: (
  input: DlpDatasetsReadRequest
) => Effect.Effect<
  DlpDatasetsReadResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DlpDatasetsReadRequest,
  output: DlpDatasetsReadResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update6Request {
  account_id: string;
  dataset_id: string;
  body: { case_sensitive?: boolean; description?: string; name?: string };
}

export const Update6Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id")),
  body: Schema.Struct({
  case_sensitive: Schema.optional(Schema.Boolean),
  description: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/dlp/datasets/{dataset_id}" }),
).annotations({ identifier: "Update6Request" }) as unknown as Schema.Schema<Update6Request>;

export interface Update6Response {
  result: { case_sensitive?: boolean; columns: { entry_id: string; header_name: string; num_cells: number; upload_status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete" }[]; created_at: string; description?: string; encoding_version: number; id: string; name: string; num_cells: number; secret: boolean; status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete"; updated_at: string; uploads: { num_cells: number; status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete"; version: number }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update6Response = Schema.Struct({
  result: Schema.Struct({
  case_sensitive: Schema.optional(Schema.Boolean),
  columns: Schema.Array(Schema.Struct({
  entry_id: Schema.UUID,
  header_name: Schema.String,
  num_cells: Schema.Number,
  upload_status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete")
})),
  created_at: Schema.Date,
  description: Schema.optional(Schema.String),
  encoding_version: Schema.Number,
  id: Schema.UUID,
  name: Schema.String,
  num_cells: Schema.Number,
  secret: Schema.Boolean,
  status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete"),
  updated_at: Schema.Date,
  uploads: Schema.Array(Schema.Struct({
  num_cells: Schema.Number,
  status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete"),
  version: Schema.Number
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update6Response" }) as unknown as Schema.Schema<Update6Response>;

export const update6: (
  input: Update6Request
) => Effect.Effect<
  Update6Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update6Request,
  output: Update6Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_7Request {
  account_id: string;
  dataset_id: string;
}

export const Delete_7Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/dlp/datasets/{dataset_id}" }),
).annotations({ identifier: "Delete_7Request" }) as unknown as Schema.Schema<Delete_7Request>;

export interface Delete_7Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_7Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_7Response" }) as unknown as Schema.Schema<Delete_7Response>;

export const delete_7: (
  input: Delete_7Request
) => Effect.Effect<
  Delete_7Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_7Request,
  output: Delete_7Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateVersionRequest {
  account_id: string;
  dataset_id: string;
}

export const CreateVersionRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/datasets/{dataset_id}/upload" }),
).annotations({ identifier: "CreateVersionRequest" }) as unknown as Schema.Schema<CreateVersionRequest>;

export interface CreateVersionResponse {
  result: { case_sensitive?: boolean; columns?: { entry_id: string; header_name: string; num_cells: number; upload_status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete" }[]; encoding_version: number; max_cells: number; secret?: string; version: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateVersionResponse = Schema.Struct({
  result: Schema.Struct({
  case_sensitive: Schema.optional(Schema.Boolean),
  columns: Schema.optional(Schema.Array(Schema.Struct({
  entry_id: Schema.UUID,
  header_name: Schema.String,
  num_cells: Schema.Number,
  upload_status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete")
}))),
  encoding_version: Schema.Number,
  max_cells: Schema.Number,
  secret: Schema.optional(Schema.String),
  version: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateVersionResponse" }) as unknown as Schema.Schema<CreateVersionResponse>;

export const createVersion: (
  input: CreateVersionRequest
) => Effect.Effect<
  CreateVersionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateVersionRequest,
  output: CreateVersionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DlpDatasetsUploadVersionRequest {
  account_id: string;
  dataset_id: string;
  version: number;
}

export const DlpDatasetsUploadVersionRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id")),
  version: Schema.Number.pipe(T.HttpPath("version"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/datasets/{dataset_id}/upload/{version}" }),
).annotations({ identifier: "DlpDatasetsUploadVersionRequest" }) as unknown as Schema.Schema<DlpDatasetsUploadVersionRequest>;

export interface DlpDatasetsUploadVersionResponse {
  result: { case_sensitive?: boolean; columns: { entry_id: string; header_name: string; num_cells: number; upload_status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete" }[]; created_at: string; description?: string; encoding_version: number; id: string; name: string; num_cells: number; secret: boolean; status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete"; updated_at: string; uploads: { num_cells: number; status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete"; version: number }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DlpDatasetsUploadVersionResponse = Schema.Struct({
  result: Schema.Struct({
  case_sensitive: Schema.optional(Schema.Boolean),
  columns: Schema.Array(Schema.Struct({
  entry_id: Schema.UUID,
  header_name: Schema.String,
  num_cells: Schema.Number,
  upload_status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete")
})),
  created_at: Schema.Date,
  description: Schema.optional(Schema.String),
  encoding_version: Schema.Number,
  id: Schema.UUID,
  name: Schema.String,
  num_cells: Schema.Number,
  secret: Schema.Boolean,
  status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete"),
  updated_at: Schema.Date,
  uploads: Schema.Array(Schema.Struct({
  num_cells: Schema.Number,
  status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete"),
  version: Schema.Number
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DlpDatasetsUploadVersionResponse" }) as unknown as Schema.Schema<DlpDatasetsUploadVersionResponse>;

export const dlpDatasetsUploadVersion: (
  input: DlpDatasetsUploadVersionRequest
) => Effect.Effect<
  DlpDatasetsUploadVersionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DlpDatasetsUploadVersionRequest,
  output: DlpDatasetsUploadVersionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DlpDatasetsDefineColumnsRequest {
  account_id: string;
  dataset_id: string;
  version: number;
  body: unknown[];
}

export const DlpDatasetsDefineColumnsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id")),
  version: Schema.Number.pipe(T.HttpPath("version")),
  body: Schema.Array(Schema.Union(Schema.Struct({
  entry_id: Schema.UUID
}), Schema.Struct({
  entry_name: Schema.String
}))).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/datasets/{dataset_id}/versions/{version}" }),
).annotations({ identifier: "DlpDatasetsDefineColumnsRequest" }) as unknown as Schema.Schema<DlpDatasetsDefineColumnsRequest>;

export interface DlpDatasetsDefineColumnsResponse {
  result: { entry_id: string; header_name: string; num_cells: number; upload_status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DlpDatasetsDefineColumnsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  entry_id: Schema.UUID,
  header_name: Schema.String,
  num_cells: Schema.Number,
  upload_status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete")
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DlpDatasetsDefineColumnsResponse" }) as unknown as Schema.Schema<DlpDatasetsDefineColumnsResponse>;

export const dlpDatasetsDefineColumns: (
  input: DlpDatasetsDefineColumnsRequest
) => Effect.Effect<
  DlpDatasetsDefineColumnsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DlpDatasetsDefineColumnsRequest,
  output: DlpDatasetsDefineColumnsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DlpDatasetsUploadDatasetColumnRequest {
  account_id: string;
  dataset_id: string;
  version: number;
  entry_id: string;
}

export const DlpDatasetsUploadDatasetColumnRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dataset_id: Schema.UUID.pipe(T.HttpPath("dataset_id")),
  version: Schema.Number.pipe(T.HttpPath("version")),
  entry_id: Schema.UUID.pipe(T.HttpPath("entry_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/datasets/{dataset_id}/versions/{version}/entries/{entry_id}" }),
).annotations({ identifier: "DlpDatasetsUploadDatasetColumnRequest" }) as unknown as Schema.Schema<DlpDatasetsUploadDatasetColumnRequest>;

export interface DlpDatasetsUploadDatasetColumnResponse {
  result: { entry_id: string; header_name: string; num_cells: number; upload_status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DlpDatasetsUploadDatasetColumnResponse = Schema.Struct({
  result: Schema.Struct({
  entry_id: Schema.UUID,
  header_name: Schema.String,
  num_cells: Schema.Number,
  upload_status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DlpDatasetsUploadDatasetColumnResponse" }) as unknown as Schema.Schema<DlpDatasetsUploadDatasetColumnResponse>;

export const dlpDatasetsUploadDatasetColumn: (
  input: DlpDatasetsUploadDatasetColumnRequest
) => Effect.Effect<
  DlpDatasetsUploadDatasetColumnResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DlpDatasetsUploadDatasetColumnRequest,
  output: DlpDatasetsUploadDatasetColumnResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DlpDocumentFingerprintsReadAllRequest {
  account_id: string;
}

export const DlpDocumentFingerprintsReadAllRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/document_fingerprints" }),
).annotations({ identifier: "DlpDocumentFingerprintsReadAllRequest" }) as unknown as Schema.Schema<DlpDocumentFingerprintsReadAllRequest>;

export interface DlpDocumentFingerprintsReadAllResponse {
  result: { created_at: string; description: string; entry_id: string; file_name?: string; id: string; match_percent: number; name: string; status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete"; updated_at: string; version?: number }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DlpDocumentFingerprintsReadAllResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.Date,
  description: Schema.String,
  entry_id: Schema.UUID,
  file_name: Schema.optional(Schema.String),
  id: Schema.UUID,
  match_percent: Schema.Number,
  name: Schema.String,
  status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete"),
  updated_at: Schema.Date,
  version: Schema.optional(Schema.Number)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DlpDocumentFingerprintsReadAllResponse" }) as unknown as Schema.Schema<DlpDocumentFingerprintsReadAllResponse>;

export const dlpDocumentFingerprintsReadAll: (
  input: DlpDocumentFingerprintsReadAllRequest
) => Effect.Effect<
  DlpDocumentFingerprintsReadAllResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DlpDocumentFingerprintsReadAllRequest,
  output: DlpDocumentFingerprintsReadAllResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create4Request {
  account_id: string;
  body: { description?: string; match_percent: number; name: string };
}

export const Create4Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  match_percent: Schema.Number,
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/document_fingerprints" }),
).annotations({ identifier: "Create4Request" }) as unknown as Schema.Schema<Create4Request>;

export interface Create4Response {
  result: { created_at: string; description: string; entry_id: string; file_name?: string; id: string; match_percent: number; name: string; status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete"; updated_at: string; version?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create4Response = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  description: Schema.String,
  entry_id: Schema.UUID,
  file_name: Schema.optional(Schema.String),
  id: Schema.UUID,
  match_percent: Schema.Number,
  name: Schema.String,
  status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete"),
  updated_at: Schema.Date,
  version: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create4Response" }) as unknown as Schema.Schema<Create4Response>;

export const create4: (
  input: Create4Request
) => Effect.Effect<
  Create4Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create4Request,
  output: Create4Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DlpDocumentFingerprintsReadRequest {
  account_id: string;
  document_fingerprint_id: string;
}

export const DlpDocumentFingerprintsReadRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  document_fingerprint_id: Schema.UUID.pipe(T.HttpPath("document_fingerprint_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/document_fingerprints/{document_fingerprint_id}" }),
).annotations({ identifier: "DlpDocumentFingerprintsReadRequest" }) as unknown as Schema.Schema<DlpDocumentFingerprintsReadRequest>;

export interface DlpDocumentFingerprintsReadResponse {
  result: { created_at: string; description: string; entry_id: string; file_name?: string; id: string; match_percent: number; name: string; status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete"; updated_at: string; version?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DlpDocumentFingerprintsReadResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  description: Schema.String,
  entry_id: Schema.UUID,
  file_name: Schema.optional(Schema.String),
  id: Schema.UUID,
  match_percent: Schema.Number,
  name: Schema.String,
  status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete"),
  updated_at: Schema.Date,
  version: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DlpDocumentFingerprintsReadResponse" }) as unknown as Schema.Schema<DlpDocumentFingerprintsReadResponse>;

export const dlpDocumentFingerprintsRead: (
  input: DlpDocumentFingerprintsReadRequest
) => Effect.Effect<
  DlpDocumentFingerprintsReadResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DlpDocumentFingerprintsReadRequest,
  output: DlpDocumentFingerprintsReadResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update7Request {
  account_id: string;
  document_fingerprint_id: string;
  body: { description?: string; match_percent?: number; name?: string };
}

export const Update7Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  document_fingerprint_id: Schema.UUID.pipe(T.HttpPath("document_fingerprint_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  match_percent: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/document_fingerprints/{document_fingerprint_id}" }),
).annotations({ identifier: "Update7Request" }) as unknown as Schema.Schema<Update7Request>;

export interface Update7Response {
  result: { created_at: string; description: string; entry_id: string; file_name?: string; id: string; match_percent: number; name: string; status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete"; updated_at: string; version?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update7Response = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  description: Schema.String,
  entry_id: Schema.UUID,
  file_name: Schema.optional(Schema.String),
  id: Schema.UUID,
  match_percent: Schema.Number,
  name: Schema.String,
  status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete"),
  updated_at: Schema.Date,
  version: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update7Response" }) as unknown as Schema.Schema<Update7Response>;

export const update7: (
  input: Update7Request
) => Effect.Effect<
  Update7Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update7Request,
  output: Update7Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DlpDocumentFingerprintsUploadRequest {
  account_id: string;
  document_fingerprint_id: string;
  body: FormData;
}

export const DlpDocumentFingerprintsUploadRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  document_fingerprint_id: Schema.UUID.pipe(T.HttpPath("document_fingerprint_id")),
  body: Schema.instanceOf(FormData).pipe(T.HttpFormData())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/dlp/document_fingerprints/{document_fingerprint_id}" }),
).annotations({ identifier: "DlpDocumentFingerprintsUploadRequest" }) as unknown as Schema.Schema<DlpDocumentFingerprintsUploadRequest>;

export interface DlpDocumentFingerprintsUploadResponse {
  result: { created_at: string; description: string; entry_id: string; file_name: string; id: string; match_percent: number; name: string; status: "empty" | "uploading" | "pending" | "processing" | "failed" | "complete"; updated_at: string; version: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DlpDocumentFingerprintsUploadResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  description: Schema.String,
  entry_id: Schema.UUID,
  file_name: Schema.String,
  id: Schema.UUID,
  match_percent: Schema.Number,
  name: Schema.String,
  status: Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete"),
  updated_at: Schema.Date,
  version: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DlpDocumentFingerprintsUploadResponse" }) as unknown as Schema.Schema<DlpDocumentFingerprintsUploadResponse>;

export const dlpDocumentFingerprintsUpload: (
  input: DlpDocumentFingerprintsUploadRequest
) => Effect.Effect<
  DlpDocumentFingerprintsUploadResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DlpDocumentFingerprintsUploadRequest,
  output: DlpDocumentFingerprintsUploadResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_8Request {
  account_id: string;
  document_fingerprint_id: string;
}

export const Delete_8Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  document_fingerprint_id: Schema.UUID.pipe(T.HttpPath("document_fingerprint_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/dlp/document_fingerprints/{document_fingerprint_id}" }),
).annotations({ identifier: "Delete_8Request" }) as unknown as Schema.Schema<Delete_8Request>;

export interface Delete_8Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_8Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_8Response" }) as unknown as Schema.Schema<Delete_8Response>;

export const delete_8: (
  input: Delete_8Request
) => Effect.Effect<
  Delete_8Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_8Request,
  output: Delete_8Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountMappingRequest {
  account_id: string;
}

export const GetAccountMappingRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/email/account_mapping" }),
).annotations({ identifier: "GetAccountMappingRequest" }) as unknown as Schema.Schema<GetAccountMappingRequest>;

export interface GetAccountMappingResponse {
  result: { addin_identifier_token: string; auth_requirements: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountMappingResponse = Schema.Struct({
  result: Schema.Struct({
  addin_identifier_token: Schema.UUID,
  auth_requirements: Schema.Union(Schema.Struct({
  allowed_microsoft_organizations: Schema.Array(Schema.String),
  type: Schema.Literal("Org")
}), Schema.Struct({
  type: Schema.Literal("NoAuth")
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountMappingResponse" }) as unknown as Schema.Schema<GetAccountMappingResponse>;

export const getAccountMapping: (
  input: GetAccountMappingRequest
) => Effect.Effect<
  GetAccountMappingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountMappingRequest,
  output: GetAccountMappingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateAccountMappingRequest {
  account_id: string;
  body: { auth_requirements: unknown };
}

export const CreateAccountMappingRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  auth_requirements: Schema.Union(Schema.Struct({
  allowed_microsoft_organizations: Schema.Array(Schema.String),
  type: Schema.Literal("Org")
}), Schema.Struct({
  type: Schema.Literal("NoAuth")
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/email/account_mapping" }),
).annotations({ identifier: "CreateAccountMappingRequest" }) as unknown as Schema.Schema<CreateAccountMappingRequest>;

export interface CreateAccountMappingResponse {
  result: { addin_identifier_token: string; auth_requirements: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateAccountMappingResponse = Schema.Struct({
  result: Schema.Struct({
  addin_identifier_token: Schema.UUID,
  auth_requirements: Schema.Union(Schema.Struct({
  allowed_microsoft_organizations: Schema.Array(Schema.String),
  type: Schema.Literal("Org")
}), Schema.Struct({
  type: Schema.Literal("NoAuth")
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateAccountMappingResponse" }) as unknown as Schema.Schema<CreateAccountMappingResponse>;

export const createAccountMapping: (
  input: CreateAccountMappingRequest
) => Effect.Effect<
  CreateAccountMappingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccountMappingRequest,
  output: CreateAccountMappingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAllRulesRequest {
  account_id: string;
}

export const ListAllRulesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/email/rules" }),
).annotations({ identifier: "ListAllRulesRequest" }) as unknown as Schema.Schema<ListAllRulesRequest>;

export interface ListAllRulesResponse {
  result: { action: unknown; conditions: { operator: "InList" | "NotInList" | "MatchRegex" | "NotMatchRegex"; selector: "Recipients" | "Sender" | "DLPProfiles"; value: unknown }[]; created_at: string; description?: string; enabled: boolean; name: string; priority: number; rule_id: string; updated_at: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAllRulesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  action: Schema.Union(Schema.Struct({
  action: Schema.Literal("Block"),
  message: Schema.optional(Schema.String)
})),
  conditions: Schema.Array(Schema.Struct({
  operator: Schema.Literal("InList", "NotInList", "MatchRegex", "NotMatchRegex"),
  selector: Schema.Literal("Recipients", "Sender", "DLPProfiles"),
  value: Schema.Union(Schema.Array(Schema.String), Schema.String)
})),
  created_at: Schema.Date,
  description: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  name: Schema.String,
  priority: Schema.Number,
  rule_id: Schema.UUID,
  updated_at: Schema.Date
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAllRulesResponse" }) as unknown as Schema.Schema<ListAllRulesResponse>;

export const listAllRules: (
  input: ListAllRulesRequest
) => Effect.Effect<
  ListAllRulesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAllRulesRequest,
  output: ListAllRulesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateRuleRequest {
  account_id: string;
  body: { action: unknown; conditions: { operator: "InList" | "NotInList" | "MatchRegex" | "NotMatchRegex"; selector: "Recipients" | "Sender" | "DLPProfiles"; value: unknown }[]; description?: string; enabled: boolean; name: string };
}

export const CreateRuleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  action: Schema.Union(Schema.Struct({
  action: Schema.Literal("Block"),
  message: Schema.optional(Schema.String)
})),
  conditions: Schema.Array(Schema.Struct({
  operator: Schema.Literal("InList", "NotInList", "MatchRegex", "NotMatchRegex"),
  selector: Schema.Literal("Recipients", "Sender", "DLPProfiles"),
  value: Schema.Union(Schema.Array(Schema.String), Schema.String)
})),
  description: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/email/rules" }),
).annotations({ identifier: "CreateRuleRequest" }) as unknown as Schema.Schema<CreateRuleRequest>;

export interface CreateRuleResponse {
  result: { action: unknown; conditions: { operator: "InList" | "NotInList" | "MatchRegex" | "NotMatchRegex"; selector: "Recipients" | "Sender" | "DLPProfiles"; value: unknown }[]; created_at: string; description?: string; enabled: boolean; name: string; priority: number; rule_id: string; updated_at: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateRuleResponse = Schema.Struct({
  result: Schema.Struct({
  action: Schema.Union(Schema.Struct({
  action: Schema.Literal("Block"),
  message: Schema.optional(Schema.String)
})),
  conditions: Schema.Array(Schema.Struct({
  operator: Schema.Literal("InList", "NotInList", "MatchRegex", "NotMatchRegex"),
  selector: Schema.Literal("Recipients", "Sender", "DLPProfiles"),
  value: Schema.Union(Schema.Array(Schema.String), Schema.String)
})),
  created_at: Schema.Date,
  description: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  name: Schema.String,
  priority: Schema.Number,
  rule_id: Schema.UUID,
  updated_at: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateRuleResponse" }) as unknown as Schema.Schema<CreateRuleResponse>;

export const createRule: (
  input: CreateRuleRequest
) => Effect.Effect<
  CreateRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateRuleRequest,
  output: CreateRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateRulePrioritiesRequest {
  account_id: string;
  body: { new_priorities: Record<string, unknown> };
}

export const UpdateRulePrioritiesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  new_priorities: Schema.Record({ key: Schema.String, value: Schema.Number })
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/dlp/email/rules" }),
).annotations({ identifier: "UpdateRulePrioritiesRequest" }) as unknown as Schema.Schema<UpdateRulePrioritiesRequest>;

export interface UpdateRulePrioritiesResponse {
  result: { action: unknown; conditions: { operator: "InList" | "NotInList" | "MatchRegex" | "NotMatchRegex"; selector: "Recipients" | "Sender" | "DLPProfiles"; value: unknown }[]; created_at: string; description?: string; enabled: boolean; name: string; priority: number; rule_id: string; updated_at: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateRulePrioritiesResponse = Schema.Struct({
  result: Schema.Struct({
  action: Schema.Union(Schema.Struct({
  action: Schema.Literal("Block"),
  message: Schema.optional(Schema.String)
})),
  conditions: Schema.Array(Schema.Struct({
  operator: Schema.Literal("InList", "NotInList", "MatchRegex", "NotMatchRegex"),
  selector: Schema.Literal("Recipients", "Sender", "DLPProfiles"),
  value: Schema.Union(Schema.Array(Schema.String), Schema.String)
})),
  created_at: Schema.Date,
  description: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  name: Schema.String,
  priority: Schema.Number,
  rule_id: Schema.UUID,
  updated_at: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateRulePrioritiesResponse" }) as unknown as Schema.Schema<UpdateRulePrioritiesResponse>;

export const updateRulePriorities: (
  input: UpdateRulePrioritiesRequest
) => Effect.Effect<
  UpdateRulePrioritiesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateRulePrioritiesRequest,
  output: UpdateRulePrioritiesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetRuleRequest {
  account_id: string;
  rule_id: string;
}

export const GetRuleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  rule_id: Schema.UUID.pipe(T.HttpPath("rule_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/email/rules/{rule_id}" }),
).annotations({ identifier: "GetRuleRequest" }) as unknown as Schema.Schema<GetRuleRequest>;

export interface GetRuleResponse {
  result: { action: unknown; conditions: { operator: "InList" | "NotInList" | "MatchRegex" | "NotMatchRegex"; selector: "Recipients" | "Sender" | "DLPProfiles"; value: unknown }[]; created_at: string; description?: string; enabled: boolean; name: string; priority: number; rule_id: string; updated_at: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetRuleResponse = Schema.Struct({
  result: Schema.Struct({
  action: Schema.Union(Schema.Struct({
  action: Schema.Literal("Block"),
  message: Schema.optional(Schema.String)
})),
  conditions: Schema.Array(Schema.Struct({
  operator: Schema.Literal("InList", "NotInList", "MatchRegex", "NotMatchRegex"),
  selector: Schema.Literal("Recipients", "Sender", "DLPProfiles"),
  value: Schema.Union(Schema.Array(Schema.String), Schema.String)
})),
  created_at: Schema.Date,
  description: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  name: Schema.String,
  priority: Schema.Number,
  rule_id: Schema.UUID,
  updated_at: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetRuleResponse" }) as unknown as Schema.Schema<GetRuleResponse>;

export const getRule: (
  input: GetRuleRequest
) => Effect.Effect<
  GetRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRuleRequest,
  output: GetRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateRuleRequest {
  account_id: string;
  rule_id: string;
  body: { action: unknown; conditions: { operator: "InList" | "NotInList" | "MatchRegex" | "NotMatchRegex"; selector: "Recipients" | "Sender" | "DLPProfiles"; value: unknown }[]; description?: string; enabled: boolean; name: string };
}

export const UpdateRuleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  rule_id: Schema.UUID.pipe(T.HttpPath("rule_id")),
  body: Schema.Struct({
  action: Schema.Union(Schema.Struct({
  action: Schema.Literal("Block"),
  message: Schema.optional(Schema.String)
})),
  conditions: Schema.Array(Schema.Struct({
  operator: Schema.Literal("InList", "NotInList", "MatchRegex", "NotMatchRegex"),
  selector: Schema.Literal("Recipients", "Sender", "DLPProfiles"),
  value: Schema.Union(Schema.Array(Schema.String), Schema.String)
})),
  description: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/dlp/email/rules/{rule_id}" }),
).annotations({ identifier: "UpdateRuleRequest" }) as unknown as Schema.Schema<UpdateRuleRequest>;

export interface UpdateRuleResponse {
  result: { action: unknown; conditions: { operator: "InList" | "NotInList" | "MatchRegex" | "NotMatchRegex"; selector: "Recipients" | "Sender" | "DLPProfiles"; value: unknown }[]; created_at: string; description?: string; enabled: boolean; name: string; priority: number; rule_id: string; updated_at: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateRuleResponse = Schema.Struct({
  result: Schema.Struct({
  action: Schema.Union(Schema.Struct({
  action: Schema.Literal("Block"),
  message: Schema.optional(Schema.String)
})),
  conditions: Schema.Array(Schema.Struct({
  operator: Schema.Literal("InList", "NotInList", "MatchRegex", "NotMatchRegex"),
  selector: Schema.Literal("Recipients", "Sender", "DLPProfiles"),
  value: Schema.Union(Schema.Array(Schema.String), Schema.String)
})),
  created_at: Schema.Date,
  description: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  name: Schema.String,
  priority: Schema.Number,
  rule_id: Schema.UUID,
  updated_at: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateRuleResponse" }) as unknown as Schema.Schema<UpdateRuleResponse>;

export const updateRule: (
  input: UpdateRuleRequest
) => Effect.Effect<
  UpdateRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateRuleRequest,
  output: UpdateRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteRuleRequest {
  account_id: string;
  rule_id: string;
}

export const DeleteRuleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  rule_id: Schema.UUID.pipe(T.HttpPath("rule_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/dlp/email/rules/{rule_id}" }),
).annotations({ identifier: "DeleteRuleRequest" }) as unknown as Schema.Schema<DeleteRuleRequest>;

export interface DeleteRuleResponse {
  result: { action: unknown; conditions: { operator: "InList" | "NotInList" | "MatchRegex" | "NotMatchRegex"; selector: "Recipients" | "Sender" | "DLPProfiles"; value: unknown }[]; created_at: string; description?: string; enabled: boolean; name: string; priority: number; rule_id: string; updated_at: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteRuleResponse = Schema.Struct({
  result: Schema.Struct({
  action: Schema.Union(Schema.Struct({
  action: Schema.Literal("Block"),
  message: Schema.optional(Schema.String)
})),
  conditions: Schema.Array(Schema.Struct({
  operator: Schema.Literal("InList", "NotInList", "MatchRegex", "NotMatchRegex"),
  selector: Schema.Literal("Recipients", "Sender", "DLPProfiles"),
  value: Schema.Union(Schema.Array(Schema.String), Schema.String)
})),
  created_at: Schema.Date,
  description: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  name: Schema.String,
  priority: Schema.Number,
  rule_id: Schema.UUID,
  updated_at: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteRuleResponse" }) as unknown as Schema.Schema<DeleteRuleResponse>;

export const deleteRule: (
  input: DeleteRuleRequest
) => Effect.Effect<
  DeleteRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteRuleRequest,
  output: DeleteRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAllEntriesRequest {
  account_id: string;
}

export const ListAllEntriesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/entries" }),
).annotations({ identifier: "ListAllEntriesRequest" }) as unknown as Schema.Schema<ListAllEntriesRequest>;

export interface ListAllEntriesResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAllEntriesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  upload_status: Schema.optional(Schema.Literal("empty", "uploading", "pending", "processing", "failed", "complete"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAllEntriesResponse" }) as unknown as Schema.Schema<ListAllEntriesResponse>;

export const listAllEntries: (
  input: ListAllEntriesRequest
) => Effect.Effect<
  ListAllEntriesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAllEntriesRequest,
  output: ListAllEntriesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateEntryRequest {
  account_id: string;
  body: { enabled: boolean; name: string; pattern: { regex: string; validation?: unknown }; profile_id?: string };
}

export const CreateEntryRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  enabled: Schema.Boolean,
  name: Schema.String,
  pattern: Schema.Struct({
  regex: Schema.String,
  validation: Schema.optional(Schema.Literal("luhn"))
}),
  profile_id: Schema.optional(Schema.UUID)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/entries" }),
).annotations({ identifier: "CreateEntryRequest" }) as unknown as Schema.Schema<CreateEntryRequest>;

export interface CreateEntryResponse {
  result: { created_at: string; enabled: boolean; id: string; name: string; pattern: { regex: string; validation?: unknown }; profile_id?: string; updated_at: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateEntryResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  enabled: Schema.Boolean,
  id: Schema.UUID,
  name: Schema.String,
  pattern: Schema.Struct({
  regex: Schema.String,
  validation: Schema.optional(Schema.Literal("luhn"))
}),
  profile_id: Schema.optional(Schema.UUID),
  updated_at: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateEntryResponse" }) as unknown as Schema.Schema<CreateEntryResponse>;

export const createEntry: (
  input: CreateEntryRequest
) => Effect.Effect<
  CreateEntryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateEntryRequest,
  output: CreateEntryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateCustomEntryRequest {
  account_id: string;
  entry_id: string;
  body: unknown;
}

export const UpdateCustomEntryRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  entry_id: Schema.UUID.pipe(T.HttpPath("entry_id")),
  body: Schema.Struct({
  enabled: Schema.Boolean
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/dlp/entries/custom/{entry_id}" }),
).annotations({ identifier: "UpdateCustomEntryRequest" }) as unknown as Schema.Schema<UpdateCustomEntryRequest>;

export interface UpdateCustomEntryResponse {
  result: { created_at: string; enabled: boolean; id: string; name: string; pattern: { regex: string; validation?: unknown }; profile_id?: string; updated_at: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateCustomEntryResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  enabled: Schema.Boolean,
  id: Schema.UUID,
  name: Schema.String,
  pattern: Schema.Struct({
  regex: Schema.String,
  validation: Schema.optional(Schema.Literal("luhn"))
}),
  profile_id: Schema.optional(Schema.UUID),
  updated_at: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateCustomEntryResponse" }) as unknown as Schema.Schema<UpdateCustomEntryResponse>;

export const updateCustomEntry: (
  input: UpdateCustomEntryRequest
) => Effect.Effect<
  UpdateCustomEntryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateCustomEntryRequest,
  output: UpdateCustomEntryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateIntegrationEntryRequest {
  account_id: string;
  body: { enabled: boolean; entry_id: string; profile_id?: string };
}

export const CreateIntegrationEntryRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  enabled: Schema.Boolean,
  entry_id: Schema.UUID,
  profile_id: Schema.optional(Schema.UUID)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/entries/integration" }),
).annotations({ identifier: "CreateIntegrationEntryRequest" }) as unknown as Schema.Schema<CreateIntegrationEntryRequest>;

export interface CreateIntegrationEntryResponse {
  result: { created_at: string; enabled: boolean; id: string; name: string; profile_id?: string; updated_at: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateIntegrationEntryResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  enabled: Schema.Boolean,
  id: Schema.UUID,
  name: Schema.String,
  profile_id: Schema.optional(Schema.UUID),
  updated_at: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateIntegrationEntryResponse" }) as unknown as Schema.Schema<CreateIntegrationEntryResponse>;

export const createIntegrationEntry: (
  input: CreateIntegrationEntryRequest
) => Effect.Effect<
  CreateIntegrationEntryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateIntegrationEntryRequest,
  output: CreateIntegrationEntryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateIntegrationEntryRequest {
  account_id: string;
  entry_id: string;
  body: { enabled: boolean };
}

export const UpdateIntegrationEntryRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  entry_id: Schema.UUID.pipe(T.HttpPath("entry_id")),
  body: Schema.Struct({
  enabled: Schema.Boolean
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/dlp/entries/integration/{entry_id}" }),
).annotations({ identifier: "UpdateIntegrationEntryRequest" }) as unknown as Schema.Schema<UpdateIntegrationEntryRequest>;

export interface UpdateIntegrationEntryResponse {
  result: { created_at: string; enabled: boolean; id: string; name: string; profile_id?: string; updated_at: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateIntegrationEntryResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  enabled: Schema.Boolean,
  id: Schema.UUID,
  name: Schema.String,
  profile_id: Schema.optional(Schema.UUID),
  updated_at: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateIntegrationEntryResponse" }) as unknown as Schema.Schema<UpdateIntegrationEntryResponse>;

export const updateIntegrationEntry: (
  input: UpdateIntegrationEntryRequest
) => Effect.Effect<
  UpdateIntegrationEntryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateIntegrationEntryRequest,
  output: UpdateIntegrationEntryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteIntegrationEntryRequest {
  account_id: string;
  entry_id: string;
}

export const DeleteIntegrationEntryRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  entry_id: Schema.UUID.pipe(T.HttpPath("entry_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/dlp/entries/integration/{entry_id}" }),
).annotations({ identifier: "DeleteIntegrationEntryRequest" }) as unknown as Schema.Schema<DeleteIntegrationEntryRequest>;

export interface DeleteIntegrationEntryResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteIntegrationEntryResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteIntegrationEntryResponse" }) as unknown as Schema.Schema<DeleteIntegrationEntryResponse>;

export const deleteIntegrationEntry: (
  input: DeleteIntegrationEntryRequest
) => Effect.Effect<
  DeleteIntegrationEntryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteIntegrationEntryRequest,
  output: DeleteIntegrationEntryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatePredefinedEntryRequest {
  account_id: string;
  body: { enabled: boolean; entry_id: string; profile_id?: string };
}

export const CreatePredefinedEntryRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  enabled: Schema.Boolean,
  entry_id: Schema.UUID,
  profile_id: Schema.optional(Schema.UUID)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/entries/predefined" }),
).annotations({ identifier: "CreatePredefinedEntryRequest" }) as unknown as Schema.Schema<CreatePredefinedEntryRequest>;

export interface CreatePredefinedEntryResponse {
  result: { confidence: { ai_context_available: boolean; available: boolean }; enabled: boolean; id: string; name: string; profile_id?: string; variant?: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatePredefinedEntryResponse = Schema.Struct({
  result: Schema.Struct({
  confidence: Schema.Struct({
  ai_context_available: Schema.Boolean,
  available: Schema.Boolean
}),
  enabled: Schema.Boolean,
  id: Schema.UUID,
  name: Schema.String,
  profile_id: Schema.optional(Schema.UUID),
  variant: Schema.optional(Schema.Union(Schema.Struct({
  description: Schema.optional(Schema.String),
  topic_type: Schema.Literal("Intent", "Content"),
  type: Schema.Literal("PromptTopic")
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatePredefinedEntryResponse" }) as unknown as Schema.Schema<CreatePredefinedEntryResponse>;

export const createPredefinedEntry: (
  input: CreatePredefinedEntryRequest
) => Effect.Effect<
  CreatePredefinedEntryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatePredefinedEntryRequest,
  output: CreatePredefinedEntryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatePredefinedEntryRequest {
  account_id: string;
  entry_id: string;
  body: { enabled: boolean };
}

export const UpdatePredefinedEntryRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  entry_id: Schema.UUID.pipe(T.HttpPath("entry_id")),
  body: Schema.Struct({
  enabled: Schema.Boolean
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/dlp/entries/predefined/{entry_id}" }),
).annotations({ identifier: "UpdatePredefinedEntryRequest" }) as unknown as Schema.Schema<UpdatePredefinedEntryRequest>;

export interface UpdatePredefinedEntryResponse {
  result: { confidence: { ai_context_available: boolean; available: boolean }; enabled: boolean; id: string; name: string; profile_id?: string; variant?: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatePredefinedEntryResponse = Schema.Struct({
  result: Schema.Struct({
  confidence: Schema.Struct({
  ai_context_available: Schema.Boolean,
  available: Schema.Boolean
}),
  enabled: Schema.Boolean,
  id: Schema.UUID,
  name: Schema.String,
  profile_id: Schema.optional(Schema.UUID),
  variant: Schema.optional(Schema.Union(Schema.Struct({
  description: Schema.optional(Schema.String),
  topic_type: Schema.Literal("Intent", "Content"),
  type: Schema.Literal("PromptTopic")
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatePredefinedEntryResponse" }) as unknown as Schema.Schema<UpdatePredefinedEntryResponse>;

export const updatePredefinedEntry: (
  input: UpdatePredefinedEntryRequest
) => Effect.Effect<
  UpdatePredefinedEntryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatePredefinedEntryRequest,
  output: UpdatePredefinedEntryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletePredefinedEntryRequest {
  account_id: string;
  entry_id: string;
}

export const DeletePredefinedEntryRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  entry_id: Schema.UUID.pipe(T.HttpPath("entry_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/dlp/entries/predefined/{entry_id}" }),
).annotations({ identifier: "DeletePredefinedEntryRequest" }) as unknown as Schema.Schema<DeletePredefinedEntryRequest>;

export interface DeletePredefinedEntryResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletePredefinedEntryResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletePredefinedEntryResponse" }) as unknown as Schema.Schema<DeletePredefinedEntryResponse>;

export const deletePredefinedEntry: (
  input: DeletePredefinedEntryRequest
) => Effect.Effect<
  DeletePredefinedEntryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletePredefinedEntryRequest,
  output: DeletePredefinedEntryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDlpEntryRequest {
  account_id: string;
  entry_id: string;
}

export const GetDlpEntryRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  entry_id: Schema.UUID.pipe(T.HttpPath("entry_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/entries/{entry_id}" }),
).annotations({ identifier: "GetDlpEntryRequest" }) as unknown as Schema.Schema<GetDlpEntryRequest>;

export interface GetDlpEntryResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDlpEntryResponse = Schema.Struct({
  result: Schema.Struct({
  profiles: Schema.Array(Schema.Struct({
  id: Schema.UUID,
  name: Schema.String
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDlpEntryResponse" }) as unknown as Schema.Schema<GetDlpEntryResponse>;

export const getDlpEntry: (
  input: GetDlpEntryRequest
) => Effect.Effect<
  GetDlpEntryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDlpEntryRequest,
  output: GetDlpEntryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateEntryRequest {
  account_id: string;
  entry_id: string;
  body: unknown;
}

export const UpdateEntryRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  entry_id: Schema.UUID.pipe(T.HttpPath("entry_id")),
  body: Schema.Struct({
  enabled: Schema.Boolean
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/dlp/entries/{entry_id}" }),
).annotations({ identifier: "UpdateEntryRequest" }) as unknown as Schema.Schema<UpdateEntryRequest>;

export interface UpdateEntryResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateEntryResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  type: Schema.Literal("custom")
}), Schema.Struct({
  type: Schema.Literal("predefined")
}), Schema.Struct({
  type: Schema.Literal("integration")
}), Schema.Struct({
  type: Schema.Literal("exact_data")
}), Schema.Struct({
  type: Schema.Literal("document_fingerprint")
}), Schema.Struct({
  type: Schema.Literal("word_list")
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateEntryResponse" }) as unknown as Schema.Schema<UpdateEntryResponse>;

export const updateEntry: (
  input: UpdateEntryRequest
) => Effect.Effect<
  UpdateEntryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateEntryRequest,
  output: UpdateEntryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteEntryRequest {
  account_id: string;
  entry_id: string;
}

export const DeleteEntryRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  entry_id: Schema.UUID.pipe(T.HttpPath("entry_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/dlp/entries/{entry_id}" }),
).annotations({ identifier: "DeleteEntryRequest" }) as unknown as Schema.Schema<DeleteEntryRequest>;

export interface DeleteEntryResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteEntryResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteEntryResponse" }) as unknown as Schema.Schema<DeleteEntryResponse>;

export const deleteEntry: (
  input: DeleteEntryRequest
) => Effect.Effect<
  DeleteEntryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteEntryRequest,
  output: DeleteEntryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_6Request {
  account_id: string;
}

export const Get_6Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/limits" }),
).annotations({ identifier: "Get_6Request" }) as unknown as Schema.Schema<Get_6Request>;

export interface Get_6Response {
  result: { max_dataset_cells: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_6Response = Schema.Struct({
  result: Schema.Struct({
  max_dataset_cells: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_6Response" }) as unknown as Schema.Schema<Get_6Response>;

export const get_6: (
  input: Get_6Request
) => Effect.Effect<
  Get_6Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_6Request,
  output: Get_6Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DlpPatternValidateRequest {
  account_id: string;
  body: { max_match_bytes?: number; regex: string };
}

export const DlpPatternValidateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  max_match_bytes: Schema.optional(Schema.Number),
  regex: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/patterns/validate" }),
).annotations({ identifier: "DlpPatternValidateRequest" }) as unknown as Schema.Schema<DlpPatternValidateRequest>;

export interface DlpPatternValidateResponse {
  result: { valid: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DlpPatternValidateResponse = Schema.Struct({
  result: Schema.Struct({
  valid: Schema.Boolean
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DlpPatternValidateResponse" }) as unknown as Schema.Schema<DlpPatternValidateResponse>;

export const dlpPatternValidate: (
  input: DlpPatternValidateRequest
) => Effect.Effect<
  DlpPatternValidateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DlpPatternValidateRequest,
  output: DlpPatternValidateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_7Request {
  account_id: string;
}

export const Get_7Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/payload_log" }),
).annotations({ identifier: "Get_7Request" }) as unknown as Schema.Schema<Get_7Request>;

export interface Get_7Response {
  result: { public_key?: string; updated_at: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_7Response = Schema.Struct({
  result: Schema.Struct({
  public_key: Schema.optional(Schema.String),
  updated_at: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_7Response" }) as unknown as Schema.Schema<Get_7Response>;

export const get_7: (
  input: Get_7Request
) => Effect.Effect<
  Get_7Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_7Request,
  output: Get_7Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Put1Request {
  account_id: string;
  body: { public_key?: string };
}

export const Put1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  public_key: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/dlp/payload_log" }),
).annotations({ identifier: "Put1Request" }) as unknown as Schema.Schema<Put1Request>;

export interface Put1Response {
  result: { public_key?: string; updated_at: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Put1Response = Schema.Struct({
  result: Schema.Struct({
  public_key: Schema.optional(Schema.String),
  updated_at: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Put1Response" }) as unknown as Schema.Schema<Put1Response>;

export const put1: (
  input: Put1Request
) => Effect.Effect<
  Put1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Put1Request,
  output: Put1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAllProfilesRequest {
  all?: boolean;
  account_id: string;
}

export const ListAllProfilesRequest = Schema.Struct({
  all: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("all")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/profiles" }),
).annotations({ identifier: "ListAllProfilesRequest" }) as unknown as Schema.Schema<ListAllProfilesRequest>;

export interface ListAllProfilesResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAllProfilesResponse = Schema.Struct({
  result: Schema.Array(Schema.Union(Schema.Struct({
  type: Schema.Literal("custom")
}), Schema.Struct({
  type: Schema.Literal("predefined")
}), Schema.Struct({
  type: Schema.Literal("integration")
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAllProfilesResponse" }) as unknown as Schema.Schema<ListAllProfilesResponse>;

export const listAllProfiles: (
  input: ListAllProfilesRequest
) => Effect.Effect<
  ListAllProfilesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAllProfilesRequest,
  output: ListAllProfilesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAllCustomProfilesRequest {
  account_id: string;
}

export const ListAllCustomProfilesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/profiles/custom" }),
).annotations({ identifier: "ListAllCustomProfilesRequest" }) as unknown as Schema.Schema<ListAllCustomProfilesRequest>;

export interface ListAllCustomProfilesResponse {
  result: { ai_context_enabled?: boolean; allowed_match_count: number; confidence_threshold?: unknown; context_awareness?: { enabled: boolean; skip: { files: boolean } }; created_at: string; description?: string; entries?: unknown[]; id: string; name: string; ocr_enabled: boolean; updated_at: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAllCustomProfilesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  ai_context_enabled: Schema.optional(Schema.Boolean),
  allowed_match_count: Schema.Number,
  confidence_threshold: Schema.optional(Schema.Literal("low", "medium", "high", "very_high")),
  context_awareness: Schema.optional(Schema.Struct({
  enabled: Schema.Boolean,
  skip: Schema.Struct({
  files: Schema.Boolean
})
})),
  created_at: Schema.Date,
  description: Schema.optional(Schema.String),
  entries: Schema.optional(Schema.Array(Schema.Union(Schema.Struct({
  type: Schema.Literal("custom")
}), Schema.Struct({
  type: Schema.Literal("predefined")
}), Schema.Struct({
  type: Schema.Literal("integration")
}), Schema.Struct({
  type: Schema.Literal("exact_data")
}), Schema.Struct({
  type: Schema.Literal("document_fingerprint")
}), Schema.Struct({
  type: Schema.Literal("word_list")
})))),
  id: Schema.UUID,
  name: Schema.String,
  ocr_enabled: Schema.Boolean,
  updated_at: Schema.Date
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAllCustomProfilesResponse" }) as unknown as Schema.Schema<ListAllCustomProfilesResponse>;

export const listAllCustomProfiles: (
  input: ListAllCustomProfilesRequest
) => Effect.Effect<
  ListAllCustomProfilesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAllCustomProfilesRequest,
  output: ListAllCustomProfilesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateCustomProfilesRequest {
  account_id: string;
  body: { ai_context_enabled?: boolean; allowed_match_count?: number; confidence_threshold?: string; context_awareness?: { enabled: boolean; skip: { files: boolean } }; description?: string; entries?: unknown[]; name: string; ocr_enabled?: boolean; shared_entries?: unknown[] };
}

export const CreateCustomProfilesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  ai_context_enabled: Schema.optional(Schema.Boolean),
  allowed_match_count: Schema.optional(Schema.Number),
  confidence_threshold: Schema.optional(Schema.String),
  context_awareness: Schema.optional(Schema.Struct({
  enabled: Schema.Boolean,
  skip: Schema.Struct({
  files: Schema.Boolean
})
})),
  description: Schema.optional(Schema.String),
  entries: Schema.optional(Schema.Array(Schema.Union(Schema.Struct({
  enabled: Schema.Boolean,
  name: Schema.String,
  pattern: Schema.Struct({
  regex: Schema.String,
  validation: Schema.optional(Schema.Literal("luhn"))
})
}), Schema.Struct({
  enabled: Schema.Boolean,
  name: Schema.String,
  words: Schema.Array(Schema.String)
})))),
  name: Schema.String,
  ocr_enabled: Schema.optional(Schema.Boolean),
  shared_entries: Schema.optional(Schema.Array(Schema.Union(Schema.Struct({
  enabled: Schema.Boolean,
  entry_id: Schema.UUID,
  entry_type: Schema.Literal("custom")
}), Schema.Struct({
  enabled: Schema.Boolean,
  entry_id: Schema.UUID,
  entry_type: Schema.Literal("predefined")
}), Schema.Struct({
  enabled: Schema.Boolean,
  entry_id: Schema.UUID,
  entry_type: Schema.Literal("integration")
}), Schema.Struct({
  enabled: Schema.Boolean,
  entry_id: Schema.UUID,
  entry_type: Schema.Literal("exact_data")
}), Schema.Struct({
  enabled: Schema.Boolean,
  entry_id: Schema.UUID,
  entry_type: Schema.Literal("document_fingerprint")
}))))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/profiles/custom" }),
).annotations({ identifier: "CreateCustomProfilesRequest" }) as unknown as Schema.Schema<CreateCustomProfilesRequest>;

export interface CreateCustomProfilesResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateCustomProfilesResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  type: Schema.Literal("custom")
}), Schema.Struct({
  type: Schema.Literal("predefined")
}), Schema.Struct({
  type: Schema.Literal("integration")
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateCustomProfilesResponse" }) as unknown as Schema.Schema<CreateCustomProfilesResponse>;

export const createCustomProfiles: (
  input: CreateCustomProfilesRequest
) => Effect.Effect<
  CreateCustomProfilesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateCustomProfilesRequest,
  output: CreateCustomProfilesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetCustomProfileRequest {
  account_id: string;
  profile_id: string;
}

export const GetCustomProfileRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  profile_id: Schema.UUID.pipe(T.HttpPath("profile_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/profiles/custom/{profile_id}" }),
).annotations({ identifier: "GetCustomProfileRequest" }) as unknown as Schema.Schema<GetCustomProfileRequest>;

export interface GetCustomProfileResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetCustomProfileResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  type: Schema.Literal("custom")
}), Schema.Struct({
  type: Schema.Literal("predefined")
}), Schema.Struct({
  type: Schema.Literal("integration")
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetCustomProfileResponse" }) as unknown as Schema.Schema<GetCustomProfileResponse>;

export const getCustomProfile: (
  input: GetCustomProfileRequest
) => Effect.Effect<
  GetCustomProfileResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetCustomProfileRequest,
  output: GetCustomProfileResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateCustomProfileRequest {
  account_id: string;
  profile_id: string;
  body: { ai_context_enabled?: boolean; allowed_match_count?: number; confidence_threshold?: string; context_awareness?: { enabled: boolean; skip: { files: boolean } }; description?: string; entries?: unknown[]; name: string; ocr_enabled?: boolean; shared_entries?: unknown[] };
}

export const UpdateCustomProfileRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  profile_id: Schema.UUID.pipe(T.HttpPath("profile_id")),
  body: Schema.Struct({
  ai_context_enabled: Schema.optional(Schema.Boolean),
  allowed_match_count: Schema.optional(Schema.Number),
  confidence_threshold: Schema.optional(Schema.String),
  context_awareness: Schema.optional(Schema.Struct({
  enabled: Schema.Boolean,
  skip: Schema.Struct({
  files: Schema.Boolean
})
})),
  description: Schema.optional(Schema.String),
  entries: Schema.optional(Schema.Array(Schema.Union(Schema.Struct({
  entry_id: Schema.UUID
}), Schema.Struct({
  enabled: Schema.Boolean,
  name: Schema.String,
  pattern: Schema.Struct({
  regex: Schema.String,
  validation: Schema.optional(Schema.Literal("luhn"))
})
})))),
  name: Schema.String,
  ocr_enabled: Schema.optional(Schema.Boolean),
  shared_entries: Schema.optional(Schema.Array(Schema.Union(Schema.Struct({
  enabled: Schema.Boolean,
  entry_id: Schema.UUID,
  entry_type: Schema.Literal("predefined")
}), Schema.Struct({
  enabled: Schema.Boolean,
  entry_id: Schema.UUID,
  entry_type: Schema.Literal("integration")
}), Schema.Struct({
  enabled: Schema.Boolean,
  entry_id: Schema.UUID,
  entry_type: Schema.Literal("exact_data")
}), Schema.Struct({
  enabled: Schema.Boolean,
  entry_id: Schema.UUID,
  entry_type: Schema.Literal("document_fingerprint")
}))))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/dlp/profiles/custom/{profile_id}" }),
).annotations({ identifier: "UpdateCustomProfileRequest" }) as unknown as Schema.Schema<UpdateCustomProfileRequest>;

export interface UpdateCustomProfileResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateCustomProfileResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  type: Schema.Literal("custom")
}), Schema.Struct({
  type: Schema.Literal("predefined")
}), Schema.Struct({
  type: Schema.Literal("integration")
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateCustomProfileResponse" }) as unknown as Schema.Schema<UpdateCustomProfileResponse>;

export const updateCustomProfile: (
  input: UpdateCustomProfileRequest
) => Effect.Effect<
  UpdateCustomProfileResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateCustomProfileRequest,
  output: UpdateCustomProfileResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteCustomProfileRequest {
  account_id: string;
  profile_id: string;
}

export const DeleteCustomProfileRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  profile_id: Schema.UUID.pipe(T.HttpPath("profile_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/dlp/profiles/custom/{profile_id}" }),
).annotations({ identifier: "DeleteCustomProfileRequest" }) as unknown as Schema.Schema<DeleteCustomProfileRequest>;

export interface DeleteCustomProfileResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteCustomProfileResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteCustomProfileResponse" }) as unknown as Schema.Schema<DeleteCustomProfileResponse>;

export const deleteCustomProfile: (
  input: DeleteCustomProfileRequest
) => Effect.Effect<
  DeleteCustomProfileResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteCustomProfileRequest,
  output: DeleteCustomProfileResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatePredefinedProfileRequest {
  account_id: string;
  body: unknown;
}

export const CreatePredefinedProfileRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  profile_id: Schema.UUID
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/profiles/predefined" }),
).annotations({ identifier: "CreatePredefinedProfileRequest" }) as unknown as Schema.Schema<CreatePredefinedProfileRequest>;

export interface CreatePredefinedProfileResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatePredefinedProfileResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  type: Schema.Literal("custom")
}), Schema.Struct({
  type: Schema.Literal("predefined")
}), Schema.Struct({
  type: Schema.Literal("integration")
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatePredefinedProfileResponse" }) as unknown as Schema.Schema<CreatePredefinedProfileResponse>;

export const createPredefinedProfile: (
  input: CreatePredefinedProfileRequest
) => Effect.Effect<
  CreatePredefinedProfileResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatePredefinedProfileRequest,
  output: CreatePredefinedProfileResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetPredefinedProfileRequest {
  account_id: string;
  profile_id: string;
}

export const GetPredefinedProfileRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  profile_id: Schema.UUID.pipe(T.HttpPath("profile_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/profiles/predefined/{profile_id}" }),
).annotations({ identifier: "GetPredefinedProfileRequest" }) as unknown as Schema.Schema<GetPredefinedProfileRequest>;

export interface GetPredefinedProfileResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetPredefinedProfileResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  type: Schema.Literal("custom")
}), Schema.Struct({
  type: Schema.Literal("predefined")
}), Schema.Struct({
  type: Schema.Literal("integration")
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetPredefinedProfileResponse" }) as unknown as Schema.Schema<GetPredefinedProfileResponse>;

export const getPredefinedProfile: (
  input: GetPredefinedProfileRequest
) => Effect.Effect<
  GetPredefinedProfileResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetPredefinedProfileRequest,
  output: GetPredefinedProfileResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatePredefinedProfileRequest {
  account_id: string;
  profile_id: string;
  body: { ai_context_enabled?: boolean; allowed_match_count?: number; confidence_threshold?: string; context_awareness?: { enabled: boolean; skip: { files: boolean } }; entries?: { enabled: boolean; id: string }[]; ocr_enabled?: boolean };
}

export const UpdatePredefinedProfileRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  profile_id: Schema.UUID.pipe(T.HttpPath("profile_id")),
  body: Schema.Struct({
  ai_context_enabled: Schema.optional(Schema.Boolean),
  allowed_match_count: Schema.optional(Schema.Number),
  confidence_threshold: Schema.optional(Schema.String),
  context_awareness: Schema.optional(Schema.Struct({
  enabled: Schema.Boolean,
  skip: Schema.Struct({
  files: Schema.Boolean
})
})),
  entries: Schema.optional(Schema.Array(Schema.Struct({
  enabled: Schema.Boolean,
  id: Schema.UUID
}))),
  ocr_enabled: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/dlp/profiles/predefined/{profile_id}" }),
).annotations({ identifier: "UpdatePredefinedProfileRequest" }) as unknown as Schema.Schema<UpdatePredefinedProfileRequest>;

export interface UpdatePredefinedProfileResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatePredefinedProfileResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  type: Schema.Literal("custom")
}), Schema.Struct({
  type: Schema.Literal("predefined")
}), Schema.Struct({
  type: Schema.Literal("integration")
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatePredefinedProfileResponse" }) as unknown as Schema.Schema<UpdatePredefinedProfileResponse>;

export const updatePredefinedProfile: (
  input: UpdatePredefinedProfileRequest
) => Effect.Effect<
  UpdatePredefinedProfileResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatePredefinedProfileRequest,
  output: UpdatePredefinedProfileResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletePredefinedProfileRequest {
  account_id: string;
  profile_id: string;
}

export const DeletePredefinedProfileRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  profile_id: Schema.UUID.pipe(T.HttpPath("profile_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/dlp/profiles/predefined/{profile_id}" }),
).annotations({ identifier: "DeletePredefinedProfileRequest" }) as unknown as Schema.Schema<DeletePredefinedProfileRequest>;

export interface DeletePredefinedProfileResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletePredefinedProfileResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletePredefinedProfileResponse" }) as unknown as Schema.Schema<DeletePredefinedProfileResponse>;

export const deletePredefinedProfile: (
  input: DeletePredefinedProfileRequest
) => Effect.Effect<
  DeletePredefinedProfileResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletePredefinedProfileRequest,
  output: DeletePredefinedProfileResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetPredefinedProfileConfigRequest {
  account_id: string;
  profile_id: string;
}

export const GetPredefinedProfileConfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  profile_id: Schema.UUID.pipe(T.HttpPath("profile_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/profiles/predefined/{profile_id}/config" }),
).annotations({ identifier: "GetPredefinedProfileConfigRequest" }) as unknown as Schema.Schema<GetPredefinedProfileConfigRequest>;

export interface GetPredefinedProfileConfigResponse {
  result: { ai_context_enabled?: boolean; allowed_match_count: number; confidence_threshold: string; enabled_entries: string[]; entries: unknown[]; id: string; name: string; ocr_enabled?: boolean; open_access?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetPredefinedProfileConfigResponse = Schema.Struct({
  result: Schema.Struct({
  ai_context_enabled: Schema.optional(Schema.Boolean),
  allowed_match_count: Schema.Number,
  confidence_threshold: Schema.String,
  enabled_entries: Schema.Array(Schema.UUID),
  entries: Schema.Array(Schema.Union(Schema.Struct({
  type: Schema.Literal("custom")
}), Schema.Struct({
  type: Schema.Literal("predefined")
}), Schema.Struct({
  type: Schema.Literal("integration")
}), Schema.Struct({
  type: Schema.Literal("exact_data")
}), Schema.Struct({
  type: Schema.Literal("document_fingerprint")
}), Schema.Struct({
  type: Schema.Literal("word_list")
}))),
  id: Schema.UUID,
  name: Schema.String,
  ocr_enabled: Schema.optional(Schema.Boolean),
  open_access: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetPredefinedProfileConfigResponse" }) as unknown as Schema.Schema<GetPredefinedProfileConfigResponse>;

export const getPredefinedProfileConfig: (
  input: GetPredefinedProfileConfigRequest
) => Effect.Effect<
  GetPredefinedProfileConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetPredefinedProfileConfigRequest,
  output: GetPredefinedProfileConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatePredefinedProfileConfigRequest {
  account_id: string;
  profile_id: string;
  body: { ai_context_enabled?: boolean; allowed_match_count?: number; confidence_threshold?: string; enabled_entries?: string[]; entries?: { enabled: boolean; id: string }[]; ocr_enabled?: boolean };
}

export const CreatePredefinedProfileConfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  profile_id: Schema.UUID.pipe(T.HttpPath("profile_id")),
  body: Schema.Struct({
  ai_context_enabled: Schema.optional(Schema.Boolean),
  allowed_match_count: Schema.optional(Schema.Number),
  confidence_threshold: Schema.optional(Schema.String),
  enabled_entries: Schema.optional(Schema.Array(Schema.UUID)),
  entries: Schema.optional(Schema.Array(Schema.Struct({
  enabled: Schema.Boolean,
  id: Schema.UUID
}))),
  ocr_enabled: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/profiles/predefined/{profile_id}/config" }),
).annotations({ identifier: "CreatePredefinedProfileConfigRequest" }) as unknown as Schema.Schema<CreatePredefinedProfileConfigRequest>;

export interface CreatePredefinedProfileConfigResponse {
  result: { ai_context_enabled?: boolean; allowed_match_count: number; confidence_threshold: string; enabled_entries: string[]; entries: unknown[]; id: string; name: string; ocr_enabled?: boolean; open_access?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatePredefinedProfileConfigResponse = Schema.Struct({
  result: Schema.Struct({
  ai_context_enabled: Schema.optional(Schema.Boolean),
  allowed_match_count: Schema.Number,
  confidence_threshold: Schema.String,
  enabled_entries: Schema.Array(Schema.UUID),
  entries: Schema.Array(Schema.Union(Schema.Struct({
  type: Schema.Literal("custom")
}), Schema.Struct({
  type: Schema.Literal("predefined")
}), Schema.Struct({
  type: Schema.Literal("integration")
}), Schema.Struct({
  type: Schema.Literal("exact_data")
}), Schema.Struct({
  type: Schema.Literal("document_fingerprint")
}), Schema.Struct({
  type: Schema.Literal("word_list")
}))),
  id: Schema.UUID,
  name: Schema.String,
  ocr_enabled: Schema.optional(Schema.Boolean),
  open_access: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatePredefinedProfileConfigResponse" }) as unknown as Schema.Schema<CreatePredefinedProfileConfigResponse>;

export const createPredefinedProfileConfig: (
  input: CreatePredefinedProfileConfigRequest
) => Effect.Effect<
  CreatePredefinedProfileConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatePredefinedProfileConfigRequest,
  output: CreatePredefinedProfileConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatePredefinedProfileConfigRequest {
  account_id: string;
  profile_id: string;
  body: { ai_context_enabled?: boolean; allowed_match_count?: number; confidence_threshold?: string; enabled_entries?: string[]; entries?: { enabled: boolean; id: string }[]; ocr_enabled?: boolean };
}

export const UpdatePredefinedProfileConfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  profile_id: Schema.UUID.pipe(T.HttpPath("profile_id")),
  body: Schema.Struct({
  ai_context_enabled: Schema.optional(Schema.Boolean),
  allowed_match_count: Schema.optional(Schema.Number),
  confidence_threshold: Schema.optional(Schema.String),
  enabled_entries: Schema.optional(Schema.Array(Schema.UUID)),
  entries: Schema.optional(Schema.Array(Schema.Struct({
  enabled: Schema.Boolean,
  id: Schema.UUID
}))),
  ocr_enabled: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/dlp/profiles/predefined/{profile_id}/config" }),
).annotations({ identifier: "UpdatePredefinedProfileConfigRequest" }) as unknown as Schema.Schema<UpdatePredefinedProfileConfigRequest>;

export interface UpdatePredefinedProfileConfigResponse {
  result: { ai_context_enabled?: boolean; allowed_match_count: number; confidence_threshold: string; enabled_entries: string[]; entries: unknown[]; id: string; name: string; ocr_enabled?: boolean; open_access?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatePredefinedProfileConfigResponse = Schema.Struct({
  result: Schema.Struct({
  ai_context_enabled: Schema.optional(Schema.Boolean),
  allowed_match_count: Schema.Number,
  confidence_threshold: Schema.String,
  enabled_entries: Schema.Array(Schema.UUID),
  entries: Schema.Array(Schema.Union(Schema.Struct({
  type: Schema.Literal("custom")
}), Schema.Struct({
  type: Schema.Literal("predefined")
}), Schema.Struct({
  type: Schema.Literal("integration")
}), Schema.Struct({
  type: Schema.Literal("exact_data")
}), Schema.Struct({
  type: Schema.Literal("document_fingerprint")
}), Schema.Struct({
  type: Schema.Literal("word_list")
}))),
  id: Schema.UUID,
  name: Schema.String,
  ocr_enabled: Schema.optional(Schema.Boolean),
  open_access: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatePredefinedProfileConfigResponse" }) as unknown as Schema.Schema<UpdatePredefinedProfileConfigResponse>;

export const updatePredefinedProfileConfig: (
  input: UpdatePredefinedProfileConfigRequest
) => Effect.Effect<
  UpdatePredefinedProfileConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatePredefinedProfileConfigRequest,
  output: UpdatePredefinedProfileConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDlpProfileRequest {
  account_id: string;
  profile_id: string;
}

export const GetDlpProfileRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  profile_id: Schema.UUID.pipe(T.HttpPath("profile_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/profiles/{profile_id}" }),
).annotations({ identifier: "GetDlpProfileRequest" }) as unknown as Schema.Schema<GetDlpProfileRequest>;

export interface GetDlpProfileResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDlpProfileResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  type: Schema.Literal("custom")
}), Schema.Struct({
  type: Schema.Literal("predefined")
}), Schema.Struct({
  type: Schema.Literal("integration")
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDlpProfileResponse" }) as unknown as Schema.Schema<GetDlpProfileResponse>;

export const getDlpProfile: (
  input: GetDlpProfileRequest
) => Effect.Effect<
  GetDlpProfileResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDlpProfileRequest,
  output: GetDlpProfileResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDnsFirewallClustersRequest {
  account_id: string;
  page?: number;
  per_page?: number;
}

export const ListDnsFirewallClustersRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dns_firewall" }),
).annotations({ identifier: "ListDnsFirewallClustersRequest" }) as unknown as Schema.Schema<ListDnsFirewallClustersRequest>;

export interface ListDnsFirewallClustersResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDnsFirewallClustersResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDnsFirewallClustersResponse" }) as unknown as Schema.Schema<ListDnsFirewallClustersResponse>;

export const listDnsFirewallClusters: (
  input: ListDnsFirewallClustersRequest
) => Effect.Effect<
  ListDnsFirewallClustersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDnsFirewallClustersRequest,
  output: ListDnsFirewallClustersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateDnsFirewallClusterRequest {
  account_id: string;
  body: Record<string, unknown>;
}

export const CreateDnsFirewallClusterRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dns_firewall" }),
).annotations({ identifier: "CreateDnsFirewallClusterRequest" }) as unknown as Schema.Schema<CreateDnsFirewallClusterRequest>;

export interface CreateDnsFirewallClusterResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateDnsFirewallClusterResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateDnsFirewallClusterResponse" }) as unknown as Schema.Schema<CreateDnsFirewallClusterResponse>;

export const createDnsFirewallCluster: (
  input: CreateDnsFirewallClusterRequest
) => Effect.Effect<
  CreateDnsFirewallClusterResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDnsFirewallClusterRequest,
  output: CreateDnsFirewallClusterResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DnsFirewallDnsFirewallClusterDetailsRequest {
  dns_firewall_id: string;
  account_id: string;
}

export const DnsFirewallDnsFirewallClusterDetailsRequest = Schema.Struct({
  dns_firewall_id: Schema.String.pipe(T.HttpPath("dns_firewall_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dns_firewall/{dns_firewall_id}" }),
).annotations({ identifier: "DnsFirewallDnsFirewallClusterDetailsRequest" }) as unknown as Schema.Schema<DnsFirewallDnsFirewallClusterDetailsRequest>;

export interface DnsFirewallDnsFirewallClusterDetailsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DnsFirewallDnsFirewallClusterDetailsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DnsFirewallDnsFirewallClusterDetailsResponse" }) as unknown as Schema.Schema<DnsFirewallDnsFirewallClusterDetailsResponse>;

export const dnsFirewallDnsFirewallClusterDetails: (
  input: DnsFirewallDnsFirewallClusterDetailsRequest
) => Effect.Effect<
  DnsFirewallDnsFirewallClusterDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DnsFirewallDnsFirewallClusterDetailsRequest,
  output: DnsFirewallDnsFirewallClusterDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDnsFirewallClusterRequest {
  dns_firewall_id: string;
  account_id: string;
}

export const DeleteDnsFirewallClusterRequest = Schema.Struct({
  dns_firewall_id: Schema.String.pipe(T.HttpPath("dns_firewall_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/dns_firewall/{dns_firewall_id}" }),
).annotations({ identifier: "DeleteDnsFirewallClusterRequest" }) as unknown as Schema.Schema<DeleteDnsFirewallClusterRequest>;

export interface DeleteDnsFirewallClusterResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDnsFirewallClusterResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDnsFirewallClusterResponse" }) as unknown as Schema.Schema<DeleteDnsFirewallClusterResponse>;

export const deleteDnsFirewallCluster: (
  input: DeleteDnsFirewallClusterRequest
) => Effect.Effect<
  DeleteDnsFirewallClusterResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDnsFirewallClusterRequest,
  output: DeleteDnsFirewallClusterResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateDnsFirewallClusterRequest {
  dns_firewall_id: string;
  account_id: string;
  body: Record<string, unknown>;
}

export const UpdateDnsFirewallClusterRequest = Schema.Struct({
  dns_firewall_id: Schema.String.pipe(T.HttpPath("dns_firewall_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/dns_firewall/{dns_firewall_id}" }),
).annotations({ identifier: "UpdateDnsFirewallClusterRequest" }) as unknown as Schema.Schema<UpdateDnsFirewallClusterRequest>;

export interface UpdateDnsFirewallClusterResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateDnsFirewallClusterResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateDnsFirewallClusterResponse" }) as unknown as Schema.Schema<UpdateDnsFirewallClusterResponse>;

export const updateDnsFirewallCluster: (
  input: UpdateDnsFirewallClusterRequest
) => Effect.Effect<
  UpdateDnsFirewallClusterResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDnsFirewallClusterRequest,
  output: UpdateDnsFirewallClusterResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DnsFirewallAnalyticsTableRequest {
  dns_firewall_id: string;
  account_id: string;
  metrics?: string;
  dimensions?: string;
  since?: string;
  until?: string;
  limit?: number;
  sort?: string;
  filters?: string;
}

export const DnsFirewallAnalyticsTableRequest = Schema.Struct({
  dns_firewall_id: Schema.String.pipe(T.HttpPath("dns_firewall_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  metrics: Schema.optional(Schema.String).pipe(T.HttpQuery("metrics")),
  dimensions: Schema.optional(Schema.String).pipe(T.HttpQuery("dimensions")),
  since: Schema.optional(Schema.Date).pipe(T.HttpQuery("since")),
  until: Schema.optional(Schema.Date).pipe(T.HttpQuery("until")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  sort: Schema.optional(Schema.String).pipe(T.HttpQuery("sort")),
  filters: Schema.optional(Schema.String).pipe(T.HttpQuery("filters"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dns_firewall/{dns_firewall_id}/dns_analytics/report" }),
).annotations({ identifier: "DnsFirewallAnalyticsTableRequest" }) as unknown as Schema.Schema<DnsFirewallAnalyticsTableRequest>;

export interface DnsFirewallAnalyticsTableResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DnsFirewallAnalyticsTableResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DnsFirewallAnalyticsTableResponse" }) as unknown as Schema.Schema<DnsFirewallAnalyticsTableResponse>;

export const dnsFirewallAnalyticsTable: (
  input: DnsFirewallAnalyticsTableRequest
) => Effect.Effect<
  DnsFirewallAnalyticsTableResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DnsFirewallAnalyticsTableRequest,
  output: DnsFirewallAnalyticsTableResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DnsFirewallAnalyticsByTimeRequest {
  dns_firewall_id: string;
  account_id: string;
  metrics?: string;
  dimensions?: string;
  since?: string;
  until?: string;
  limit?: number;
  sort?: string;
  filters?: string;
  time_delta?: "all" | "auto" | "year" | "quarter" | "month" | "week" | "day" | "hour" | "dekaminute" | "minute";
}

export const DnsFirewallAnalyticsByTimeRequest = Schema.Struct({
  dns_firewall_id: Schema.String.pipe(T.HttpPath("dns_firewall_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  metrics: Schema.optional(Schema.String).pipe(T.HttpQuery("metrics")),
  dimensions: Schema.optional(Schema.String).pipe(T.HttpQuery("dimensions")),
  since: Schema.optional(Schema.Date).pipe(T.HttpQuery("since")),
  until: Schema.optional(Schema.Date).pipe(T.HttpQuery("until")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  sort: Schema.optional(Schema.String).pipe(T.HttpQuery("sort")),
  filters: Schema.optional(Schema.String).pipe(T.HttpQuery("filters")),
  time_delta: Schema.optional(Schema.Literal("all", "auto", "year", "quarter", "month", "week", "day", "hour", "dekaminute", "minute")).pipe(T.HttpQuery("time_delta"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dns_firewall/{dns_firewall_id}/dns_analytics/report/bytime" }),
).annotations({ identifier: "DnsFirewallAnalyticsByTimeRequest" }) as unknown as Schema.Schema<DnsFirewallAnalyticsByTimeRequest>;

export interface DnsFirewallAnalyticsByTimeResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DnsFirewallAnalyticsByTimeResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DnsFirewallAnalyticsByTimeResponse" }) as unknown as Schema.Schema<DnsFirewallAnalyticsByTimeResponse>;

export const dnsFirewallAnalyticsByTime: (
  input: DnsFirewallAnalyticsByTimeRequest
) => Effect.Effect<
  DnsFirewallAnalyticsByTimeResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DnsFirewallAnalyticsByTimeRequest,
  output: DnsFirewallAnalyticsByTimeResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DnsFirewallShowDnsFirewallClusterReverseDnsRequest {
  dns_firewall_id: string;
  account_id: string;
}

export const DnsFirewallShowDnsFirewallClusterReverseDnsRequest = Schema.Struct({
  dns_firewall_id: Schema.String.pipe(T.HttpPath("dns_firewall_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dns_firewall/{dns_firewall_id}/reverse_dns" }),
).annotations({ identifier: "DnsFirewallShowDnsFirewallClusterReverseDnsRequest" }) as unknown as Schema.Schema<DnsFirewallShowDnsFirewallClusterReverseDnsRequest>;

export interface DnsFirewallShowDnsFirewallClusterReverseDnsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DnsFirewallShowDnsFirewallClusterReverseDnsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DnsFirewallShowDnsFirewallClusterReverseDnsResponse" }) as unknown as Schema.Schema<DnsFirewallShowDnsFirewallClusterReverseDnsResponse>;

export const dnsFirewallShowDnsFirewallClusterReverseDns: (
  input: DnsFirewallShowDnsFirewallClusterReverseDnsRequest
) => Effect.Effect<
  DnsFirewallShowDnsFirewallClusterReverseDnsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DnsFirewallShowDnsFirewallClusterReverseDnsRequest,
  output: DnsFirewallShowDnsFirewallClusterReverseDnsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateDnsFirewallClusterReverseDnsRequest {
  dns_firewall_id: string;
  account_id: string;
  body: Record<string, unknown>;
}

export const UpdateDnsFirewallClusterReverseDnsRequest = Schema.Struct({
  dns_firewall_id: Schema.String.pipe(T.HttpPath("dns_firewall_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/dns_firewall/{dns_firewall_id}/reverse_dns" }),
).annotations({ identifier: "UpdateDnsFirewallClusterReverseDnsRequest" }) as unknown as Schema.Schema<UpdateDnsFirewallClusterReverseDnsRequest>;

export interface UpdateDnsFirewallClusterReverseDnsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateDnsFirewallClusterReverseDnsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateDnsFirewallClusterReverseDnsResponse" }) as unknown as Schema.Schema<UpdateDnsFirewallClusterReverseDnsResponse>;

export const updateDnsFirewallClusterReverseDns: (
  input: UpdateDnsFirewallClusterReverseDnsRequest
) => Effect.Effect<
  UpdateDnsFirewallClusterReverseDnsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDnsFirewallClusterReverseDnsRequest,
  output: UpdateDnsFirewallClusterReverseDnsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetUsageRequest {
  account_id: string;
}

export const GetUsageRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dns_records/usage" }),
).annotations({ identifier: "GetUsageRequest" }) as unknown as Schema.Schema<GetUsageRequest>;

export interface GetUsageResponse {
  result: { internal_record_quota?: number; internal_record_usage?: number; record_quota?: number; record_usage?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetUsageResponse = Schema.Struct({
  result: Schema.Struct({
  internal_record_quota: Schema.optional(Schema.Number),
  internal_record_usage: Schema.optional(Schema.Number),
  record_quota: Schema.optional(Schema.Number),
  record_usage: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetUsageResponse" }) as unknown as Schema.Schema<GetUsageResponse>;

export const getUsage: (
  input: GetUsageRequest
) => Effect.Effect<
  GetUsageResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetUsageRequest,
  output: GetUsageResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDnsSettingsRequest {
  account_id: string;
}

export const ListDnsSettingsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dns_settings" }),
).annotations({ identifier: "ListDnsSettingsRequest" }) as unknown as Schema.Schema<ListDnsSettingsRequest>;

export interface ListDnsSettingsResponse {
  result: { zone_defaults: Record<string, unknown> };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDnsSettingsResponse = Schema.Struct({
  result: Schema.Struct({
  zone_defaults: Schema.Struct({})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDnsSettingsResponse" }) as unknown as Schema.Schema<ListDnsSettingsResponse>;

export const listDnsSettings: (
  input: ListDnsSettingsRequest
) => Effect.Effect<
  ListDnsSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDnsSettingsRequest,
  output: ListDnsSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateDnsSettingsRequest {
  account_id: string;
  body: { zone_defaults?: Record<string, unknown> };
}

export const UpdateDnsSettingsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  zone_defaults: Schema.optional(Schema.Struct({}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/dns_settings" }),
).annotations({ identifier: "UpdateDnsSettingsRequest" }) as unknown as Schema.Schema<UpdateDnsSettingsRequest>;

export interface UpdateDnsSettingsResponse {
  result: { zone_defaults: Record<string, unknown> };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateDnsSettingsResponse = Schema.Struct({
  result: Schema.Struct({
  zone_defaults: Schema.Struct({})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateDnsSettingsResponse" }) as unknown as Schema.Schema<UpdateDnsSettingsResponse>;

export const updateDnsSettings: (
  input: UpdateDnsSettingsRequest
) => Effect.Effect<
  UpdateDnsSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDnsSettingsRequest,
  output: UpdateDnsSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListInternalDnsViewsRequest {
  account_id: string;
  name?: string;
  "name.exact"?: string;
  "name.contains"?: string;
  "name.startswith"?: string;
  "name.endswith"?: string;
  zone_id?: string;
  zone_name?: string;
  match?: "any" | "all";
  page?: number;
  per_page?: number;
  order?: "name" | "created_on" | "modified_on";
  direction?: "asc" | "desc";
}

export const ListInternalDnsViewsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  "name.exact": Schema.optional(Schema.String).pipe(T.HttpQuery("name.exact")),
  "name.contains": Schema.optional(Schema.String).pipe(T.HttpQuery("name.contains")),
  "name.startswith": Schema.optional(Schema.String).pipe(T.HttpQuery("name.startswith")),
  "name.endswith": Schema.optional(Schema.String).pipe(T.HttpQuery("name.endswith")),
  zone_id: Schema.optional(Schema.String).pipe(T.HttpQuery("zone_id")),
  zone_name: Schema.optional(Schema.String).pipe(T.HttpQuery("zone_name")),
  match: Schema.optional(Schema.Literal("any", "all")).pipe(T.HttpQuery("match")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.Literal("name", "created_on", "modified_on")).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dns_settings/views" }),
).annotations({ identifier: "ListInternalDnsViewsRequest" }) as unknown as Schema.Schema<ListInternalDnsViewsRequest>;

export interface ListInternalDnsViewsResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListInternalDnsViewsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListInternalDnsViewsResponse" }) as unknown as Schema.Schema<ListInternalDnsViewsResponse>;

export const listInternalDnsViews: (
  input: ListInternalDnsViewsRequest
) => Effect.Effect<
  ListInternalDnsViewsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListInternalDnsViewsRequest,
  output: ListInternalDnsViewsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateInternalDnsViewsRequest {
  account_id: string;
  body: Record<string, unknown>;
}

export const CreateInternalDnsViewsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dns_settings/views" }),
).annotations({ identifier: "CreateInternalDnsViewsRequest" }) as unknown as Schema.Schema<CreateInternalDnsViewsRequest>;

export interface CreateInternalDnsViewsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateInternalDnsViewsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateInternalDnsViewsResponse" }) as unknown as Schema.Schema<CreateInternalDnsViewsResponse>;

export const createInternalDnsViews: (
  input: CreateInternalDnsViewsRequest
) => Effect.Effect<
  CreateInternalDnsViewsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateInternalDnsViewsRequest,
  output: CreateInternalDnsViewsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetInternalDnsViewRequest {
  account_id: string;
  view_id: string;
}

export const GetInternalDnsViewRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  view_id: Schema.String.pipe(T.HttpPath("view_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dns_settings/views/{view_id}" }),
).annotations({ identifier: "GetInternalDnsViewRequest" }) as unknown as Schema.Schema<GetInternalDnsViewRequest>;

export interface GetInternalDnsViewResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetInternalDnsViewResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetInternalDnsViewResponse" }) as unknown as Schema.Schema<GetInternalDnsViewResponse>;

export const getInternalDnsView: (
  input: GetInternalDnsViewRequest
) => Effect.Effect<
  GetInternalDnsViewResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetInternalDnsViewRequest,
  output: GetInternalDnsViewResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteInternalDnsViewRequest {
  account_id: string;
  view_id: string;
}

export const DeleteInternalDnsViewRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  view_id: Schema.String.pipe(T.HttpPath("view_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/dns_settings/views/{view_id}" }),
).annotations({ identifier: "DeleteInternalDnsViewRequest" }) as unknown as Schema.Schema<DeleteInternalDnsViewRequest>;

export interface DeleteInternalDnsViewResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteInternalDnsViewResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteInternalDnsViewResponse" }) as unknown as Schema.Schema<DeleteInternalDnsViewResponse>;

export const deleteInternalDnsView: (
  input: DeleteInternalDnsViewRequest
) => Effect.Effect<
  DeleteInternalDnsViewResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteInternalDnsViewRequest,
  output: DeleteInternalDnsViewResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateInternalDnsViewRequest {
  account_id: string;
  view_id: string;
  body: Record<string, unknown>;
}

export const UpdateInternalDnsViewRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  view_id: Schema.String.pipe(T.HttpPath("view_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/dns_settings/views/{view_id}" }),
).annotations({ identifier: "UpdateInternalDnsViewRequest" }) as unknown as Schema.Schema<UpdateInternalDnsViewRequest>;

export interface UpdateInternalDnsViewResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateInternalDnsViewResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateInternalDnsViewResponse" }) as unknown as Schema.Schema<UpdateInternalDnsViewResponse>;

export const updateInternalDnsView: (
  input: UpdateInternalDnsViewRequest
) => Effect.Effect<
  UpdateInternalDnsViewResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateInternalDnsViewRequest,
  output: UpdateInternalDnsViewResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface EmailSecurityInvestigateRequest {
  account_id: string;
  start?: string;
  end?: string;
  query?: string;
  detections_only?: boolean;
  action_log?: boolean;
  final_disposition?: unknown;
  metric?: string;
  message_action?: unknown;
  recipient?: string;
  sender?: string;
  alert_id?: string;
  domain?: string;
  message_id?: string;
  subject?: string;
  cursor?: string;
  per_page?: number;
  page?: number;
}

export const EmailSecurityInvestigateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  start: Schema.optional(Schema.Date).pipe(T.HttpQuery("start")),
  end: Schema.optional(Schema.Date).pipe(T.HttpQuery("end")),
  query: Schema.optional(Schema.String).pipe(T.HttpQuery("query")),
  detections_only: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("detections_only")),
  action_log: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("action_log")),
  final_disposition: Schema.optional(Schema.Literal("MALICIOUS", "SUSPICIOUS", "SPOOF", "SPAM", "BULK", "NONE")).pipe(T.HttpQuery("final_disposition")),
  metric: Schema.optional(Schema.String).pipe(T.HttpQuery("metric")),
  message_action: Schema.optional(Schema.Literal("PREVIEW", "QUARANTINE_RELEASED", "MOVED")).pipe(T.HttpQuery("message_action")),
  recipient: Schema.optional(Schema.String).pipe(T.HttpQuery("recipient")),
  sender: Schema.optional(Schema.String).pipe(T.HttpQuery("sender")),
  alert_id: Schema.optional(Schema.String).pipe(T.HttpQuery("alert_id")),
  domain: Schema.optional(Schema.String).pipe(T.HttpQuery("domain")),
  message_id: Schema.optional(Schema.String).pipe(T.HttpQuery("message_id")),
  subject: Schema.optional(Schema.String).pipe(T.HttpQuery("subject")),
  cursor: Schema.optional(Schema.String).pipe(T.HttpQuery("cursor")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/investigate" }),
).annotations({ identifier: "EmailSecurityInvestigateRequest" }) as unknown as Schema.Schema<EmailSecurityInvestigateRequest>;

export interface EmailSecurityInvestigateResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const EmailSecurityInvestigateResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  action_log: Schema.Unknown,
  alert_id: Schema.optional(Schema.String),
  client_recipients: Schema.Array(Schema.String),
  delivery_mode: Schema.optional(Schema.String),
  detection_reasons: Schema.Array(Schema.String),
  edf_hash: Schema.optional(Schema.String),
  envelope_from: Schema.optional(Schema.String),
  envelope_to: Schema.optional(Schema.Array(Schema.String)),
  final_disposition: Schema.optional(Schema.String),
  findings: Schema.optional(Schema.Array(Schema.Struct({
  attachment: Schema.optional(Schema.String),
  detail: Schema.optional(Schema.String),
  detection: Schema.optional(Schema.String),
  field: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  portion: Schema.optional(Schema.String),
  reason: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.String)
}))),
  from: Schema.optional(Schema.String),
  from_name: Schema.optional(Schema.String),
  htmltext_structure_hash: Schema.optional(Schema.String),
  is_phish_submission: Schema.Boolean,
  is_quarantined: Schema.Boolean,
  message_id: Schema.optional(Schema.String),
  postfix_id: Schema.String,
  postfix_id_outbound: Schema.optional(Schema.String),
  properties: Schema.Struct({
  allowlisted_pattern: Schema.optional(Schema.String),
  allowlisted_pattern_type: Schema.optional(Schema.Literal("quarantine_release", "acceptable_sender", "allowed_sender", "allowed_recipient", "domain_similarity", "domain_recency", "managed_acceptable_sender", "outbound_ndr")),
  blocklisted_message: Schema.optional(Schema.Boolean),
  blocklisted_pattern: Schema.optional(Schema.String),
  whitelisted_pattern_type: Schema.optional(Schema.Literal("quarantine_release", "acceptable_sender", "allowed_sender", "allowed_recipient", "domain_similarity", "domain_recency", "managed_acceptable_sender", "outbound_ndr"))
}),
  replyto: Schema.optional(Schema.String),
  sent_date: Schema.optional(Schema.String),
  subject: Schema.optional(Schema.String),
  threat_categories: Schema.optional(Schema.Array(Schema.String)),
  to: Schema.optional(Schema.Array(Schema.String)),
  to_name: Schema.optional(Schema.Array(Schema.String)),
  ts: Schema.String,
  validation: Schema.optional(Schema.Struct({
  comment: Schema.optional(Schema.String),
  dkim: Schema.optional(Schema.String),
  dmarc: Schema.optional(Schema.String),
  spf: Schema.optional(Schema.String)
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "EmailSecurityInvestigateResponse" }) as unknown as Schema.Schema<EmailSecurityInvestigateResponse>;

export const emailSecurityInvestigate: (
  input: EmailSecurityInvestigateRequest
) => Effect.Effect<
  EmailSecurityInvestigateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: EmailSecurityInvestigateRequest,
  output: EmailSecurityInvestigateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostBulkMessageMoveRequest {
  account_id: string;
  body: { destination: "Inbox" | "JunkEmail" | "DeletedItems" | "RecoverableItemsDeletions" | "RecoverableItemsPurges"; postfix_ids: string[] };
}

export const PostBulkMessageMoveRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  destination: Schema.Literal("Inbox", "JunkEmail", "DeletedItems", "RecoverableItemsDeletions", "RecoverableItemsPurges"),
  postfix_ids: Schema.Array(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/email-security/investigate/move" }),
).annotations({ identifier: "PostBulkMessageMoveRequest" }) as unknown as Schema.Schema<PostBulkMessageMoveRequest>;

export interface PostBulkMessageMoveResponse {
  result: { completed_timestamp: string; destination?: string; item_count: number; message_id?: string; operation?: string; recipient?: string; status?: string; success: boolean }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostBulkMessageMoveResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  completed_timestamp: Schema.Date,
  destination: Schema.optional(Schema.String),
  item_count: Schema.Number,
  message_id: Schema.optional(Schema.String),
  operation: Schema.optional(Schema.String),
  recipient: Schema.optional(Schema.String),
  status: Schema.optional(Schema.String),
  success: Schema.Boolean
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostBulkMessageMoveResponse" }) as unknown as Schema.Schema<PostBulkMessageMoveResponse>;

export const postBulkMessageMove: (
  input: PostBulkMessageMoveRequest
) => Effect.Effect<
  PostBulkMessageMoveResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostBulkMessageMoveRequest,
  output: PostBulkMessageMoveResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostPreviewRequest {
  account_id: string;
  body: { postfix_id: string };
}

export const PostPreviewRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  postfix_id: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/email-security/investigate/preview" }),
).annotations({ identifier: "PostPreviewRequest" }) as unknown as Schema.Schema<PostPreviewRequest>;

export interface PostPreviewResponse {
  result: { screenshot: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostPreviewResponse = Schema.Struct({
  result: Schema.Struct({
  screenshot: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostPreviewResponse" }) as unknown as Schema.Schema<PostPreviewResponse>;

export const postPreview: (
  input: PostPreviewRequest
) => Effect.Effect<
  PostPreviewResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostPreviewRequest,
  output: PostPreviewResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostReleaseRequest {
  account_id: string;
  body: string[];
}

export const PostReleaseRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.String).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/email-security/investigate/release" }),
).annotations({ identifier: "PostReleaseRequest" }) as unknown as Schema.Schema<PostReleaseRequest>;

export interface PostReleaseResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostReleaseResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  delivered: Schema.optional(Schema.Array(Schema.String)),
  failed: Schema.optional(Schema.Array(Schema.String)),
  undelivered: Schema.optional(Schema.Array(Schema.String))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostReleaseResponse" }) as unknown as Schema.Schema<PostReleaseResponse>;

export const postRelease: (
  input: PostReleaseRequest
) => Effect.Effect<
  PostReleaseResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostReleaseRequest,
  output: PostReleaseResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetMessageRequest {
  account_id: string;
  postfix_id: string;
}

export const GetMessageRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  postfix_id: Schema.String.pipe(T.HttpPath("postfix_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/investigate/{postfix_id}" }),
).annotations({ identifier: "GetMessageRequest" }) as unknown as Schema.Schema<GetMessageRequest>;

export interface GetMessageResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetMessageResponse = Schema.Struct({
  result: Schema.Struct({
  action_log: Schema.Unknown,
  alert_id: Schema.optional(Schema.String),
  client_recipients: Schema.Array(Schema.String),
  delivery_mode: Schema.optional(Schema.String),
  detection_reasons: Schema.Array(Schema.String),
  edf_hash: Schema.optional(Schema.String),
  envelope_from: Schema.optional(Schema.String),
  envelope_to: Schema.optional(Schema.Array(Schema.String)),
  final_disposition: Schema.optional(Schema.String),
  findings: Schema.optional(Schema.Array(Schema.Struct({
  attachment: Schema.optional(Schema.String),
  detail: Schema.optional(Schema.String),
  detection: Schema.optional(Schema.String),
  field: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  portion: Schema.optional(Schema.String),
  reason: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.String)
}))),
  from: Schema.optional(Schema.String),
  from_name: Schema.optional(Schema.String),
  htmltext_structure_hash: Schema.optional(Schema.String),
  is_phish_submission: Schema.Boolean,
  is_quarantined: Schema.Boolean,
  message_id: Schema.optional(Schema.String),
  postfix_id: Schema.String,
  postfix_id_outbound: Schema.optional(Schema.String),
  properties: Schema.Struct({
  allowlisted_pattern: Schema.optional(Schema.String),
  allowlisted_pattern_type: Schema.optional(Schema.Literal("quarantine_release", "acceptable_sender", "allowed_sender", "allowed_recipient", "domain_similarity", "domain_recency", "managed_acceptable_sender", "outbound_ndr")),
  blocklisted_message: Schema.optional(Schema.Boolean),
  blocklisted_pattern: Schema.optional(Schema.String),
  whitelisted_pattern_type: Schema.optional(Schema.Literal("quarantine_release", "acceptable_sender", "allowed_sender", "allowed_recipient", "domain_similarity", "domain_recency", "managed_acceptable_sender", "outbound_ndr"))
}),
  replyto: Schema.optional(Schema.String),
  sent_date: Schema.optional(Schema.String),
  subject: Schema.optional(Schema.String),
  threat_categories: Schema.optional(Schema.Array(Schema.String)),
  to: Schema.optional(Schema.Array(Schema.String)),
  to_name: Schema.optional(Schema.Array(Schema.String)),
  ts: Schema.String,
  validation: Schema.optional(Schema.Struct({
  comment: Schema.optional(Schema.String),
  dkim: Schema.optional(Schema.String),
  dmarc: Schema.optional(Schema.String),
  spf: Schema.optional(Schema.String)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetMessageResponse" }) as unknown as Schema.Schema<GetMessageResponse>;

export const getMessage: (
  input: GetMessageRequest
) => Effect.Effect<
  GetMessageResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetMessageRequest,
  output: GetMessageResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetMessageDetectionsRequest {
  account_id: string;
  postfix_id: string;
}

export const GetMessageDetectionsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  postfix_id: Schema.String.pipe(T.HttpPath("postfix_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/investigate/{postfix_id}/detections" }),
).annotations({ identifier: "GetMessageDetectionsRequest" }) as unknown as Schema.Schema<GetMessageDetectionsRequest>;

export interface GetMessageDetectionsResponse {
  result: { action: string; attachments: { content_type?: string; detection?: unknown; encrypted?: boolean; name?: string; size: number }[]; final_disposition?: unknown; headers: { name: string; value: string }[]; links: { href: string; text?: string }[]; sender_info: { as_name?: string; as_number?: number; geo?: string; ip?: string; pld?: string }; threat_categories: { description?: string; id: number; name?: string }[]; validation: { comment?: string; dkim?: unknown; dmarc?: unknown; spf?: unknown } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetMessageDetectionsResponse = Schema.Struct({
  result: Schema.Struct({
  action: Schema.String,
  attachments: Schema.Array(Schema.Struct({
  content_type: Schema.optional(Schema.String),
  detection: Schema.optional(Schema.String),
  encrypted: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  size: Schema.Number
})),
  final_disposition: Schema.optional(Schema.String),
  headers: Schema.Array(Schema.Struct({
  name: Schema.String,
  value: Schema.String
})),
  links: Schema.Array(Schema.Struct({
  href: Schema.String,
  text: Schema.optional(Schema.String)
})),
  sender_info: Schema.Struct({
  as_name: Schema.optional(Schema.String),
  as_number: Schema.optional(Schema.Number),
  geo: Schema.optional(Schema.String),
  ip: Schema.optional(Schema.String),
  pld: Schema.optional(Schema.String)
}),
  threat_categories: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  id: Schema.Number,
  name: Schema.optional(Schema.String)
})),
  validation: Schema.Struct({
  comment: Schema.optional(Schema.String),
  dkim: Schema.optional(Schema.String),
  dmarc: Schema.optional(Schema.String),
  spf: Schema.optional(Schema.String)
})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetMessageDetectionsResponse" }) as unknown as Schema.Schema<GetMessageDetectionsResponse>;

export const getMessageDetections: (
  input: GetMessageDetectionsRequest
) => Effect.Effect<
  GetMessageDetectionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetMessageDetectionsRequest,
  output: GetMessageDetectionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostMessageMoveRequest {
  account_id: string;
  postfix_id: string;
  body: { destination: "Inbox" | "JunkEmail" | "DeletedItems" | "RecoverableItemsDeletions" | "RecoverableItemsPurges" };
}

export const PostMessageMoveRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  postfix_id: Schema.String.pipe(T.HttpPath("postfix_id")),
  body: Schema.Struct({
  destination: Schema.Literal("Inbox", "JunkEmail", "DeletedItems", "RecoverableItemsDeletions", "RecoverableItemsPurges")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/email-security/investigate/{postfix_id}/move" }),
).annotations({ identifier: "PostMessageMoveRequest" }) as unknown as Schema.Schema<PostMessageMoveRequest>;

export interface PostMessageMoveResponse {
  result: { completed_timestamp: string; destination?: string; item_count: number; message_id?: string; operation?: string; recipient?: string; status?: string; success: boolean }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostMessageMoveResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  completed_timestamp: Schema.Date,
  destination: Schema.optional(Schema.String),
  item_count: Schema.Number,
  message_id: Schema.optional(Schema.String),
  operation: Schema.optional(Schema.String),
  recipient: Schema.optional(Schema.String),
  status: Schema.optional(Schema.String),
  success: Schema.Boolean
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostMessageMoveResponse" }) as unknown as Schema.Schema<PostMessageMoveResponse>;

export const postMessageMove: (
  input: PostMessageMoveRequest
) => Effect.Effect<
  PostMessageMoveResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostMessageMoveRequest,
  output: PostMessageMoveResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetMessagePreviewRequest {
  account_id: string;
  postfix_id: string;
}

export const GetMessagePreviewRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  postfix_id: Schema.String.pipe(T.HttpPath("postfix_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/investigate/{postfix_id}/preview" }),
).annotations({ identifier: "GetMessagePreviewRequest" }) as unknown as Schema.Schema<GetMessagePreviewRequest>;

export interface GetMessagePreviewResponse {
  result: { screenshot: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetMessagePreviewResponse = Schema.Struct({
  result: Schema.Struct({
  screenshot: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetMessagePreviewResponse" }) as unknown as Schema.Schema<GetMessagePreviewResponse>;

export const getMessagePreview: (
  input: GetMessagePreviewRequest
) => Effect.Effect<
  GetMessagePreviewResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetMessagePreviewRequest,
  output: GetMessagePreviewResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetMessageRawRequest {
  account_id: string;
  postfix_id: string;
}

export const GetMessageRawRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  postfix_id: Schema.String.pipe(T.HttpPath("postfix_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/investigate/{postfix_id}/raw" }),
).annotations({ identifier: "GetMessageRawRequest" }) as unknown as Schema.Schema<GetMessageRawRequest>;

export interface GetMessageRawResponse {
  result: { raw: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetMessageRawResponse = Schema.Struct({
  result: Schema.Struct({
  raw: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetMessageRawResponse" }) as unknown as Schema.Schema<GetMessageRawResponse>;

export const getMessageRaw: (
  input: GetMessageRawRequest
) => Effect.Effect<
  GetMessageRawResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetMessageRawRequest,
  output: GetMessageRawResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostReclassifyRequest {
  account_id: string;
  postfix_id: string;
  body: { eml_content?: string; escalated_submission_id?: string; expected_disposition: "NONE" | "BULK" | "MALICIOUS" | "SPAM" | "SPOOF" | "SUSPICIOUS" };
}

export const PostReclassifyRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  postfix_id: Schema.String.pipe(T.HttpPath("postfix_id")),
  body: Schema.Struct({
  eml_content: Schema.optional(Schema.String),
  escalated_submission_id: Schema.optional(Schema.String),
  expected_disposition: Schema.Literal("NONE", "BULK", "MALICIOUS", "SPAM", "SPOOF", "SUSPICIOUS")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/email-security/investigate/{postfix_id}/reclassify" }),
).annotations({ identifier: "PostReclassifyRequest" }) as unknown as Schema.Schema<PostReclassifyRequest>;

export interface PostReclassifyResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostReclassifyResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostReclassifyResponse" }) as unknown as Schema.Schema<PostReclassifyResponse>;

export const postReclassify: (
  input: PostReclassifyRequest
) => Effect.Effect<
  PostReclassifyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostReclassifyRequest,
  output: PostReclassifyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetMessageTraceRequest {
  account_id: string;
  postfix_id: string;
}

export const GetMessageTraceRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  postfix_id: Schema.String.pipe(T.HttpPath("postfix_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/investigate/{postfix_id}/trace" }),
).annotations({ identifier: "GetMessageTraceRequest" }) as unknown as Schema.Schema<GetMessageTraceRequest>;

export interface GetMessageTraceResponse {
  result: { inbound: { lines?: { lineno: number; message: string; ts: string }[]; pending?: boolean }; outbound: { lines?: { lineno: number; message: string; ts: string }[]; pending?: boolean } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetMessageTraceResponse = Schema.Struct({
  result: Schema.Struct({
  inbound: Schema.Struct({
  lines: Schema.optional(Schema.Array(Schema.Struct({
  lineno: Schema.Number,
  message: Schema.String,
  ts: Schema.Date
}))),
  pending: Schema.optional(Schema.Boolean)
}),
  outbound: Schema.Struct({
  lines: Schema.optional(Schema.Array(Schema.Struct({
  lineno: Schema.Number,
  message: Schema.String,
  ts: Schema.Date
}))),
  pending: Schema.optional(Schema.Boolean)
})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetMessageTraceResponse" }) as unknown as Schema.Schema<GetMessageTraceResponse>;

export const getMessageTrace: (
  input: GetMessageTraceRequest
) => Effect.Effect<
  GetMessageTraceResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetMessageTraceRequest,
  output: GetMessageTraceResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetPhishguardReportsRequest {
  account_id: string;
  from_date: string;
  to_date: string;
}

export const GetPhishguardReportsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  from_date: Schema.Date.pipe(T.HttpQuery("from_date")),
  to_date: Schema.Date.pipe(T.HttpQuery("to_date"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/phishguard/reports" }),
).annotations({ identifier: "GetPhishguardReportsRequest" }) as unknown as Schema.Schema<GetPhishguardReportsRequest>;

export interface GetPhishguardReportsResponse {
  result: { content: string; disposition: "MALICIOUS" | "MALICIOUS-BEC" | "SUSPICIOUS" | "SPOOF" | "SPAM" | "BULK" | "ENCRYPTED" | "EXTERNAL" | "UNKNOWN" | "NONE"; fields: { from?: string; postfix_id?: string; to: string[]; ts: string }; id: number; priority: string; tags?: { category: string; value: string }[]; title: string; ts: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetPhishguardReportsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  content: Schema.String,
  disposition: Schema.Literal("MALICIOUS", "MALICIOUS-BEC", "SUSPICIOUS", "SPOOF", "SPAM", "BULK", "ENCRYPTED", "EXTERNAL", "UNKNOWN", "NONE"),
  fields: Schema.Struct({
  from: Schema.optional(Schema.String),
  postfix_id: Schema.optional(Schema.String),
  to: Schema.Array(Schema.String),
  ts: Schema.Date
}),
  id: Schema.Number,
  priority: Schema.String,
  tags: Schema.optional(Schema.Array(Schema.Struct({
  category: Schema.String,
  value: Schema.String
}))),
  title: Schema.String,
  ts: Schema.Date
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetPhishguardReportsResponse" }) as unknown as Schema.Schema<GetPhishguardReportsResponse>;

export const getPhishguardReports: (
  input: GetPhishguardReportsRequest
) => Effect.Effect<
  GetPhishguardReportsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetPhishguardReportsRequest,
  output: GetPhishguardReportsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAllowPoliciesRequest {
  account_id: string;
  page?: number;
  per_page?: number;
  order?: "pattern" | "created_at";
  direction?: unknown;
  search?: string;
  is_sender?: boolean;
  is_trusted_sender?: boolean;
  is_recipient?: boolean;
  is_exempt_recipient?: boolean;
  is_spoof?: boolean;
  is_acceptable_sender?: boolean;
  verify_sender?: boolean;
  pattern_type?: unknown;
  pattern?: string;
}

export const ListAllowPoliciesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.Literal("pattern", "created_at")).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
  is_sender: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_sender")),
  is_trusted_sender: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_trusted_sender")),
  is_recipient: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_recipient")),
  is_exempt_recipient: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_exempt_recipient")),
  is_spoof: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_spoof")),
  is_acceptable_sender: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_acceptable_sender")),
  verify_sender: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("verify_sender")),
  pattern_type: Schema.optional(Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN")).pipe(T.HttpQuery("pattern_type")),
  pattern: Schema.optional(Schema.String).pipe(T.HttpQuery("pattern"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/settings/allow_policies" }),
).annotations({ identifier: "ListAllowPoliciesRequest" }) as unknown as Schema.Schema<ListAllowPoliciesRequest>;

export interface ListAllowPoliciesResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAllowPoliciesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_acceptable_sender: Schema.Boolean,
  is_exempt_recipient: Schema.Boolean,
  is_recipient: Schema.optional(Schema.Boolean),
  is_regex: Schema.Boolean,
  is_sender: Schema.optional(Schema.Boolean),
  is_spoof: Schema.optional(Schema.Boolean),
  is_trusted_sender: Schema.Boolean,
  pattern: Schema.String,
  pattern_type: Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN"),
  verify_sender: Schema.Boolean
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAllowPoliciesResponse" }) as unknown as Schema.Schema<ListAllowPoliciesResponse>;

export const listAllowPolicies: (
  input: ListAllowPoliciesRequest
) => Effect.Effect<
  ListAllowPoliciesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAllowPoliciesRequest,
  output: ListAllowPoliciesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateAllowPolicyRequest {
  account_id: string;
  body: { comments?: string; is_acceptable_sender: boolean; is_exempt_recipient: boolean; is_recipient?: boolean; is_regex: boolean; is_sender?: boolean; is_spoof?: boolean; is_trusted_sender: boolean; pattern: string; pattern_type: "EMAIL" | "DOMAIN" | "IP" | "UNKNOWN"; verify_sender: boolean };
}

export const CreateAllowPolicyRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_acceptable_sender: Schema.Boolean,
  is_exempt_recipient: Schema.Boolean,
  is_recipient: Schema.optional(Schema.Boolean),
  is_regex: Schema.Boolean,
  is_sender: Schema.optional(Schema.Boolean),
  is_spoof: Schema.optional(Schema.Boolean),
  is_trusted_sender: Schema.Boolean,
  pattern: Schema.String,
  pattern_type: Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN"),
  verify_sender: Schema.Boolean
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/email-security/settings/allow_policies" }),
).annotations({ identifier: "CreateAllowPolicyRequest" }) as unknown as Schema.Schema<CreateAllowPolicyRequest>;

export interface CreateAllowPolicyResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateAllowPolicyResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateAllowPolicyResponse" }) as unknown as Schema.Schema<CreateAllowPolicyResponse>;

export const createAllowPolicy: (
  input: CreateAllowPolicyRequest
) => Effect.Effect<
  CreateAllowPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAllowPolicyRequest,
  output: CreateAllowPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface EmailSecurityBatchAllowPoliciesRequest {
  account_id: string;
  body: { deletes: { id: number }[]; patches: unknown[]; posts: { comments?: string; is_acceptable_sender: boolean; is_exempt_recipient: boolean; is_recipient?: boolean; is_regex: boolean; is_sender?: boolean; is_spoof?: boolean; is_trusted_sender: boolean; pattern: string; pattern_type: "EMAIL" | "DOMAIN" | "IP" | "UNKNOWN"; verify_sender: boolean }[]; puts: unknown[] };
}

export const EmailSecurityBatchAllowPoliciesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  deletes: Schema.Array(Schema.Struct({
  id: Schema.Number
})),
  patches: Schema.Array(Schema.Struct({
  id: Schema.Number
})),
  posts: Schema.Array(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_acceptable_sender: Schema.Boolean,
  is_exempt_recipient: Schema.Boolean,
  is_recipient: Schema.optional(Schema.Boolean),
  is_regex: Schema.Boolean,
  is_sender: Schema.optional(Schema.Boolean),
  is_spoof: Schema.optional(Schema.Boolean),
  is_trusted_sender: Schema.Boolean,
  pattern: Schema.String,
  pattern_type: Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN"),
  verify_sender: Schema.Boolean
})),
  puts: Schema.Array(Schema.Struct({
  id: Schema.Number
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/email-security/settings/allow_policies/batch" }),
).annotations({ identifier: "EmailSecurityBatchAllowPoliciesRequest" }) as unknown as Schema.Schema<EmailSecurityBatchAllowPoliciesRequest>;

export interface EmailSecurityBatchAllowPoliciesResponse {
  result: { deletes: { id: number }[]; patches: unknown[]; posts: unknown[]; puts: unknown[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const EmailSecurityBatchAllowPoliciesResponse = Schema.Struct({
  result: Schema.Struct({
  deletes: Schema.Array(Schema.Struct({
  id: Schema.Number
})),
  patches: Schema.Array(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_acceptable_sender: Schema.Boolean,
  is_exempt_recipient: Schema.Boolean,
  is_recipient: Schema.optional(Schema.Boolean),
  is_regex: Schema.Boolean,
  is_sender: Schema.optional(Schema.Boolean),
  is_spoof: Schema.optional(Schema.Boolean),
  is_trusted_sender: Schema.Boolean,
  pattern: Schema.String,
  pattern_type: Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN"),
  verify_sender: Schema.Boolean
})),
  posts: Schema.Array(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_acceptable_sender: Schema.Boolean,
  is_exempt_recipient: Schema.Boolean,
  is_recipient: Schema.optional(Schema.Boolean),
  is_regex: Schema.Boolean,
  is_sender: Schema.optional(Schema.Boolean),
  is_spoof: Schema.optional(Schema.Boolean),
  is_trusted_sender: Schema.Boolean,
  pattern: Schema.String,
  pattern_type: Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN"),
  verify_sender: Schema.Boolean
})),
  puts: Schema.Array(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_acceptable_sender: Schema.Boolean,
  is_exempt_recipient: Schema.Boolean,
  is_recipient: Schema.optional(Schema.Boolean),
  is_regex: Schema.Boolean,
  is_sender: Schema.optional(Schema.Boolean),
  is_spoof: Schema.optional(Schema.Boolean),
  is_trusted_sender: Schema.Boolean,
  pattern: Schema.String,
  pattern_type: Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN"),
  verify_sender: Schema.Boolean
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "EmailSecurityBatchAllowPoliciesResponse" }) as unknown as Schema.Schema<EmailSecurityBatchAllowPoliciesResponse>;

export const emailSecurityBatchAllowPolicies: (
  input: EmailSecurityBatchAllowPoliciesRequest
) => Effect.Effect<
  EmailSecurityBatchAllowPoliciesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: EmailSecurityBatchAllowPoliciesRequest,
  output: EmailSecurityBatchAllowPoliciesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAllowPolicyRequest {
  account_id: string;
  policy_id: number;
}

export const GetAllowPolicyRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  policy_id: Schema.Number.pipe(T.HttpPath("policy_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/settings/allow_policies/{policy_id}" }),
).annotations({ identifier: "GetAllowPolicyRequest" }) as unknown as Schema.Schema<GetAllowPolicyRequest>;

export interface GetAllowPolicyResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAllowPolicyResponse = Schema.Struct({
  result: Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_acceptable_sender: Schema.Boolean,
  is_exempt_recipient: Schema.Boolean,
  is_recipient: Schema.optional(Schema.Boolean),
  is_regex: Schema.Boolean,
  is_sender: Schema.optional(Schema.Boolean),
  is_spoof: Schema.optional(Schema.Boolean),
  is_trusted_sender: Schema.Boolean,
  pattern: Schema.String,
  pattern_type: Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN"),
  verify_sender: Schema.Boolean
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAllowPolicyResponse" }) as unknown as Schema.Schema<GetAllowPolicyResponse>;

export const getAllowPolicy: (
  input: GetAllowPolicyRequest
) => Effect.Effect<
  GetAllowPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAllowPolicyRequest,
  output: GetAllowPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAllowPolicyRequest {
  account_id: string;
  policy_id: number;
}

export const DeleteAllowPolicyRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  policy_id: Schema.Number.pipe(T.HttpPath("policy_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/email-security/settings/allow_policies/{policy_id}" }),
).annotations({ identifier: "DeleteAllowPolicyRequest" }) as unknown as Schema.Schema<DeleteAllowPolicyRequest>;

export interface DeleteAllowPolicyResponse {
  result: { id: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAllowPolicyResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAllowPolicyResponse" }) as unknown as Schema.Schema<DeleteAllowPolicyResponse>;

export const deleteAllowPolicy: (
  input: DeleteAllowPolicyRequest
) => Effect.Effect<
  DeleteAllowPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAllowPolicyRequest,
  output: DeleteAllowPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAllowPolicyRequest {
  account_id: string;
  policy_id: number;
  body: { comments?: string; is_acceptable_sender?: boolean; is_exempt_recipient?: boolean; is_regex?: boolean; is_trusted_sender?: boolean; pattern?: string; pattern_type?: unknown; verify_sender?: boolean };
}

export const UpdateAllowPolicyRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  policy_id: Schema.Number.pipe(T.HttpPath("policy_id")),
  body: Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_acceptable_sender: Schema.optional(Schema.Boolean),
  is_exempt_recipient: Schema.optional(Schema.Boolean),
  is_regex: Schema.optional(Schema.Boolean),
  is_trusted_sender: Schema.optional(Schema.Boolean),
  pattern: Schema.optional(Schema.String),
  pattern_type: Schema.optional(Schema.String),
  verify_sender: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/email-security/settings/allow_policies/{policy_id}" }),
).annotations({ identifier: "UpdateAllowPolicyRequest" }) as unknown as Schema.Schema<UpdateAllowPolicyRequest>;

export interface UpdateAllowPolicyResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAllowPolicyResponse = Schema.Struct({
  result: Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_acceptable_sender: Schema.Boolean,
  is_exempt_recipient: Schema.Boolean,
  is_recipient: Schema.optional(Schema.Boolean),
  is_regex: Schema.Boolean,
  is_sender: Schema.optional(Schema.Boolean),
  is_spoof: Schema.optional(Schema.Boolean),
  is_trusted_sender: Schema.Boolean,
  pattern: Schema.String,
  pattern_type: Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN"),
  verify_sender: Schema.Boolean
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAllowPolicyResponse" }) as unknown as Schema.Schema<UpdateAllowPolicyResponse>;

export const updateAllowPolicy: (
  input: UpdateAllowPolicyRequest
) => Effect.Effect<
  UpdateAllowPolicyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAllowPolicyRequest,
  output: UpdateAllowPolicyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListBlockedSendersRequest {
  account_id: string;
  page?: number;
  per_page?: number;
  order?: "pattern" | "created_at";
  direction?: unknown;
  search?: string;
  pattern_type?: unknown;
  pattern?: string;
}

export const ListBlockedSendersRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.Literal("pattern", "created_at")).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
  pattern_type: Schema.optional(Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN")).pipe(T.HttpQuery("pattern_type")),
  pattern: Schema.optional(Schema.String).pipe(T.HttpQuery("pattern"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/settings/block_senders" }),
).annotations({ identifier: "ListBlockedSendersRequest" }) as unknown as Schema.Schema<ListBlockedSendersRequest>;

export interface ListBlockedSendersResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListBlockedSendersResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_regex: Schema.Boolean,
  pattern: Schema.String,
  pattern_type: Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN")
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListBlockedSendersResponse" }) as unknown as Schema.Schema<ListBlockedSendersResponse>;

export const listBlockedSenders: (
  input: ListBlockedSendersRequest
) => Effect.Effect<
  ListBlockedSendersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListBlockedSendersRequest,
  output: ListBlockedSendersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateBlockedSenderRequest {
  account_id: string;
  body: { comments?: string; is_regex: boolean; pattern: string; pattern_type: "EMAIL" | "DOMAIN" | "IP" | "UNKNOWN" };
}

export const CreateBlockedSenderRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_regex: Schema.Boolean,
  pattern: Schema.String,
  pattern_type: Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/email-security/settings/block_senders" }),
).annotations({ identifier: "CreateBlockedSenderRequest" }) as unknown as Schema.Schema<CreateBlockedSenderRequest>;

export interface CreateBlockedSenderResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateBlockedSenderResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateBlockedSenderResponse" }) as unknown as Schema.Schema<CreateBlockedSenderResponse>;

export const createBlockedSender: (
  input: CreateBlockedSenderRequest
) => Effect.Effect<
  CreateBlockedSenderResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateBlockedSenderRequest,
  output: CreateBlockedSenderResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface EmailSecurityBatchBlockedSendersRequest {
  account_id: string;
  body: { deletes: { id: number }[]; patches: unknown[]; posts: { comments?: string; is_regex: boolean; pattern: string; pattern_type: "EMAIL" | "DOMAIN" | "IP" | "UNKNOWN" }[]; puts: unknown[] };
}

export const EmailSecurityBatchBlockedSendersRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  deletes: Schema.Array(Schema.Struct({
  id: Schema.Number
})),
  patches: Schema.Array(Schema.Struct({
  id: Schema.Number
})),
  posts: Schema.Array(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_regex: Schema.Boolean,
  pattern: Schema.String,
  pattern_type: Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN")
})),
  puts: Schema.Array(Schema.Struct({
  id: Schema.Number
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/email-security/settings/block_senders/batch" }),
).annotations({ identifier: "EmailSecurityBatchBlockedSendersRequest" }) as unknown as Schema.Schema<EmailSecurityBatchBlockedSendersRequest>;

export interface EmailSecurityBatchBlockedSendersResponse {
  result: { deletes: { id: number }[]; patches: unknown[]; posts: unknown[]; puts: unknown[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const EmailSecurityBatchBlockedSendersResponse = Schema.Struct({
  result: Schema.Struct({
  deletes: Schema.Array(Schema.Struct({
  id: Schema.Number
})),
  patches: Schema.Array(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_regex: Schema.Boolean,
  pattern: Schema.String,
  pattern_type: Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN")
})),
  posts: Schema.Array(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_regex: Schema.Boolean,
  pattern: Schema.String,
  pattern_type: Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN")
})),
  puts: Schema.Array(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_regex: Schema.Boolean,
  pattern: Schema.String,
  pattern_type: Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN")
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "EmailSecurityBatchBlockedSendersResponse" }) as unknown as Schema.Schema<EmailSecurityBatchBlockedSendersResponse>;

export const emailSecurityBatchBlockedSenders: (
  input: EmailSecurityBatchBlockedSendersRequest
) => Effect.Effect<
  EmailSecurityBatchBlockedSendersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: EmailSecurityBatchBlockedSendersRequest,
  output: EmailSecurityBatchBlockedSendersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetBlockedSenderRequest {
  account_id: string;
  pattern_id: number;
}

export const GetBlockedSenderRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  pattern_id: Schema.Number.pipe(T.HttpPath("pattern_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/settings/block_senders/{pattern_id}" }),
).annotations({ identifier: "GetBlockedSenderRequest" }) as unknown as Schema.Schema<GetBlockedSenderRequest>;

export interface GetBlockedSenderResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetBlockedSenderResponse = Schema.Struct({
  result: Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_regex: Schema.Boolean,
  pattern: Schema.String,
  pattern_type: Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetBlockedSenderResponse" }) as unknown as Schema.Schema<GetBlockedSenderResponse>;

export const getBlockedSender: (
  input: GetBlockedSenderRequest
) => Effect.Effect<
  GetBlockedSenderResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBlockedSenderRequest,
  output: GetBlockedSenderResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteBlockedSenderRequest {
  account_id: string;
  pattern_id: number;
}

export const DeleteBlockedSenderRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  pattern_id: Schema.Number.pipe(T.HttpPath("pattern_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/email-security/settings/block_senders/{pattern_id}" }),
).annotations({ identifier: "DeleteBlockedSenderRequest" }) as unknown as Schema.Schema<DeleteBlockedSenderRequest>;

export interface DeleteBlockedSenderResponse {
  result: { id: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteBlockedSenderResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteBlockedSenderResponse" }) as unknown as Schema.Schema<DeleteBlockedSenderResponse>;

export const deleteBlockedSender: (
  input: DeleteBlockedSenderRequest
) => Effect.Effect<
  DeleteBlockedSenderResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteBlockedSenderRequest,
  output: DeleteBlockedSenderResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateBlockedSenderRequest {
  account_id: string;
  pattern_id: number;
  body: { comments?: string; is_regex?: boolean; pattern?: string; pattern_type?: unknown };
}

export const UpdateBlockedSenderRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  pattern_id: Schema.Number.pipe(T.HttpPath("pattern_id")),
  body: Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_regex: Schema.optional(Schema.Boolean),
  pattern: Schema.optional(Schema.String),
  pattern_type: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/email-security/settings/block_senders/{pattern_id}" }),
).annotations({ identifier: "UpdateBlockedSenderRequest" }) as unknown as Schema.Schema<UpdateBlockedSenderRequest>;

export interface UpdateBlockedSenderResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateBlockedSenderResponse = Schema.Struct({
  result: Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_regex: Schema.Boolean,
  pattern: Schema.String,
  pattern_type: Schema.Literal("EMAIL", "DOMAIN", "IP", "UNKNOWN")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateBlockedSenderResponse" }) as unknown as Schema.Schema<UpdateBlockedSenderResponse>;

export const updateBlockedSender: (
  input: UpdateBlockedSenderRequest
) => Effect.Effect<
  UpdateBlockedSenderResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateBlockedSenderRequest,
  output: UpdateBlockedSenderResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDomainsRequest {
  account_id: string;
  page?: number;
  per_page?: number;
  order?: "domain" | "created_at";
  direction?: unknown;
  search?: string;
  allowed_delivery_mode?: unknown;
  domain?: string[];
  active_delivery_mode?: unknown;
  integration_id?: string;
}

export const ListDomainsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.Literal("domain", "created_at")).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
  allowed_delivery_mode: Schema.optional(Schema.Literal("DIRECT", "BCC", "JOURNAL", "API", "RETRO_SCAN")).pipe(T.HttpQuery("allowed_delivery_mode")),
  domain: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("domain")),
  active_delivery_mode: Schema.optional(Schema.Literal("DIRECT", "BCC", "JOURNAL", "API", "RETRO_SCAN")).pipe(T.HttpQuery("active_delivery_mode")),
  integration_id: Schema.optional(Schema.UUID).pipe(T.HttpQuery("integration_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/settings/domains" }),
).annotations({ identifier: "ListDomainsRequest" }) as unknown as Schema.Schema<ListDomainsRequest>;

export interface ListDomainsResponse {
  result: { allowed_delivery_modes: "DIRECT" | "BCC" | "JOURNAL" | "API" | "RETRO_SCAN"[]; authorization?: unknown; created_at: string; dmarc_status?: unknown; domain: string; drop_dispositions: "MALICIOUS" | "MALICIOUS-BEC" | "SUSPICIOUS" | "SPOOF" | "SPAM" | "BULK" | "ENCRYPTED" | "EXTERNAL" | "UNKNOWN" | "NONE"[]; emails_processed?: unknown; folder?: unknown; id: number; inbox_provider?: unknown; integration_id?: string; ip_restrictions: string[]; last_modified: string; lookback_hops: number; o365_tenant_id?: string; regions: "GLOBAL" | "AU" | "DE" | "IN" | "US"[]; require_tls_inbound?: boolean; require_tls_outbound?: boolean; spf_status?: unknown; transport: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDomainsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  allowed_delivery_modes: Schema.Array(Schema.Literal("DIRECT", "BCC", "JOURNAL", "API", "RETRO_SCAN")),
  authorization: Schema.optional(Schema.Struct({
  authorized: Schema.Boolean,
  status_message: Schema.optional(Schema.String),
  timestamp: Schema.Date
})),
  created_at: Schema.Date,
  dmarc_status: Schema.optional(Schema.Literal("none", "good", "invalid")),
  domain: Schema.String,
  drop_dispositions: Schema.Array(Schema.Literal("MALICIOUS", "MALICIOUS-BEC", "SUSPICIOUS", "SPOOF", "SPAM", "BULK", "ENCRYPTED", "EXTERNAL", "UNKNOWN", "NONE")),
  emails_processed: Schema.optional(Schema.Struct({
  timestamp: Schema.Date,
  total_emails_processed: Schema.Number,
  total_emails_processed_previous: Schema.Number
})),
  folder: Schema.optional(Schema.String),
  id: Schema.Number,
  inbox_provider: Schema.optional(Schema.Literal("Microsoft", "Google")),
  integration_id: Schema.optional(Schema.UUID),
  ip_restrictions: Schema.Array(Schema.String),
  last_modified: Schema.Date,
  lookback_hops: Schema.Number,
  o365_tenant_id: Schema.optional(Schema.String),
  regions: Schema.Array(Schema.Literal("GLOBAL", "AU", "DE", "IN", "US")),
  require_tls_inbound: Schema.optional(Schema.Boolean),
  require_tls_outbound: Schema.optional(Schema.Boolean),
  spf_status: Schema.optional(Schema.Literal("none", "good", "neutral", "open", "invalid")),
  transport: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDomainsResponse" }) as unknown as Schema.Schema<ListDomainsResponse>;

export const listDomains: (
  input: ListDomainsRequest
) => Effect.Effect<
  ListDomainsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDomainsRequest,
  output: ListDomainsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDomainsRequest {
  account_id: string;
  body: { id: number }[];
}

export const DeleteDomainsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Struct({
  id: Schema.Number
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/email-security/settings/domains" }),
).annotations({ identifier: "DeleteDomainsRequest" }) as unknown as Schema.Schema<DeleteDomainsRequest>;

export interface DeleteDomainsResponse {
  result: { id: number }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDomainsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  id: Schema.Number
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDomainsResponse" }) as unknown as Schema.Schema<DeleteDomainsResponse>;

export const deleteDomains: (
  input: DeleteDomainsRequest
) => Effect.Effect<
  DeleteDomainsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDomainsRequest,
  output: DeleteDomainsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDomainRequest {
  account_id: string;
  domain_id: number;
}

export const GetDomainRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  domain_id: Schema.Number.pipe(T.HttpPath("domain_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/settings/domains/{domain_id}" }),
).annotations({ identifier: "GetDomainRequest" }) as unknown as Schema.Schema<GetDomainRequest>;

export interface GetDomainResponse {
  result: { allowed_delivery_modes: "DIRECT" | "BCC" | "JOURNAL" | "API" | "RETRO_SCAN"[]; authorization?: unknown; created_at: string; dmarc_status?: unknown; domain: string; drop_dispositions: "MALICIOUS" | "MALICIOUS-BEC" | "SUSPICIOUS" | "SPOOF" | "SPAM" | "BULK" | "ENCRYPTED" | "EXTERNAL" | "UNKNOWN" | "NONE"[]; emails_processed?: unknown; folder?: unknown; id: number; inbox_provider?: unknown; integration_id?: string; ip_restrictions: string[]; last_modified: string; lookback_hops: number; o365_tenant_id?: string; regions: "GLOBAL" | "AU" | "DE" | "IN" | "US"[]; require_tls_inbound?: boolean; require_tls_outbound?: boolean; spf_status?: unknown; transport: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDomainResponse = Schema.Struct({
  result: Schema.Struct({
  allowed_delivery_modes: Schema.Array(Schema.Literal("DIRECT", "BCC", "JOURNAL", "API", "RETRO_SCAN")),
  authorization: Schema.optional(Schema.Struct({
  authorized: Schema.Boolean,
  status_message: Schema.optional(Schema.String),
  timestamp: Schema.Date
})),
  created_at: Schema.Date,
  dmarc_status: Schema.optional(Schema.Literal("none", "good", "invalid")),
  domain: Schema.String,
  drop_dispositions: Schema.Array(Schema.Literal("MALICIOUS", "MALICIOUS-BEC", "SUSPICIOUS", "SPOOF", "SPAM", "BULK", "ENCRYPTED", "EXTERNAL", "UNKNOWN", "NONE")),
  emails_processed: Schema.optional(Schema.Struct({
  timestamp: Schema.Date,
  total_emails_processed: Schema.Number,
  total_emails_processed_previous: Schema.Number
})),
  folder: Schema.optional(Schema.String),
  id: Schema.Number,
  inbox_provider: Schema.optional(Schema.Literal("Microsoft", "Google")),
  integration_id: Schema.optional(Schema.UUID),
  ip_restrictions: Schema.Array(Schema.String),
  last_modified: Schema.Date,
  lookback_hops: Schema.Number,
  o365_tenant_id: Schema.optional(Schema.String),
  regions: Schema.Array(Schema.Literal("GLOBAL", "AU", "DE", "IN", "US")),
  require_tls_inbound: Schema.optional(Schema.Boolean),
  require_tls_outbound: Schema.optional(Schema.Boolean),
  spf_status: Schema.optional(Schema.Literal("none", "good", "neutral", "open", "invalid")),
  transport: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDomainResponse" }) as unknown as Schema.Schema<GetDomainResponse>;

export const getDomain: (
  input: GetDomainRequest
) => Effect.Effect<
  GetDomainResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDomainRequest,
  output: GetDomainResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDomainRequest {
  account_id: string;
  domain_id: number;
}

export const DeleteDomainRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  domain_id: Schema.Number.pipe(T.HttpPath("domain_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/email-security/settings/domains/{domain_id}" }),
).annotations({ identifier: "DeleteDomainRequest" }) as unknown as Schema.Schema<DeleteDomainRequest>;

export interface DeleteDomainResponse {
  result: { id: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDomainResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDomainResponse" }) as unknown as Schema.Schema<DeleteDomainResponse>;

export const deleteDomain: (
  input: DeleteDomainRequest
) => Effect.Effect<
  DeleteDomainResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDomainRequest,
  output: DeleteDomainResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateDomainRequest {
  account_id: string;
  domain_id: number;
  body: { allowed_delivery_modes?: "DIRECT" | "BCC" | "JOURNAL" | "API" | "RETRO_SCAN"[]; domain?: string; drop_dispositions?: "MALICIOUS" | "MALICIOUS-BEC" | "SUSPICIOUS" | "SPOOF" | "SPAM" | "BULK" | "ENCRYPTED" | "EXTERNAL" | "UNKNOWN" | "NONE"[]; folder?: unknown; integration_id?: string; ip_restrictions: string[]; lookback_hops?: number; regions?: "GLOBAL" | "AU" | "DE" | "IN" | "US"[]; require_tls_inbound?: boolean; require_tls_outbound?: boolean; transport?: string };
}

export const UpdateDomainRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  domain_id: Schema.Number.pipe(T.HttpPath("domain_id")),
  body: Schema.Struct({
  allowed_delivery_modes: Schema.optional(Schema.Array(Schema.Literal("DIRECT", "BCC", "JOURNAL", "API", "RETRO_SCAN"))),
  domain: Schema.optional(Schema.String),
  drop_dispositions: Schema.optional(Schema.Array(Schema.Literal("MALICIOUS", "MALICIOUS-BEC", "SUSPICIOUS", "SPOOF", "SPAM", "BULK", "ENCRYPTED", "EXTERNAL", "UNKNOWN", "NONE"))),
  folder: Schema.optional(Schema.Literal("AllItems", "Inbox")),
  integration_id: Schema.optional(Schema.UUID),
  ip_restrictions: Schema.Array(Schema.String),
  lookback_hops: Schema.optional(Schema.Number),
  regions: Schema.optional(Schema.Array(Schema.Literal("GLOBAL", "AU", "DE", "IN", "US"))),
  require_tls_inbound: Schema.optional(Schema.Boolean),
  require_tls_outbound: Schema.optional(Schema.Boolean),
  transport: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/email-security/settings/domains/{domain_id}" }),
).annotations({ identifier: "UpdateDomainRequest" }) as unknown as Schema.Schema<UpdateDomainRequest>;

export interface UpdateDomainResponse {
  result: { allowed_delivery_modes: "DIRECT" | "BCC" | "JOURNAL" | "API" | "RETRO_SCAN"[]; authorization?: unknown; created_at: string; dmarc_status?: unknown; domain: string; drop_dispositions: "MALICIOUS" | "MALICIOUS-BEC" | "SUSPICIOUS" | "SPOOF" | "SPAM" | "BULK" | "ENCRYPTED" | "EXTERNAL" | "UNKNOWN" | "NONE"[]; emails_processed?: unknown; folder?: unknown; id: number; inbox_provider?: unknown; integration_id?: string; ip_restrictions: string[]; last_modified: string; lookback_hops: number; o365_tenant_id?: string; regions: "GLOBAL" | "AU" | "DE" | "IN" | "US"[]; require_tls_inbound?: boolean; require_tls_outbound?: boolean; spf_status?: unknown; transport: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateDomainResponse = Schema.Struct({
  result: Schema.Struct({
  allowed_delivery_modes: Schema.Array(Schema.Literal("DIRECT", "BCC", "JOURNAL", "API", "RETRO_SCAN")),
  authorization: Schema.optional(Schema.Struct({
  authorized: Schema.Boolean,
  status_message: Schema.optional(Schema.String),
  timestamp: Schema.Date
})),
  created_at: Schema.Date,
  dmarc_status: Schema.optional(Schema.Literal("none", "good", "invalid")),
  domain: Schema.String,
  drop_dispositions: Schema.Array(Schema.Literal("MALICIOUS", "MALICIOUS-BEC", "SUSPICIOUS", "SPOOF", "SPAM", "BULK", "ENCRYPTED", "EXTERNAL", "UNKNOWN", "NONE")),
  emails_processed: Schema.optional(Schema.Struct({
  timestamp: Schema.Date,
  total_emails_processed: Schema.Number,
  total_emails_processed_previous: Schema.Number
})),
  folder: Schema.optional(Schema.String),
  id: Schema.Number,
  inbox_provider: Schema.optional(Schema.Literal("Microsoft", "Google")),
  integration_id: Schema.optional(Schema.UUID),
  ip_restrictions: Schema.Array(Schema.String),
  last_modified: Schema.Date,
  lookback_hops: Schema.Number,
  o365_tenant_id: Schema.optional(Schema.String),
  regions: Schema.Array(Schema.Literal("GLOBAL", "AU", "DE", "IN", "US")),
  require_tls_inbound: Schema.optional(Schema.Boolean),
  require_tls_outbound: Schema.optional(Schema.Boolean),
  spf_status: Schema.optional(Schema.Literal("none", "good", "neutral", "open", "invalid")),
  transport: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateDomainResponse" }) as unknown as Schema.Schema<UpdateDomainResponse>;

export const updateDomain: (
  input: UpdateDomainRequest
) => Effect.Effect<
  UpdateDomainResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDomainRequest,
  output: UpdateDomainResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDisplayNamesRequest {
  account_id: string;
  page?: number;
  per_page?: number;
  order?: "name" | "email" | "created_at";
  direction?: unknown;
  search?: string;
  provenance?: unknown;
}

export const ListDisplayNamesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.Literal("name", "email", "created_at")).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
  provenance: Schema.optional(Schema.Literal("A1S_INTERNAL", "SNOOPY-CASB_OFFICE_365", "SNOOPY-OFFICE_365", "SNOOPY-GOOGLE_DIRECTORY")).pipe(T.HttpQuery("provenance"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/settings/impersonation_registry" }),
).annotations({ identifier: "ListDisplayNamesRequest" }) as unknown as Schema.Schema<ListDisplayNamesRequest>;

export interface ListDisplayNamesResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDisplayNamesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  email: Schema.String,
  is_email_regex: Schema.Boolean,
  name: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDisplayNamesResponse" }) as unknown as Schema.Schema<ListDisplayNamesResponse>;

export const listDisplayNames: (
  input: ListDisplayNamesRequest
) => Effect.Effect<
  ListDisplayNamesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDisplayNamesRequest,
  output: ListDisplayNamesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateDisplayNameRequest {
  account_id: string;
  body: { email: string; is_email_regex: boolean; name: string };
}

export const CreateDisplayNameRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  email: Schema.String,
  is_email_regex: Schema.Boolean,
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/email-security/settings/impersonation_registry" }),
).annotations({ identifier: "CreateDisplayNameRequest" }) as unknown as Schema.Schema<CreateDisplayNameRequest>;

export interface CreateDisplayNameResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateDisplayNameResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateDisplayNameResponse" }) as unknown as Schema.Schema<CreateDisplayNameResponse>;

export const createDisplayName: (
  input: CreateDisplayNameRequest
) => Effect.Effect<
  CreateDisplayNameResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDisplayNameRequest,
  output: CreateDisplayNameResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDisplayNameRequest {
  account_id: string;
  display_name_id: number;
}

export const GetDisplayNameRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  display_name_id: Schema.Number.pipe(T.HttpPath("display_name_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/settings/impersonation_registry/{display_name_id}" }),
).annotations({ identifier: "GetDisplayNameRequest" }) as unknown as Schema.Schema<GetDisplayNameRequest>;

export interface GetDisplayNameResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDisplayNameResponse = Schema.Struct({
  result: Schema.Struct({
  email: Schema.String,
  is_email_regex: Schema.Boolean,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDisplayNameResponse" }) as unknown as Schema.Schema<GetDisplayNameResponse>;

export const getDisplayName: (
  input: GetDisplayNameRequest
) => Effect.Effect<
  GetDisplayNameResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDisplayNameRequest,
  output: GetDisplayNameResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDisplayNameRequest {
  account_id: string;
  display_name_id: number;
}

export const DeleteDisplayNameRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  display_name_id: Schema.Number.pipe(T.HttpPath("display_name_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/email-security/settings/impersonation_registry/{display_name_id}" }),
).annotations({ identifier: "DeleteDisplayNameRequest" }) as unknown as Schema.Schema<DeleteDisplayNameRequest>;

export interface DeleteDisplayNameResponse {
  result: { id: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDisplayNameResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDisplayNameResponse" }) as unknown as Schema.Schema<DeleteDisplayNameResponse>;

export const deleteDisplayName: (
  input: DeleteDisplayNameRequest
) => Effect.Effect<
  DeleteDisplayNameResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDisplayNameRequest,
  output: DeleteDisplayNameResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateDisplayNameRequest {
  account_id: string;
  display_name_id: number;
  body: { email?: string; is_email_regex?: boolean; name?: string };
}

export const UpdateDisplayNameRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  display_name_id: Schema.Number.pipe(T.HttpPath("display_name_id")),
  body: Schema.Struct({
  email: Schema.optional(Schema.String),
  is_email_regex: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/email-security/settings/impersonation_registry/{display_name_id}" }),
).annotations({ identifier: "UpdateDisplayNameRequest" }) as unknown as Schema.Schema<UpdateDisplayNameRequest>;

export interface UpdateDisplayNameResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateDisplayNameResponse = Schema.Struct({
  result: Schema.Struct({
  email: Schema.String,
  is_email_regex: Schema.Boolean,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateDisplayNameResponse" }) as unknown as Schema.Schema<UpdateDisplayNameResponse>;

export const updateDisplayName: (
  input: UpdateDisplayNameRequest
) => Effect.Effect<
  UpdateDisplayNameResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDisplayNameRequest,
  output: UpdateDisplayNameResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface EmailSecurityBatchSendingDomainRestrictionsRequest {
  account_id: string;
  body: { deletes: { id: number }[] };
}

export const EmailSecurityBatchSendingDomainRestrictionsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  deletes: Schema.Array(Schema.Struct({
  id: Schema.Number
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/email-security/settings/sending_domain_restrictions/batch" }),
).annotations({ identifier: "EmailSecurityBatchSendingDomainRestrictionsRequest" }) as unknown as Schema.Schema<EmailSecurityBatchSendingDomainRestrictionsRequest>;

export interface EmailSecurityBatchSendingDomainRestrictionsResponse {
  result: { deletes: { id: number }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const EmailSecurityBatchSendingDomainRestrictionsResponse = Schema.Struct({
  result: Schema.Struct({
  deletes: Schema.Array(Schema.Struct({
  id: Schema.Number
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "EmailSecurityBatchSendingDomainRestrictionsResponse" }) as unknown as Schema.Schema<EmailSecurityBatchSendingDomainRestrictionsResponse>;

export const emailSecurityBatchSendingDomainRestrictions: (
  input: EmailSecurityBatchSendingDomainRestrictionsRequest
) => Effect.Effect<
  EmailSecurityBatchSendingDomainRestrictionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: EmailSecurityBatchSendingDomainRestrictionsRequest,
  output: EmailSecurityBatchSendingDomainRestrictionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListTrustedDomainsRequest {
  account_id: string;
  page?: number;
  per_page?: number;
  order?: "pattern" | "created_at";
  direction?: unknown;
  search?: string;
  is_recent?: boolean;
  is_similarity?: boolean;
  pattern?: string;
}

export const ListTrustedDomainsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.Literal("pattern", "created_at")).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
  is_recent: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_recent")),
  is_similarity: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_similarity")),
  pattern: Schema.optional(Schema.String).pipe(T.HttpQuery("pattern"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/settings/trusted_domains" }),
).annotations({ identifier: "ListTrustedDomainsRequest" }) as unknown as Schema.Schema<ListTrustedDomainsRequest>;

export interface ListTrustedDomainsResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListTrustedDomainsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_recent: Schema.Boolean,
  is_regex: Schema.Boolean,
  is_similarity: Schema.Boolean,
  pattern: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListTrustedDomainsResponse" }) as unknown as Schema.Schema<ListTrustedDomainsResponse>;

export const listTrustedDomains: (
  input: ListTrustedDomainsRequest
) => Effect.Effect<
  ListTrustedDomainsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListTrustedDomainsRequest,
  output: ListTrustedDomainsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateTrustedDomainRequest {
  account_id: string;
  body: unknown;
}

export const CreateTrustedDomainRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Union(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_recent: Schema.Boolean,
  is_regex: Schema.Boolean,
  is_similarity: Schema.Boolean,
  pattern: Schema.String
}), Schema.Array(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_recent: Schema.Boolean,
  is_regex: Schema.Boolean,
  is_similarity: Schema.Boolean,
  pattern: Schema.String
}))).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/email-security/settings/trusted_domains" }),
).annotations({ identifier: "CreateTrustedDomainRequest" }) as unknown as Schema.Schema<CreateTrustedDomainRequest>;

export interface CreateTrustedDomainResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateTrustedDomainResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateTrustedDomainResponse" }) as unknown as Schema.Schema<CreateTrustedDomainResponse>;

export const createTrustedDomain: (
  input: CreateTrustedDomainRequest
) => Effect.Effect<
  CreateTrustedDomainResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateTrustedDomainRequest,
  output: CreateTrustedDomainResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface EmailSecurityBatchTrustedDomainsRequest {
  account_id: string;
  body: { deletes: { id: number }[]; patches: unknown[]; posts: { comments?: string; is_recent: boolean; is_regex: boolean; is_similarity: boolean; pattern: string }[]; puts: unknown[] };
}

export const EmailSecurityBatchTrustedDomainsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  deletes: Schema.Array(Schema.Struct({
  id: Schema.Number
})),
  patches: Schema.Array(Schema.Struct({
  id: Schema.Number
})),
  posts: Schema.Array(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_recent: Schema.Boolean,
  is_regex: Schema.Boolean,
  is_similarity: Schema.Boolean,
  pattern: Schema.String
})),
  puts: Schema.Array(Schema.Struct({
  id: Schema.Number
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/email-security/settings/trusted_domains/batch" }),
).annotations({ identifier: "EmailSecurityBatchTrustedDomainsRequest" }) as unknown as Schema.Schema<EmailSecurityBatchTrustedDomainsRequest>;

export interface EmailSecurityBatchTrustedDomainsResponse {
  result: { deletes: { id: number }[]; patches: unknown[]; posts: unknown[]; puts: unknown[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const EmailSecurityBatchTrustedDomainsResponse = Schema.Struct({
  result: Schema.Struct({
  deletes: Schema.Array(Schema.Struct({
  id: Schema.Number
})),
  patches: Schema.Array(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_recent: Schema.Boolean,
  is_regex: Schema.Boolean,
  is_similarity: Schema.Boolean,
  pattern: Schema.String
})),
  posts: Schema.Array(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_recent: Schema.Boolean,
  is_regex: Schema.Boolean,
  is_similarity: Schema.Boolean,
  pattern: Schema.String
})),
  puts: Schema.Array(Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_recent: Schema.Boolean,
  is_regex: Schema.Boolean,
  is_similarity: Schema.Boolean,
  pattern: Schema.String
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "EmailSecurityBatchTrustedDomainsResponse" }) as unknown as Schema.Schema<EmailSecurityBatchTrustedDomainsResponse>;

export const emailSecurityBatchTrustedDomains: (
  input: EmailSecurityBatchTrustedDomainsRequest
) => Effect.Effect<
  EmailSecurityBatchTrustedDomainsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: EmailSecurityBatchTrustedDomainsRequest,
  output: EmailSecurityBatchTrustedDomainsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetTrustedDomainRequest {
  account_id: string;
  trusted_domain_id: number;
}

export const GetTrustedDomainRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  trusted_domain_id: Schema.Number.pipe(T.HttpPath("trusted_domain_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/settings/trusted_domains/{trusted_domain_id}" }),
).annotations({ identifier: "GetTrustedDomainRequest" }) as unknown as Schema.Schema<GetTrustedDomainRequest>;

export interface GetTrustedDomainResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetTrustedDomainResponse = Schema.Struct({
  result: Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_recent: Schema.Boolean,
  is_regex: Schema.Boolean,
  is_similarity: Schema.Boolean,
  pattern: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetTrustedDomainResponse" }) as unknown as Schema.Schema<GetTrustedDomainResponse>;

export const getTrustedDomain: (
  input: GetTrustedDomainRequest
) => Effect.Effect<
  GetTrustedDomainResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTrustedDomainRequest,
  output: GetTrustedDomainResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteTrustedDomainRequest {
  account_id: string;
  trusted_domain_id: number;
}

export const DeleteTrustedDomainRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  trusted_domain_id: Schema.Number.pipe(T.HttpPath("trusted_domain_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/email-security/settings/trusted_domains/{trusted_domain_id}" }),
).annotations({ identifier: "DeleteTrustedDomainRequest" }) as unknown as Schema.Schema<DeleteTrustedDomainRequest>;

export interface DeleteTrustedDomainResponse {
  result: { id: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteTrustedDomainResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteTrustedDomainResponse" }) as unknown as Schema.Schema<DeleteTrustedDomainResponse>;

export const deleteTrustedDomain: (
  input: DeleteTrustedDomainRequest
) => Effect.Effect<
  DeleteTrustedDomainResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteTrustedDomainRequest,
  output: DeleteTrustedDomainResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateTrustedDomainRequest {
  account_id: string;
  trusted_domain_id: number;
  body: { comments?: string; is_recent?: boolean; is_regex?: boolean; is_similarity?: boolean; pattern?: string };
}

export const UpdateTrustedDomainRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  trusted_domain_id: Schema.Number.pipe(T.HttpPath("trusted_domain_id")),
  body: Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_recent: Schema.optional(Schema.Boolean),
  is_regex: Schema.optional(Schema.Boolean),
  is_similarity: Schema.optional(Schema.Boolean),
  pattern: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/email-security/settings/trusted_domains/{trusted_domain_id}" }),
).annotations({ identifier: "UpdateTrustedDomainRequest" }) as unknown as Schema.Schema<UpdateTrustedDomainRequest>;

export interface UpdateTrustedDomainResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateTrustedDomainResponse = Schema.Struct({
  result: Schema.Struct({
  comments: Schema.optional(Schema.String),
  is_recent: Schema.Boolean,
  is_regex: Schema.Boolean,
  is_similarity: Schema.Boolean,
  pattern: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateTrustedDomainResponse" }) as unknown as Schema.Schema<UpdateTrustedDomainResponse>;

export const updateTrustedDomain: (
  input: UpdateTrustedDomainRequest
) => Effect.Effect<
  UpdateTrustedDomainResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateTrustedDomainRequest,
  output: UpdateTrustedDomainResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface EmailSecuritySubmissionsRequest {
  account_id: string;
  start?: string;
  end?: string;
  type?: unknown;
  submission_id?: string;
  original_disposition?: unknown;
  requested_disposition?: unknown;
  outcome_disposition?: unknown;
  status?: string;
  query?: string;
  page?: number;
  per_page?: number;
}

export const EmailSecuritySubmissionsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  start: Schema.optional(Schema.Date).pipe(T.HttpQuery("start")),
  end: Schema.optional(Schema.Date).pipe(T.HttpQuery("end")),
  type: Schema.optional(Schema.Literal("TEAM", "USER")).pipe(T.HttpQuery("type")),
  submission_id: Schema.optional(Schema.String).pipe(T.HttpQuery("submission_id")),
  original_disposition: Schema.optional(Schema.Literal("MALICIOUS", "SUSPICIOUS", "SPOOF", "SPAM", "BULK", "NONE")).pipe(T.HttpQuery("original_disposition")),
  requested_disposition: Schema.optional(Schema.Literal("MALICIOUS", "SUSPICIOUS", "SPOOF", "SPAM", "BULK", "NONE")).pipe(T.HttpQuery("requested_disposition")),
  outcome_disposition: Schema.optional(Schema.Literal("MALICIOUS", "SUSPICIOUS", "SPOOF", "SPAM", "BULK", "NONE")).pipe(T.HttpQuery("outcome_disposition")),
  status: Schema.optional(Schema.String).pipe(T.HttpQuery("status")),
  query: Schema.optional(Schema.String).pipe(T.HttpQuery("query")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email-security/submissions" }),
).annotations({ identifier: "EmailSecuritySubmissionsRequest" }) as unknown as Schema.Schema<EmailSecuritySubmissionsRequest>;

export interface EmailSecuritySubmissionsResponse {
  result: { original_disposition?: unknown; original_edf_hash?: string; outcome?: string; outcome_disposition?: unknown; requested_by?: string; requested_disposition?: unknown; requested_ts: string; status?: string; subject?: string; submission_id: string; type?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const EmailSecuritySubmissionsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  original_disposition: Schema.optional(Schema.String),
  original_edf_hash: Schema.optional(Schema.String),
  outcome: Schema.optional(Schema.String),
  outcome_disposition: Schema.optional(Schema.String),
  requested_by: Schema.optional(Schema.String),
  requested_disposition: Schema.optional(Schema.String),
  requested_ts: Schema.Date,
  status: Schema.optional(Schema.String),
  subject: Schema.optional(Schema.String),
  submission_id: Schema.String,
  type: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "EmailSecuritySubmissionsResponse" }) as unknown as Schema.Schema<EmailSecuritySubmissionsResponse>;

export const emailSecuritySubmissions: (
  input: EmailSecuritySubmissionsRequest
) => Effect.Effect<
  EmailSecuritySubmissionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: EmailSecuritySubmissionsRequest,
  output: EmailSecuritySubmissionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDestinationAddressesRequest {
  account_id: string;
  page?: number;
  per_page?: number;
  direction?: "asc" | "desc";
  verified?: true | false;
}

export const ListDestinationAddressesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction")),
  verified: Schema.optional(Schema.Literal(true, false)).pipe(T.HttpQuery("verified"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email/routing/addresses" }),
).annotations({ identifier: "ListDestinationAddressesRequest" }) as unknown as Schema.Schema<ListDestinationAddressesRequest>;

export interface ListDestinationAddressesResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDestinationAddressesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDestinationAddressesResponse" }) as unknown as Schema.Schema<ListDestinationAddressesResponse>;

export const listDestinationAddresses: (
  input: ListDestinationAddressesRequest
) => Effect.Effect<
  ListDestinationAddressesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDestinationAddressesRequest,
  output: ListDestinationAddressesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateADestinationAddressRequest {
  account_id: string;
  body: { email: string };
}

export const CreateADestinationAddressRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  email: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/email/routing/addresses" }),
).annotations({ identifier: "CreateADestinationAddressRequest" }) as unknown as Schema.Schema<CreateADestinationAddressRequest>;

export interface CreateADestinationAddressResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateADestinationAddressResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateADestinationAddressResponse" }) as unknown as Schema.Schema<CreateADestinationAddressResponse>;

export const createADestinationAddress: (
  input: CreateADestinationAddressRequest
) => Effect.Effect<
  CreateADestinationAddressResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateADestinationAddressRequest,
  output: CreateADestinationAddressResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetADestinationAddressRequest {
  destination_address_identifier: string;
  account_id: string;
}

export const GetADestinationAddressRequest = Schema.Struct({
  destination_address_identifier: Schema.String.pipe(T.HttpPath("destination_address_identifier")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/email/routing/addresses/{destination_address_identifier}" }),
).annotations({ identifier: "GetADestinationAddressRequest" }) as unknown as Schema.Schema<GetADestinationAddressRequest>;

export interface GetADestinationAddressResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetADestinationAddressResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetADestinationAddressResponse" }) as unknown as Schema.Schema<GetADestinationAddressResponse>;

export const getADestinationAddress: (
  input: GetADestinationAddressRequest
) => Effect.Effect<
  GetADestinationAddressResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetADestinationAddressRequest,
  output: GetADestinationAddressResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteDestinationAddressRequest {
  destination_address_identifier: string;
  account_id: string;
}

export const DeleteDestinationAddressRequest = Schema.Struct({
  destination_address_identifier: Schema.String.pipe(T.HttpPath("destination_address_identifier")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/email/routing/addresses/{destination_address_identifier}" }),
).annotations({ identifier: "DeleteDestinationAddressRequest" }) as unknown as Schema.Schema<DeleteDestinationAddressRequest>;

export interface DeleteDestinationAddressResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteDestinationAddressResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteDestinationAddressResponse" }) as unknown as Schema.Schema<DeleteDestinationAddressResponse>;

export const deleteDestinationAddress: (
  input: DeleteDestinationAddressRequest
) => Effect.Effect<
  DeleteDestinationAddressResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDestinationAddressRequest,
  output: DeleteDestinationAddressResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetEventNotificationConfigsRequest {
  bucket_name: string;
  account_id: string;
  "cf-r2-jurisdiction"?: "default" | "eu" | "fedramp";
}

export const GetEventNotificationConfigsRequest = Schema.Struct({
  bucket_name: Schema.String.pipe(T.HttpPath("bucket_name")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "cf-r2-jurisdiction": Schema.optional(Schema.Literal("default", "eu", "fedramp")).pipe(T.HttpHeader("cf-r2-jurisdiction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/event_notifications/r2/{bucket_name}/configuration" }),
).annotations({ identifier: "GetEventNotificationConfigsRequest" }) as unknown as Schema.Schema<GetEventNotificationConfigsRequest>;

export interface GetEventNotificationConfigsResponse {
  result: { bucketName?: string; queues?: { queueId?: string; queueName?: string; rules?: unknown[] }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetEventNotificationConfigsResponse = Schema.Struct({
  result: Schema.Struct({
  bucketName: Schema.optional(Schema.String),
  queues: Schema.optional(Schema.Array(Schema.Struct({
  queueId: Schema.optional(Schema.String),
  queueName: Schema.optional(Schema.String),
  rules: Schema.optional(Schema.Array(Schema.Struct({
  createdAt: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  ruleId: Schema.optional(Schema.String)
})))
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetEventNotificationConfigsResponse" }) as unknown as Schema.Schema<GetEventNotificationConfigsResponse>;

export const getEventNotificationConfigs: (
  input: GetEventNotificationConfigsRequest
) => Effect.Effect<
  GetEventNotificationConfigsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEventNotificationConfigsRequest,
  output: GetEventNotificationConfigsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetEventNotificationConfigRequest {
  queue_id: string;
  bucket_name: string;
  account_id: string;
  "cf-r2-jurisdiction"?: "default" | "eu" | "fedramp";
}

export const GetEventNotificationConfigRequest = Schema.Struct({
  queue_id: Schema.String.pipe(T.HttpPath("queue_id")),
  bucket_name: Schema.String.pipe(T.HttpPath("bucket_name")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "cf-r2-jurisdiction": Schema.optional(Schema.Literal("default", "eu", "fedramp")).pipe(T.HttpHeader("cf-r2-jurisdiction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/event_notifications/r2/{bucket_name}/configuration/queues/{queue_id}" }),
).annotations({ identifier: "GetEventNotificationConfigRequest" }) as unknown as Schema.Schema<GetEventNotificationConfigRequest>;

export interface GetEventNotificationConfigResponse {
  result: { queueId?: string; queueName?: string; rules?: unknown[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetEventNotificationConfigResponse = Schema.Struct({
  result: Schema.Struct({
  queueId: Schema.optional(Schema.String),
  queueName: Schema.optional(Schema.String),
  rules: Schema.optional(Schema.Array(Schema.Struct({
  createdAt: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  ruleId: Schema.optional(Schema.String)
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetEventNotificationConfigResponse" }) as unknown as Schema.Schema<GetEventNotificationConfigResponse>;

export const getEventNotificationConfig: (
  input: GetEventNotificationConfigRequest
) => Effect.Effect<
  GetEventNotificationConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetEventNotificationConfigRequest,
  output: GetEventNotificationConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PutEventNotificationConfigRequest {
  queue_id: string;
  bucket_name: string;
  account_id: string;
  "cf-r2-jurisdiction"?: "default" | "eu" | "fedramp";
  body: { rules: { actions: "PutObject" | "CopyObject" | "DeleteObject" | "CompleteMultipartUpload" | "LifecycleDeletion"[]; description?: string; prefix?: string; suffix?: string }[] };
}

export const PutEventNotificationConfigRequest = Schema.Struct({
  queue_id: Schema.String.pipe(T.HttpPath("queue_id")),
  bucket_name: Schema.String.pipe(T.HttpPath("bucket_name")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "cf-r2-jurisdiction": Schema.optional(Schema.Literal("default", "eu", "fedramp")).pipe(T.HttpHeader("cf-r2-jurisdiction")),
  body: Schema.Struct({
  rules: Schema.Array(Schema.Struct({
  actions: Schema.Array(Schema.Literal("PutObject", "CopyObject", "DeleteObject", "CompleteMultipartUpload", "LifecycleDeletion")),
  description: Schema.optional(Schema.String),
  prefix: Schema.optional(Schema.String),
  suffix: Schema.optional(Schema.String)
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/event_notifications/r2/{bucket_name}/configuration/queues/{queue_id}" }),
).annotations({ identifier: "PutEventNotificationConfigRequest" }) as unknown as Schema.Schema<PutEventNotificationConfigRequest>;

export interface PutEventNotificationConfigResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PutEventNotificationConfigResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PutEventNotificationConfigResponse" }) as unknown as Schema.Schema<PutEventNotificationConfigResponse>;

export const putEventNotificationConfig: (
  input: PutEventNotificationConfigRequest
) => Effect.Effect<
  PutEventNotificationConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutEventNotificationConfigRequest,
  output: PutEventNotificationConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteConfigRequest {
  queue_id: string;
  bucket_name: string;
  account_id: string;
  "cf-r2-jurisdiction"?: "default" | "eu" | "fedramp";
  body: { ruleIds?: string[] };
}

export const DeleteConfigRequest = Schema.Struct({
  queue_id: Schema.String.pipe(T.HttpPath("queue_id")),
  bucket_name: Schema.String.pipe(T.HttpPath("bucket_name")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "cf-r2-jurisdiction": Schema.optional(Schema.Literal("default", "eu", "fedramp")).pipe(T.HttpHeader("cf-r2-jurisdiction")),
  body: Schema.Struct({
  ruleIds: Schema.optional(Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/event_notifications/r2/{bucket_name}/configuration/queues/{queue_id}" }),
).annotations({ identifier: "DeleteConfigRequest" }) as unknown as Schema.Schema<DeleteConfigRequest>;

export interface DeleteConfigResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteConfigResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteConfigResponse" }) as unknown as Schema.Schema<DeleteConfigResponse>;

export const deleteConfig: (
  input: DeleteConfigRequest
) => Effect.Effect<
  DeleteConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteConfigRequest,
  output: DeleteConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List15Request {
  account_id: string;
  page?: number;
  per_page?: number;
  order?: "created_at" | "name" | "enabled" | "source";
  direction?: "asc" | "desc";
}

export const List15Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.Literal("created_at", "name", "enabled", "source")).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/event_subscriptions/subscriptions" }),
).annotations({ identifier: "List15Request" }) as unknown as Schema.Schema<List15Request>;

export interface List15Response {
  result: { created_at: string; destination: Record<string, unknown>; enabled: boolean; events: string[]; id: string; modified_at: string; name: string; source: Record<string, unknown> }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List15Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.Date,
  destination: Schema.Struct({}),
  enabled: Schema.Boolean,
  events: Schema.Array(Schema.String),
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  source: Schema.Struct({})
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List15Response" }) as unknown as Schema.Schema<List15Response>;

export const list15: (
  input: List15Request
) => Effect.Effect<
  List15Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List15Request,
  output: List15Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create5Request {
  account_id: string;
  body: { destination?: Record<string, unknown>; enabled?: boolean; events?: string[]; name?: string; source?: Record<string, unknown> };
}

export const Create5Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  destination: Schema.optional(Schema.Struct({})),
  enabled: Schema.optional(Schema.Boolean),
  events: Schema.optional(Schema.Array(Schema.String)),
  name: Schema.optional(Schema.String),
  source: Schema.optional(Schema.Struct({}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/event_subscriptions/subscriptions" }),
).annotations({ identifier: "Create5Request" }) as unknown as Schema.Schema<Create5Request>;

export interface Create5Response {
  result: { created_at: string; destination: Record<string, unknown>; enabled: boolean; events: string[]; id: string; modified_at: string; name: string; source: Record<string, unknown> };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create5Response = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  destination: Schema.Struct({}),
  enabled: Schema.Boolean,
  events: Schema.Array(Schema.String),
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  source: Schema.Struct({})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create5Response" }) as unknown as Schema.Schema<Create5Response>;

export const create5: (
  input: Create5Request
) => Effect.Effect<
  Create5Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create5Request,
  output: Create5Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_8Request {
  account_id: string;
  subscription_id: string;
}

export const Get_8Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  subscription_id: Schema.String.pipe(T.HttpPath("subscription_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/event_subscriptions/subscriptions/{subscription_id}" }),
).annotations({ identifier: "Get_8Request" }) as unknown as Schema.Schema<Get_8Request>;

export interface Get_8Response {
  result: { created_at: string; destination: Record<string, unknown>; enabled: boolean; events: string[]; id: string; modified_at: string; name: string; source: Record<string, unknown> };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_8Response = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  destination: Schema.Struct({}),
  enabled: Schema.Boolean,
  events: Schema.Array(Schema.String),
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  source: Schema.Struct({})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_8Response" }) as unknown as Schema.Schema<Get_8Response>;

export const get_8: (
  input: Get_8Request
) => Effect.Effect<
  Get_8Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_8Request,
  output: Get_8Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_9Request {
  account_id: string;
  subscription_id: string;
}

export const Delete_9Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  subscription_id: Schema.String.pipe(T.HttpPath("subscription_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/event_subscriptions/subscriptions/{subscription_id}" }),
).annotations({ identifier: "Delete_9Request" }) as unknown as Schema.Schema<Delete_9Request>;

export interface Delete_9Response {
  result: { created_at: string; destination: Record<string, unknown>; enabled: boolean; events: string[]; id: string; modified_at: string; name: string; source: Record<string, unknown> };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_9Response = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  destination: Schema.Struct({}),
  enabled: Schema.Boolean,
  events: Schema.Array(Schema.String),
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  source: Schema.Struct({})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_9Response" }) as unknown as Schema.Schema<Delete_9Response>;

export const delete_9: (
  input: Delete_9Request
) => Effect.Effect<
  Delete_9Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_9Request,
  output: Delete_9Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchRequest {
  account_id: string;
  subscription_id: string;
  body: { destination?: Record<string, unknown>; enabled?: boolean; events?: string[]; name?: string };
}

export const PatchRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  subscription_id: Schema.String.pipe(T.HttpPath("subscription_id")),
  body: Schema.Struct({
  destination: Schema.optional(Schema.Struct({})),
  enabled: Schema.optional(Schema.Boolean),
  events: Schema.optional(Schema.Array(Schema.String)),
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/event_subscriptions/subscriptions/{subscription_id}" }),
).annotations({ identifier: "PatchRequest" }) as unknown as Schema.Schema<PatchRequest>;

export interface PatchResponse {
  result: { created_at: string; destination: Record<string, unknown>; enabled: boolean; events: string[]; id: string; modified_at: string; name: string; source: Record<string, unknown> };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  destination: Schema.Struct({}),
  enabled: Schema.Boolean,
  events: Schema.Array(Schema.String),
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  source: Schema.Struct({})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchResponse" }) as unknown as Schema.Schema<PatchResponse>;

export const patch: (
  input: PatchRequest
) => Effect.Effect<
  PatchResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchRequest,
  output: PatchResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListIpAccessRulesRequest {
  account_id: string;
  mode?: "block" | "challenge" | "whitelist" | "js_challenge" | "managed_challenge";
  "configuration.target"?: "ip" | "ip_range" | "asn" | "country";
  "configuration.value"?: string;
  notes?: string;
  match?: "any" | "all";
  page?: number;
  per_page?: number;
  order?: "configuration.target" | "configuration.value" | "mode";
  direction?: "asc" | "desc";
}

export const ListIpAccessRulesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  mode: Schema.optional(Schema.Literal("block", "challenge", "whitelist", "js_challenge", "managed_challenge")).pipe(T.HttpQuery("mode")),
  "configuration.target": Schema.optional(Schema.Literal("ip", "ip_range", "asn", "country")).pipe(T.HttpQuery("configuration.target")),
  "configuration.value": Schema.optional(Schema.String).pipe(T.HttpQuery("configuration.value")),
  notes: Schema.optional(Schema.String).pipe(T.HttpQuery("notes")),
  match: Schema.optional(Schema.Literal("any", "all")).pipe(T.HttpQuery("match")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.Literal("configuration.target", "configuration.value", "mode")).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/firewall/access_rules/rules" }),
).annotations({ identifier: "ListIpAccessRulesRequest" }) as unknown as Schema.Schema<ListIpAccessRulesRequest>;

export interface ListIpAccessRulesResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListIpAccessRulesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListIpAccessRulesResponse" }) as unknown as Schema.Schema<ListIpAccessRulesResponse>;

export const listIpAccessRules: (
  input: ListIpAccessRulesRequest
) => Effect.Effect<
  ListIpAccessRulesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListIpAccessRulesRequest,
  output: ListIpAccessRulesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateAnIpAccessRuleRequest {
  account_id: string;
  body: { configuration: Record<string, unknown>; mode: "block" | "challenge" | "whitelist" | "js_challenge" | "managed_challenge"; notes?: unknown };
}

export const CreateAnIpAccessRuleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  configuration: Schema.Struct({}),
  mode: Schema.Literal("block", "challenge", "whitelist", "js_challenge", "managed_challenge"),
  notes: Schema.optional(Schema.Unknown)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/firewall/access_rules/rules" }),
).annotations({ identifier: "CreateAnIpAccessRuleRequest" }) as unknown as Schema.Schema<CreateAnIpAccessRuleRequest>;

export interface CreateAnIpAccessRuleResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateAnIpAccessRuleResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateAnIpAccessRuleResponse" }) as unknown as Schema.Schema<CreateAnIpAccessRuleResponse>;

export const createAnIpAccessRule: (
  input: CreateAnIpAccessRuleRequest
) => Effect.Effect<
  CreateAnIpAccessRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAnIpAccessRuleRequest,
  output: CreateAnIpAccessRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAnIpAccessRuleRequest {
  rule_id: string;
  account_id: string;
}

export const GetAnIpAccessRuleRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/firewall/access_rules/rules/{rule_id}" }),
).annotations({ identifier: "GetAnIpAccessRuleRequest" }) as unknown as Schema.Schema<GetAnIpAccessRuleRequest>;

export interface GetAnIpAccessRuleResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAnIpAccessRuleResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAnIpAccessRuleResponse" }) as unknown as Schema.Schema<GetAnIpAccessRuleResponse>;

export const getAnIpAccessRule: (
  input: GetAnIpAccessRuleRequest
) => Effect.Effect<
  GetAnIpAccessRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAnIpAccessRuleRequest,
  output: GetAnIpAccessRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAnIpAccessRuleRequest {
  rule_id: string;
  account_id: string;
}

export const DeleteAnIpAccessRuleRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/firewall/access_rules/rules/{rule_id}" }),
).annotations({ identifier: "DeleteAnIpAccessRuleRequest" }) as unknown as Schema.Schema<DeleteAnIpAccessRuleRequest>;

export interface DeleteAnIpAccessRuleResponse {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAnIpAccessRuleResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAnIpAccessRuleResponse" }) as unknown as Schema.Schema<DeleteAnIpAccessRuleResponse>;

export const deleteAnIpAccessRule: (
  input: DeleteAnIpAccessRuleRequest
) => Effect.Effect<
  DeleteAnIpAccessRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAnIpAccessRuleRequest,
  output: DeleteAnIpAccessRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAnIpAccessRuleRequest {
  rule_id: string;
  account_id: string;
  body: Record<string, unknown>;
}

export const UpdateAnIpAccessRuleRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/firewall/access_rules/rules/{rule_id}" }),
).annotations({ identifier: "UpdateAnIpAccessRuleRequest" }) as unknown as Schema.Schema<UpdateAnIpAccessRuleRequest>;

export interface UpdateAnIpAccessRuleResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAnIpAccessRuleResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAnIpAccessRuleResponse" }) as unknown as Schema.Schema<UpdateAnIpAccessRuleResponse>;

export const updateAnIpAccessRule: (
  input: UpdateAnIpAccessRuleRequest
) => Effect.Effect<
  UpdateAnIpAccessRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAnIpAccessRuleRequest,
  output: UpdateAnIpAccessRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZeroTrustAccountInformationRequest {
  account_id: string;
}

export const GetZeroTrustAccountInformationRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway" }),
).annotations({ identifier: "GetZeroTrustAccountInformationRequest" }) as unknown as Schema.Schema<GetZeroTrustAccountInformationRequest>;

export interface GetZeroTrustAccountInformationResponse {
  result: { gateway_tag?: string; id?: string; provider_name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZeroTrustAccountInformationResponse = Schema.Struct({
  result: Schema.Struct({
  gateway_tag: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  provider_name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZeroTrustAccountInformationResponse" }) as unknown as Schema.Schema<GetZeroTrustAccountInformationResponse>;

export const getZeroTrustAccountInformation: (
  input: GetZeroTrustAccountInformationRequest
) => Effect.Effect<
  GetZeroTrustAccountInformationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZeroTrustAccountInformationRequest,
  output: GetZeroTrustAccountInformationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateZeroTrustAccountRequest {
  account_id: string;
}

export const CreateZeroTrustAccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/gateway" }),
).annotations({ identifier: "CreateZeroTrustAccountRequest" }) as unknown as Schema.Schema<CreateZeroTrustAccountRequest>;

export interface CreateZeroTrustAccountResponse {
  result: { gateway_tag?: string; id?: string; provider_name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateZeroTrustAccountResponse = Schema.Struct({
  result: Schema.Struct({
  gateway_tag: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  provider_name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateZeroTrustAccountResponse" }) as unknown as Schema.Schema<CreateZeroTrustAccountResponse>;

export const createZeroTrustAccount: (
  input: CreateZeroTrustAccountRequest
) => Effect.Effect<
  CreateZeroTrustAccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateZeroTrustAccountRequest,
  output: CreateZeroTrustAccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListApplicationAndApplicationTypeMappingsRequest {
  account_id: string;
}

export const ListApplicationAndApplicationTypeMappingsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/app_types" }),
).annotations({ identifier: "ListApplicationAndApplicationTypeMappingsRequest" }) as unknown as Schema.Schema<ListApplicationAndApplicationTypeMappingsRequest>;

export interface ListApplicationAndApplicationTypeMappingsResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListApplicationAndApplicationTypeMappingsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListApplicationAndApplicationTypeMappingsResponse" }) as unknown as Schema.Schema<ListApplicationAndApplicationTypeMappingsResponse>;

export const listApplicationAndApplicationTypeMappings: (
  input: ListApplicationAndApplicationTypeMappingsRequest
) => Effect.Effect<
  ListApplicationAndApplicationTypeMappingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListApplicationAndApplicationTypeMappingsRequest,
  output: ListApplicationAndApplicationTypeMappingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List16Request {
  account_id: string;
}

export const List16Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/apps/review_status" }),
).annotations({ identifier: "List16Request" }) as unknown as Schema.Schema<List16Request>;

export interface List16Response {
  result: { approved_apps?: number[]; created_at?: string; in_review_apps?: number[]; unapproved_apps?: number[]; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List16Response = Schema.Struct({
  result: Schema.Struct({
  approved_apps: Schema.optional(Schema.Array(Schema.Number)),
  created_at: Schema.optional(Schema.Date),
  in_review_apps: Schema.optional(Schema.Array(Schema.Number)),
  unapproved_apps: Schema.optional(Schema.Array(Schema.Number)),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List16Response" }) as unknown as Schema.Schema<List16Response>;

export const list16: (
  input: List16Request
) => Effect.Effect<
  List16Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List16Request,
  output: List16Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update8Request {
  account_id: string;
  body: { approved_apps: number[]; in_review_apps: number[]; unapproved_apps: number[] };
}

export const Update8Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  approved_apps: Schema.Array(Schema.Number),
  in_review_apps: Schema.Array(Schema.Number),
  unapproved_apps: Schema.Array(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/gateway/apps/review_status" }),
).annotations({ identifier: "Update8Request" }) as unknown as Schema.Schema<Update8Request>;

export interface Update8Response {
  result: { approved_apps?: number[]; created_at?: string; in_review_apps?: number[]; unapproved_apps?: number[]; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update8Response = Schema.Struct({
  result: Schema.Struct({
  approved_apps: Schema.optional(Schema.Array(Schema.Number)),
  created_at: Schema.optional(Schema.Date),
  in_review_apps: Schema.optional(Schema.Array(Schema.Number)),
  unapproved_apps: Schema.optional(Schema.Array(Schema.Number)),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update8Response" }) as unknown as Schema.Schema<Update8Response>;

export const update8: (
  input: Update8Request
) => Effect.Effect<
  Update8Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update8Request,
  output: Update8Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAuditSshSettingsRequest {
  account_id: string;
}

export const GetAuditSshSettingsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/audit_ssh_settings" }),
).annotations({ identifier: "GetAuditSshSettingsRequest" }) as unknown as Schema.Schema<GetAuditSshSettingsRequest>;

export interface GetAuditSshSettingsResponse {
  result: { created_at?: string; public_key?: string; seed_id?: string; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAuditSshSettingsResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  public_key: Schema.optional(Schema.String),
  seed_id: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAuditSshSettingsResponse" }) as unknown as Schema.Schema<GetAuditSshSettingsResponse>;

export const getAuditSshSettings: (
  input: GetAuditSshSettingsRequest
) => Effect.Effect<
  GetAuditSshSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAuditSshSettingsRequest,
  output: GetAuditSshSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAuditSshSettingsRequest {
  account_id: string;
  body: { public_key: string };
}

export const UpdateAuditSshSettingsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  public_key: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/gateway/audit_ssh_settings" }),
).annotations({ identifier: "UpdateAuditSshSettingsRequest" }) as unknown as Schema.Schema<UpdateAuditSshSettingsRequest>;

export interface UpdateAuditSshSettingsResponse {
  result: { created_at?: string; public_key?: string; seed_id?: string; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAuditSshSettingsResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  public_key: Schema.optional(Schema.String),
  seed_id: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAuditSshSettingsResponse" }) as unknown as Schema.Schema<UpdateAuditSshSettingsResponse>;

export const updateAuditSshSettings: (
  input: UpdateAuditSshSettingsRequest
) => Effect.Effect<
  UpdateAuditSshSettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAuditSshSettingsRequest,
  output: UpdateAuditSshSettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZeroTrustRotateSshAccountSeedRequest {
  account_id: string;
}

export const ZeroTrustRotateSshAccountSeedRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/gateway/audit_ssh_settings/rotate_seed" }),
).annotations({ identifier: "ZeroTrustRotateSshAccountSeedRequest" }) as unknown as Schema.Schema<ZeroTrustRotateSshAccountSeedRequest>;

export interface ZeroTrustRotateSshAccountSeedResponse {
  result: { created_at?: string; public_key?: string; seed_id?: string; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZeroTrustRotateSshAccountSeedResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  public_key: Schema.optional(Schema.String),
  seed_id: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZeroTrustRotateSshAccountSeedResponse" }) as unknown as Schema.Schema<ZeroTrustRotateSshAccountSeedResponse>;

export const zeroTrustRotateSshAccountSeed: (
  input: ZeroTrustRotateSshAccountSeedRequest
) => Effect.Effect<
  ZeroTrustRotateSshAccountSeedResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZeroTrustRotateSshAccountSeedRequest,
  output: ZeroTrustRotateSshAccountSeedResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListCategoriesRequest {
  account_id: string;
}

export const ListCategoriesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/categories" }),
).annotations({ identifier: "ListCategoriesRequest" }) as unknown as Schema.Schema<ListCategoriesRequest>;

export interface ListCategoriesResponse {
  result: { beta?: boolean; class?: "free" | "premium" | "blocked" | "removalPending" | "noBlock"; description?: string; id?: number; name?: string; subcategories?: { beta?: boolean; class?: "free" | "premium" | "blocked" | "removalPending" | "noBlock"; description?: string; id?: number; name?: string }[] }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListCategoriesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  beta: Schema.optional(Schema.Boolean),
  class: Schema.optional(Schema.Literal("free", "premium", "blocked", "removalPending", "noBlock")),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  subcategories: Schema.optional(Schema.Array(Schema.Struct({
  beta: Schema.optional(Schema.Boolean),
  class: Schema.optional(Schema.Literal("free", "premium", "blocked", "removalPending", "noBlock")),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String)
})))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListCategoriesResponse" }) as unknown as Schema.Schema<ListCategoriesResponse>;

export const listCategories: (
  input: ListCategoriesRequest
) => Effect.Effect<
  ListCategoriesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListCategoriesRequest,
  output: ListCategoriesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListZeroTrustCertificatesRequest {
  account_id: string;
}

export const ListZeroTrustCertificatesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/certificates" }),
).annotations({ identifier: "ListZeroTrustCertificatesRequest" }) as unknown as Schema.Schema<ListZeroTrustCertificatesRequest>;

export interface ListZeroTrustCertificatesResponse {
  result: { binding_status?: "pending_deployment" | "available" | "pending_deletion" | "inactive"; certificate?: string; created_at?: string; expires_on?: string; fingerprint?: string; id?: string; in_use?: boolean; issuer_org?: string; issuer_raw?: string; type?: "custom" | "gateway_managed"; updated_at?: string; uploaded_on?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListZeroTrustCertificatesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  binding_status: Schema.optional(Schema.Literal("pending_deployment", "available", "pending_deletion", "inactive")),
  certificate: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  expires_on: Schema.optional(Schema.Date),
  fingerprint: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  in_use: Schema.optional(Schema.Boolean),
  issuer_org: Schema.optional(Schema.String),
  issuer_raw: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("custom", "gateway_managed")),
  updated_at: Schema.optional(Schema.Date),
  uploaded_on: Schema.optional(Schema.Date)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListZeroTrustCertificatesResponse" }) as unknown as Schema.Schema<ListZeroTrustCertificatesResponse>;

export const listZeroTrustCertificates: (
  input: ListZeroTrustCertificatesRequest
) => Effect.Effect<
  ListZeroTrustCertificatesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListZeroTrustCertificatesRequest,
  output: ListZeroTrustCertificatesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateZeroTrustCertificateRequest {
  account_id: string;
  body: { validity_period_days?: number };
}

export const CreateZeroTrustCertificateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  validity_period_days: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/gateway/certificates" }),
).annotations({ identifier: "CreateZeroTrustCertificateRequest" }) as unknown as Schema.Schema<CreateZeroTrustCertificateRequest>;

export interface CreateZeroTrustCertificateResponse {
  result: { binding_status?: "pending_deployment" | "available" | "pending_deletion" | "inactive"; certificate?: string; created_at?: string; expires_on?: string; fingerprint?: string; id?: string; in_use?: boolean; issuer_org?: string; issuer_raw?: string; type?: "custom" | "gateway_managed"; updated_at?: string; uploaded_on?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateZeroTrustCertificateResponse = Schema.Struct({
  result: Schema.Struct({
  binding_status: Schema.optional(Schema.Literal("pending_deployment", "available", "pending_deletion", "inactive")),
  certificate: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  expires_on: Schema.optional(Schema.Date),
  fingerprint: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  in_use: Schema.optional(Schema.Boolean),
  issuer_org: Schema.optional(Schema.String),
  issuer_raw: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("custom", "gateway_managed")),
  updated_at: Schema.optional(Schema.Date),
  uploaded_on: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateZeroTrustCertificateResponse" }) as unknown as Schema.Schema<CreateZeroTrustCertificateResponse>;

export const createZeroTrustCertificate: (
  input: CreateZeroTrustCertificateRequest
) => Effect.Effect<
  CreateZeroTrustCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateZeroTrustCertificateRequest,
  output: CreateZeroTrustCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZeroTrustCertificatesZeroTrustCertificateDetailsRequest {
  certificate_id: string;
  account_id: string;
}

export const ZeroTrustCertificatesZeroTrustCertificateDetailsRequest = Schema.Struct({
  certificate_id: Schema.String.pipe(T.HttpPath("certificate_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/certificates/{certificate_id}" }),
).annotations({ identifier: "ZeroTrustCertificatesZeroTrustCertificateDetailsRequest" }) as unknown as Schema.Schema<ZeroTrustCertificatesZeroTrustCertificateDetailsRequest>;

export interface ZeroTrustCertificatesZeroTrustCertificateDetailsResponse {
  result: { binding_status?: "pending_deployment" | "available" | "pending_deletion" | "inactive"; certificate?: string; created_at?: string; expires_on?: string; fingerprint?: string; id?: string; in_use?: boolean; issuer_org?: string; issuer_raw?: string; type?: "custom" | "gateway_managed"; updated_at?: string; uploaded_on?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZeroTrustCertificatesZeroTrustCertificateDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  binding_status: Schema.optional(Schema.Literal("pending_deployment", "available", "pending_deletion", "inactive")),
  certificate: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  expires_on: Schema.optional(Schema.Date),
  fingerprint: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  in_use: Schema.optional(Schema.Boolean),
  issuer_org: Schema.optional(Schema.String),
  issuer_raw: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("custom", "gateway_managed")),
  updated_at: Schema.optional(Schema.Date),
  uploaded_on: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZeroTrustCertificatesZeroTrustCertificateDetailsResponse" }) as unknown as Schema.Schema<ZeroTrustCertificatesZeroTrustCertificateDetailsResponse>;

export const zeroTrustCertificatesZeroTrustCertificateDetails: (
  input: ZeroTrustCertificatesZeroTrustCertificateDetailsRequest
) => Effect.Effect<
  ZeroTrustCertificatesZeroTrustCertificateDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZeroTrustCertificatesZeroTrustCertificateDetailsRequest,
  output: ZeroTrustCertificatesZeroTrustCertificateDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteZeroTrustCertificateRequest {
  certificate_id: string;
  account_id: string;
}

export const DeleteZeroTrustCertificateRequest = Schema.Struct({
  certificate_id: Schema.String.pipe(T.HttpPath("certificate_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/gateway/certificates/{certificate_id}" }),
).annotations({ identifier: "DeleteZeroTrustCertificateRequest" }) as unknown as Schema.Schema<DeleteZeroTrustCertificateRequest>;

export interface DeleteZeroTrustCertificateResponse {
  result: { binding_status?: "pending_deployment" | "available" | "pending_deletion" | "inactive"; certificate?: string; created_at?: string; expires_on?: string; fingerprint?: string; id?: string; in_use?: boolean; issuer_org?: string; issuer_raw?: string; type?: "custom" | "gateway_managed"; updated_at?: string; uploaded_on?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteZeroTrustCertificateResponse = Schema.Struct({
  result: Schema.Struct({
  binding_status: Schema.optional(Schema.Literal("pending_deployment", "available", "pending_deletion", "inactive")),
  certificate: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  expires_on: Schema.optional(Schema.Date),
  fingerprint: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  in_use: Schema.optional(Schema.Boolean),
  issuer_org: Schema.optional(Schema.String),
  issuer_raw: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("custom", "gateway_managed")),
  updated_at: Schema.optional(Schema.Date),
  uploaded_on: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteZeroTrustCertificateResponse" }) as unknown as Schema.Schema<DeleteZeroTrustCertificateResponse>;

export const deleteZeroTrustCertificate: (
  input: DeleteZeroTrustCertificateRequest
) => Effect.Effect<
  DeleteZeroTrustCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteZeroTrustCertificateRequest,
  output: DeleteZeroTrustCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZeroTrustCertificatesActivateZeroTrustCertificateRequest {
  certificate_id: string;
  account_id: string;
}

export const ZeroTrustCertificatesActivateZeroTrustCertificateRequest = Schema.Struct({
  certificate_id: Schema.String.pipe(T.HttpPath("certificate_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/gateway/certificates/{certificate_id}/activate" }),
).annotations({ identifier: "ZeroTrustCertificatesActivateZeroTrustCertificateRequest" }) as unknown as Schema.Schema<ZeroTrustCertificatesActivateZeroTrustCertificateRequest>;

export interface ZeroTrustCertificatesActivateZeroTrustCertificateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZeroTrustCertificatesActivateZeroTrustCertificateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZeroTrustCertificatesActivateZeroTrustCertificateResponse" }) as unknown as Schema.Schema<ZeroTrustCertificatesActivateZeroTrustCertificateResponse>;

export const zeroTrustCertificatesActivateZeroTrustCertificate: (
  input: ZeroTrustCertificatesActivateZeroTrustCertificateRequest
) => Effect.Effect<
  ZeroTrustCertificatesActivateZeroTrustCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZeroTrustCertificatesActivateZeroTrustCertificateRequest,
  output: ZeroTrustCertificatesActivateZeroTrustCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZeroTrustCertificatesDeactivateZeroTrustCertificateRequest {
  certificate_id: string;
  account_id: string;
}

export const ZeroTrustCertificatesDeactivateZeroTrustCertificateRequest = Schema.Struct({
  certificate_id: Schema.String.pipe(T.HttpPath("certificate_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/gateway/certificates/{certificate_id}/deactivate" }),
).annotations({ identifier: "ZeroTrustCertificatesDeactivateZeroTrustCertificateRequest" }) as unknown as Schema.Schema<ZeroTrustCertificatesDeactivateZeroTrustCertificateRequest>;

export interface ZeroTrustCertificatesDeactivateZeroTrustCertificateResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZeroTrustCertificatesDeactivateZeroTrustCertificateResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZeroTrustCertificatesDeactivateZeroTrustCertificateResponse" }) as unknown as Schema.Schema<ZeroTrustCertificatesDeactivateZeroTrustCertificateResponse>;

export const zeroTrustCertificatesDeactivateZeroTrustCertificate: (
  input: ZeroTrustCertificatesDeactivateZeroTrustCertificateRequest
) => Effect.Effect<
  ZeroTrustCertificatesDeactivateZeroTrustCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZeroTrustCertificatesDeactivateZeroTrustCertificateRequest,
  output: ZeroTrustCertificatesDeactivateZeroTrustCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZeroTrustAccountConfigurationRequest {
  account_id: string;
}

export const GetZeroTrustAccountConfigurationRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/configuration" }),
).annotations({ identifier: "GetZeroTrustAccountConfigurationRequest" }) as unknown as Schema.Schema<GetZeroTrustAccountConfigurationRequest>;

export interface GetZeroTrustAccountConfigurationResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZeroTrustAccountConfigurationResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZeroTrustAccountConfigurationResponse" }) as unknown as Schema.Schema<GetZeroTrustAccountConfigurationResponse>;

export const getZeroTrustAccountConfiguration: (
  input: GetZeroTrustAccountConfigurationRequest
) => Effect.Effect<
  GetZeroTrustAccountConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZeroTrustAccountConfigurationRequest,
  output: GetZeroTrustAccountConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateZeroTrustAccountConfigurationRequest {
  account_id: string;
  body: unknown;
}

export const UpdateZeroTrustAccountConfigurationRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/gateway/configuration" }),
).annotations({ identifier: "UpdateZeroTrustAccountConfigurationRequest" }) as unknown as Schema.Schema<UpdateZeroTrustAccountConfigurationRequest>;

export interface UpdateZeroTrustAccountConfigurationResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateZeroTrustAccountConfigurationResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateZeroTrustAccountConfigurationResponse" }) as unknown as Schema.Schema<UpdateZeroTrustAccountConfigurationResponse>;

export const updateZeroTrustAccountConfiguration: (
  input: UpdateZeroTrustAccountConfigurationRequest
) => Effect.Effect<
  UpdateZeroTrustAccountConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateZeroTrustAccountConfigurationRequest,
  output: UpdateZeroTrustAccountConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchZeroTrustAccountConfigurationRequest {
  account_id: string;
  body: unknown;
}

export const PatchZeroTrustAccountConfigurationRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/gateway/configuration" }),
).annotations({ identifier: "PatchZeroTrustAccountConfigurationRequest" }) as unknown as Schema.Schema<PatchZeroTrustAccountConfigurationRequest>;

export interface PatchZeroTrustAccountConfigurationResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchZeroTrustAccountConfigurationResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchZeroTrustAccountConfigurationResponse" }) as unknown as Schema.Schema<PatchZeroTrustAccountConfigurationResponse>;

export const patchZeroTrustAccountConfiguration: (
  input: PatchZeroTrustAccountConfigurationRequest
) => Effect.Effect<
  PatchZeroTrustAccountConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchZeroTrustAccountConfigurationRequest,
  output: PatchZeroTrustAccountConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetZeroTrustCertificateConfigurationRequest {
  account_id: string;
}

export const GetZeroTrustCertificateConfigurationRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/configuration/custom_certificate" }),
).annotations({ identifier: "GetZeroTrustCertificateConfigurationRequest" }) as unknown as Schema.Schema<GetZeroTrustCertificateConfigurationRequest>;

export interface GetZeroTrustCertificateConfigurationResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetZeroTrustCertificateConfigurationResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetZeroTrustCertificateConfigurationResponse" }) as unknown as Schema.Schema<GetZeroTrustCertificateConfigurationResponse>;

export const getZeroTrustCertificateConfiguration: (
  input: GetZeroTrustCertificateConfigurationRequest
) => Effect.Effect<
  GetZeroTrustCertificateConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetZeroTrustCertificateConfigurationRequest,
  output: GetZeroTrustCertificateConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListZeroTrustListsRequest {
  account_id: string;
  type?: "SERIAL" | "URL" | "DOMAIN" | "EMAIL" | "IP" | "CATEGORY" | "LOCATION" | "DEVICE";
}

export const ListZeroTrustListsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  type: Schema.optional(Schema.Literal("SERIAL", "URL", "DOMAIN", "EMAIL", "IP", "CATEGORY", "LOCATION", "DEVICE")).pipe(T.HttpQuery("type"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/lists" }),
).annotations({ identifier: "ListZeroTrustListsRequest" }) as unknown as Schema.Schema<ListZeroTrustListsRequest>;

export interface ListZeroTrustListsResponse {
  result: { count?: number; created_at?: string; description?: string; id?: string; items?: { created_at?: string; description?: string; value?: string }[]; name?: string; type?: "SERIAL" | "URL" | "DOMAIN" | "EMAIL" | "IP" | "CATEGORY" | "LOCATION" | "DEVICE"; updated_at?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListZeroTrustListsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  count: Schema.optional(Schema.Number),
  created_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  items: Schema.optional(Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
}))),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("SERIAL", "URL", "DOMAIN", "EMAIL", "IP", "CATEGORY", "LOCATION", "DEVICE")),
  updated_at: Schema.optional(Schema.Date)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListZeroTrustListsResponse" }) as unknown as Schema.Schema<ListZeroTrustListsResponse>;

export const listZeroTrustLists: (
  input: ListZeroTrustListsRequest
) => Effect.Effect<
  ListZeroTrustListsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListZeroTrustListsRequest,
  output: ListZeroTrustListsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List17Request {
  account_id: string;
  body: { description?: string; items?: { description?: string; value?: string }[]; name: string; type: "SERIAL" | "URL" | "DOMAIN" | "EMAIL" | "IP" | "CATEGORY" | "LOCATION" | "DEVICE" };
}

export const List17Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  items: Schema.optional(Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
}))),
  name: Schema.String,
  type: Schema.Literal("SERIAL", "URL", "DOMAIN", "EMAIL", "IP", "CATEGORY", "LOCATION", "DEVICE")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/gateway/lists" }),
).annotations({ identifier: "List17Request" }) as unknown as Schema.Schema<List17Request>;

export interface List17Response {
  result: { created_at?: string; description?: string; id?: string; items?: { created_at?: string; description?: string; value?: string }[]; name?: string; type?: "SERIAL" | "URL" | "DOMAIN" | "EMAIL" | "IP" | "CATEGORY" | "LOCATION" | "DEVICE"; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List17Response = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  items: Schema.optional(Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
}))),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("SERIAL", "URL", "DOMAIN", "EMAIL", "IP", "CATEGORY", "LOCATION", "DEVICE")),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List17Response" }) as unknown as Schema.Schema<List17Response>;

export const list17: (
  input: List17Request
) => Effect.Effect<
  List17Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List17Request,
  output: List17Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDetailsRequest {
  list_id: string;
  account_id: string;
}

export const ListDetailsRequest = Schema.Struct({
  list_id: Schema.String.pipe(T.HttpPath("list_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/lists/{list_id}" }),
).annotations({ identifier: "ListDetailsRequest" }) as unknown as Schema.Schema<ListDetailsRequest>;

export interface ListDetailsResponse {
  result: { count?: number; created_at?: string; description?: string; id?: string; items?: { created_at?: string; description?: string; value?: string }[]; name?: string; type?: "SERIAL" | "URL" | "DOMAIN" | "EMAIL" | "IP" | "CATEGORY" | "LOCATION" | "DEVICE"; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  count: Schema.optional(Schema.Number),
  created_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  items: Schema.optional(Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
}))),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("SERIAL", "URL", "DOMAIN", "EMAIL", "IP", "CATEGORY", "LOCATION", "DEVICE")),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDetailsResponse" }) as unknown as Schema.Schema<ListDetailsResponse>;

export const listDetails: (
  input: ListDetailsRequest
) => Effect.Effect<
  ListDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDetailsRequest,
  output: ListDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List18Request {
  list_id: string;
  account_id: string;
  body: { description?: string; items?: { description?: string; value?: string }[]; name: string };
}

export const List18Request = Schema.Struct({
  list_id: Schema.String.pipe(T.HttpPath("list_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  items: Schema.optional(Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
}))),
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/gateway/lists/{list_id}" }),
).annotations({ identifier: "List18Request" }) as unknown as Schema.Schema<List18Request>;

export interface List18Response {
  result: { count?: number; created_at?: string; description?: string; id?: string; items?: { created_at?: string; description?: string; value?: string }[]; name?: string; type?: "SERIAL" | "URL" | "DOMAIN" | "EMAIL" | "IP" | "CATEGORY" | "LOCATION" | "DEVICE"; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List18Response = Schema.Struct({
  result: Schema.Struct({
  count: Schema.optional(Schema.Number),
  created_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  items: Schema.optional(Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
}))),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("SERIAL", "URL", "DOMAIN", "EMAIL", "IP", "CATEGORY", "LOCATION", "DEVICE")),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List18Response" }) as unknown as Schema.Schema<List18Response>;

export const list18: (
  input: List18Request
) => Effect.Effect<
  List18Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List18Request,
  output: List18Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List19Request {
  list_id: string;
  account_id: string;
}

export const List19Request = Schema.Struct({
  list_id: Schema.String.pipe(T.HttpPath("list_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/gateway/lists/{list_id}" }),
).annotations({ identifier: "List19Request" }) as unknown as Schema.Schema<List19Request>;

export interface List19Response {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List19Response = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List19Response" }) as unknown as Schema.Schema<List19Response>;

export const list19: (
  input: List19Request
) => Effect.Effect<
  List19Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List19Request,
  output: List19Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List20Request {
  list_id: string;
  account_id: string;
  body: { append?: { description?: string; value?: string }[]; remove?: string[] };
}

export const List20Request = Schema.Struct({
  list_id: Schema.String.pipe(T.HttpPath("list_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  append: Schema.optional(Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
}))),
  remove: Schema.optional(Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/gateway/lists/{list_id}" }),
).annotations({ identifier: "List20Request" }) as unknown as Schema.Schema<List20Request>;

export interface List20Response {
  result: { count?: number; created_at?: string; description?: string; id?: string; items?: { created_at?: string; description?: string; value?: string }[]; name?: string; type?: "SERIAL" | "URL" | "DOMAIN" | "EMAIL" | "IP" | "CATEGORY" | "LOCATION" | "DEVICE"; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List20Response = Schema.Struct({
  result: Schema.Struct({
  count: Schema.optional(Schema.Number),
  created_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  items: Schema.optional(Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
}))),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("SERIAL", "URL", "DOMAIN", "EMAIL", "IP", "CATEGORY", "LOCATION", "DEVICE")),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List20Response" }) as unknown as Schema.Schema<List20Response>;

export const list20: (
  input: List20Request
) => Effect.Effect<
  List20Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List20Request,
  output: List20Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListItems1Request {
  list_id: string;
  account_id: string;
}

export const ListItems1Request = Schema.Struct({
  list_id: Schema.String.pipe(T.HttpPath("list_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/lists/{list_id}/items" }),
).annotations({ identifier: "ListItems1Request" }) as unknown as Schema.Schema<ListItems1Request>;

export interface ListItems1Response {
  result: { created_at?: string; description?: string; value?: string }[][];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListItems1Response = Schema.Struct({
  result: Schema.Array(Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListItems1Response" }) as unknown as Schema.Schema<ListItems1Response>;

export const listItems1: (
  input: ListItems1Request
) => Effect.Effect<
  ListItems1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListItems1Request,
  output: ListItems1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListZeroTrustGatewayLocationsRequest {
  account_id: string;
}

export const ListZeroTrustGatewayLocationsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/locations" }),
).annotations({ identifier: "ListZeroTrustGatewayLocationsRequest" }) as unknown as Schema.Schema<ListZeroTrustGatewayLocationsRequest>;

export interface ListZeroTrustGatewayLocationsResponse {
  result: { client_default?: boolean; created_at?: string; dns_destination_ips_id?: string; dns_destination_ipv6_block_id?: string; doh_subdomain?: string; ecs_support?: boolean; endpoints?: { doh: { enabled?: boolean; networks?: { network: string }[]; require_token?: boolean }; dot: { enabled?: boolean; networks?: { network: string }[] }; ipv4: { enabled?: boolean }; ipv6: { enabled?: boolean; networks?: { network: string }[] } }; id?: string; ip?: string; ipv4_destination?: string; ipv4_destination_backup?: string; name?: string; networks?: { network: string }[]; updated_at?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListZeroTrustGatewayLocationsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  client_default: Schema.optional(Schema.Boolean),
  created_at: Schema.optional(Schema.Date),
  dns_destination_ips_id: Schema.optional(Schema.String),
  dns_destination_ipv6_block_id: Schema.optional(Schema.String),
  doh_subdomain: Schema.optional(Schema.String),
  ecs_support: Schema.optional(Schema.Boolean),
  endpoints: Schema.optional(Schema.Struct({
  doh: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
}))),
  require_token: Schema.optional(Schema.Boolean)
}),
  dot: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
})))
}),
  ipv4: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
}),
  ipv6: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
})))
})
})),
  id: Schema.optional(Schema.String),
  ip: Schema.optional(Schema.String),
  ipv4_destination: Schema.optional(Schema.String),
  ipv4_destination_backup: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
}))),
  updated_at: Schema.optional(Schema.Date)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListZeroTrustGatewayLocationsResponse" }) as unknown as Schema.Schema<ListZeroTrustGatewayLocationsResponse>;

export const listZeroTrustGatewayLocations: (
  input: ListZeroTrustGatewayLocationsRequest
) => Effect.Effect<
  ListZeroTrustGatewayLocationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListZeroTrustGatewayLocationsRequest,
  output: ListZeroTrustGatewayLocationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateZeroTrustGatewayLocationRequest {
  account_id: string;
  body: { client_default?: boolean; dns_destination_ips_id?: string; ecs_support?: boolean; endpoints?: { doh: { enabled?: boolean; networks?: { network: string }[]; require_token?: boolean }; dot: { enabled?: boolean; networks?: { network: string }[] }; ipv4: { enabled?: boolean }; ipv6: { enabled?: boolean; networks?: { network: string }[] } }; name: string; networks?: { network: string }[] };
}

export const CreateZeroTrustGatewayLocationRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  client_default: Schema.optional(Schema.Boolean),
  dns_destination_ips_id: Schema.optional(Schema.String),
  ecs_support: Schema.optional(Schema.Boolean),
  endpoints: Schema.optional(Schema.Struct({
  doh: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
}))),
  require_token: Schema.optional(Schema.Boolean)
}),
  dot: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
})))
}),
  ipv4: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
}),
  ipv6: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
})))
})
})),
  name: Schema.String,
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/gateway/locations" }),
).annotations({ identifier: "CreateZeroTrustGatewayLocationRequest" }) as unknown as Schema.Schema<CreateZeroTrustGatewayLocationRequest>;

export interface CreateZeroTrustGatewayLocationResponse {
  result: { client_default?: boolean; created_at?: string; dns_destination_ips_id?: string; dns_destination_ipv6_block_id?: string; doh_subdomain?: string; ecs_support?: boolean; endpoints?: { doh: { enabled?: boolean; networks?: { network: string }[]; require_token?: boolean }; dot: { enabled?: boolean; networks?: { network: string }[] }; ipv4: { enabled?: boolean }; ipv6: { enabled?: boolean; networks?: { network: string }[] } }; id?: string; ip?: string; ipv4_destination?: string; ipv4_destination_backup?: string; name?: string; networks?: { network: string }[]; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateZeroTrustGatewayLocationResponse = Schema.Struct({
  result: Schema.Struct({
  client_default: Schema.optional(Schema.Boolean),
  created_at: Schema.optional(Schema.Date),
  dns_destination_ips_id: Schema.optional(Schema.String),
  dns_destination_ipv6_block_id: Schema.optional(Schema.String),
  doh_subdomain: Schema.optional(Schema.String),
  ecs_support: Schema.optional(Schema.Boolean),
  endpoints: Schema.optional(Schema.Struct({
  doh: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
}))),
  require_token: Schema.optional(Schema.Boolean)
}),
  dot: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
})))
}),
  ipv4: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
}),
  ipv6: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
})))
})
})),
  id: Schema.optional(Schema.String),
  ip: Schema.optional(Schema.String),
  ipv4_destination: Schema.optional(Schema.String),
  ipv4_destination_backup: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
}))),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateZeroTrustGatewayLocationResponse" }) as unknown as Schema.Schema<CreateZeroTrustGatewayLocationResponse>;

export const createZeroTrustGatewayLocation: (
  input: CreateZeroTrustGatewayLocationRequest
) => Effect.Effect<
  CreateZeroTrustGatewayLocationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateZeroTrustGatewayLocationRequest,
  output: CreateZeroTrustGatewayLocationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsRequest {
  location_id: string;
  account_id: string;
}

export const ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsRequest = Schema.Struct({
  location_id: Schema.String.pipe(T.HttpPath("location_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/locations/{location_id}" }),
).annotations({ identifier: "ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsRequest" }) as unknown as Schema.Schema<ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsRequest>;

export interface ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsResponse {
  result: { client_default?: boolean; created_at?: string; dns_destination_ips_id?: string; dns_destination_ipv6_block_id?: string; doh_subdomain?: string; ecs_support?: boolean; endpoints?: { doh: { enabled?: boolean; networks?: { network: string }[]; require_token?: boolean }; dot: { enabled?: boolean; networks?: { network: string }[] }; ipv4: { enabled?: boolean }; ipv6: { enabled?: boolean; networks?: { network: string }[] } }; id?: string; ip?: string; ipv4_destination?: string; ipv4_destination_backup?: string; name?: string; networks?: { network: string }[]; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  client_default: Schema.optional(Schema.Boolean),
  created_at: Schema.optional(Schema.Date),
  dns_destination_ips_id: Schema.optional(Schema.String),
  dns_destination_ipv6_block_id: Schema.optional(Schema.String),
  doh_subdomain: Schema.optional(Schema.String),
  ecs_support: Schema.optional(Schema.Boolean),
  endpoints: Schema.optional(Schema.Struct({
  doh: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
}))),
  require_token: Schema.optional(Schema.Boolean)
}),
  dot: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
})))
}),
  ipv4: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
}),
  ipv6: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
})))
})
})),
  id: Schema.optional(Schema.String),
  ip: Schema.optional(Schema.String),
  ipv4_destination: Schema.optional(Schema.String),
  ipv4_destination_backup: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
}))),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsResponse" }) as unknown as Schema.Schema<ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsResponse>;

export const zeroTrustGatewayLocationsZeroTrustGatewayLocationDetails: (
  input: ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsRequest
) => Effect.Effect<
  ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsRequest,
  output: ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateZeroTrustGatewayLocationRequest {
  location_id: string;
  account_id: string;
  body: { client_default?: boolean; dns_destination_ips_id?: string; ecs_support?: boolean; endpoints?: { doh: { enabled?: boolean; networks?: { network: string }[]; require_token?: boolean }; dot: { enabled?: boolean; networks?: { network: string }[] }; ipv4: { enabled?: boolean }; ipv6: { enabled?: boolean; networks?: { network: string }[] } }; name: string; networks?: { network: string }[] };
}

export const UpdateZeroTrustGatewayLocationRequest = Schema.Struct({
  location_id: Schema.String.pipe(T.HttpPath("location_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  client_default: Schema.optional(Schema.Boolean),
  dns_destination_ips_id: Schema.optional(Schema.String),
  ecs_support: Schema.optional(Schema.Boolean),
  endpoints: Schema.optional(Schema.Struct({
  doh: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
}))),
  require_token: Schema.optional(Schema.Boolean)
}),
  dot: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
})))
}),
  ipv4: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
}),
  ipv6: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
})))
})
})),
  name: Schema.String,
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/gateway/locations/{location_id}" }),
).annotations({ identifier: "UpdateZeroTrustGatewayLocationRequest" }) as unknown as Schema.Schema<UpdateZeroTrustGatewayLocationRequest>;

export interface UpdateZeroTrustGatewayLocationResponse {
  result: { client_default?: boolean; created_at?: string; dns_destination_ips_id?: string; dns_destination_ipv6_block_id?: string; doh_subdomain?: string; ecs_support?: boolean; endpoints?: { doh: { enabled?: boolean; networks?: { network: string }[]; require_token?: boolean }; dot: { enabled?: boolean; networks?: { network: string }[] }; ipv4: { enabled?: boolean }; ipv6: { enabled?: boolean; networks?: { network: string }[] } }; id?: string; ip?: string; ipv4_destination?: string; ipv4_destination_backup?: string; name?: string; networks?: { network: string }[]; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateZeroTrustGatewayLocationResponse = Schema.Struct({
  result: Schema.Struct({
  client_default: Schema.optional(Schema.Boolean),
  created_at: Schema.optional(Schema.Date),
  dns_destination_ips_id: Schema.optional(Schema.String),
  dns_destination_ipv6_block_id: Schema.optional(Schema.String),
  doh_subdomain: Schema.optional(Schema.String),
  ecs_support: Schema.optional(Schema.Boolean),
  endpoints: Schema.optional(Schema.Struct({
  doh: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
}))),
  require_token: Schema.optional(Schema.Boolean)
}),
  dot: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
})))
}),
  ipv4: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
}),
  ipv6: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
})))
})
})),
  id: Schema.optional(Schema.String),
  ip: Schema.optional(Schema.String),
  ipv4_destination: Schema.optional(Schema.String),
  ipv4_destination_backup: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(Schema.Array(Schema.Struct({
  network: Schema.String
}))),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateZeroTrustGatewayLocationResponse" }) as unknown as Schema.Schema<UpdateZeroTrustGatewayLocationResponse>;

export const updateZeroTrustGatewayLocation: (
  input: UpdateZeroTrustGatewayLocationRequest
) => Effect.Effect<
  UpdateZeroTrustGatewayLocationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateZeroTrustGatewayLocationRequest,
  output: UpdateZeroTrustGatewayLocationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteZeroTrustGatewayLocationRequest {
  location_id: string;
  account_id: string;
}

export const DeleteZeroTrustGatewayLocationRequest = Schema.Struct({
  location_id: Schema.String.pipe(T.HttpPath("location_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/gateway/locations/{location_id}" }),
).annotations({ identifier: "DeleteZeroTrustGatewayLocationRequest" }) as unknown as Schema.Schema<DeleteZeroTrustGatewayLocationRequest>;

export interface DeleteZeroTrustGatewayLocationResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteZeroTrustGatewayLocationResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteZeroTrustGatewayLocationResponse" }) as unknown as Schema.Schema<DeleteZeroTrustGatewayLocationResponse>;

export const deleteZeroTrustGatewayLocation: (
  input: DeleteZeroTrustGatewayLocationRequest
) => Effect.Effect<
  DeleteZeroTrustGatewayLocationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteZeroTrustGatewayLocationRequest,
  output: DeleteZeroTrustGatewayLocationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetLoggingSettingsForTheZeroTrustAccountRequest {
  account_id: string;
}

export const GetLoggingSettingsForTheZeroTrustAccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/logging" }),
).annotations({ identifier: "GetLoggingSettingsForTheZeroTrustAccountRequest" }) as unknown as Schema.Schema<GetLoggingSettingsForTheZeroTrustAccountRequest>;

export interface GetLoggingSettingsForTheZeroTrustAccountResponse {
  result: { redact_pii?: boolean; settings_by_rule_type?: { dns?: unknown; http?: unknown; l4?: unknown } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetLoggingSettingsForTheZeroTrustAccountResponse = Schema.Struct({
  result: Schema.Struct({
  redact_pii: Schema.optional(Schema.Boolean),
  settings_by_rule_type: Schema.optional(Schema.Struct({
  dns: Schema.optional(Schema.Struct({
  log_all: Schema.optional(Schema.Boolean),
  log_blocks: Schema.optional(Schema.Boolean)
})),
  http: Schema.optional(Schema.Struct({
  log_all: Schema.optional(Schema.Boolean),
  log_blocks: Schema.optional(Schema.Boolean)
})),
  l4: Schema.optional(Schema.Struct({
  log_all: Schema.optional(Schema.Boolean),
  log_blocks: Schema.optional(Schema.Boolean)
}))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetLoggingSettingsForTheZeroTrustAccountResponse" }) as unknown as Schema.Schema<GetLoggingSettingsForTheZeroTrustAccountResponse>;

export const getLoggingSettingsForTheZeroTrustAccount: (
  input: GetLoggingSettingsForTheZeroTrustAccountRequest
) => Effect.Effect<
  GetLoggingSettingsForTheZeroTrustAccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetLoggingSettingsForTheZeroTrustAccountRequest,
  output: GetLoggingSettingsForTheZeroTrustAccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateLoggingSettingsForTheZeroTrustAccountRequest {
  account_id: string;
  body: { redact_pii?: boolean; settings_by_rule_type?: { dns?: unknown; http?: unknown; l4?: unknown } };
}

export const UpdateLoggingSettingsForTheZeroTrustAccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  redact_pii: Schema.optional(Schema.Boolean),
  settings_by_rule_type: Schema.optional(Schema.Struct({
  dns: Schema.optional(Schema.Struct({
  log_all: Schema.optional(Schema.Boolean),
  log_blocks: Schema.optional(Schema.Boolean)
})),
  http: Schema.optional(Schema.Struct({
  log_all: Schema.optional(Schema.Boolean),
  log_blocks: Schema.optional(Schema.Boolean)
})),
  l4: Schema.optional(Schema.Struct({
  log_all: Schema.optional(Schema.Boolean),
  log_blocks: Schema.optional(Schema.Boolean)
}))
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/gateway/logging" }),
).annotations({ identifier: "UpdateLoggingSettingsForTheZeroTrustAccountRequest" }) as unknown as Schema.Schema<UpdateLoggingSettingsForTheZeroTrustAccountRequest>;

export interface UpdateLoggingSettingsForTheZeroTrustAccountResponse {
  result: { redact_pii?: boolean; settings_by_rule_type?: { dns?: unknown; http?: unknown; l4?: unknown } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateLoggingSettingsForTheZeroTrustAccountResponse = Schema.Struct({
  result: Schema.Struct({
  redact_pii: Schema.optional(Schema.Boolean),
  settings_by_rule_type: Schema.optional(Schema.Struct({
  dns: Schema.optional(Schema.Struct({
  log_all: Schema.optional(Schema.Boolean),
  log_blocks: Schema.optional(Schema.Boolean)
})),
  http: Schema.optional(Schema.Struct({
  log_all: Schema.optional(Schema.Boolean),
  log_blocks: Schema.optional(Schema.Boolean)
})),
  l4: Schema.optional(Schema.Struct({
  log_all: Schema.optional(Schema.Boolean),
  log_blocks: Schema.optional(Schema.Boolean)
}))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateLoggingSettingsForTheZeroTrustAccountResponse" }) as unknown as Schema.Schema<UpdateLoggingSettingsForTheZeroTrustAccountResponse>;

export const updateLoggingSettingsForTheZeroTrustAccount: (
  input: UpdateLoggingSettingsForTheZeroTrustAccountRequest
) => Effect.Effect<
  UpdateLoggingSettingsForTheZeroTrustAccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateLoggingSettingsForTheZeroTrustAccountRequest,
  output: UpdateLoggingSettingsForTheZeroTrustAccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List21Request {
  account_id: string;
}

export const List21Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/pacfiles" }),
).annotations({ identifier: "List21Request" }) as unknown as Schema.Schema<List21Request>;

export interface List21Response {
  result: { created_at?: string; description?: string; id?: string; name?: string; slug?: string; updated_at?: string; url?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List21Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  slug: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date),
  url: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List21Response" }) as unknown as Schema.Schema<List21Response>;

export const list21: (
  input: List21Request
) => Effect.Effect<
  List21Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List21Request,
  output: List21Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatePacfileRequest {
  account_id: string;
  body: { contents: string; description?: string; name: string; slug?: string };
}

export const CreatePacfileRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  contents: Schema.String,
  description: Schema.optional(Schema.String),
  name: Schema.String,
  slug: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/gateway/pacfiles" }),
).annotations({ identifier: "CreatePacfileRequest" }) as unknown as Schema.Schema<CreatePacfileRequest>;

export interface CreatePacfileResponse {
  result: { contents?: string; created_at?: string; description?: string; id?: string; name?: string; slug?: string; updated_at?: string; url?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatePacfileResponse = Schema.Struct({
  result: Schema.Struct({
  contents: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  slug: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date),
  url: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatePacfileResponse" }) as unknown as Schema.Schema<CreatePacfileResponse>;

export const createPacfile: (
  input: CreatePacfileRequest
) => Effect.Effect<
  CreatePacfileResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatePacfileRequest,
  output: CreatePacfileResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListProxyEndpointsRequest {
  account_id: string;
}

export const ListProxyEndpointsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/proxy_endpoints" }),
).annotations({ identifier: "ListProxyEndpointsRequest" }) as unknown as Schema.Schema<ListProxyEndpointsRequest>;

export interface ListProxyEndpointsResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListProxyEndpointsResponse = Schema.Struct({
  result: Schema.Array(Schema.Union(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  ips: Schema.Array(Schema.String),
  kind: Schema.optional(Schema.Literal("ip")),
  name: Schema.String,
  subdomain: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
}), Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  kind: Schema.Literal("identity"),
  name: Schema.String,
  subdomain: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListProxyEndpointsResponse" }) as unknown as Schema.Schema<ListProxyEndpointsResponse>;

export const listProxyEndpoints: (
  input: ListProxyEndpointsRequest
) => Effect.Effect<
  ListProxyEndpointsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListProxyEndpointsRequest,
  output: ListProxyEndpointsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateProxyEndpointRequest {
  account_id: string;
  body: unknown;
}

export const CreateProxyEndpointRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Union(Schema.Struct({
  kind: Schema.optional(Schema.Literal("ip")),
  name: Schema.String
}), Schema.Struct({
  kind: Schema.Literal("identity"),
  name: Schema.String
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/gateway/proxy_endpoints" }),
).annotations({ identifier: "CreateProxyEndpointRequest" }) as unknown as Schema.Schema<CreateProxyEndpointRequest>;

export interface CreateProxyEndpointResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateProxyEndpointResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  ips: Schema.Array(Schema.String),
  kind: Schema.optional(Schema.Literal("ip")),
  name: Schema.String,
  subdomain: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
}), Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  kind: Schema.Literal("identity"),
  name: Schema.String,
  subdomain: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateProxyEndpointResponse" }) as unknown as Schema.Schema<CreateProxyEndpointResponse>;

export const createProxyEndpoint: (
  input: CreateProxyEndpointRequest
) => Effect.Effect<
  CreateProxyEndpointResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateProxyEndpointRequest,
  output: CreateProxyEndpointResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsRequest {
  proxy_endpoint_id: string;
  account_id: string;
}

export const ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsRequest = Schema.Struct({
  proxy_endpoint_id: Schema.String.pipe(T.HttpPath("proxy_endpoint_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/proxy_endpoints/{proxy_endpoint_id}" }),
).annotations({ identifier: "ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsRequest" }) as unknown as Schema.Schema<ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsRequest>;

export interface ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  ips: Schema.Array(Schema.String),
  kind: Schema.optional(Schema.Literal("ip")),
  name: Schema.String,
  subdomain: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
}), Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  kind: Schema.Literal("identity"),
  name: Schema.String,
  subdomain: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsResponse" }) as unknown as Schema.Schema<ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsResponse>;

export const zeroTrustGatewayProxyEndpointsProxyEndpointDetails: (
  input: ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsRequest
) => Effect.Effect<
  ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsRequest,
  output: ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteProxyEndpointRequest {
  proxy_endpoint_id: string;
  account_id: string;
}

export const DeleteProxyEndpointRequest = Schema.Struct({
  proxy_endpoint_id: Schema.String.pipe(T.HttpPath("proxy_endpoint_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/gateway/proxy_endpoints/{proxy_endpoint_id}" }),
).annotations({ identifier: "DeleteProxyEndpointRequest" }) as unknown as Schema.Schema<DeleteProxyEndpointRequest>;

export interface DeleteProxyEndpointResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteProxyEndpointResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteProxyEndpointResponse" }) as unknown as Schema.Schema<DeleteProxyEndpointResponse>;

export const deleteProxyEndpoint: (
  input: DeleteProxyEndpointRequest
) => Effect.Effect<
  DeleteProxyEndpointResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteProxyEndpointRequest,
  output: DeleteProxyEndpointResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateProxyEndpointRequest {
  proxy_endpoint_id: string;
  account_id: string;
  body: { ips?: string[]; name?: string };
}

export const UpdateProxyEndpointRequest = Schema.Struct({
  proxy_endpoint_id: Schema.String.pipe(T.HttpPath("proxy_endpoint_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  ips: Schema.optional(Schema.Array(Schema.String)),
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/gateway/proxy_endpoints/{proxy_endpoint_id}" }),
).annotations({ identifier: "UpdateProxyEndpointRequest" }) as unknown as Schema.Schema<UpdateProxyEndpointRequest>;

export interface UpdateProxyEndpointResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateProxyEndpointResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  ips: Schema.Array(Schema.String),
  kind: Schema.optional(Schema.Literal("ip")),
  name: Schema.String,
  subdomain: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
}), Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  kind: Schema.Literal("identity"),
  name: Schema.String,
  subdomain: Schema.optional(Schema.String),
  updated_at: Schema.optional(Schema.Date)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateProxyEndpointResponse" }) as unknown as Schema.Schema<UpdateProxyEndpointResponse>;

export const updateProxyEndpoint: (
  input: UpdateProxyEndpointRequest
) => Effect.Effect<
  UpdateProxyEndpointResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateProxyEndpointRequest,
  output: UpdateProxyEndpointResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListZeroTrustGatewayRulesRequest {
  account_id: string;
}

export const ListZeroTrustGatewayRulesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/rules" }),
).annotations({ identifier: "ListZeroTrustGatewayRulesRequest" }) as unknown as Schema.Schema<ListZeroTrustGatewayRulesRequest>;

export interface ListZeroTrustGatewayRulesResponse {
  result: { action: "on" | "off" | "allow" | "block" | "scan" | "noscan" | "safesearch" | "ytrestricted" | "isolate" | "noisolate" | "override" | "l4_override" | "egress" | "resolve" | "quarantine" | "redirect"; created_at?: string; deleted_at?: string; description?: string; device_posture?: string; enabled: boolean; expiration?: { duration?: number; expired?: boolean; expires_at: unknown }; filters: "http" | "dns" | "l4" | "egress" | "dns_resolver"[]; id?: string; identity?: string; name: string; precedence: number; read_only?: boolean; rule_settings?: { add_headers?: Record<string, unknown>; allow_child_bypass?: boolean; audit_ssh?: { command_logging?: boolean }; biso_admin_controls?: { copy?: "enabled" | "disabled" | "remote_only"; dcp?: boolean; dd?: boolean; dk?: boolean; download?: "enabled" | "disabled" | "remote_only"; dp?: boolean; du?: boolean; keyboard?: "enabled" | "disabled"; paste?: "enabled" | "disabled" | "remote_only"; printing?: "enabled" | "disabled"; upload?: "enabled" | "disabled"; version?: "v1" | "v2" }; block_page?: { include_context?: boolean; target_uri: string }; block_page_enabled?: boolean; block_reason?: string; bypass_parent_rule?: boolean; check_session?: { duration?: string; enforce?: boolean }; dns_resolvers?: { ipv4?: { ip: string; port?: number; route_through_private_network?: boolean; vnet_id?: string }[]; ipv6?: { ip: string; port?: number; route_through_private_network?: boolean; vnet_id?: string }[] }; egress?: { ipv4?: string; ipv4_fallback?: string; ipv6?: string }; forensic_copy?: { enabled?: boolean }; ignore_cname_category_matches?: boolean; insecure_disable_dnssec_validation?: boolean; ip_categories?: boolean; ip_indicator_feeds?: boolean; l4override?: { ip?: string; port?: number }; notification_settings?: { enabled?: boolean; include_context?: boolean; msg?: string; support_url?: string }; override_host?: string; override_ips?: string[]; payload_log?: { enabled?: boolean }; quarantine?: { file_types?: "exe" | "pdf" | "doc" | "docm" | "docx" | "rtf" | "ppt" | "pptx" | "xls" | "xlsm" | "xlsx" | "zip" | "rar"[] }; redirect?: { include_context?: boolean; preserve_path_and_query?: boolean; target_uri: string }; resolve_dns_internally?: { fallback?: "none" | "public_dns"; view_id?: string }; resolve_dns_through_cloudflare?: boolean; untrusted_cert?: { action?: "pass_through" | "block" | "error" } }; schedule?: { fri?: string; mon?: string; sat?: string; sun?: string; thu?: string; time_zone?: string; tue?: string; wed?: string }; sharable?: boolean; source_account?: string; traffic: string; updated_at?: string; version?: number; warning_status?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListZeroTrustGatewayRulesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  action: Schema.Literal("on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "resolve", "quarantine", "redirect"),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  device_posture: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  expiration: Schema.optional(Schema.Struct({
  duration: Schema.optional(Schema.Number),
  expired: Schema.optional(Schema.Boolean),
  expires_at: Schema.String
})),
  filters: Schema.Array(Schema.Literal("http", "dns", "l4", "egress", "dns_resolver")),
  id: Schema.optional(Schema.String),
  identity: Schema.optional(Schema.String),
  name: Schema.String,
  precedence: Schema.Number,
  read_only: Schema.optional(Schema.Boolean),
  rule_settings: Schema.optional(Schema.Struct({
  add_headers: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  allow_child_bypass: Schema.optional(Schema.Boolean),
  audit_ssh: Schema.optional(Schema.Struct({
  command_logging: Schema.optional(Schema.Boolean)
})),
  biso_admin_controls: Schema.optional(Schema.Struct({
  copy: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  dcp: Schema.optional(Schema.Boolean),
  dd: Schema.optional(Schema.Boolean),
  dk: Schema.optional(Schema.Boolean),
  download: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  dp: Schema.optional(Schema.Boolean),
  du: Schema.optional(Schema.Boolean),
  keyboard: Schema.optional(Schema.Literal("enabled", "disabled")),
  paste: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  printing: Schema.optional(Schema.Literal("enabled", "disabled")),
  upload: Schema.optional(Schema.Literal("enabled", "disabled")),
  version: Schema.optional(Schema.Literal("v1", "v2"))
})),
  block_page: Schema.optional(Schema.Struct({
  include_context: Schema.optional(Schema.Boolean),
  target_uri: Schema.String
})),
  block_page_enabled: Schema.optional(Schema.Boolean),
  block_reason: Schema.optional(Schema.String),
  bypass_parent_rule: Schema.optional(Schema.Boolean),
  check_session: Schema.optional(Schema.Struct({
  duration: Schema.optional(Schema.String),
  enforce: Schema.optional(Schema.Boolean)
})),
  dns_resolvers: Schema.optional(Schema.Struct({
  ipv4: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.String,
  port: Schema.optional(Schema.Number),
  route_through_private_network: Schema.optional(Schema.Boolean),
  vnet_id: Schema.optional(Schema.String)
}))),
  ipv6: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.String,
  port: Schema.optional(Schema.Number),
  route_through_private_network: Schema.optional(Schema.Boolean),
  vnet_id: Schema.optional(Schema.String)
})))
})),
  egress: Schema.optional(Schema.Struct({
  ipv4: Schema.optional(Schema.String),
  ipv4_fallback: Schema.optional(Schema.String),
  ipv6: Schema.optional(Schema.String)
})),
  forensic_copy: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
})),
  ignore_cname_category_matches: Schema.optional(Schema.Boolean),
  insecure_disable_dnssec_validation: Schema.optional(Schema.Boolean),
  ip_categories: Schema.optional(Schema.Boolean),
  ip_indicator_feeds: Schema.optional(Schema.Boolean),
  l4override: Schema.optional(Schema.Struct({
  ip: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  notification_settings: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  include_context: Schema.optional(Schema.Boolean),
  msg: Schema.optional(Schema.String),
  support_url: Schema.optional(Schema.String)
})),
  override_host: Schema.optional(Schema.String),
  override_ips: Schema.optional(Schema.Array(Schema.String)),
  payload_log: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
})),
  quarantine: Schema.optional(Schema.Struct({
  file_types: Schema.optional(Schema.Array(Schema.Literal("exe", "pdf", "doc", "docm", "docx", "rtf", "ppt", "pptx", "xls", "xlsm", "xlsx", "zip", "rar")))
})),
  redirect: Schema.optional(Schema.Struct({
  include_context: Schema.optional(Schema.Boolean),
  preserve_path_and_query: Schema.optional(Schema.Boolean),
  target_uri: Schema.String
})),
  resolve_dns_internally: Schema.optional(Schema.Struct({
  fallback: Schema.optional(Schema.Literal("none", "public_dns")),
  view_id: Schema.optional(Schema.String)
})),
  resolve_dns_through_cloudflare: Schema.optional(Schema.Boolean),
  untrusted_cert: Schema.optional(Schema.Struct({
  action: Schema.optional(Schema.Literal("pass_through", "block", "error"))
}))
})),
  schedule: Schema.optional(Schema.Struct({
  fri: Schema.optional(Schema.String),
  mon: Schema.optional(Schema.String),
  sat: Schema.optional(Schema.String),
  sun: Schema.optional(Schema.String),
  thu: Schema.optional(Schema.String),
  time_zone: Schema.optional(Schema.String),
  tue: Schema.optional(Schema.String),
  wed: Schema.optional(Schema.String)
})),
  sharable: Schema.optional(Schema.Boolean),
  source_account: Schema.optional(Schema.String),
  traffic: Schema.String,
  updated_at: Schema.optional(Schema.Date),
  version: Schema.optional(Schema.Number),
  warning_status: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListZeroTrustGatewayRulesResponse" }) as unknown as Schema.Schema<ListZeroTrustGatewayRulesResponse>;

export const listZeroTrustGatewayRules: (
  input: ListZeroTrustGatewayRulesRequest
) => Effect.Effect<
  ListZeroTrustGatewayRulesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListZeroTrustGatewayRulesRequest,
  output: ListZeroTrustGatewayRulesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateZeroTrustGatewayRuleRequest {
  account_id: string;
  body: { action: "on" | "off" | "allow" | "block" | "scan" | "noscan" | "safesearch" | "ytrestricted" | "isolate" | "noisolate" | "override" | "l4_override" | "egress" | "resolve" | "quarantine" | "redirect"; description?: string; device_posture?: string; enabled?: boolean; expiration?: { duration?: number; expired?: boolean; expires_at: unknown }; filters?: "http" | "dns" | "l4" | "egress" | "dns_resolver"[]; identity?: string; name: string; precedence?: number; rule_settings?: { add_headers?: Record<string, unknown>; allow_child_bypass?: boolean; audit_ssh?: { command_logging?: boolean }; biso_admin_controls?: { copy?: "enabled" | "disabled" | "remote_only"; dcp?: boolean; dd?: boolean; dk?: boolean; download?: "enabled" | "disabled" | "remote_only"; dp?: boolean; du?: boolean; keyboard?: "enabled" | "disabled"; paste?: "enabled" | "disabled" | "remote_only"; printing?: "enabled" | "disabled"; upload?: "enabled" | "disabled"; version?: "v1" | "v2" }; block_page?: { include_context?: boolean; target_uri: string }; block_page_enabled?: boolean; block_reason?: string; bypass_parent_rule?: boolean; check_session?: { duration?: string; enforce?: boolean }; dns_resolvers?: { ipv4?: { ip: string; port?: number; route_through_private_network?: boolean; vnet_id?: string }[]; ipv6?: { ip: string; port?: number; route_through_private_network?: boolean; vnet_id?: string }[] }; egress?: { ipv4?: string; ipv4_fallback?: string; ipv6?: string }; forensic_copy?: { enabled?: boolean }; ignore_cname_category_matches?: boolean; insecure_disable_dnssec_validation?: boolean; ip_categories?: boolean; ip_indicator_feeds?: boolean; l4override?: { ip?: string; port?: number }; notification_settings?: { enabled?: boolean; include_context?: boolean; msg?: string; support_url?: string }; override_host?: string; override_ips?: string[]; payload_log?: { enabled?: boolean }; quarantine?: { file_types?: "exe" | "pdf" | "doc" | "docm" | "docx" | "rtf" | "ppt" | "pptx" | "xls" | "xlsm" | "xlsx" | "zip" | "rar"[] }; redirect?: { include_context?: boolean; preserve_path_and_query?: boolean; target_uri: string }; resolve_dns_internally?: { fallback?: "none" | "public_dns"; view_id?: string }; resolve_dns_through_cloudflare?: boolean; untrusted_cert?: { action?: "pass_through" | "block" | "error" } }; schedule?: { fri?: string; mon?: string; sat?: string; sun?: string; thu?: string; time_zone?: string; tue?: string; wed?: string }; traffic?: string };
}

export const CreateZeroTrustGatewayRuleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  action: Schema.Literal("on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "resolve", "quarantine", "redirect"),
  description: Schema.optional(Schema.String),
  device_posture: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  expiration: Schema.optional(Schema.Struct({
  duration: Schema.optional(Schema.Number),
  expired: Schema.optional(Schema.Boolean),
  expires_at: Schema.String
})),
  filters: Schema.optional(Schema.Array(Schema.Literal("http", "dns", "l4", "egress", "dns_resolver"))),
  identity: Schema.optional(Schema.String),
  name: Schema.String,
  precedence: Schema.optional(Schema.Number),
  rule_settings: Schema.optional(Schema.Struct({
  add_headers: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  allow_child_bypass: Schema.optional(Schema.Boolean),
  audit_ssh: Schema.optional(Schema.Struct({
  command_logging: Schema.optional(Schema.Boolean)
})),
  biso_admin_controls: Schema.optional(Schema.Struct({
  copy: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  dcp: Schema.optional(Schema.Boolean),
  dd: Schema.optional(Schema.Boolean),
  dk: Schema.optional(Schema.Boolean),
  download: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  dp: Schema.optional(Schema.Boolean),
  du: Schema.optional(Schema.Boolean),
  keyboard: Schema.optional(Schema.Literal("enabled", "disabled")),
  paste: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  printing: Schema.optional(Schema.Literal("enabled", "disabled")),
  upload: Schema.optional(Schema.Literal("enabled", "disabled")),
  version: Schema.optional(Schema.Literal("v1", "v2"))
})),
  block_page: Schema.optional(Schema.Struct({
  include_context: Schema.optional(Schema.Boolean),
  target_uri: Schema.String
})),
  block_page_enabled: Schema.optional(Schema.Boolean),
  block_reason: Schema.optional(Schema.String),
  bypass_parent_rule: Schema.optional(Schema.Boolean),
  check_session: Schema.optional(Schema.Struct({
  duration: Schema.optional(Schema.String),
  enforce: Schema.optional(Schema.Boolean)
})),
  dns_resolvers: Schema.optional(Schema.Struct({
  ipv4: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.String,
  port: Schema.optional(Schema.Number),
  route_through_private_network: Schema.optional(Schema.Boolean),
  vnet_id: Schema.optional(Schema.String)
}))),
  ipv6: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.String,
  port: Schema.optional(Schema.Number),
  route_through_private_network: Schema.optional(Schema.Boolean),
  vnet_id: Schema.optional(Schema.String)
})))
})),
  egress: Schema.optional(Schema.Struct({
  ipv4: Schema.optional(Schema.String),
  ipv4_fallback: Schema.optional(Schema.String),
  ipv6: Schema.optional(Schema.String)
})),
  forensic_copy: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
})),
  ignore_cname_category_matches: Schema.optional(Schema.Boolean),
  insecure_disable_dnssec_validation: Schema.optional(Schema.Boolean),
  ip_categories: Schema.optional(Schema.Boolean),
  ip_indicator_feeds: Schema.optional(Schema.Boolean),
  l4override: Schema.optional(Schema.Struct({
  ip: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  notification_settings: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  include_context: Schema.optional(Schema.Boolean),
  msg: Schema.optional(Schema.String),
  support_url: Schema.optional(Schema.String)
})),
  override_host: Schema.optional(Schema.String),
  override_ips: Schema.optional(Schema.Array(Schema.String)),
  payload_log: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
})),
  quarantine: Schema.optional(Schema.Struct({
  file_types: Schema.optional(Schema.Array(Schema.Literal("exe", "pdf", "doc", "docm", "docx", "rtf", "ppt", "pptx", "xls", "xlsm", "xlsx", "zip", "rar")))
})),
  redirect: Schema.optional(Schema.Struct({
  include_context: Schema.optional(Schema.Boolean),
  preserve_path_and_query: Schema.optional(Schema.Boolean),
  target_uri: Schema.String
})),
  resolve_dns_internally: Schema.optional(Schema.Struct({
  fallback: Schema.optional(Schema.Literal("none", "public_dns")),
  view_id: Schema.optional(Schema.String)
})),
  resolve_dns_through_cloudflare: Schema.optional(Schema.Boolean),
  untrusted_cert: Schema.optional(Schema.Struct({
  action: Schema.optional(Schema.Literal("pass_through", "block", "error"))
}))
})),
  schedule: Schema.optional(Schema.Struct({
  fri: Schema.optional(Schema.String),
  mon: Schema.optional(Schema.String),
  sat: Schema.optional(Schema.String),
  sun: Schema.optional(Schema.String),
  thu: Schema.optional(Schema.String),
  time_zone: Schema.optional(Schema.String),
  tue: Schema.optional(Schema.String),
  wed: Schema.optional(Schema.String)
})),
  traffic: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/gateway/rules" }),
).annotations({ identifier: "CreateZeroTrustGatewayRuleRequest" }) as unknown as Schema.Schema<CreateZeroTrustGatewayRuleRequest>;

export interface CreateZeroTrustGatewayRuleResponse {
  result: { action: "on" | "off" | "allow" | "block" | "scan" | "noscan" | "safesearch" | "ytrestricted" | "isolate" | "noisolate" | "override" | "l4_override" | "egress" | "resolve" | "quarantine" | "redirect"; created_at?: string; deleted_at?: string; description?: string; device_posture?: string; enabled: boolean; expiration?: { duration?: number; expired?: boolean; expires_at: unknown }; filters: "http" | "dns" | "l4" | "egress" | "dns_resolver"[]; id?: string; identity?: string; name: string; precedence: number; read_only?: boolean; rule_settings?: { add_headers?: Record<string, unknown>; allow_child_bypass?: boolean; audit_ssh?: { command_logging?: boolean }; biso_admin_controls?: { copy?: "enabled" | "disabled" | "remote_only"; dcp?: boolean; dd?: boolean; dk?: boolean; download?: "enabled" | "disabled" | "remote_only"; dp?: boolean; du?: boolean; keyboard?: "enabled" | "disabled"; paste?: "enabled" | "disabled" | "remote_only"; printing?: "enabled" | "disabled"; upload?: "enabled" | "disabled"; version?: "v1" | "v2" }; block_page?: { include_context?: boolean; target_uri: string }; block_page_enabled?: boolean; block_reason?: string; bypass_parent_rule?: boolean; check_session?: { duration?: string; enforce?: boolean }; dns_resolvers?: { ipv4?: { ip: string; port?: number; route_through_private_network?: boolean; vnet_id?: string }[]; ipv6?: { ip: string; port?: number; route_through_private_network?: boolean; vnet_id?: string }[] }; egress?: { ipv4?: string; ipv4_fallback?: string; ipv6?: string }; forensic_copy?: { enabled?: boolean }; ignore_cname_category_matches?: boolean; insecure_disable_dnssec_validation?: boolean; ip_categories?: boolean; ip_indicator_feeds?: boolean; l4override?: { ip?: string; port?: number }; notification_settings?: { enabled?: boolean; include_context?: boolean; msg?: string; support_url?: string }; override_host?: string; override_ips?: string[]; payload_log?: { enabled?: boolean }; quarantine?: { file_types?: "exe" | "pdf" | "doc" | "docm" | "docx" | "rtf" | "ppt" | "pptx" | "xls" | "xlsm" | "xlsx" | "zip" | "rar"[] }; redirect?: { include_context?: boolean; preserve_path_and_query?: boolean; target_uri: string }; resolve_dns_internally?: { fallback?: "none" | "public_dns"; view_id?: string }; resolve_dns_through_cloudflare?: boolean; untrusted_cert?: { action?: "pass_through" | "block" | "error" } }; schedule?: { fri?: string; mon?: string; sat?: string; sun?: string; thu?: string; time_zone?: string; tue?: string; wed?: string }; sharable?: boolean; source_account?: string; traffic: string; updated_at?: string; version?: number; warning_status?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateZeroTrustGatewayRuleResponse = Schema.Struct({
  result: Schema.Struct({
  action: Schema.Literal("on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "resolve", "quarantine", "redirect"),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  device_posture: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  expiration: Schema.optional(Schema.Struct({
  duration: Schema.optional(Schema.Number),
  expired: Schema.optional(Schema.Boolean),
  expires_at: Schema.String
})),
  filters: Schema.Array(Schema.Literal("http", "dns", "l4", "egress", "dns_resolver")),
  id: Schema.optional(Schema.String),
  identity: Schema.optional(Schema.String),
  name: Schema.String,
  precedence: Schema.Number,
  read_only: Schema.optional(Schema.Boolean),
  rule_settings: Schema.optional(Schema.Struct({
  add_headers: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  allow_child_bypass: Schema.optional(Schema.Boolean),
  audit_ssh: Schema.optional(Schema.Struct({
  command_logging: Schema.optional(Schema.Boolean)
})),
  biso_admin_controls: Schema.optional(Schema.Struct({
  copy: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  dcp: Schema.optional(Schema.Boolean),
  dd: Schema.optional(Schema.Boolean),
  dk: Schema.optional(Schema.Boolean),
  download: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  dp: Schema.optional(Schema.Boolean),
  du: Schema.optional(Schema.Boolean),
  keyboard: Schema.optional(Schema.Literal("enabled", "disabled")),
  paste: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  printing: Schema.optional(Schema.Literal("enabled", "disabled")),
  upload: Schema.optional(Schema.Literal("enabled", "disabled")),
  version: Schema.optional(Schema.Literal("v1", "v2"))
})),
  block_page: Schema.optional(Schema.Struct({
  include_context: Schema.optional(Schema.Boolean),
  target_uri: Schema.String
})),
  block_page_enabled: Schema.optional(Schema.Boolean),
  block_reason: Schema.optional(Schema.String),
  bypass_parent_rule: Schema.optional(Schema.Boolean),
  check_session: Schema.optional(Schema.Struct({
  duration: Schema.optional(Schema.String),
  enforce: Schema.optional(Schema.Boolean)
})),
  dns_resolvers: Schema.optional(Schema.Struct({
  ipv4: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.String,
  port: Schema.optional(Schema.Number),
  route_through_private_network: Schema.optional(Schema.Boolean),
  vnet_id: Schema.optional(Schema.String)
}))),
  ipv6: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.String,
  port: Schema.optional(Schema.Number),
  route_through_private_network: Schema.optional(Schema.Boolean),
  vnet_id: Schema.optional(Schema.String)
})))
})),
  egress: Schema.optional(Schema.Struct({
  ipv4: Schema.optional(Schema.String),
  ipv4_fallback: Schema.optional(Schema.String),
  ipv6: Schema.optional(Schema.String)
})),
  forensic_copy: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
})),
  ignore_cname_category_matches: Schema.optional(Schema.Boolean),
  insecure_disable_dnssec_validation: Schema.optional(Schema.Boolean),
  ip_categories: Schema.optional(Schema.Boolean),
  ip_indicator_feeds: Schema.optional(Schema.Boolean),
  l4override: Schema.optional(Schema.Struct({
  ip: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  notification_settings: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  include_context: Schema.optional(Schema.Boolean),
  msg: Schema.optional(Schema.String),
  support_url: Schema.optional(Schema.String)
})),
  override_host: Schema.optional(Schema.String),
  override_ips: Schema.optional(Schema.Array(Schema.String)),
  payload_log: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
})),
  quarantine: Schema.optional(Schema.Struct({
  file_types: Schema.optional(Schema.Array(Schema.Literal("exe", "pdf", "doc", "docm", "docx", "rtf", "ppt", "pptx", "xls", "xlsm", "xlsx", "zip", "rar")))
})),
  redirect: Schema.optional(Schema.Struct({
  include_context: Schema.optional(Schema.Boolean),
  preserve_path_and_query: Schema.optional(Schema.Boolean),
  target_uri: Schema.String
})),
  resolve_dns_internally: Schema.optional(Schema.Struct({
  fallback: Schema.optional(Schema.Literal("none", "public_dns")),
  view_id: Schema.optional(Schema.String)
})),
  resolve_dns_through_cloudflare: Schema.optional(Schema.Boolean),
  untrusted_cert: Schema.optional(Schema.Struct({
  action: Schema.optional(Schema.Literal("pass_through", "block", "error"))
}))
})),
  schedule: Schema.optional(Schema.Struct({
  fri: Schema.optional(Schema.String),
  mon: Schema.optional(Schema.String),
  sat: Schema.optional(Schema.String),
  sun: Schema.optional(Schema.String),
  thu: Schema.optional(Schema.String),
  time_zone: Schema.optional(Schema.String),
  tue: Schema.optional(Schema.String),
  wed: Schema.optional(Schema.String)
})),
  sharable: Schema.optional(Schema.Boolean),
  source_account: Schema.optional(Schema.String),
  traffic: Schema.String,
  updated_at: Schema.optional(Schema.Date),
  version: Schema.optional(Schema.Number),
  warning_status: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateZeroTrustGatewayRuleResponse" }) as unknown as Schema.Schema<CreateZeroTrustGatewayRuleResponse>;

export const createZeroTrustGatewayRule: (
  input: CreateZeroTrustGatewayRuleRequest
) => Effect.Effect<
  CreateZeroTrustGatewayRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateZeroTrustGatewayRuleRequest,
  output: CreateZeroTrustGatewayRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListZeroTrustGatewayRulesTenantRequest {
  account_id: string;
}

export const ListZeroTrustGatewayRulesTenantRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/rules/tenant" }),
).annotations({ identifier: "ListZeroTrustGatewayRulesTenantRequest" }) as unknown as Schema.Schema<ListZeroTrustGatewayRulesTenantRequest>;

export interface ListZeroTrustGatewayRulesTenantResponse {
  result: { action: "on" | "off" | "allow" | "block" | "scan" | "noscan" | "safesearch" | "ytrestricted" | "isolate" | "noisolate" | "override" | "l4_override" | "egress" | "resolve" | "quarantine" | "redirect"; created_at?: string; deleted_at?: string; description?: string; device_posture?: string; enabled: boolean; expiration?: { duration?: number; expired?: boolean; expires_at: unknown }; filters: "http" | "dns" | "l4" | "egress" | "dns_resolver"[]; id?: string; identity?: string; name: string; precedence: number; read_only?: boolean; rule_settings?: { add_headers?: Record<string, unknown>; allow_child_bypass?: boolean; audit_ssh?: { command_logging?: boolean }; biso_admin_controls?: { copy?: "enabled" | "disabled" | "remote_only"; dcp?: boolean; dd?: boolean; dk?: boolean; download?: "enabled" | "disabled" | "remote_only"; dp?: boolean; du?: boolean; keyboard?: "enabled" | "disabled"; paste?: "enabled" | "disabled" | "remote_only"; printing?: "enabled" | "disabled"; upload?: "enabled" | "disabled"; version?: "v1" | "v2" }; block_page?: { include_context?: boolean; target_uri: string }; block_page_enabled?: boolean; block_reason?: string; bypass_parent_rule?: boolean; check_session?: { duration?: string; enforce?: boolean }; dns_resolvers?: { ipv4?: { ip: string; port?: number; route_through_private_network?: boolean; vnet_id?: string }[]; ipv6?: { ip: string; port?: number; route_through_private_network?: boolean; vnet_id?: string }[] }; egress?: { ipv4?: string; ipv4_fallback?: string; ipv6?: string }; forensic_copy?: { enabled?: boolean }; ignore_cname_category_matches?: boolean; insecure_disable_dnssec_validation?: boolean; ip_categories?: boolean; ip_indicator_feeds?: boolean; l4override?: { ip?: string; port?: number }; notification_settings?: { enabled?: boolean; include_context?: boolean; msg?: string; support_url?: string }; override_host?: string; override_ips?: string[]; payload_log?: { enabled?: boolean }; quarantine?: { file_types?: "exe" | "pdf" | "doc" | "docm" | "docx" | "rtf" | "ppt" | "pptx" | "xls" | "xlsm" | "xlsx" | "zip" | "rar"[] }; redirect?: { include_context?: boolean; preserve_path_and_query?: boolean; target_uri: string }; resolve_dns_internally?: { fallback?: "none" | "public_dns"; view_id?: string }; resolve_dns_through_cloudflare?: boolean; untrusted_cert?: { action?: "pass_through" | "block" | "error" } }; schedule?: { fri?: string; mon?: string; sat?: string; sun?: string; thu?: string; time_zone?: string; tue?: string; wed?: string }; sharable?: boolean; source_account?: string; traffic: string; updated_at?: string; version?: number; warning_status?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListZeroTrustGatewayRulesTenantResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  action: Schema.Literal("on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "resolve", "quarantine", "redirect"),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  device_posture: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  expiration: Schema.optional(Schema.Struct({
  duration: Schema.optional(Schema.Number),
  expired: Schema.optional(Schema.Boolean),
  expires_at: Schema.String
})),
  filters: Schema.Array(Schema.Literal("http", "dns", "l4", "egress", "dns_resolver")),
  id: Schema.optional(Schema.String),
  identity: Schema.optional(Schema.String),
  name: Schema.String,
  precedence: Schema.Number,
  read_only: Schema.optional(Schema.Boolean),
  rule_settings: Schema.optional(Schema.Struct({
  add_headers: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  allow_child_bypass: Schema.optional(Schema.Boolean),
  audit_ssh: Schema.optional(Schema.Struct({
  command_logging: Schema.optional(Schema.Boolean)
})),
  biso_admin_controls: Schema.optional(Schema.Struct({
  copy: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  dcp: Schema.optional(Schema.Boolean),
  dd: Schema.optional(Schema.Boolean),
  dk: Schema.optional(Schema.Boolean),
  download: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  dp: Schema.optional(Schema.Boolean),
  du: Schema.optional(Schema.Boolean),
  keyboard: Schema.optional(Schema.Literal("enabled", "disabled")),
  paste: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  printing: Schema.optional(Schema.Literal("enabled", "disabled")),
  upload: Schema.optional(Schema.Literal("enabled", "disabled")),
  version: Schema.optional(Schema.Literal("v1", "v2"))
})),
  block_page: Schema.optional(Schema.Struct({
  include_context: Schema.optional(Schema.Boolean),
  target_uri: Schema.String
})),
  block_page_enabled: Schema.optional(Schema.Boolean),
  block_reason: Schema.optional(Schema.String),
  bypass_parent_rule: Schema.optional(Schema.Boolean),
  check_session: Schema.optional(Schema.Struct({
  duration: Schema.optional(Schema.String),
  enforce: Schema.optional(Schema.Boolean)
})),
  dns_resolvers: Schema.optional(Schema.Struct({
  ipv4: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.String,
  port: Schema.optional(Schema.Number),
  route_through_private_network: Schema.optional(Schema.Boolean),
  vnet_id: Schema.optional(Schema.String)
}))),
  ipv6: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.String,
  port: Schema.optional(Schema.Number),
  route_through_private_network: Schema.optional(Schema.Boolean),
  vnet_id: Schema.optional(Schema.String)
})))
})),
  egress: Schema.optional(Schema.Struct({
  ipv4: Schema.optional(Schema.String),
  ipv4_fallback: Schema.optional(Schema.String),
  ipv6: Schema.optional(Schema.String)
})),
  forensic_copy: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
})),
  ignore_cname_category_matches: Schema.optional(Schema.Boolean),
  insecure_disable_dnssec_validation: Schema.optional(Schema.Boolean),
  ip_categories: Schema.optional(Schema.Boolean),
  ip_indicator_feeds: Schema.optional(Schema.Boolean),
  l4override: Schema.optional(Schema.Struct({
  ip: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  notification_settings: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  include_context: Schema.optional(Schema.Boolean),
  msg: Schema.optional(Schema.String),
  support_url: Schema.optional(Schema.String)
})),
  override_host: Schema.optional(Schema.String),
  override_ips: Schema.optional(Schema.Array(Schema.String)),
  payload_log: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
})),
  quarantine: Schema.optional(Schema.Struct({
  file_types: Schema.optional(Schema.Array(Schema.Literal("exe", "pdf", "doc", "docm", "docx", "rtf", "ppt", "pptx", "xls", "xlsm", "xlsx", "zip", "rar")))
})),
  redirect: Schema.optional(Schema.Struct({
  include_context: Schema.optional(Schema.Boolean),
  preserve_path_and_query: Schema.optional(Schema.Boolean),
  target_uri: Schema.String
})),
  resolve_dns_internally: Schema.optional(Schema.Struct({
  fallback: Schema.optional(Schema.Literal("none", "public_dns")),
  view_id: Schema.optional(Schema.String)
})),
  resolve_dns_through_cloudflare: Schema.optional(Schema.Boolean),
  untrusted_cert: Schema.optional(Schema.Struct({
  action: Schema.optional(Schema.Literal("pass_through", "block", "error"))
}))
})),
  schedule: Schema.optional(Schema.Struct({
  fri: Schema.optional(Schema.String),
  mon: Schema.optional(Schema.String),
  sat: Schema.optional(Schema.String),
  sun: Schema.optional(Schema.String),
  thu: Schema.optional(Schema.String),
  time_zone: Schema.optional(Schema.String),
  tue: Schema.optional(Schema.String),
  wed: Schema.optional(Schema.String)
})),
  sharable: Schema.optional(Schema.Boolean),
  source_account: Schema.optional(Schema.String),
  traffic: Schema.String,
  updated_at: Schema.optional(Schema.Date),
  version: Schema.optional(Schema.Number),
  warning_status: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListZeroTrustGatewayRulesTenantResponse" }) as unknown as Schema.Schema<ListZeroTrustGatewayRulesTenantResponse>;

export const listZeroTrustGatewayRulesTenant: (
  input: ListZeroTrustGatewayRulesTenantRequest
) => Effect.Effect<
  ListZeroTrustGatewayRulesTenantResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListZeroTrustGatewayRulesTenantRequest,
  output: ListZeroTrustGatewayRulesTenantResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsRequest {
  rule_id: string;
  account_id: string;
}

export const ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/rules/{rule_id}" }),
).annotations({ identifier: "ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsRequest" }) as unknown as Schema.Schema<ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsRequest>;

export interface ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsResponse {
  result: { action: "on" | "off" | "allow" | "block" | "scan" | "noscan" | "safesearch" | "ytrestricted" | "isolate" | "noisolate" | "override" | "l4_override" | "egress" | "resolve" | "quarantine" | "redirect"; created_at?: string; deleted_at?: string; description?: string; device_posture?: string; enabled: boolean; expiration?: { duration?: number; expired?: boolean; expires_at: unknown }; filters: "http" | "dns" | "l4" | "egress" | "dns_resolver"[]; id?: string; identity?: string; name: string; precedence: number; read_only?: boolean; rule_settings?: { add_headers?: Record<string, unknown>; allow_child_bypass?: boolean; audit_ssh?: { command_logging?: boolean }; biso_admin_controls?: { copy?: "enabled" | "disabled" | "remote_only"; dcp?: boolean; dd?: boolean; dk?: boolean; download?: "enabled" | "disabled" | "remote_only"; dp?: boolean; du?: boolean; keyboard?: "enabled" | "disabled"; paste?: "enabled" | "disabled" | "remote_only"; printing?: "enabled" | "disabled"; upload?: "enabled" | "disabled"; version?: "v1" | "v2" }; block_page?: { include_context?: boolean; target_uri: string }; block_page_enabled?: boolean; block_reason?: string; bypass_parent_rule?: boolean; check_session?: { duration?: string; enforce?: boolean }; dns_resolvers?: { ipv4?: { ip: string; port?: number; route_through_private_network?: boolean; vnet_id?: string }[]; ipv6?: { ip: string; port?: number; route_through_private_network?: boolean; vnet_id?: string }[] }; egress?: { ipv4?: string; ipv4_fallback?: string; ipv6?: string }; forensic_copy?: { enabled?: boolean }; ignore_cname_category_matches?: boolean; insecure_disable_dnssec_validation?: boolean; ip_categories?: boolean; ip_indicator_feeds?: boolean; l4override?: { ip?: string; port?: number }; notification_settings?: { enabled?: boolean; include_context?: boolean; msg?: string; support_url?: string }; override_host?: string; override_ips?: string[]; payload_log?: { enabled?: boolean }; quarantine?: { file_types?: "exe" | "pdf" | "doc" | "docm" | "docx" | "rtf" | "ppt" | "pptx" | "xls" | "xlsm" | "xlsx" | "zip" | "rar"[] }; redirect?: { include_context?: boolean; preserve_path_and_query?: boolean; target_uri: string }; resolve_dns_internally?: { fallback?: "none" | "public_dns"; view_id?: string }; resolve_dns_through_cloudflare?: boolean; untrusted_cert?: { action?: "pass_through" | "block" | "error" } }; schedule?: { fri?: string; mon?: string; sat?: string; sun?: string; thu?: string; time_zone?: string; tue?: string; wed?: string }; sharable?: boolean; source_account?: string; traffic: string; updated_at?: string; version?: number; warning_status?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  action: Schema.Literal("on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "resolve", "quarantine", "redirect"),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  device_posture: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  expiration: Schema.optional(Schema.Struct({
  duration: Schema.optional(Schema.Number),
  expired: Schema.optional(Schema.Boolean),
  expires_at: Schema.String
})),
  filters: Schema.Array(Schema.Literal("http", "dns", "l4", "egress", "dns_resolver")),
  id: Schema.optional(Schema.String),
  identity: Schema.optional(Schema.String),
  name: Schema.String,
  precedence: Schema.Number,
  read_only: Schema.optional(Schema.Boolean),
  rule_settings: Schema.optional(Schema.Struct({
  add_headers: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  allow_child_bypass: Schema.optional(Schema.Boolean),
  audit_ssh: Schema.optional(Schema.Struct({
  command_logging: Schema.optional(Schema.Boolean)
})),
  biso_admin_controls: Schema.optional(Schema.Struct({
  copy: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  dcp: Schema.optional(Schema.Boolean),
  dd: Schema.optional(Schema.Boolean),
  dk: Schema.optional(Schema.Boolean),
  download: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  dp: Schema.optional(Schema.Boolean),
  du: Schema.optional(Schema.Boolean),
  keyboard: Schema.optional(Schema.Literal("enabled", "disabled")),
  paste: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  printing: Schema.optional(Schema.Literal("enabled", "disabled")),
  upload: Schema.optional(Schema.Literal("enabled", "disabled")),
  version: Schema.optional(Schema.Literal("v1", "v2"))
})),
  block_page: Schema.optional(Schema.Struct({
  include_context: Schema.optional(Schema.Boolean),
  target_uri: Schema.String
})),
  block_page_enabled: Schema.optional(Schema.Boolean),
  block_reason: Schema.optional(Schema.String),
  bypass_parent_rule: Schema.optional(Schema.Boolean),
  check_session: Schema.optional(Schema.Struct({
  duration: Schema.optional(Schema.String),
  enforce: Schema.optional(Schema.Boolean)
})),
  dns_resolvers: Schema.optional(Schema.Struct({
  ipv4: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.String,
  port: Schema.optional(Schema.Number),
  route_through_private_network: Schema.optional(Schema.Boolean),
  vnet_id: Schema.optional(Schema.String)
}))),
  ipv6: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.String,
  port: Schema.optional(Schema.Number),
  route_through_private_network: Schema.optional(Schema.Boolean),
  vnet_id: Schema.optional(Schema.String)
})))
})),
  egress: Schema.optional(Schema.Struct({
  ipv4: Schema.optional(Schema.String),
  ipv4_fallback: Schema.optional(Schema.String),
  ipv6: Schema.optional(Schema.String)
})),
  forensic_copy: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
})),
  ignore_cname_category_matches: Schema.optional(Schema.Boolean),
  insecure_disable_dnssec_validation: Schema.optional(Schema.Boolean),
  ip_categories: Schema.optional(Schema.Boolean),
  ip_indicator_feeds: Schema.optional(Schema.Boolean),
  l4override: Schema.optional(Schema.Struct({
  ip: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  notification_settings: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  include_context: Schema.optional(Schema.Boolean),
  msg: Schema.optional(Schema.String),
  support_url: Schema.optional(Schema.String)
})),
  override_host: Schema.optional(Schema.String),
  override_ips: Schema.optional(Schema.Array(Schema.String)),
  payload_log: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
})),
  quarantine: Schema.optional(Schema.Struct({
  file_types: Schema.optional(Schema.Array(Schema.Literal("exe", "pdf", "doc", "docm", "docx", "rtf", "ppt", "pptx", "xls", "xlsm", "xlsx", "zip", "rar")))
})),
  redirect: Schema.optional(Schema.Struct({
  include_context: Schema.optional(Schema.Boolean),
  preserve_path_and_query: Schema.optional(Schema.Boolean),
  target_uri: Schema.String
})),
  resolve_dns_internally: Schema.optional(Schema.Struct({
  fallback: Schema.optional(Schema.Literal("none", "public_dns")),
  view_id: Schema.optional(Schema.String)
})),
  resolve_dns_through_cloudflare: Schema.optional(Schema.Boolean),
  untrusted_cert: Schema.optional(Schema.Struct({
  action: Schema.optional(Schema.Literal("pass_through", "block", "error"))
}))
})),
  schedule: Schema.optional(Schema.Struct({
  fri: Schema.optional(Schema.String),
  mon: Schema.optional(Schema.String),
  sat: Schema.optional(Schema.String),
  sun: Schema.optional(Schema.String),
  thu: Schema.optional(Schema.String),
  time_zone: Schema.optional(Schema.String),
  tue: Schema.optional(Schema.String),
  wed: Schema.optional(Schema.String)
})),
  sharable: Schema.optional(Schema.Boolean),
  source_account: Schema.optional(Schema.String),
  traffic: Schema.String,
  updated_at: Schema.optional(Schema.Date),
  version: Schema.optional(Schema.Number),
  warning_status: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsResponse" }) as unknown as Schema.Schema<ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsResponse>;

export const zeroTrustGatewayRulesZeroTrustGatewayRuleDetails: (
  input: ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsRequest
) => Effect.Effect<
  ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsRequest,
  output: ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateZeroTrustGatewayRuleRequest {
  rule_id: string;
  account_id: string;
  body: { action: "on" | "off" | "allow" | "block" | "scan" | "noscan" | "safesearch" | "ytrestricted" | "isolate" | "noisolate" | "override" | "l4_override" | "egress" | "resolve" | "quarantine" | "redirect"; description?: string; device_posture?: string; enabled?: boolean; expiration?: { duration?: number; expired?: boolean; expires_at: unknown }; filters?: "http" | "dns" | "l4" | "egress" | "dns_resolver"[]; identity?: string; name: string; precedence?: number; rule_settings?: { add_headers?: Record<string, unknown>; allow_child_bypass?: boolean; audit_ssh?: { command_logging?: boolean }; biso_admin_controls?: { copy?: "enabled" | "disabled" | "remote_only"; dcp?: boolean; dd?: boolean; dk?: boolean; download?: "enabled" | "disabled" | "remote_only"; dp?: boolean; du?: boolean; keyboard?: "enabled" | "disabled"; paste?: "enabled" | "disabled" | "remote_only"; printing?: "enabled" | "disabled"; upload?: "enabled" | "disabled"; version?: "v1" | "v2" }; block_page?: { include_context?: boolean; target_uri: string }; block_page_enabled?: boolean; block_reason?: string; bypass_parent_rule?: boolean; check_session?: { duration?: string; enforce?: boolean }; dns_resolvers?: { ipv4?: { ip: string; port?: number; route_through_private_network?: boolean; vnet_id?: string }[]; ipv6?: { ip: string; port?: number; route_through_private_network?: boolean; vnet_id?: string }[] }; egress?: { ipv4?: string; ipv4_fallback?: string; ipv6?: string }; forensic_copy?: { enabled?: boolean }; ignore_cname_category_matches?: boolean; insecure_disable_dnssec_validation?: boolean; ip_categories?: boolean; ip_indicator_feeds?: boolean; l4override?: { ip?: string; port?: number }; notification_settings?: { enabled?: boolean; include_context?: boolean; msg?: string; support_url?: string }; override_host?: string; override_ips?: string[]; payload_log?: { enabled?: boolean }; quarantine?: { file_types?: "exe" | "pdf" | "doc" | "docm" | "docx" | "rtf" | "ppt" | "pptx" | "xls" | "xlsm" | "xlsx" | "zip" | "rar"[] }; redirect?: { include_context?: boolean; preserve_path_and_query?: boolean; target_uri: string }; resolve_dns_internally?: { fallback?: "none" | "public_dns"; view_id?: string }; resolve_dns_through_cloudflare?: boolean; untrusted_cert?: { action?: "pass_through" | "block" | "error" } }; schedule?: { fri?: string; mon?: string; sat?: string; sun?: string; thu?: string; time_zone?: string; tue?: string; wed?: string }; traffic?: string };
}

export const UpdateZeroTrustGatewayRuleRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  action: Schema.Literal("on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "resolve", "quarantine", "redirect"),
  description: Schema.optional(Schema.String),
  device_posture: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  expiration: Schema.optional(Schema.Struct({
  duration: Schema.optional(Schema.Number),
  expired: Schema.optional(Schema.Boolean),
  expires_at: Schema.String
})),
  filters: Schema.optional(Schema.Array(Schema.Literal("http", "dns", "l4", "egress", "dns_resolver"))),
  identity: Schema.optional(Schema.String),
  name: Schema.String,
  precedence: Schema.optional(Schema.Number),
  rule_settings: Schema.optional(Schema.Struct({
  add_headers: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  allow_child_bypass: Schema.optional(Schema.Boolean),
  audit_ssh: Schema.optional(Schema.Struct({
  command_logging: Schema.optional(Schema.Boolean)
})),
  biso_admin_controls: Schema.optional(Schema.Struct({
  copy: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  dcp: Schema.optional(Schema.Boolean),
  dd: Schema.optional(Schema.Boolean),
  dk: Schema.optional(Schema.Boolean),
  download: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  dp: Schema.optional(Schema.Boolean),
  du: Schema.optional(Schema.Boolean),
  keyboard: Schema.optional(Schema.Literal("enabled", "disabled")),
  paste: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  printing: Schema.optional(Schema.Literal("enabled", "disabled")),
  upload: Schema.optional(Schema.Literal("enabled", "disabled")),
  version: Schema.optional(Schema.Literal("v1", "v2"))
})),
  block_page: Schema.optional(Schema.Struct({
  include_context: Schema.optional(Schema.Boolean),
  target_uri: Schema.String
})),
  block_page_enabled: Schema.optional(Schema.Boolean),
  block_reason: Schema.optional(Schema.String),
  bypass_parent_rule: Schema.optional(Schema.Boolean),
  check_session: Schema.optional(Schema.Struct({
  duration: Schema.optional(Schema.String),
  enforce: Schema.optional(Schema.Boolean)
})),
  dns_resolvers: Schema.optional(Schema.Struct({
  ipv4: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.String,
  port: Schema.optional(Schema.Number),
  route_through_private_network: Schema.optional(Schema.Boolean),
  vnet_id: Schema.optional(Schema.String)
}))),
  ipv6: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.String,
  port: Schema.optional(Schema.Number),
  route_through_private_network: Schema.optional(Schema.Boolean),
  vnet_id: Schema.optional(Schema.String)
})))
})),
  egress: Schema.optional(Schema.Struct({
  ipv4: Schema.optional(Schema.String),
  ipv4_fallback: Schema.optional(Schema.String),
  ipv6: Schema.optional(Schema.String)
})),
  forensic_copy: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
})),
  ignore_cname_category_matches: Schema.optional(Schema.Boolean),
  insecure_disable_dnssec_validation: Schema.optional(Schema.Boolean),
  ip_categories: Schema.optional(Schema.Boolean),
  ip_indicator_feeds: Schema.optional(Schema.Boolean),
  l4override: Schema.optional(Schema.Struct({
  ip: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  notification_settings: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  include_context: Schema.optional(Schema.Boolean),
  msg: Schema.optional(Schema.String),
  support_url: Schema.optional(Schema.String)
})),
  override_host: Schema.optional(Schema.String),
  override_ips: Schema.optional(Schema.Array(Schema.String)),
  payload_log: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
})),
  quarantine: Schema.optional(Schema.Struct({
  file_types: Schema.optional(Schema.Array(Schema.Literal("exe", "pdf", "doc", "docm", "docx", "rtf", "ppt", "pptx", "xls", "xlsm", "xlsx", "zip", "rar")))
})),
  redirect: Schema.optional(Schema.Struct({
  include_context: Schema.optional(Schema.Boolean),
  preserve_path_and_query: Schema.optional(Schema.Boolean),
  target_uri: Schema.String
})),
  resolve_dns_internally: Schema.optional(Schema.Struct({
  fallback: Schema.optional(Schema.Literal("none", "public_dns")),
  view_id: Schema.optional(Schema.String)
})),
  resolve_dns_through_cloudflare: Schema.optional(Schema.Boolean),
  untrusted_cert: Schema.optional(Schema.Struct({
  action: Schema.optional(Schema.Literal("pass_through", "block", "error"))
}))
})),
  schedule: Schema.optional(Schema.Struct({
  fri: Schema.optional(Schema.String),
  mon: Schema.optional(Schema.String),
  sat: Schema.optional(Schema.String),
  sun: Schema.optional(Schema.String),
  thu: Schema.optional(Schema.String),
  time_zone: Schema.optional(Schema.String),
  tue: Schema.optional(Schema.String),
  wed: Schema.optional(Schema.String)
})),
  traffic: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/gateway/rules/{rule_id}" }),
).annotations({ identifier: "UpdateZeroTrustGatewayRuleRequest" }) as unknown as Schema.Schema<UpdateZeroTrustGatewayRuleRequest>;

export interface UpdateZeroTrustGatewayRuleResponse {
  result: { action: "on" | "off" | "allow" | "block" | "scan" | "noscan" | "safesearch" | "ytrestricted" | "isolate" | "noisolate" | "override" | "l4_override" | "egress" | "resolve" | "quarantine" | "redirect"; created_at?: string; deleted_at?: string; description?: string; device_posture?: string; enabled: boolean; expiration?: { duration?: number; expired?: boolean; expires_at: unknown }; filters: "http" | "dns" | "l4" | "egress" | "dns_resolver"[]; id?: string; identity?: string; name: string; precedence: number; read_only?: boolean; rule_settings?: { add_headers?: Record<string, unknown>; allow_child_bypass?: boolean; audit_ssh?: { command_logging?: boolean }; biso_admin_controls?: { copy?: "enabled" | "disabled" | "remote_only"; dcp?: boolean; dd?: boolean; dk?: boolean; download?: "enabled" | "disabled" | "remote_only"; dp?: boolean; du?: boolean; keyboard?: "enabled" | "disabled"; paste?: "enabled" | "disabled" | "remote_only"; printing?: "enabled" | "disabled"; upload?: "enabled" | "disabled"; version?: "v1" | "v2" }; block_page?: { include_context?: boolean; target_uri: string }; block_page_enabled?: boolean; block_reason?: string; bypass_parent_rule?: boolean; check_session?: { duration?: string; enforce?: boolean }; dns_resolvers?: { ipv4?: { ip: string; port?: number; route_through_private_network?: boolean; vnet_id?: string }[]; ipv6?: { ip: string; port?: number; route_through_private_network?: boolean; vnet_id?: string }[] }; egress?: { ipv4?: string; ipv4_fallback?: string; ipv6?: string }; forensic_copy?: { enabled?: boolean }; ignore_cname_category_matches?: boolean; insecure_disable_dnssec_validation?: boolean; ip_categories?: boolean; ip_indicator_feeds?: boolean; l4override?: { ip?: string; port?: number }; notification_settings?: { enabled?: boolean; include_context?: boolean; msg?: string; support_url?: string }; override_host?: string; override_ips?: string[]; payload_log?: { enabled?: boolean }; quarantine?: { file_types?: "exe" | "pdf" | "doc" | "docm" | "docx" | "rtf" | "ppt" | "pptx" | "xls" | "xlsm" | "xlsx" | "zip" | "rar"[] }; redirect?: { include_context?: boolean; preserve_path_and_query?: boolean; target_uri: string }; resolve_dns_internally?: { fallback?: "none" | "public_dns"; view_id?: string }; resolve_dns_through_cloudflare?: boolean; untrusted_cert?: { action?: "pass_through" | "block" | "error" } }; schedule?: { fri?: string; mon?: string; sat?: string; sun?: string; thu?: string; time_zone?: string; tue?: string; wed?: string }; sharable?: boolean; source_account?: string; traffic: string; updated_at?: string; version?: number; warning_status?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateZeroTrustGatewayRuleResponse = Schema.Struct({
  result: Schema.Struct({
  action: Schema.Literal("on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "resolve", "quarantine", "redirect"),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  device_posture: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  expiration: Schema.optional(Schema.Struct({
  duration: Schema.optional(Schema.Number),
  expired: Schema.optional(Schema.Boolean),
  expires_at: Schema.String
})),
  filters: Schema.Array(Schema.Literal("http", "dns", "l4", "egress", "dns_resolver")),
  id: Schema.optional(Schema.String),
  identity: Schema.optional(Schema.String),
  name: Schema.String,
  precedence: Schema.Number,
  read_only: Schema.optional(Schema.Boolean),
  rule_settings: Schema.optional(Schema.Struct({
  add_headers: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  allow_child_bypass: Schema.optional(Schema.Boolean),
  audit_ssh: Schema.optional(Schema.Struct({
  command_logging: Schema.optional(Schema.Boolean)
})),
  biso_admin_controls: Schema.optional(Schema.Struct({
  copy: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  dcp: Schema.optional(Schema.Boolean),
  dd: Schema.optional(Schema.Boolean),
  dk: Schema.optional(Schema.Boolean),
  download: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  dp: Schema.optional(Schema.Boolean),
  du: Schema.optional(Schema.Boolean),
  keyboard: Schema.optional(Schema.Literal("enabled", "disabled")),
  paste: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  printing: Schema.optional(Schema.Literal("enabled", "disabled")),
  upload: Schema.optional(Schema.Literal("enabled", "disabled")),
  version: Schema.optional(Schema.Literal("v1", "v2"))
})),
  block_page: Schema.optional(Schema.Struct({
  include_context: Schema.optional(Schema.Boolean),
  target_uri: Schema.String
})),
  block_page_enabled: Schema.optional(Schema.Boolean),
  block_reason: Schema.optional(Schema.String),
  bypass_parent_rule: Schema.optional(Schema.Boolean),
  check_session: Schema.optional(Schema.Struct({
  duration: Schema.optional(Schema.String),
  enforce: Schema.optional(Schema.Boolean)
})),
  dns_resolvers: Schema.optional(Schema.Struct({
  ipv4: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.String,
  port: Schema.optional(Schema.Number),
  route_through_private_network: Schema.optional(Schema.Boolean),
  vnet_id: Schema.optional(Schema.String)
}))),
  ipv6: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.String,
  port: Schema.optional(Schema.Number),
  route_through_private_network: Schema.optional(Schema.Boolean),
  vnet_id: Schema.optional(Schema.String)
})))
})),
  egress: Schema.optional(Schema.Struct({
  ipv4: Schema.optional(Schema.String),
  ipv4_fallback: Schema.optional(Schema.String),
  ipv6: Schema.optional(Schema.String)
})),
  forensic_copy: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
})),
  ignore_cname_category_matches: Schema.optional(Schema.Boolean),
  insecure_disable_dnssec_validation: Schema.optional(Schema.Boolean),
  ip_categories: Schema.optional(Schema.Boolean),
  ip_indicator_feeds: Schema.optional(Schema.Boolean),
  l4override: Schema.optional(Schema.Struct({
  ip: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  notification_settings: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  include_context: Schema.optional(Schema.Boolean),
  msg: Schema.optional(Schema.String),
  support_url: Schema.optional(Schema.String)
})),
  override_host: Schema.optional(Schema.String),
  override_ips: Schema.optional(Schema.Array(Schema.String)),
  payload_log: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
})),
  quarantine: Schema.optional(Schema.Struct({
  file_types: Schema.optional(Schema.Array(Schema.Literal("exe", "pdf", "doc", "docm", "docx", "rtf", "ppt", "pptx", "xls", "xlsm", "xlsx", "zip", "rar")))
})),
  redirect: Schema.optional(Schema.Struct({
  include_context: Schema.optional(Schema.Boolean),
  preserve_path_and_query: Schema.optional(Schema.Boolean),
  target_uri: Schema.String
})),
  resolve_dns_internally: Schema.optional(Schema.Struct({
  fallback: Schema.optional(Schema.Literal("none", "public_dns")),
  view_id: Schema.optional(Schema.String)
})),
  resolve_dns_through_cloudflare: Schema.optional(Schema.Boolean),
  untrusted_cert: Schema.optional(Schema.Struct({
  action: Schema.optional(Schema.Literal("pass_through", "block", "error"))
}))
})),
  schedule: Schema.optional(Schema.Struct({
  fri: Schema.optional(Schema.String),
  mon: Schema.optional(Schema.String),
  sat: Schema.optional(Schema.String),
  sun: Schema.optional(Schema.String),
  thu: Schema.optional(Schema.String),
  time_zone: Schema.optional(Schema.String),
  tue: Schema.optional(Schema.String),
  wed: Schema.optional(Schema.String)
})),
  sharable: Schema.optional(Schema.Boolean),
  source_account: Schema.optional(Schema.String),
  traffic: Schema.String,
  updated_at: Schema.optional(Schema.Date),
  version: Schema.optional(Schema.Number),
  warning_status: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateZeroTrustGatewayRuleResponse" }) as unknown as Schema.Schema<UpdateZeroTrustGatewayRuleResponse>;

export const updateZeroTrustGatewayRule: (
  input: UpdateZeroTrustGatewayRuleRequest
) => Effect.Effect<
  UpdateZeroTrustGatewayRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateZeroTrustGatewayRuleRequest,
  output: UpdateZeroTrustGatewayRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteZeroTrustGatewayRuleRequest {
  rule_id: string;
  account_id: string;
}

export const DeleteZeroTrustGatewayRuleRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/gateway/rules/{rule_id}" }),
).annotations({ identifier: "DeleteZeroTrustGatewayRuleRequest" }) as unknown as Schema.Schema<DeleteZeroTrustGatewayRuleRequest>;

export interface DeleteZeroTrustGatewayRuleResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteZeroTrustGatewayRuleResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteZeroTrustGatewayRuleResponse" }) as unknown as Schema.Schema<DeleteZeroTrustGatewayRuleResponse>;

export const deleteZeroTrustGatewayRule: (
  input: DeleteZeroTrustGatewayRuleRequest
) => Effect.Effect<
  DeleteZeroTrustGatewayRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteZeroTrustGatewayRuleRequest,
  output: DeleteZeroTrustGatewayRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRuleRequest {
  rule_id: string;
  account_id: string;
}

export const ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRuleRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/gateway/rules/{rule_id}/reset_expiration" }),
).annotations({ identifier: "ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRuleRequest" }) as unknown as Schema.Schema<ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRuleRequest>;

export interface ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRuleResponse {
  result: { action: "on" | "off" | "allow" | "block" | "scan" | "noscan" | "safesearch" | "ytrestricted" | "isolate" | "noisolate" | "override" | "l4_override" | "egress" | "resolve" | "quarantine" | "redirect"; created_at?: string; deleted_at?: string; description?: string; device_posture?: string; enabled: boolean; expiration?: { duration?: number; expired?: boolean; expires_at: unknown }; filters: "http" | "dns" | "l4" | "egress" | "dns_resolver"[]; id?: string; identity?: string; name: string; precedence: number; read_only?: boolean; rule_settings?: { add_headers?: Record<string, unknown>; allow_child_bypass?: boolean; audit_ssh?: { command_logging?: boolean }; biso_admin_controls?: { copy?: "enabled" | "disabled" | "remote_only"; dcp?: boolean; dd?: boolean; dk?: boolean; download?: "enabled" | "disabled" | "remote_only"; dp?: boolean; du?: boolean; keyboard?: "enabled" | "disabled"; paste?: "enabled" | "disabled" | "remote_only"; printing?: "enabled" | "disabled"; upload?: "enabled" | "disabled"; version?: "v1" | "v2" }; block_page?: { include_context?: boolean; target_uri: string }; block_page_enabled?: boolean; block_reason?: string; bypass_parent_rule?: boolean; check_session?: { duration?: string; enforce?: boolean }; dns_resolvers?: { ipv4?: { ip: string; port?: number; route_through_private_network?: boolean; vnet_id?: string }[]; ipv6?: { ip: string; port?: number; route_through_private_network?: boolean; vnet_id?: string }[] }; egress?: { ipv4?: string; ipv4_fallback?: string; ipv6?: string }; forensic_copy?: { enabled?: boolean }; ignore_cname_category_matches?: boolean; insecure_disable_dnssec_validation?: boolean; ip_categories?: boolean; ip_indicator_feeds?: boolean; l4override?: { ip?: string; port?: number }; notification_settings?: { enabled?: boolean; include_context?: boolean; msg?: string; support_url?: string }; override_host?: string; override_ips?: string[]; payload_log?: { enabled?: boolean }; quarantine?: { file_types?: "exe" | "pdf" | "doc" | "docm" | "docx" | "rtf" | "ppt" | "pptx" | "xls" | "xlsm" | "xlsx" | "zip" | "rar"[] }; redirect?: { include_context?: boolean; preserve_path_and_query?: boolean; target_uri: string }; resolve_dns_internally?: { fallback?: "none" | "public_dns"; view_id?: string }; resolve_dns_through_cloudflare?: boolean; untrusted_cert?: { action?: "pass_through" | "block" | "error" } }; schedule?: { fri?: string; mon?: string; sat?: string; sun?: string; thu?: string; time_zone?: string; tue?: string; wed?: string }; sharable?: boolean; source_account?: string; traffic: string; updated_at?: string; version?: number; warning_status?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRuleResponse = Schema.Struct({
  result: Schema.Struct({
  action: Schema.Literal("on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "resolve", "quarantine", "redirect"),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  device_posture: Schema.optional(Schema.String),
  enabled: Schema.Boolean,
  expiration: Schema.optional(Schema.Struct({
  duration: Schema.optional(Schema.Number),
  expired: Schema.optional(Schema.Boolean),
  expires_at: Schema.String
})),
  filters: Schema.Array(Schema.Literal("http", "dns", "l4", "egress", "dns_resolver")),
  id: Schema.optional(Schema.String),
  identity: Schema.optional(Schema.String),
  name: Schema.String,
  precedence: Schema.Number,
  read_only: Schema.optional(Schema.Boolean),
  rule_settings: Schema.optional(Schema.Struct({
  add_headers: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  allow_child_bypass: Schema.optional(Schema.Boolean),
  audit_ssh: Schema.optional(Schema.Struct({
  command_logging: Schema.optional(Schema.Boolean)
})),
  biso_admin_controls: Schema.optional(Schema.Struct({
  copy: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  dcp: Schema.optional(Schema.Boolean),
  dd: Schema.optional(Schema.Boolean),
  dk: Schema.optional(Schema.Boolean),
  download: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  dp: Schema.optional(Schema.Boolean),
  du: Schema.optional(Schema.Boolean),
  keyboard: Schema.optional(Schema.Literal("enabled", "disabled")),
  paste: Schema.optional(Schema.Literal("enabled", "disabled", "remote_only")),
  printing: Schema.optional(Schema.Literal("enabled", "disabled")),
  upload: Schema.optional(Schema.Literal("enabled", "disabled")),
  version: Schema.optional(Schema.Literal("v1", "v2"))
})),
  block_page: Schema.optional(Schema.Struct({
  include_context: Schema.optional(Schema.Boolean),
  target_uri: Schema.String
})),
  block_page_enabled: Schema.optional(Schema.Boolean),
  block_reason: Schema.optional(Schema.String),
  bypass_parent_rule: Schema.optional(Schema.Boolean),
  check_session: Schema.optional(Schema.Struct({
  duration: Schema.optional(Schema.String),
  enforce: Schema.optional(Schema.Boolean)
})),
  dns_resolvers: Schema.optional(Schema.Struct({
  ipv4: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.String,
  port: Schema.optional(Schema.Number),
  route_through_private_network: Schema.optional(Schema.Boolean),
  vnet_id: Schema.optional(Schema.String)
}))),
  ipv6: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.String,
  port: Schema.optional(Schema.Number),
  route_through_private_network: Schema.optional(Schema.Boolean),
  vnet_id: Schema.optional(Schema.String)
})))
})),
  egress: Schema.optional(Schema.Struct({
  ipv4: Schema.optional(Schema.String),
  ipv4_fallback: Schema.optional(Schema.String),
  ipv6: Schema.optional(Schema.String)
})),
  forensic_copy: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
})),
  ignore_cname_category_matches: Schema.optional(Schema.Boolean),
  insecure_disable_dnssec_validation: Schema.optional(Schema.Boolean),
  ip_categories: Schema.optional(Schema.Boolean),
  ip_indicator_feeds: Schema.optional(Schema.Boolean),
  l4override: Schema.optional(Schema.Struct({
  ip: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number)
})),
  notification_settings: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  include_context: Schema.optional(Schema.Boolean),
  msg: Schema.optional(Schema.String),
  support_url: Schema.optional(Schema.String)
})),
  override_host: Schema.optional(Schema.String),
  override_ips: Schema.optional(Schema.Array(Schema.String)),
  payload_log: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean)
})),
  quarantine: Schema.optional(Schema.Struct({
  file_types: Schema.optional(Schema.Array(Schema.Literal("exe", "pdf", "doc", "docm", "docx", "rtf", "ppt", "pptx", "xls", "xlsm", "xlsx", "zip", "rar")))
})),
  redirect: Schema.optional(Schema.Struct({
  include_context: Schema.optional(Schema.Boolean),
  preserve_path_and_query: Schema.optional(Schema.Boolean),
  target_uri: Schema.String
})),
  resolve_dns_internally: Schema.optional(Schema.Struct({
  fallback: Schema.optional(Schema.Literal("none", "public_dns")),
  view_id: Schema.optional(Schema.String)
})),
  resolve_dns_through_cloudflare: Schema.optional(Schema.Boolean),
  untrusted_cert: Schema.optional(Schema.Struct({
  action: Schema.optional(Schema.Literal("pass_through", "block", "error"))
}))
})),
  schedule: Schema.optional(Schema.Struct({
  fri: Schema.optional(Schema.String),
  mon: Schema.optional(Schema.String),
  sat: Schema.optional(Schema.String),
  sun: Schema.optional(Schema.String),
  thu: Schema.optional(Schema.String),
  time_zone: Schema.optional(Schema.String),
  tue: Schema.optional(Schema.String),
  wed: Schema.optional(Schema.String)
})),
  sharable: Schema.optional(Schema.Boolean),
  source_account: Schema.optional(Schema.String),
  traffic: Schema.String,
  updated_at: Schema.optional(Schema.Date),
  version: Schema.optional(Schema.Number),
  warning_status: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRuleResponse" }) as unknown as Schema.Schema<ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRuleResponse>;

export const zeroTrustGatewayRulesResetExpirationZeroTrustGatewayRule: (
  input: ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRuleRequest
) => Effect.Effect<
  ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRuleRequest,
  output: ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List22Request {
  account_id: unknown;
  id?: string;
  name?: string;
  label?: string;
  page?: number;
  per_page?: number;
}

export const List22Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.optional(Schema.String).pipe(T.HttpQuery("id")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  label: Schema.optional(Schema.String).pipe(T.HttpQuery("label")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/iam/permission_groups" }),
).annotations({ identifier: "List22Request" }) as unknown as Schema.Schema<List22Request>;

export interface List22Response {
  result: { id: string; meta?: { key?: string; value?: string }; name?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List22Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  id: Schema.String,
  meta: Schema.optional(Schema.Struct({
  key: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List22Response" }) as unknown as Schema.Schema<List22Response>;

export const list22: (
  input: List22Request
) => Effect.Effect<
  List22Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List22Request,
  output: List22Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountPermissionGroupDetailsRequest {
  account_id: unknown;
  permission_group_id: unknown;
}

export const AccountPermissionGroupDetailsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  permission_group_id: Schema.String.pipe(T.HttpPath("permission_group_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/iam/permission_groups/{permission_group_id}" }),
).annotations({ identifier: "AccountPermissionGroupDetailsRequest" }) as unknown as Schema.Schema<AccountPermissionGroupDetailsRequest>;

export interface AccountPermissionGroupDetailsResponse {
  result: { id: string; meta?: { key?: string; value?: string }; name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountPermissionGroupDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String,
  meta: Schema.optional(Schema.Struct({
  key: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountPermissionGroupDetailsResponse" }) as unknown as Schema.Schema<AccountPermissionGroupDetailsResponse>;

export const accountPermissionGroupDetails: (
  input: AccountPermissionGroupDetailsRequest
) => Effect.Effect<
  AccountPermissionGroupDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountPermissionGroupDetailsRequest,
  output: AccountPermissionGroupDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List23Request {
  account_id: unknown;
  id?: unknown;
  name?: string;
}

export const List23Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.optional(Schema.String).pipe(T.HttpQuery("id")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/iam/resource_groups" }),
).annotations({ identifier: "List23Request" }) as unknown as Schema.Schema<List23Request>;

export interface List23Response {
  result: { id: string; meta?: { key?: string; value?: string }; name?: string; scope: { key: unknown; objects: { key: unknown }[] }[] }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List23Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  id: Schema.String,
  meta: Schema.optional(Schema.Struct({
  key: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String),
  scope: Schema.Array(Schema.Struct({
  key: Schema.Unknown,
  objects: Schema.Array(Schema.Struct({
  key: Schema.Unknown
}))
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List23Response" }) as unknown as Schema.Schema<List23Response>;

export const list23: (
  input: List23Request
) => Effect.Effect<
  List23Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List23Request,
  output: List23Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create6Request {
  account_id: unknown;
  body: { name: string; scope: { key: unknown; objects: { key: unknown }[] } };
}

export const Create6Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  name: Schema.String,
  scope: Schema.Struct({
  key: Schema.Unknown,
  objects: Schema.Array(Schema.Struct({
  key: Schema.Unknown
}))
})
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/iam/resource_groups" }),
).annotations({ identifier: "Create6Request" }) as unknown as Schema.Schema<Create6Request>;

export interface Create6Response {
  result: { id: string; meta?: { key?: string; value?: string }; name?: string; scope: { key: unknown; objects: { key: unknown }[] }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create6Response = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String,
  meta: Schema.optional(Schema.Struct({
  key: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String),
  scope: Schema.Array(Schema.Struct({
  key: Schema.Unknown,
  objects: Schema.Array(Schema.Struct({
  key: Schema.Unknown
}))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create6Response" }) as unknown as Schema.Schema<Create6Response>;

export const create6: (
  input: Create6Request
) => Effect.Effect<
  Create6Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create6Request,
  output: Create6Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountResourceGroupDetailsRequest {
  account_id: unknown;
  resource_group_id: unknown;
}

export const AccountResourceGroupDetailsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  resource_group_id: Schema.String.pipe(T.HttpPath("resource_group_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/iam/resource_groups/{resource_group_id}" }),
).annotations({ identifier: "AccountResourceGroupDetailsRequest" }) as unknown as Schema.Schema<AccountResourceGroupDetailsRequest>;

export interface AccountResourceGroupDetailsResponse {
  result: { id: string; meta?: { key?: string; value?: string }; name?: string; scope: { key: unknown; objects: { key: unknown }[] }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountResourceGroupDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String,
  meta: Schema.optional(Schema.Struct({
  key: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String),
  scope: Schema.Array(Schema.Struct({
  key: Schema.Unknown,
  objects: Schema.Array(Schema.Struct({
  key: Schema.Unknown
}))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountResourceGroupDetailsResponse" }) as unknown as Schema.Schema<AccountResourceGroupDetailsResponse>;

export const accountResourceGroupDetails: (
  input: AccountResourceGroupDetailsRequest
) => Effect.Effect<
  AccountResourceGroupDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountResourceGroupDetailsRequest,
  output: AccountResourceGroupDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update9Request {
  account_id: unknown;
  resource_group_id: unknown;
  body: { name?: string; scope?: { key: unknown; objects: { key: unknown }[] } };
}

export const Update9Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  resource_group_id: Schema.String.pipe(T.HttpPath("resource_group_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String),
  scope: Schema.optional(Schema.Struct({
  key: Schema.Unknown,
  objects: Schema.Array(Schema.Struct({
  key: Schema.Unknown
}))
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/iam/resource_groups/{resource_group_id}" }),
).annotations({ identifier: "Update9Request" }) as unknown as Schema.Schema<Update9Request>;

export interface Update9Response {
  result: { id: string; meta?: { key?: string; value?: string }; name?: string; scope: { key: unknown; objects: { key: unknown }[] }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update9Response = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String,
  meta: Schema.optional(Schema.Struct({
  key: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String),
  scope: Schema.Array(Schema.Struct({
  key: Schema.Unknown,
  objects: Schema.Array(Schema.Struct({
  key: Schema.Unknown
}))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update9Response" }) as unknown as Schema.Schema<Update9Response>;

export const update9: (
  input: Update9Request
) => Effect.Effect<
  Update9Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update9Request,
  output: Update9Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_10Request {
  account_id: unknown;
  resource_group_id: unknown;
}

export const Delete_10Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  resource_group_id: Schema.String.pipe(T.HttpPath("resource_group_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/iam/resource_groups/{resource_group_id}" }),
).annotations({ identifier: "Delete_10Request" }) as unknown as Schema.Schema<Delete_10Request>;

export interface Delete_10Response {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_10Response = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_10Response" }) as unknown as Schema.Schema<Delete_10Response>;

export const delete_10: (
  input: Delete_10Request
) => Effect.Effect<
  Delete_10Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_10Request,
  output: Delete_10Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List24Request {
  account_id: unknown;
  id?: unknown;
  name?: string;
  fuzzyName?: string;
  page?: number;
  per_page?: number;
  direction?: string;
}

export const List24Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.optional(Schema.String).pipe(T.HttpQuery("id")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  fuzzyName: Schema.optional(Schema.String).pipe(T.HttpQuery("fuzzyName")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  direction: Schema.optional(Schema.String).pipe(T.HttpQuery("direction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/iam/user_groups" }),
).annotations({ identifier: "List24Request" }) as unknown as Schema.Schema<List24Request>;

export interface List24Response {
  result: { created_on: string; id: unknown; modified_on: string; name: string; policies?: unknown[] }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List24Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_on: Schema.Date,
  id: Schema.String,
  modified_on: Schema.Date,
  name: Schema.String,
  policies: Schema.optional(Schema.Array(Schema.Unknown))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List24Response" }) as unknown as Schema.Schema<List24Response>;

export const list24: (
  input: List24Request
) => Effect.Effect<
  List24Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List24Request,
  output: List24Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create7Request {
  account_id: unknown;
  body: { name: string; policies: unknown[] };
}

export const Create7Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  name: Schema.String,
  policies: Schema.Array(Schema.Unknown)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/iam/user_groups" }),
).annotations({ identifier: "Create7Request" }) as unknown as Schema.Schema<Create7Request>;

export interface Create7Response {
  result: { created_on: string; id: unknown; modified_on: string; name: string; policies?: unknown[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create7Response = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.Date,
  id: Schema.String,
  modified_on: Schema.Date,
  name: Schema.String,
  policies: Schema.optional(Schema.Array(Schema.Unknown))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create7Response" }) as unknown as Schema.Schema<Create7Response>;

export const create7: (
  input: Create7Request
) => Effect.Effect<
  Create7Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create7Request,
  output: Create7Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountUserGroupDetailsRequest {
  account_id: unknown;
  user_group_id: unknown;
}

export const AccountUserGroupDetailsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  user_group_id: Schema.String.pipe(T.HttpPath("user_group_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/iam/user_groups/{user_group_id}" }),
).annotations({ identifier: "AccountUserGroupDetailsRequest" }) as unknown as Schema.Schema<AccountUserGroupDetailsRequest>;

export interface AccountUserGroupDetailsResponse {
  result: { created_on: string; id: unknown; modified_on: string; name: string; policies?: unknown[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountUserGroupDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.Date,
  id: Schema.String,
  modified_on: Schema.Date,
  name: Schema.String,
  policies: Schema.optional(Schema.Array(Schema.Unknown))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountUserGroupDetailsResponse" }) as unknown as Schema.Schema<AccountUserGroupDetailsResponse>;

export const accountUserGroupDetails: (
  input: AccountUserGroupDetailsRequest
) => Effect.Effect<
  AccountUserGroupDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountUserGroupDetailsRequest,
  output: AccountUserGroupDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update10Request {
  account_id: unknown;
  user_group_id: unknown;
  body: { name?: string; policies?: unknown[] };
}

export const Update10Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  user_group_id: Schema.String.pipe(T.HttpPath("user_group_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String),
  policies: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.String
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/iam/user_groups/{user_group_id}" }),
).annotations({ identifier: "Update10Request" }) as unknown as Schema.Schema<Update10Request>;

export interface Update10Response {
  result: { created_on: string; id: unknown; modified_on: string; name: string; policies?: unknown[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update10Response = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.Date,
  id: Schema.String,
  modified_on: Schema.Date,
  name: Schema.String,
  policies: Schema.optional(Schema.Array(Schema.Unknown))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update10Response" }) as unknown as Schema.Schema<Update10Response>;

export const update10: (
  input: Update10Request
) => Effect.Effect<
  Update10Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update10Request,
  output: Update10Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_11Request {
  account_id: unknown;
  user_group_id: unknown;
}

export const Delete_11Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  user_group_id: Schema.String.pipe(T.HttpPath("user_group_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/iam/user_groups/{user_group_id}" }),
).annotations({ identifier: "Delete_11Request" }) as unknown as Schema.Schema<Delete_11Request>;

export interface Delete_11Response {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_11Response = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_11Response" }) as unknown as Schema.Schema<Delete_11Response>;

export const delete_11: (
  input: Delete_11Request
) => Effect.Effect<
  Delete_11Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_11Request,
  output: Delete_11Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List25Request {
  account_id: unknown;
  user_group_id: unknown;
  page?: number;
  per_page?: number;
}

export const List25Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  user_group_id: Schema.String.pipe(T.HttpPath("user_group_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/iam/user_groups/{user_group_id}/members" }),
).annotations({ identifier: "List25Request" }) as unknown as Schema.Schema<List25Request>;

export interface List25Response {
  result: { email?: string; id: string; status?: "accepted" | "pending" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List25Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  email: Schema.optional(Schema.String),
  id: Schema.String,
  status: Schema.optional(Schema.Literal("accepted", "pending"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List25Response" }) as unknown as Schema.Schema<List25Response>;

export const list25: (
  input: List25Request
) => Effect.Effect<
  List25Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List25Request,
  output: List25Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create8Request {
  account_id: unknown;
  user_group_id: unknown;
  body: { id: unknown }[];
}

export const Create8Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  user_group_id: Schema.String.pipe(T.HttpPath("user_group_id")),
  body: Schema.Array(Schema.Struct({
  id: Schema.String
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/iam/user_groups/{user_group_id}/members" }),
).annotations({ identifier: "Create8Request" }) as unknown as Schema.Schema<Create8Request>;

export interface Create8Response {
  result: { email?: string; id: string; status?: "accepted" | "pending" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create8Response = Schema.Struct({
  result: Schema.Struct({
  email: Schema.optional(Schema.String),
  id: Schema.String,
  status: Schema.optional(Schema.Literal("accepted", "pending"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create8Response" }) as unknown as Schema.Schema<Create8Response>;

export const create8: (
  input: Create8Request
) => Effect.Effect<
  Create8Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create8Request,
  output: Create8Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update11Request {
  account_id: unknown;
  user_group_id: unknown;
  body: { id: unknown }[];
}

export const Update11Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  user_group_id: Schema.String.pipe(T.HttpPath("user_group_id")),
  body: Schema.Array(Schema.Struct({
  id: Schema.String
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/iam/user_groups/{user_group_id}/members" }),
).annotations({ identifier: "Update11Request" }) as unknown as Schema.Schema<Update11Request>;

export interface Update11Response {
  result: { email?: string; id: string; status?: "accepted" | "pending" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update11Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  email: Schema.optional(Schema.String),
  id: Schema.String,
  status: Schema.optional(Schema.Literal("accepted", "pending"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update11Response" }) as unknown as Schema.Schema<Update11Response>;

export const update11: (
  input: Update11Request
) => Effect.Effect<
  Update11Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update11Request,
  output: Update11Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_12Request {
  account_id: unknown;
  user_group_id: unknown;
  member_id: unknown;
}

export const Delete_12Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  user_group_id: Schema.String.pipe(T.HttpPath("user_group_id")),
  member_id: Schema.String.pipe(T.HttpPath("member_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/iam/user_groups/{user_group_id}/members/{member_id}" }),
).annotations({ identifier: "Delete_12Request" }) as unknown as Schema.Schema<Delete_12Request>;

export interface Delete_12Response {
  result: { email?: string; id: string; status?: "accepted" | "pending" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_12Response = Schema.Struct({
  result: Schema.Struct({
  email: Schema.optional(Schema.String),
  id: Schema.String,
  status: Schema.optional(Schema.Literal("accepted", "pending"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_12Response" }) as unknown as Schema.Schema<Delete_12Response>;

export const delete_12: (
  input: Delete_12Request
) => Effect.Effect<
  Delete_12Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_12Request,
  output: Delete_12Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List26Request {
  account_id: string;
  hostname?: string;
  hostname_contains?: string;
  virtual_network_id?: string;
  ip_v4?: string;
  ip_v6?: string;
  created_before?: string;
  created_after?: string;
  modified_before?: string;
  modified_after?: string;
  ips?: string[];
  target_ids?: string[];
  ip_like?: string;
  ipv4_start?: string;
  ipv4_end?: string;
  ipv6_start?: string;
  ipv6_end?: string;
  page?: number;
  per_page?: number;
  order?: "hostname" | "created_at";
  direction?: unknown;
}

export const List26Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  hostname: Schema.optional(Schema.String).pipe(T.HttpQuery("hostname")),
  hostname_contains: Schema.optional(Schema.String).pipe(T.HttpQuery("hostname_contains")),
  virtual_network_id: Schema.optional(Schema.UUID).pipe(T.HttpQuery("virtual_network_id")),
  ip_v4: Schema.optional(Schema.String).pipe(T.HttpQuery("ip_v4")),
  ip_v6: Schema.optional(Schema.String).pipe(T.HttpQuery("ip_v6")),
  created_before: Schema.optional(Schema.Date).pipe(T.HttpQuery("created_before")),
  created_after: Schema.optional(Schema.Date).pipe(T.HttpQuery("created_after")),
  modified_before: Schema.optional(Schema.Date).pipe(T.HttpQuery("modified_before")),
  modified_after: Schema.optional(Schema.Date).pipe(T.HttpQuery("modified_after")),
  ips: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("ips")),
  target_ids: Schema.optional(Schema.Array(Schema.UUID)).pipe(T.HttpQuery("target_ids")),
  ip_like: Schema.optional(Schema.String).pipe(T.HttpQuery("ip_like")),
  ipv4_start: Schema.optional(Schema.String).pipe(T.HttpQuery("ipv4_start")),
  ipv4_end: Schema.optional(Schema.String).pipe(T.HttpQuery("ipv4_end")),
  ipv6_start: Schema.optional(Schema.String).pipe(T.HttpQuery("ipv6_start")),
  ipv6_end: Schema.optional(Schema.String).pipe(T.HttpQuery("ipv6_end")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.Literal("hostname", "created_at")).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/infrastructure/targets" }),
).annotations({ identifier: "List26Request" }) as unknown as Schema.Schema<List26Request>;

export interface List26Response {
  result: { created_at: string; hostname: string; id: string; ip: { ipv4?: { ip_addr?: string; virtual_network_id?: string }; ipv6?: { ip_addr?: string; virtual_network_id?: string } }; modified_at: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List26Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.Date,
  hostname: Schema.String,
  id: Schema.UUID,
  ip: Schema.Struct({
  ipv4: Schema.optional(Schema.Struct({
  ip_addr: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID)
})),
  ipv6: Schema.optional(Schema.Struct({
  ip_addr: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID)
}))
}),
  modified_at: Schema.Date
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List26Response" }) as unknown as Schema.Schema<List26Response>;

export const list26: (
  input: List26Request
) => Effect.Effect<
  List26Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List26Request,
  output: List26Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Post1Request {
  account_id: string;
  body: { hostname: string; ip: { ipv4?: { ip_addr?: string; virtual_network_id?: string }; ipv6?: { ip_addr?: string; virtual_network_id?: string } } };
}

export const Post1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  hostname: Schema.String,
  ip: Schema.Struct({
  ipv4: Schema.optional(Schema.Struct({
  ip_addr: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID)
})),
  ipv6: Schema.optional(Schema.Struct({
  ip_addr: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID)
}))
})
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/infrastructure/targets" }),
).annotations({ identifier: "Post1Request" }) as unknown as Schema.Schema<Post1Request>;

export interface Post1Response {
  result: { created_at: string; hostname: string; id: string; ip: { ipv4?: { ip_addr?: string; virtual_network_id?: string }; ipv6?: { ip_addr?: string; virtual_network_id?: string } }; modified_at: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Post1Response = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  hostname: Schema.String,
  id: Schema.UUID,
  ip: Schema.Struct({
  ipv4: Schema.optional(Schema.Struct({
  ip_addr: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID)
})),
  ipv6: Schema.optional(Schema.Struct({
  ip_addr: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID)
}))
}),
  modified_at: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Post1Response" }) as unknown as Schema.Schema<Post1Response>;

export const post1: (
  input: Post1Request
) => Effect.Effect<
  Post1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Post1Request,
  output: Post1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PutBatchRequest {
  account_id: string;
  body: { hostname: string; ip: { ipv4?: { ip_addr?: string; virtual_network_id?: string }; ipv6?: { ip_addr?: string; virtual_network_id?: string } } }[];
}

export const PutBatchRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Struct({
  hostname: Schema.String,
  ip: Schema.Struct({
  ipv4: Schema.optional(Schema.Struct({
  ip_addr: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID)
})),
  ipv6: Schema.optional(Schema.Struct({
  ip_addr: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID)
}))
})
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/infrastructure/targets/batch" }),
).annotations({ identifier: "PutBatchRequest" }) as unknown as Schema.Schema<PutBatchRequest>;

export interface PutBatchResponse {
  result: { created_at: string; hostname: string; id: string; ip: { ipv4?: { ip_addr?: string; virtual_network_id?: string }; ipv6?: { ip_addr?: string; virtual_network_id?: string } }; modified_at: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PutBatchResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.Date,
  hostname: Schema.String,
  id: Schema.UUID,
  ip: Schema.Struct({
  ipv4: Schema.optional(Schema.Struct({
  ip_addr: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID)
})),
  ipv6: Schema.optional(Schema.Struct({
  ip_addr: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID)
}))
}),
  modified_at: Schema.Date
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PutBatchResponse" }) as unknown as Schema.Schema<PutBatchResponse>;

export const putBatch: (
  input: PutBatchRequest
) => Effect.Effect<
  PutBatchResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutBatchRequest,
  output: PutBatchResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteBatchRequest {
  account_id: string;
  body: { target_ids: string[] };
}

export const DeleteBatchRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  target_ids: Schema.Array(Schema.UUID)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/infrastructure/targets/batch" }),
).annotations({ identifier: "DeleteBatchRequest" }) as unknown as Schema.Schema<DeleteBatchRequest>;

export interface DeleteBatchResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteBatchResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteBatchResponse" }) as unknown as Schema.Schema<DeleteBatchResponse>;

export const deleteBatch: (
  input: DeleteBatchRequest
) => Effect.Effect<
  DeleteBatchResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteBatchRequest,
  output: DeleteBatchResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Post2Request {
  account_id: string;
  body: { target_ids: string[] };
}

export const Post2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  target_ids: Schema.Array(Schema.UUID)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/infrastructure/targets/batch_delete" }),
).annotations({ identifier: "Post2Request" }) as unknown as Schema.Schema<Post2Request>;

export interface Post2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Post2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Post2Response" }) as unknown as Schema.Schema<Post2Response>;

export const post2: (
  input: Post2Request
) => Effect.Effect<
  Post2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Post2Request,
  output: Post2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_9Request {
  account_id: string;
  target_id: string;
}

export const Get_9Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  target_id: Schema.UUID.pipe(T.HttpPath("target_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/infrastructure/targets/{target_id}" }),
).annotations({ identifier: "Get_9Request" }) as unknown as Schema.Schema<Get_9Request>;

export interface Get_9Response {
  result: { created_at: string; hostname: string; id: string; ip: { ipv4?: { ip_addr?: string; virtual_network_id?: string }; ipv6?: { ip_addr?: string; virtual_network_id?: string } }; modified_at: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_9Response = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  hostname: Schema.String,
  id: Schema.UUID,
  ip: Schema.Struct({
  ipv4: Schema.optional(Schema.Struct({
  ip_addr: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID)
})),
  ipv6: Schema.optional(Schema.Struct({
  ip_addr: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID)
}))
}),
  modified_at: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_9Response" }) as unknown as Schema.Schema<Get_9Response>;

export const get_9: (
  input: Get_9Request
) => Effect.Effect<
  Get_9Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_9Request,
  output: Get_9Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Put2Request {
  account_id: string;
  target_id: string;
  body: { hostname: string; ip: { ipv4?: { ip_addr?: string; virtual_network_id?: string }; ipv6?: { ip_addr?: string; virtual_network_id?: string } } };
}

export const Put2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  target_id: Schema.UUID.pipe(T.HttpPath("target_id")),
  body: Schema.Struct({
  hostname: Schema.String,
  ip: Schema.Struct({
  ipv4: Schema.optional(Schema.Struct({
  ip_addr: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID)
})),
  ipv6: Schema.optional(Schema.Struct({
  ip_addr: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID)
}))
})
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/infrastructure/targets/{target_id}" }),
).annotations({ identifier: "Put2Request" }) as unknown as Schema.Schema<Put2Request>;

export interface Put2Response {
  result: { created_at: string; hostname: string; id: string; ip: { ipv4?: { ip_addr?: string; virtual_network_id?: string }; ipv6?: { ip_addr?: string; virtual_network_id?: string } }; modified_at: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Put2Response = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  hostname: Schema.String,
  id: Schema.UUID,
  ip: Schema.Struct({
  ipv4: Schema.optional(Schema.Struct({
  ip_addr: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID)
})),
  ipv6: Schema.optional(Schema.Struct({
  ip_addr: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID)
}))
}),
  modified_at: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Put2Response" }) as unknown as Schema.Schema<Put2Response>;

export const put2: (
  input: Put2Request
) => Effect.Effect<
  Put2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Put2Request,
  output: Put2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_13Request {
  account_id: string;
  target_id: string;
}

export const Delete_13Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  target_id: Schema.UUID.pipe(T.HttpPath("target_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/infrastructure/targets/{target_id}" }),
).annotations({ identifier: "Delete_13Request" }) as unknown as Schema.Schema<Delete_13Request>;

export interface Delete_13Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_13Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_13Response" }) as unknown as Schema.Schema<Delete_13Response>;

export const delete_13: (
  input: Delete_13Request
) => Effect.Effect<
  Delete_13Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_13Request,
  output: Delete_13Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAsnOverviewRequest {
  asn: number;
  account_id: string;
}

export const GetAsnOverviewRequest = Schema.Struct({
  asn: Schema.Number.pipe(T.HttpPath("asn")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/asn/{asn}" }),
).annotations({ identifier: "GetAsnOverviewRequest" }) as unknown as Schema.Schema<GetAsnOverviewRequest>;

export interface GetAsnOverviewResponse {
  result: number;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAsnOverviewResponse = Schema.Struct({
  result: Schema.Number,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAsnOverviewResponse" }) as unknown as Schema.Schema<GetAsnOverviewResponse>;

export const getAsnOverview: (
  input: GetAsnOverviewRequest
) => Effect.Effect<
  GetAsnOverviewResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAsnOverviewRequest,
  output: GetAsnOverviewResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAsnSubnetsRequest {
  asn: number;
  account_id: string;
}

export const GetAsnSubnetsRequest = Schema.Struct({
  asn: Schema.Number.pipe(T.HttpPath("asn")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/asn/{asn}/subnets" }),
).annotations({ identifier: "GetAsnSubnetsRequest" }) as unknown as Schema.Schema<GetAsnSubnetsRequest>;

export interface GetAsnSubnetsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAsnSubnetsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAsnSubnetsResponse" }) as unknown as Schema.Schema<GetAsnSubnetsResponse>;

export const getAsnSubnets: (
  input: GetAsnSubnetsRequest
) => Effect.Effect<
  GetAsnSubnetsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAsnSubnetsRequest,
  output: GetAsnSubnetsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSecurityCenterIssueTypesRequest {
  account_id: string;
}

export const GetSecurityCenterIssueTypesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/attack-surface-report/issue-types" }),
).annotations({ identifier: "GetSecurityCenterIssueTypesRequest" }) as unknown as Schema.Schema<GetSecurityCenterIssueTypesRequest>;

export interface GetSecurityCenterIssueTypesResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSecurityCenterIssueTypesResponse = Schema.Struct({
  result: Schema.Union(Schema.Array(Schema.String)),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSecurityCenterIssueTypesResponse" }) as unknown as Schema.Schema<GetSecurityCenterIssueTypesResponse>;

export const getSecurityCenterIssueTypes: (
  input: GetSecurityCenterIssueTypesRequest
) => Effect.Effect<
  GetSecurityCenterIssueTypesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSecurityCenterIssueTypesRequest,
  output: GetSecurityCenterIssueTypesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSecurityCenterIssuesRequest {
  account_id: string;
  dismissed?: boolean;
  issue_class?: string[];
  issue_type?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  product?: string[];
  severity?: "low" | "moderate" | "critical"[];
  subject?: string[];
  "issue_class~neq"?: string[];
  "issue_type~neq"?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  "product~neq"?: string[];
  "severity~neq"?: "low" | "moderate" | "critical"[];
  "subject~neq"?: string[];
  page?: unknown;
  per_page?: unknown;
}

export const GetSecurityCenterIssuesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dismissed: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("dismissed")),
  issue_class: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class")),
  issue_type: Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type")),
  product: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product")),
  severity: Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity")),
  subject: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject")),
  "issue_class~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class~neq")),
  "issue_type~neq": Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type~neq")),
  "product~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product~neq")),
  "severity~neq": Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity~neq")),
  "subject~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject~neq")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/attack-surface-report/issues" }),
).annotations({ identifier: "GetSecurityCenterIssuesRequest" }) as unknown as Schema.Schema<GetSecurityCenterIssuesRequest>;

export interface GetSecurityCenterIssuesResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSecurityCenterIssuesResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  count: Schema.optional(Schema.Number),
  issues: Schema.optional(Schema.Array(Schema.Struct({
  dismissed: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  issue_class: Schema.optional(Schema.String),
  issue_type: Schema.optional(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion")),
  payload: Schema.optional(Schema.Struct({
  detection_method: Schema.optional(Schema.String),
  zone_tag: Schema.optional(Schema.String)
})),
  resolve_link: Schema.optional(Schema.String),
  resolve_text: Schema.optional(Schema.String),
  severity: Schema.optional(Schema.Literal("Low", "Moderate", "Critical")),
  since: Schema.optional(Schema.Date),
  subject: Schema.optional(Schema.String),
  timestamp: Schema.optional(Schema.Date)
}))),
  page: Schema.optional(Schema.Number),
  per_page: Schema.optional(Schema.Number)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSecurityCenterIssuesResponse" }) as unknown as Schema.Schema<GetSecurityCenterIssuesResponse>;

export const getSecurityCenterIssues: (
  input: GetSecurityCenterIssuesRequest
) => Effect.Effect<
  GetSecurityCenterIssuesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSecurityCenterIssuesRequest,
  output: GetSecurityCenterIssuesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSecurityCenterIssueCountsByClassRequest {
  account_id: string;
  dismissed?: boolean;
  issue_class?: string[];
  issue_type?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  product?: string[];
  severity?: "low" | "moderate" | "critical"[];
  subject?: string[];
  "issue_class~neq"?: string[];
  "issue_type~neq"?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  "product~neq"?: string[];
  "severity~neq"?: "low" | "moderate" | "critical"[];
  "subject~neq"?: string[];
}

export const GetSecurityCenterIssueCountsByClassRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dismissed: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("dismissed")),
  issue_class: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class")),
  issue_type: Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type")),
  product: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product")),
  severity: Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity")),
  subject: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject")),
  "issue_class~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class~neq")),
  "issue_type~neq": Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type~neq")),
  "product~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product~neq")),
  "severity~neq": Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity~neq")),
  "subject~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject~neq"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/attack-surface-report/issues/class" }),
).annotations({ identifier: "GetSecurityCenterIssueCountsByClassRequest" }) as unknown as Schema.Schema<GetSecurityCenterIssueCountsByClassRequest>;

export interface GetSecurityCenterIssueCountsByClassResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSecurityCenterIssueCountsByClassResponse = Schema.Struct({
  result: Schema.Union(Schema.Array(Schema.Struct({
  count: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.String)
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSecurityCenterIssueCountsByClassResponse" }) as unknown as Schema.Schema<GetSecurityCenterIssueCountsByClassResponse>;

export const getSecurityCenterIssueCountsByClass: (
  input: GetSecurityCenterIssueCountsByClassRequest
) => Effect.Effect<
  GetSecurityCenterIssueCountsByClassResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSecurityCenterIssueCountsByClassRequest,
  output: GetSecurityCenterIssueCountsByClassResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSecurityCenterIssueCountsBySeverityRequest {
  account_id: string;
  dismissed?: boolean;
  issue_class?: string[];
  issue_type?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  product?: string[];
  severity?: "low" | "moderate" | "critical"[];
  subject?: string[];
  "issue_class~neq"?: string[];
  "issue_type~neq"?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  "product~neq"?: string[];
  "severity~neq"?: "low" | "moderate" | "critical"[];
  "subject~neq"?: string[];
}

export const GetSecurityCenterIssueCountsBySeverityRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dismissed: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("dismissed")),
  issue_class: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class")),
  issue_type: Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type")),
  product: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product")),
  severity: Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity")),
  subject: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject")),
  "issue_class~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class~neq")),
  "issue_type~neq": Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type~neq")),
  "product~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product~neq")),
  "severity~neq": Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity~neq")),
  "subject~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject~neq"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/attack-surface-report/issues/severity" }),
).annotations({ identifier: "GetSecurityCenterIssueCountsBySeverityRequest" }) as unknown as Schema.Schema<GetSecurityCenterIssueCountsBySeverityRequest>;

export interface GetSecurityCenterIssueCountsBySeverityResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSecurityCenterIssueCountsBySeverityResponse = Schema.Struct({
  result: Schema.Union(Schema.Array(Schema.Struct({
  count: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.String)
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSecurityCenterIssueCountsBySeverityResponse" }) as unknown as Schema.Schema<GetSecurityCenterIssueCountsBySeverityResponse>;

export const getSecurityCenterIssueCountsBySeverity: (
  input: GetSecurityCenterIssueCountsBySeverityRequest
) => Effect.Effect<
  GetSecurityCenterIssueCountsBySeverityResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSecurityCenterIssueCountsBySeverityRequest,
  output: GetSecurityCenterIssueCountsBySeverityResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSecurityCenterIssueCountsByTypeRequest {
  account_id: string;
  dismissed?: boolean;
  issue_class?: string[];
  issue_type?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  product?: string[];
  severity?: "low" | "moderate" | "critical"[];
  subject?: string[];
  "issue_class~neq"?: string[];
  "issue_type~neq"?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  "product~neq"?: string[];
  "severity~neq"?: "low" | "moderate" | "critical"[];
  "subject~neq"?: string[];
}

export const GetSecurityCenterIssueCountsByTypeRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dismissed: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("dismissed")),
  issue_class: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class")),
  issue_type: Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type")),
  product: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product")),
  severity: Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity")),
  subject: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject")),
  "issue_class~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class~neq")),
  "issue_type~neq": Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type~neq")),
  "product~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product~neq")),
  "severity~neq": Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity~neq")),
  "subject~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject~neq"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/attack-surface-report/issues/type" }),
).annotations({ identifier: "GetSecurityCenterIssueCountsByTypeRequest" }) as unknown as Schema.Schema<GetSecurityCenterIssueCountsByTypeRequest>;

export interface GetSecurityCenterIssueCountsByTypeResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSecurityCenterIssueCountsByTypeResponse = Schema.Struct({
  result: Schema.Union(Schema.Array(Schema.Struct({
  count: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.String)
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSecurityCenterIssueCountsByTypeResponse" }) as unknown as Schema.Schema<GetSecurityCenterIssueCountsByTypeResponse>;

export const getSecurityCenterIssueCountsByType: (
  input: GetSecurityCenterIssueCountsByTypeRequest
) => Effect.Effect<
  GetSecurityCenterIssueCountsByTypeResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSecurityCenterIssueCountsByTypeRequest,
  output: GetSecurityCenterIssueCountsByTypeResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ArchiveSecurityCenterInsightDeprecatedRequest {
  account_id: string;
  issue_id: string;
  body: { dismiss?: boolean };
}

export const ArchiveSecurityCenterInsightDeprecatedRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  issue_id: Schema.String.pipe(T.HttpPath("issue_id")),
  body: Schema.Struct({
  dismiss: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/intel/attack-surface-report/{issue_id}/dismiss" }),
).annotations({ identifier: "ArchiveSecurityCenterInsightDeprecatedRequest" }) as unknown as Schema.Schema<ArchiveSecurityCenterInsightDeprecatedRequest>;

export interface ArchiveSecurityCenterInsightDeprecatedResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ArchiveSecurityCenterInsightDeprecatedResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ArchiveSecurityCenterInsightDeprecatedResponse" }) as unknown as Schema.Schema<ArchiveSecurityCenterInsightDeprecatedResponse>;

export const archiveSecurityCenterInsightDeprecated: (
  input: ArchiveSecurityCenterInsightDeprecatedRequest
) => Effect.Effect<
  ArchiveSecurityCenterInsightDeprecatedResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ArchiveSecurityCenterInsightDeprecatedRequest,
  output: ArchiveSecurityCenterInsightDeprecatedResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetPassiveDnsByIpRequest {
  account_id: string;
  start_end_params?: { end?: string; start?: string };
  ipv4?: string;
  page?: number;
  per_page?: number;
}

export const GetPassiveDnsByIpRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  start_end_params: Schema.optional(Schema.Struct({
  end: Schema.optional(Schema.Date),
  start: Schema.optional(Schema.Date)
})).pipe(T.HttpQuery("start_end_params")),
  ipv4: Schema.optional(Schema.String).pipe(T.HttpQuery("ipv4")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/dns" }),
).annotations({ identifier: "GetPassiveDnsByIpRequest" }) as unknown as Schema.Schema<GetPassiveDnsByIpRequest>;

export interface GetPassiveDnsByIpResponse {
  result: { count?: number; page?: number; per_page?: number; reverse_records?: { first_seen?: string; hostname?: string; last_seen?: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetPassiveDnsByIpResponse = Schema.Struct({
  result: Schema.Struct({
  count: Schema.optional(Schema.Number),
  page: Schema.optional(Schema.Number),
  per_page: Schema.optional(Schema.Number),
  reverse_records: Schema.optional(Schema.Array(Schema.Struct({
  first_seen: Schema.optional(Schema.Date),
  hostname: Schema.optional(Schema.String),
  last_seen: Schema.optional(Schema.Date)
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetPassiveDnsByIpResponse" }) as unknown as Schema.Schema<GetPassiveDnsByIpResponse>;

export const getPassiveDnsByIp: (
  input: GetPassiveDnsByIpRequest
) => Effect.Effect<
  GetPassiveDnsByIpResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetPassiveDnsByIpRequest,
  output: GetPassiveDnsByIpResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDomainDetailsRequest {
  account_id: string;
  domain?: string;
}

export const GetDomainDetailsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  domain: Schema.optional(Schema.String).pipe(T.HttpQuery("domain"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/domain" }),
).annotations({ identifier: "GetDomainDetailsRequest" }) as unknown as Schema.Schema<GetDomainDetailsRequest>;

export interface GetDomainDetailsResponse {
  result: { additional_information?: { suspected_malware_family?: string }; application?: { id?: number; name?: string }; content_categories?: { id?: number; name?: string; super_category_id?: number }[]; domain?: string; inherited_content_categories?: string; inherited_from?: string; inherited_risk_types?: string; popularity_rank?: number; resolves_to_refs?: { id?: string; value?: string }[]; risk_score?: number; risk_types?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDomainDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  additional_information: Schema.optional(Schema.Struct({
  suspected_malware_family: Schema.optional(Schema.String)
})),
  application: Schema.optional(Schema.Struct({
  id: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String)
})),
  content_categories: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  super_category_id: Schema.optional(Schema.Number)
}))),
  domain: Schema.optional(Schema.String),
  inherited_content_categories: Schema.optional(Schema.String),
  inherited_from: Schema.optional(Schema.String),
  inherited_risk_types: Schema.optional(Schema.String),
  popularity_rank: Schema.optional(Schema.Number),
  resolves_to_refs: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
}))),
  risk_score: Schema.optional(Schema.Number),
  risk_types: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDomainDetailsResponse" }) as unknown as Schema.Schema<GetDomainDetailsResponse>;

export const getDomainDetails: (
  input: GetDomainDetailsRequest
) => Effect.Effect<
  GetDomainDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDomainDetailsRequest,
  output: GetDomainDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDomainHistoryRequest {
  account_id: string;
  domain?: string;
}

export const GetDomainHistoryRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  domain: Schema.optional(Schema.String).pipe(T.HttpQuery("domain"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/domain-history" }),
).annotations({ identifier: "GetDomainHistoryRequest" }) as unknown as Schema.Schema<GetDomainHistoryRequest>;

export interface GetDomainHistoryResponse {
  result: { categorizations?: { categories?: { id?: number; name?: string }[]; end?: string; start?: string }[]; domain?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDomainHistoryResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  categorizations: Schema.optional(Schema.Array(Schema.Struct({
  categories: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String)
}))),
  end: Schema.optional(Schema.Date),
  start: Schema.optional(Schema.Date)
}))),
  domain: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDomainHistoryResponse" }) as unknown as Schema.Schema<GetDomainHistoryResponse>;

export const getDomainHistory: (
  input: GetDomainHistoryRequest
) => Effect.Effect<
  GetDomainHistoryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDomainHistoryRequest,
  output: GetDomainHistoryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetMultipleDomainDetailsRequest {
  account_id: string;
  domain?: string[];
}

export const GetMultipleDomainDetailsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  domain: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("domain"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/domain/bulk" }),
).annotations({ identifier: "GetMultipleDomainDetailsRequest" }) as unknown as Schema.Schema<GetMultipleDomainDetailsRequest>;

export interface GetMultipleDomainDetailsResponse {
  result: { additional_information?: { suspected_malware_family?: string }; application?: { id?: number; name?: string }; content_categories?: { id?: number; name?: string; super_category_id?: number }[]; domain?: string; inherited_content_categories?: string; inherited_from?: string; inherited_risk_types?: string; popularity_rank?: number; risk_score?: number; risk_types?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetMultipleDomainDetailsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  additional_information: Schema.optional(Schema.Struct({
  suspected_malware_family: Schema.optional(Schema.String)
})),
  application: Schema.optional(Schema.Struct({
  id: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String)
})),
  content_categories: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  super_category_id: Schema.optional(Schema.Number)
}))),
  domain: Schema.optional(Schema.String),
  inherited_content_categories: Schema.optional(Schema.String),
  inherited_from: Schema.optional(Schema.String),
  inherited_risk_types: Schema.optional(Schema.String),
  popularity_rank: Schema.optional(Schema.Number),
  risk_score: Schema.optional(Schema.Number),
  risk_types: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetMultipleDomainDetailsResponse" }) as unknown as Schema.Schema<GetMultipleDomainDetailsResponse>;

export const getMultipleDomainDetails: (
  input: GetMultipleDomainDetailsRequest
) => Effect.Effect<
  GetMultipleDomainDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetMultipleDomainDetailsRequest,
  output: GetMultipleDomainDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetIndicatorFeedsRequest {
  account_id: string;
}

export const GetIndicatorFeedsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/indicator-feeds" }),
).annotations({ identifier: "GetIndicatorFeedsRequest" }) as unknown as Schema.Schema<GetIndicatorFeedsRequest>;

export interface GetIndicatorFeedsResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetIndicatorFeedsResponse = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetIndicatorFeedsResponse" }) as unknown as Schema.Schema<GetIndicatorFeedsResponse>;

export const getIndicatorFeeds: (
  input: GetIndicatorFeedsRequest
) => Effect.Effect<
  GetIndicatorFeedsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetIndicatorFeedsRequest,
  output: GetIndicatorFeedsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateIndicatorFeedsRequest {
  account_id: string;
  body: unknown;
}

export const CreateIndicatorFeedsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/intel/indicator-feeds" }),
).annotations({ identifier: "CreateIndicatorFeedsRequest" }) as unknown as Schema.Schema<CreateIndicatorFeedsRequest>;

export interface CreateIndicatorFeedsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateIndicatorFeedsResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateIndicatorFeedsResponse" }) as unknown as Schema.Schema<CreateIndicatorFeedsResponse>;

export const createIndicatorFeeds: (
  input: CreateIndicatorFeedsRequest
) => Effect.Effect<
  CreateIndicatorFeedsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateIndicatorFeedsRequest,
  output: CreateIndicatorFeedsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CustomIndicatorFeedsAddPermissionRequest {
  account_id: string;
  body: unknown;
}

export const CustomIndicatorFeedsAddPermissionRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/intel/indicator-feeds/permissions/add" }),
).annotations({ identifier: "CustomIndicatorFeedsAddPermissionRequest" }) as unknown as Schema.Schema<CustomIndicatorFeedsAddPermissionRequest>;

export interface CustomIndicatorFeedsAddPermissionResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CustomIndicatorFeedsAddPermissionResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CustomIndicatorFeedsAddPermissionResponse" }) as unknown as Schema.Schema<CustomIndicatorFeedsAddPermissionResponse>;

export const customIndicatorFeedsAddPermission: (
  input: CustomIndicatorFeedsAddPermissionRequest
) => Effect.Effect<
  CustomIndicatorFeedsAddPermissionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CustomIndicatorFeedsAddPermissionRequest,
  output: CustomIndicatorFeedsAddPermissionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CustomIndicatorFeedsRemovePermissionRequest {
  account_id: string;
  body: unknown;
}

export const CustomIndicatorFeedsRemovePermissionRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/intel/indicator-feeds/permissions/remove" }),
).annotations({ identifier: "CustomIndicatorFeedsRemovePermissionRequest" }) as unknown as Schema.Schema<CustomIndicatorFeedsRemovePermissionRequest>;

export interface CustomIndicatorFeedsRemovePermissionResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CustomIndicatorFeedsRemovePermissionResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CustomIndicatorFeedsRemovePermissionResponse" }) as unknown as Schema.Schema<CustomIndicatorFeedsRemovePermissionResponse>;

export const customIndicatorFeedsRemovePermission: (
  input: CustomIndicatorFeedsRemovePermissionRequest
) => Effect.Effect<
  CustomIndicatorFeedsRemovePermissionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CustomIndicatorFeedsRemovePermissionRequest,
  output: CustomIndicatorFeedsRemovePermissionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CustomIndicatorFeedsViewPermissionsRequest {
  account_id: string;
}

export const CustomIndicatorFeedsViewPermissionsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/indicator-feeds/permissions/view" }),
).annotations({ identifier: "CustomIndicatorFeedsViewPermissionsRequest" }) as unknown as Schema.Schema<CustomIndicatorFeedsViewPermissionsRequest>;

export interface CustomIndicatorFeedsViewPermissionsResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CustomIndicatorFeedsViewPermissionsResponse = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CustomIndicatorFeedsViewPermissionsResponse" }) as unknown as Schema.Schema<CustomIndicatorFeedsViewPermissionsResponse>;

export const customIndicatorFeedsViewPermissions: (
  input: CustomIndicatorFeedsViewPermissionsRequest
) => Effect.Effect<
  CustomIndicatorFeedsViewPermissionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CustomIndicatorFeedsViewPermissionsRequest,
  output: CustomIndicatorFeedsViewPermissionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetIndicatorFeedMetadataRequest {
  account_id: string;
  feed_id: number;
}

export const GetIndicatorFeedMetadataRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  feed_id: Schema.Number.pipe(T.HttpPath("feed_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/indicator-feeds/{feed_id}" }),
).annotations({ identifier: "GetIndicatorFeedMetadataRequest" }) as unknown as Schema.Schema<GetIndicatorFeedMetadataRequest>;

export interface GetIndicatorFeedMetadataResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetIndicatorFeedMetadataResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetIndicatorFeedMetadataResponse" }) as unknown as Schema.Schema<GetIndicatorFeedMetadataResponse>;

export const getIndicatorFeedMetadata: (
  input: GetIndicatorFeedMetadataRequest
) => Effect.Effect<
  GetIndicatorFeedMetadataResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetIndicatorFeedMetadataRequest,
  output: GetIndicatorFeedMetadataResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateIndicatorFeedMetadataRequest {
  account_id: string;
  feed_id: number;
  body: unknown;
}

export const UpdateIndicatorFeedMetadataRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  feed_id: Schema.Number.pipe(T.HttpPath("feed_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/intel/indicator-feeds/{feed_id}" }),
).annotations({ identifier: "UpdateIndicatorFeedMetadataRequest" }) as unknown as Schema.Schema<UpdateIndicatorFeedMetadataRequest>;

export interface UpdateIndicatorFeedMetadataResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateIndicatorFeedMetadataResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateIndicatorFeedMetadataResponse" }) as unknown as Schema.Schema<UpdateIndicatorFeedMetadataResponse>;

export const updateIndicatorFeedMetadata: (
  input: UpdateIndicatorFeedMetadataRequest
) => Effect.Effect<
  UpdateIndicatorFeedMetadataResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateIndicatorFeedMetadataRequest,
  output: UpdateIndicatorFeedMetadataResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetIndicatorFeedDataRequest {
  account_id: string;
  feed_id: number;
}

export const GetIndicatorFeedDataRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  feed_id: Schema.Number.pipe(T.HttpPath("feed_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/indicator-feeds/{feed_id}/data" }),
).annotations({ identifier: "GetIndicatorFeedDataRequest" }) as unknown as Schema.Schema<GetIndicatorFeedDataRequest>;

export interface GetIndicatorFeedDataResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetIndicatorFeedDataResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetIndicatorFeedDataResponse" }) as unknown as Schema.Schema<GetIndicatorFeedDataResponse>;

export const getIndicatorFeedData: (
  input: GetIndicatorFeedDataRequest
) => Effect.Effect<
  GetIndicatorFeedDataResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetIndicatorFeedDataRequest,
  output: GetIndicatorFeedDataResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CustomIndicatorFeedsDownloadIndicatorFeedDataRequest {
  account_id: string;
  feed_id: number;
}

export const CustomIndicatorFeedsDownloadIndicatorFeedDataRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  feed_id: Schema.Number.pipe(T.HttpPath("feed_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/indicator-feeds/{feed_id}/download" }),
).annotations({ identifier: "CustomIndicatorFeedsDownloadIndicatorFeedDataRequest" }) as unknown as Schema.Schema<CustomIndicatorFeedsDownloadIndicatorFeedDataRequest>;

export interface CustomIndicatorFeedsDownloadIndicatorFeedDataResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CustomIndicatorFeedsDownloadIndicatorFeedDataResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CustomIndicatorFeedsDownloadIndicatorFeedDataResponse" }) as unknown as Schema.Schema<CustomIndicatorFeedsDownloadIndicatorFeedDataResponse>;

export const customIndicatorFeedsDownloadIndicatorFeedData: (
  input: CustomIndicatorFeedsDownloadIndicatorFeedDataRequest
) => Effect.Effect<
  CustomIndicatorFeedsDownloadIndicatorFeedDataResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CustomIndicatorFeedsDownloadIndicatorFeedDataRequest,
  output: CustomIndicatorFeedsDownloadIndicatorFeedDataResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateIndicatorFeedDataRequest {
  account_id: string;
  feed_id: number;
  body: FormData;
}

export const UpdateIndicatorFeedDataRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  feed_id: Schema.Number.pipe(T.HttpPath("feed_id")),
  body: Schema.instanceOf(FormData).pipe(T.HttpFormData())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/intel/indicator-feeds/{feed_id}/snapshot" }),
).annotations({ identifier: "UpdateIndicatorFeedDataRequest" }) as unknown as Schema.Schema<UpdateIndicatorFeedDataRequest>;

export interface UpdateIndicatorFeedDataResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateIndicatorFeedDataResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateIndicatorFeedDataResponse" }) as unknown as Schema.Schema<UpdateIndicatorFeedDataResponse>;

export const updateIndicatorFeedData: (
  input: UpdateIndicatorFeedDataRequest
) => Effect.Effect<
  UpdateIndicatorFeedDataResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateIndicatorFeedDataRequest,
  output: UpdateIndicatorFeedDataResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetIpOverviewRequest {
  account_id: string;
  ipv4?: string;
  ipv6?: string;
}

export const GetIpOverviewRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  ipv4: Schema.optional(Schema.String).pipe(T.HttpQuery("ipv4")),
  ipv6: Schema.optional(Schema.String).pipe(T.HttpQuery("ipv6"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/ip" }),
).annotations({ identifier: "GetIpOverviewRequest" }) as unknown as Schema.Schema<GetIpOverviewRequest>;

export interface GetIpOverviewResponse {
  result: { belongs_to_ref?: { country?: string; description?: string; id?: string; type?: "hosting_provider" | "isp" | "organization"; value?: string }; ip?: string; risk_types?: { id?: number; name?: string; super_category_id?: number }[] }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetIpOverviewResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  belongs_to_ref: Schema.optional(Schema.Struct({
  country: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("hosting_provider", "isp", "organization")),
  value: Schema.optional(Schema.String)
})),
  ip: Schema.optional(Schema.String),
  risk_types: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  super_category_id: Schema.optional(Schema.Number)
})))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetIpOverviewResponse" }) as unknown as Schema.Schema<GetIpOverviewResponse>;

export const getIpOverview: (
  input: GetIpOverviewRequest
) => Effect.Effect<
  GetIpOverviewResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetIpOverviewRequest,
  output: GetIpOverviewResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetIpListsRequest {
  account_id: string;
}

export const GetIpListsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/ip-list" }),
).annotations({ identifier: "GetIpListsRequest" }) as unknown as Schema.Schema<GetIpListsRequest>;

export interface GetIpListsResponse {
  result: { description?: string; id?: number; name?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetIpListsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  id: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetIpListsResponse" }) as unknown as Schema.Schema<GetIpListsResponse>;

export const getIpLists: (
  input: GetIpListsRequest
) => Effect.Effect<
  GetIpListsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetIpListsRequest,
  output: GetIpListsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateMiscategorizationRequest {
  account_id: string;
  body: { content_adds?: number[]; content_removes?: number[]; indicator_type?: "domain" | "ipv4" | "ipv6" | "url"; ip?: string; security_adds?: number[]; security_removes?: number[]; url?: string };
}

export const CreateMiscategorizationRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  content_adds: Schema.optional(Schema.Array(Schema.Number)),
  content_removes: Schema.optional(Schema.Array(Schema.Number)),
  indicator_type: Schema.optional(Schema.Literal("domain", "ipv4", "ipv6", "url")),
  ip: Schema.optional(Schema.String),
  security_adds: Schema.optional(Schema.Array(Schema.Number)),
  security_removes: Schema.optional(Schema.Array(Schema.Number)),
  url: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/intel/miscategorization" }),
).annotations({ identifier: "CreateMiscategorizationRequest" }) as unknown as Schema.Schema<CreateMiscategorizationRequest>;

export interface CreateMiscategorizationResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateMiscategorizationResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateMiscategorizationResponse" }) as unknown as Schema.Schema<CreateMiscategorizationResponse>;

export const createMiscategorization: (
  input: CreateMiscategorizationRequest
) => Effect.Effect<
  CreateMiscategorizationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateMiscategorizationRequest,
  output: CreateMiscategorizationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSinkholesRequest {
  account_id: string;
}

export const GetSinkholesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/sinkholes" }),
).annotations({ identifier: "GetSinkholesRequest" }) as unknown as Schema.Schema<GetSinkholesRequest>;

export interface GetSinkholesResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSinkholesResponse = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSinkholesResponse" }) as unknown as Schema.Schema<GetSinkholesResponse>;

export const getSinkholes: (
  input: GetSinkholesRequest
) => Effect.Effect<
  GetSinkholesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSinkholesRequest,
  output: GetSinkholesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetWhoisRecordRequest {
  account_id: string;
  domain?: string;
}

export const GetWhoisRecordRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  domain: Schema.optional(Schema.String).pipe(T.HttpQuery("domain"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/intel/whois" }),
).annotations({ identifier: "GetWhoisRecordRequest" }) as unknown as Schema.Schema<GetWhoisRecordRequest>;

export interface GetWhoisRecordResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetWhoisRecordResponse = Schema.Struct({
  result: Schema.Struct({
  administrative_city: Schema.optional(Schema.String),
  administrative_country: Schema.optional(Schema.String),
  administrative_email: Schema.optional(Schema.String),
  administrative_fax: Schema.optional(Schema.String),
  administrative_fax_ext: Schema.optional(Schema.String),
  administrative_id: Schema.optional(Schema.String),
  administrative_name: Schema.optional(Schema.String),
  administrative_org: Schema.optional(Schema.String),
  administrative_phone: Schema.optional(Schema.String),
  administrative_phone_ext: Schema.optional(Schema.String),
  administrative_postal_code: Schema.optional(Schema.String),
  administrative_province: Schema.optional(Schema.String),
  administrative_referral_url: Schema.optional(Schema.String),
  administrative_street: Schema.optional(Schema.String),
  billing_city: Schema.optional(Schema.String),
  billing_country: Schema.optional(Schema.String),
  billing_email: Schema.optional(Schema.String),
  billing_fax: Schema.optional(Schema.String),
  billing_fax_ext: Schema.optional(Schema.String),
  billing_id: Schema.optional(Schema.String),
  billing_name: Schema.optional(Schema.String),
  billing_org: Schema.optional(Schema.String),
  billing_phone: Schema.optional(Schema.String),
  billing_phone_ext: Schema.optional(Schema.String),
  billing_postal_code: Schema.optional(Schema.String),
  billing_province: Schema.optional(Schema.String),
  billing_referral_url: Schema.optional(Schema.String),
  billing_street: Schema.optional(Schema.String),
  created_date: Schema.optional(Schema.Date),
  created_date_raw: Schema.optional(Schema.String),
  dnssec: Schema.Boolean,
  domain: Schema.String,
  expiration_date: Schema.optional(Schema.Date),
  expiration_date_raw: Schema.optional(Schema.String),
  extension: Schema.String,
  found: Schema.Boolean,
  id: Schema.optional(Schema.String),
  nameservers: Schema.Array(Schema.String),
  punycode: Schema.String,
  registrant: Schema.String,
  registrant_city: Schema.optional(Schema.String),
  registrant_country: Schema.optional(Schema.String),
  registrant_email: Schema.optional(Schema.String),
  registrant_fax: Schema.optional(Schema.String),
  registrant_fax_ext: Schema.optional(Schema.String),
  registrant_id: Schema.optional(Schema.String),
  registrant_name: Schema.optional(Schema.String),
  registrant_org: Schema.optional(Schema.String),
  registrant_phone: Schema.optional(Schema.String),
  registrant_phone_ext: Schema.optional(Schema.String),
  registrant_postal_code: Schema.optional(Schema.String),
  registrant_province: Schema.optional(Schema.String),
  registrant_referral_url: Schema.optional(Schema.String),
  registrant_street: Schema.optional(Schema.String),
  registrar: Schema.String,
  registrar_city: Schema.optional(Schema.String),
  registrar_country: Schema.optional(Schema.String),
  registrar_email: Schema.optional(Schema.String),
  registrar_fax: Schema.optional(Schema.String),
  registrar_fax_ext: Schema.optional(Schema.String),
  registrar_id: Schema.optional(Schema.String),
  registrar_name: Schema.optional(Schema.String),
  registrar_org: Schema.optional(Schema.String),
  registrar_phone: Schema.optional(Schema.String),
  registrar_phone_ext: Schema.optional(Schema.String),
  registrar_postal_code: Schema.optional(Schema.String),
  registrar_province: Schema.optional(Schema.String),
  registrar_referral_url: Schema.optional(Schema.String),
  registrar_street: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Array(Schema.String)),
  technical_city: Schema.optional(Schema.String),
  technical_country: Schema.optional(Schema.String),
  technical_email: Schema.optional(Schema.String),
  technical_fax: Schema.optional(Schema.String),
  technical_fax_ext: Schema.optional(Schema.String),
  technical_id: Schema.optional(Schema.String),
  technical_name: Schema.optional(Schema.String),
  technical_org: Schema.optional(Schema.String),
  technical_phone: Schema.optional(Schema.String),
  technical_phone_ext: Schema.optional(Schema.String),
  technical_postal_code: Schema.optional(Schema.String),
  technical_province: Schema.optional(Schema.String),
  technical_referral_url: Schema.optional(Schema.String),
  technical_street: Schema.optional(Schema.String),
  updated_date: Schema.optional(Schema.Date),
  updated_date_raw: Schema.optional(Schema.String),
  whois_server: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetWhoisRecordResponse" }) as unknown as Schema.Schema<GetWhoisRecordResponse>;

export const getWhoisRecord: (
  input: GetWhoisRecordRequest
) => Effect.Effect<
  GetWhoisRecordResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetWhoisRecordRequest,
  output: GetWhoisRecordResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListMonitorGroupsRequest {
  account_id: string;
}

export const ListMonitorGroupsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/load_balancers/monitor_groups" }),
).annotations({ identifier: "ListMonitorGroupsRequest" }) as unknown as Schema.Schema<ListMonitorGroupsRequest>;

export interface ListMonitorGroupsResponse {
  result: { created_at?: string; description: string; id: string; members: { created_at?: string; enabled: boolean; monitor_id: string; monitoring_only: boolean; must_be_healthy: boolean; updated_at?: string }[]; updated_at?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListMonitorGroupsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.String,
  id: Schema.String,
  members: Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  enabled: Schema.Boolean,
  monitor_id: Schema.String,
  monitoring_only: Schema.Boolean,
  must_be_healthy: Schema.Boolean,
  updated_at: Schema.optional(Schema.Date)
})),
  updated_at: Schema.optional(Schema.Date)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListMonitorGroupsResponse" }) as unknown as Schema.Schema<ListMonitorGroupsResponse>;

export const listMonitorGroups: (
  input: ListMonitorGroupsRequest
) => Effect.Effect<
  ListMonitorGroupsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListMonitorGroupsRequest,
  output: ListMonitorGroupsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateMonitorGroupRequest {
  account_id: string;
  body: { created_at?: string; description: string; id: string; members: { created_at?: string; enabled: boolean; monitor_id: string; monitoring_only: boolean; must_be_healthy: boolean; updated_at?: string }[]; updated_at?: string };
}

export const CreateMonitorGroupRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.String,
  id: Schema.String,
  members: Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  enabled: Schema.Boolean,
  monitor_id: Schema.String,
  monitoring_only: Schema.Boolean,
  must_be_healthy: Schema.Boolean,
  updated_at: Schema.optional(Schema.Date)
})),
  updated_at: Schema.optional(Schema.Date)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/load_balancers/monitor_groups" }),
).annotations({ identifier: "CreateMonitorGroupRequest" }) as unknown as Schema.Schema<CreateMonitorGroupRequest>;

export interface CreateMonitorGroupResponse {
  result: { created_at?: string; description: string; id: string; members: { created_at?: string; enabled: boolean; monitor_id: string; monitoring_only: boolean; must_be_healthy: boolean; updated_at?: string }[]; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateMonitorGroupResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.String,
  id: Schema.String,
  members: Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  enabled: Schema.Boolean,
  monitor_id: Schema.String,
  monitoring_only: Schema.Boolean,
  must_be_healthy: Schema.Boolean,
  updated_at: Schema.optional(Schema.Date)
})),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateMonitorGroupResponse" }) as unknown as Schema.Schema<CreateMonitorGroupResponse>;

export const createMonitorGroup: (
  input: CreateMonitorGroupRequest
) => Effect.Effect<
  CreateMonitorGroupResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateMonitorGroupRequest,
  output: CreateMonitorGroupResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountLoadBalancerMonitorGroupsMonitorGroupDetailsRequest {
  monitor_group_id: string;
  account_id: string;
}

export const AccountLoadBalancerMonitorGroupsMonitorGroupDetailsRequest = Schema.Struct({
  monitor_group_id: Schema.String.pipe(T.HttpPath("monitor_group_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/load_balancers/monitor_groups/{monitor_group_id}" }),
).annotations({ identifier: "AccountLoadBalancerMonitorGroupsMonitorGroupDetailsRequest" }) as unknown as Schema.Schema<AccountLoadBalancerMonitorGroupsMonitorGroupDetailsRequest>;

export interface AccountLoadBalancerMonitorGroupsMonitorGroupDetailsResponse {
  result: { created_at?: string; description: string; id: string; members: { created_at?: string; enabled: boolean; monitor_id: string; monitoring_only: boolean; must_be_healthy: boolean; updated_at?: string }[]; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountLoadBalancerMonitorGroupsMonitorGroupDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.String,
  id: Schema.String,
  members: Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  enabled: Schema.Boolean,
  monitor_id: Schema.String,
  monitoring_only: Schema.Boolean,
  must_be_healthy: Schema.Boolean,
  updated_at: Schema.optional(Schema.Date)
})),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountLoadBalancerMonitorGroupsMonitorGroupDetailsResponse" }) as unknown as Schema.Schema<AccountLoadBalancerMonitorGroupsMonitorGroupDetailsResponse>;

export const accountLoadBalancerMonitorGroupsMonitorGroupDetails: (
  input: AccountLoadBalancerMonitorGroupsMonitorGroupDetailsRequest
) => Effect.Effect<
  AccountLoadBalancerMonitorGroupsMonitorGroupDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountLoadBalancerMonitorGroupsMonitorGroupDetailsRequest,
  output: AccountLoadBalancerMonitorGroupsMonitorGroupDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateMonitorGroupRequest {
  monitor_group_id: string;
  account_id: string;
  body: { created_at?: string; description: string; id: string; members: { created_at?: string; enabled: boolean; monitor_id: string; monitoring_only: boolean; must_be_healthy: boolean; updated_at?: string }[]; updated_at?: string };
}

export const UpdateMonitorGroupRequest = Schema.Struct({
  monitor_group_id: Schema.String.pipe(T.HttpPath("monitor_group_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.String,
  id: Schema.String,
  members: Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  enabled: Schema.Boolean,
  monitor_id: Schema.String,
  monitoring_only: Schema.Boolean,
  must_be_healthy: Schema.Boolean,
  updated_at: Schema.optional(Schema.Date)
})),
  updated_at: Schema.optional(Schema.Date)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/load_balancers/monitor_groups/{monitor_group_id}" }),
).annotations({ identifier: "UpdateMonitorGroupRequest" }) as unknown as Schema.Schema<UpdateMonitorGroupRequest>;

export interface UpdateMonitorGroupResponse {
  result: { created_at?: string; description: string; id: string; members: { created_at?: string; enabled: boolean; monitor_id: string; monitoring_only: boolean; must_be_healthy: boolean; updated_at?: string }[]; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateMonitorGroupResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.String,
  id: Schema.String,
  members: Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  enabled: Schema.Boolean,
  monitor_id: Schema.String,
  monitoring_only: Schema.Boolean,
  must_be_healthy: Schema.Boolean,
  updated_at: Schema.optional(Schema.Date)
})),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateMonitorGroupResponse" }) as unknown as Schema.Schema<UpdateMonitorGroupResponse>;

export const updateMonitorGroup: (
  input: UpdateMonitorGroupRequest
) => Effect.Effect<
  UpdateMonitorGroupResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateMonitorGroupRequest,
  output: UpdateMonitorGroupResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteMonitorGroupRequest {
  monitor_group_id: string;
  account_id: string;
}

export const DeleteMonitorGroupRequest = Schema.Struct({
  monitor_group_id: Schema.String.pipe(T.HttpPath("monitor_group_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/load_balancers/monitor_groups/{monitor_group_id}" }),
).annotations({ identifier: "DeleteMonitorGroupRequest" }) as unknown as Schema.Schema<DeleteMonitorGroupRequest>;

export interface DeleteMonitorGroupResponse {
  result: { created_at?: string; description: string; id: string; members: { created_at?: string; enabled: boolean; monitor_id: string; monitoring_only: boolean; must_be_healthy: boolean; updated_at?: string }[]; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteMonitorGroupResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.String,
  id: Schema.String,
  members: Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  enabled: Schema.Boolean,
  monitor_id: Schema.String,
  monitoring_only: Schema.Boolean,
  must_be_healthy: Schema.Boolean,
  updated_at: Schema.optional(Schema.Date)
})),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteMonitorGroupResponse" }) as unknown as Schema.Schema<DeleteMonitorGroupResponse>;

export const deleteMonitorGroup: (
  input: DeleteMonitorGroupRequest
) => Effect.Effect<
  DeleteMonitorGroupResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteMonitorGroupRequest,
  output: DeleteMonitorGroupResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchMonitorGroupRequest {
  monitor_group_id: string;
  account_id: string;
  body: { created_at?: string; description: string; id: string; members: { created_at?: string; enabled: boolean; monitor_id: string; monitoring_only: boolean; must_be_healthy: boolean; updated_at?: string }[]; updated_at?: string };
}

export const PatchMonitorGroupRequest = Schema.Struct({
  monitor_group_id: Schema.String.pipe(T.HttpPath("monitor_group_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.String,
  id: Schema.String,
  members: Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  enabled: Schema.Boolean,
  monitor_id: Schema.String,
  monitoring_only: Schema.Boolean,
  must_be_healthy: Schema.Boolean,
  updated_at: Schema.optional(Schema.Date)
})),
  updated_at: Schema.optional(Schema.Date)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/load_balancers/monitor_groups/{monitor_group_id}" }),
).annotations({ identifier: "PatchMonitorGroupRequest" }) as unknown as Schema.Schema<PatchMonitorGroupRequest>;

export interface PatchMonitorGroupResponse {
  result: { created_at?: string; description: string; id: string; members: { created_at?: string; enabled: boolean; monitor_id: string; monitoring_only: boolean; must_be_healthy: boolean; updated_at?: string }[]; updated_at?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchMonitorGroupResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  description: Schema.String,
  id: Schema.String,
  members: Schema.Array(Schema.Struct({
  created_at: Schema.optional(Schema.Date),
  enabled: Schema.Boolean,
  monitor_id: Schema.String,
  monitoring_only: Schema.Boolean,
  must_be_healthy: Schema.Boolean,
  updated_at: Schema.optional(Schema.Date)
})),
  updated_at: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchMonitorGroupResponse" }) as unknown as Schema.Schema<PatchMonitorGroupResponse>;

export const patchMonitorGroup: (
  input: PatchMonitorGroupRequest
) => Effect.Effect<
  PatchMonitorGroupResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchMonitorGroupRequest,
  output: PatchMonitorGroupResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListMonitorGroupReferencesRequest {
  monitor_group_id: string;
  account_id: string;
}

export const ListMonitorGroupReferencesRequest = Schema.Struct({
  monitor_group_id: Schema.String.pipe(T.HttpPath("monitor_group_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/load_balancers/monitor_groups/{monitor_group_id}/references" }),
).annotations({ identifier: "ListMonitorGroupReferencesRequest" }) as unknown as Schema.Schema<ListMonitorGroupReferencesRequest>;

export interface ListMonitorGroupReferencesResponse {
  result: { reference_type?: "*" | "referral" | "referrer"; resource_id?: string; resource_name?: string; resource_type?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListMonitorGroupReferencesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  reference_type: Schema.optional(Schema.Literal("*", "referral", "referrer")),
  resource_id: Schema.optional(Schema.String),
  resource_name: Schema.optional(Schema.String),
  resource_type: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListMonitorGroupReferencesResponse" }) as unknown as Schema.Schema<ListMonitorGroupReferencesResponse>;

export const listMonitorGroupReferences: (
  input: ListMonitorGroupReferencesRequest
) => Effect.Effect<
  ListMonitorGroupReferencesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListMonitorGroupReferencesRequest,
  output: ListMonitorGroupReferencesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListMonitorsRequest {
  account_id: string;
}

export const ListMonitorsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/load_balancers/monitors" }),
).annotations({ identifier: "ListMonitorsRequest" }) as unknown as Schema.Schema<ListMonitorsRequest>;

export interface ListMonitorsResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListMonitorsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListMonitorsResponse" }) as unknown as Schema.Schema<ListMonitorsResponse>;

export const listMonitors: (
  input: ListMonitorsRequest
) => Effect.Effect<
  ListMonitorsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListMonitorsRequest,
  output: ListMonitorsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateMonitorRequest {
  account_id: string;
  body: unknown;
}

export const CreateMonitorRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  consecutive_down: Schema.optional(Schema.Number),
  consecutive_up: Schema.optional(Schema.Number),
  description: Schema.optional(Schema.String),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.String),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  interval: Schema.optional(Schema.Number),
  method: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  probe_zone: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("http", "https", "tcp", "udp_icmp", "icmp_ping", "smtp"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/load_balancers/monitors" }),
).annotations({ identifier: "CreateMonitorRequest" }) as unknown as Schema.Schema<CreateMonitorRequest>;

export interface CreateMonitorResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateMonitorResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateMonitorResponse" }) as unknown as Schema.Schema<CreateMonitorResponse>;

export const createMonitor: (
  input: CreateMonitorRequest
) => Effect.Effect<
  CreateMonitorResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateMonitorRequest,
  output: CreateMonitorResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountLoadBalancerMonitorsMonitorDetailsRequest {
  monitor_id: string;
  account_id: string;
}

export const AccountLoadBalancerMonitorsMonitorDetailsRequest = Schema.Struct({
  monitor_id: Schema.String.pipe(T.HttpPath("monitor_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/load_balancers/monitors/{monitor_id}" }),
).annotations({ identifier: "AccountLoadBalancerMonitorsMonitorDetailsRequest" }) as unknown as Schema.Schema<AccountLoadBalancerMonitorsMonitorDetailsRequest>;

export interface AccountLoadBalancerMonitorsMonitorDetailsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountLoadBalancerMonitorsMonitorDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountLoadBalancerMonitorsMonitorDetailsResponse" }) as unknown as Schema.Schema<AccountLoadBalancerMonitorsMonitorDetailsResponse>;

export const accountLoadBalancerMonitorsMonitorDetails: (
  input: AccountLoadBalancerMonitorsMonitorDetailsRequest
) => Effect.Effect<
  AccountLoadBalancerMonitorsMonitorDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountLoadBalancerMonitorsMonitorDetailsRequest,
  output: AccountLoadBalancerMonitorsMonitorDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateMonitorRequest {
  monitor_id: string;
  account_id: string;
  body: unknown;
}

export const UpdateMonitorRequest = Schema.Struct({
  monitor_id: Schema.String.pipe(T.HttpPath("monitor_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  consecutive_down: Schema.optional(Schema.Number),
  consecutive_up: Schema.optional(Schema.Number),
  description: Schema.optional(Schema.String),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.String),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  interval: Schema.optional(Schema.Number),
  method: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  probe_zone: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("http", "https", "tcp", "udp_icmp", "icmp_ping", "smtp"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/load_balancers/monitors/{monitor_id}" }),
).annotations({ identifier: "UpdateMonitorRequest" }) as unknown as Schema.Schema<UpdateMonitorRequest>;

export interface UpdateMonitorResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateMonitorResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateMonitorResponse" }) as unknown as Schema.Schema<UpdateMonitorResponse>;

export const updateMonitor: (
  input: UpdateMonitorRequest
) => Effect.Effect<
  UpdateMonitorResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateMonitorRequest,
  output: UpdateMonitorResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteMonitorRequest {
  monitor_id: string;
  account_id: string;
}

export const DeleteMonitorRequest = Schema.Struct({
  monitor_id: Schema.String.pipe(T.HttpPath("monitor_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/load_balancers/monitors/{monitor_id}" }),
).annotations({ identifier: "DeleteMonitorRequest" }) as unknown as Schema.Schema<DeleteMonitorRequest>;

export interface DeleteMonitorResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteMonitorResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteMonitorResponse" }) as unknown as Schema.Schema<DeleteMonitorResponse>;

export const deleteMonitor: (
  input: DeleteMonitorRequest
) => Effect.Effect<
  DeleteMonitorResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteMonitorRequest,
  output: DeleteMonitorResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchMonitorRequest {
  monitor_id: string;
  account_id: string;
  body: unknown;
}

export const PatchMonitorRequest = Schema.Struct({
  monitor_id: Schema.String.pipe(T.HttpPath("monitor_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  consecutive_down: Schema.optional(Schema.Number),
  consecutive_up: Schema.optional(Schema.Number),
  description: Schema.optional(Schema.String),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.String),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  interval: Schema.optional(Schema.Number),
  method: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  probe_zone: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("http", "https", "tcp", "udp_icmp", "icmp_ping", "smtp"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/load_balancers/monitors/{monitor_id}" }),
).annotations({ identifier: "PatchMonitorRequest" }) as unknown as Schema.Schema<PatchMonitorRequest>;

export interface PatchMonitorResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchMonitorResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchMonitorResponse" }) as unknown as Schema.Schema<PatchMonitorResponse>;

export const patchMonitor: (
  input: PatchMonitorRequest
) => Effect.Effect<
  PatchMonitorResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchMonitorRequest,
  output: PatchMonitorResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountLoadBalancerMonitorsPreviewMonitorRequest {
  monitor_id: string;
  account_id: string;
  body: unknown;
}

export const AccountLoadBalancerMonitorsPreviewMonitorRequest = Schema.Struct({
  monitor_id: Schema.String.pipe(T.HttpPath("monitor_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  consecutive_down: Schema.optional(Schema.Number),
  consecutive_up: Schema.optional(Schema.Number),
  description: Schema.optional(Schema.String),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.String),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  interval: Schema.optional(Schema.Number),
  method: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  probe_zone: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("http", "https", "tcp", "udp_icmp", "icmp_ping", "smtp"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/load_balancers/monitors/{monitor_id}/preview" }),
).annotations({ identifier: "AccountLoadBalancerMonitorsPreviewMonitorRequest" }) as unknown as Schema.Schema<AccountLoadBalancerMonitorsPreviewMonitorRequest>;

export interface AccountLoadBalancerMonitorsPreviewMonitorResponse {
  result: { pools?: Record<string, unknown>; preview_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountLoadBalancerMonitorsPreviewMonitorResponse = Schema.Struct({
  result: Schema.Struct({
  pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  preview_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountLoadBalancerMonitorsPreviewMonitorResponse" }) as unknown as Schema.Schema<AccountLoadBalancerMonitorsPreviewMonitorResponse>;

export const accountLoadBalancerMonitorsPreviewMonitor: (
  input: AccountLoadBalancerMonitorsPreviewMonitorRequest
) => Effect.Effect<
  AccountLoadBalancerMonitorsPreviewMonitorResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountLoadBalancerMonitorsPreviewMonitorRequest,
  output: AccountLoadBalancerMonitorsPreviewMonitorResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListMonitorReferencesRequest {
  monitor_id: string;
  account_id: string;
}

export const ListMonitorReferencesRequest = Schema.Struct({
  monitor_id: Schema.String.pipe(T.HttpPath("monitor_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/load_balancers/monitors/{monitor_id}/references" }),
).annotations({ identifier: "ListMonitorReferencesRequest" }) as unknown as Schema.Schema<ListMonitorReferencesRequest>;

export interface ListMonitorReferencesResponse {
  result: { reference_type?: "*" | "referral" | "referrer"; resource_id?: string; resource_name?: string; resource_type?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListMonitorReferencesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  reference_type: Schema.optional(Schema.Literal("*", "referral", "referrer")),
  resource_id: Schema.optional(Schema.String),
  resource_name: Schema.optional(Schema.String),
  resource_type: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListMonitorReferencesResponse" }) as unknown as Schema.Schema<ListMonitorReferencesResponse>;

export const listMonitorReferences: (
  input: ListMonitorReferencesRequest
) => Effect.Effect<
  ListMonitorReferencesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListMonitorReferencesRequest,
  output: ListMonitorReferencesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListPoolsRequest {
  account_id: string;
  monitor?: string;
}

export const ListPoolsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  monitor: Schema.optional(Schema.String).pipe(T.HttpQuery("monitor"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/load_balancers/pools" }),
).annotations({ identifier: "ListPoolsRequest" }) as unknown as Schema.Schema<ListPoolsRequest>;

export interface ListPoolsResponse {
  result: { check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "SAS" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; created_on?: string; description?: string; disabled_at?: string; enabled?: boolean; id?: string; latitude?: number; load_shedding?: { default_percent?: number; default_policy?: "random" | "hash"; session_percent?: number; session_policy?: "hash" }; longitude?: number; minimum_origins?: number; modified_on?: string; monitor?: string; monitor_group?: string; name?: string; networks?: string[]; notification_email?: string; notification_filter?: { origin?: { disable?: boolean; healthy?: boolean }; pool?: { disable?: boolean; healthy?: boolean } }; origin_steering?: { policy?: "random" | "hash" | "least_outstanding_requests" | "least_connections" }; origins?: { address?: string; disabled_at?: string; enabled?: boolean; header?: { Host?: string[] }; name?: string; port?: number; virtual_network_id?: string; weight?: number }[] }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListPoolsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "SAS", "SEAS", "NEAS", "ALL_REGIONS"))),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  latitude: Schema.optional(Schema.Number),
  load_shedding: Schema.optional(Schema.Struct({
  default_percent: Schema.optional(Schema.Number),
  default_policy: Schema.optional(Schema.Literal("random", "hash")),
  session_percent: Schema.optional(Schema.Number),
  session_policy: Schema.optional(Schema.Literal("hash"))
})),
  longitude: Schema.optional(Schema.Number),
  minimum_origins: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  monitor: Schema.optional(Schema.String),
  monitor_group: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(Schema.Array(Schema.String)),
  notification_email: Schema.optional(Schema.String),
  notification_filter: Schema.optional(Schema.Struct({
  origin: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
})),
  pool: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
}))
})),
  origin_steering: Schema.optional(Schema.Struct({
  policy: Schema.optional(Schema.Literal("random", "hash", "least_outstanding_requests", "least_connections"))
})),
  origins: Schema.optional(Schema.Array(Schema.Struct({
  address: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Struct({
  Host: Schema.optional(Schema.Array(Schema.String))
})),
  name: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  virtual_network_id: Schema.optional(Schema.String),
  weight: Schema.optional(Schema.Number)
})))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListPoolsResponse" }) as unknown as Schema.Schema<ListPoolsResponse>;

export const listPools: (
  input: ListPoolsRequest
) => Effect.Effect<
  ListPoolsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListPoolsRequest,
  output: ListPoolsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatePoolRequest {
  account_id: string;
  body: { description?: string; enabled?: boolean; latitude?: number; load_shedding?: { default_percent?: number; default_policy?: "random" | "hash"; session_percent?: number; session_policy?: "hash" }; longitude?: number; minimum_origins?: number; monitor?: string; monitor_group?: string; name: string; notification_email?: string; notification_filter?: { origin?: { disable?: boolean; healthy?: boolean }; pool?: { disable?: boolean; healthy?: boolean } }; origin_steering?: { policy?: "random" | "hash" | "least_outstanding_requests" | "least_connections" }; origins: { address?: string; disabled_at?: string; enabled?: boolean; header?: { Host?: string[] }; name?: string; port?: number; virtual_network_id?: string; weight?: number }[] };
}

export const CreatePoolRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  latitude: Schema.optional(Schema.Number),
  load_shedding: Schema.optional(Schema.Struct({
  default_percent: Schema.optional(Schema.Number),
  default_policy: Schema.optional(Schema.Literal("random", "hash")),
  session_percent: Schema.optional(Schema.Number),
  session_policy: Schema.optional(Schema.Literal("hash"))
})),
  longitude: Schema.optional(Schema.Number),
  minimum_origins: Schema.optional(Schema.Number),
  monitor: Schema.optional(Schema.String),
  monitor_group: Schema.optional(Schema.String),
  name: Schema.String,
  notification_email: Schema.optional(Schema.String),
  notification_filter: Schema.optional(Schema.Struct({
  origin: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
})),
  pool: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
}))
})),
  origin_steering: Schema.optional(Schema.Struct({
  policy: Schema.optional(Schema.Literal("random", "hash", "least_outstanding_requests", "least_connections"))
})),
  origins: Schema.Array(Schema.Struct({
  address: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Struct({
  Host: Schema.optional(Schema.Array(Schema.String))
})),
  name: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  virtual_network_id: Schema.optional(Schema.String),
  weight: Schema.optional(Schema.Number)
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/load_balancers/pools" }),
).annotations({ identifier: "CreatePoolRequest" }) as unknown as Schema.Schema<CreatePoolRequest>;

export interface CreatePoolResponse {
  result: { check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "SAS" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; created_on?: string; description?: string; disabled_at?: string; enabled?: boolean; id?: string; latitude?: number; load_shedding?: { default_percent?: number; default_policy?: "random" | "hash"; session_percent?: number; session_policy?: "hash" }; longitude?: number; minimum_origins?: number; modified_on?: string; monitor?: string; monitor_group?: string; name?: string; networks?: string[]; notification_email?: string; notification_filter?: { origin?: { disable?: boolean; healthy?: boolean }; pool?: { disable?: boolean; healthy?: boolean } }; origin_steering?: { policy?: "random" | "hash" | "least_outstanding_requests" | "least_connections" }; origins?: { address?: string; disabled_at?: string; enabled?: boolean; header?: { Host?: string[] }; name?: string; port?: number; virtual_network_id?: string; weight?: number }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatePoolResponse = Schema.Struct({
  result: Schema.Struct({
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "SAS", "SEAS", "NEAS", "ALL_REGIONS"))),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  latitude: Schema.optional(Schema.Number),
  load_shedding: Schema.optional(Schema.Struct({
  default_percent: Schema.optional(Schema.Number),
  default_policy: Schema.optional(Schema.Literal("random", "hash")),
  session_percent: Schema.optional(Schema.Number),
  session_policy: Schema.optional(Schema.Literal("hash"))
})),
  longitude: Schema.optional(Schema.Number),
  minimum_origins: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  monitor: Schema.optional(Schema.String),
  monitor_group: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(Schema.Array(Schema.String)),
  notification_email: Schema.optional(Schema.String),
  notification_filter: Schema.optional(Schema.Struct({
  origin: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
})),
  pool: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
}))
})),
  origin_steering: Schema.optional(Schema.Struct({
  policy: Schema.optional(Schema.Literal("random", "hash", "least_outstanding_requests", "least_connections"))
})),
  origins: Schema.optional(Schema.Array(Schema.Struct({
  address: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Struct({
  Host: Schema.optional(Schema.Array(Schema.String))
})),
  name: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  virtual_network_id: Schema.optional(Schema.String),
  weight: Schema.optional(Schema.Number)
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatePoolResponse" }) as unknown as Schema.Schema<CreatePoolResponse>;

export const createPool: (
  input: CreatePoolRequest
) => Effect.Effect<
  CreatePoolResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatePoolRequest,
  output: CreatePoolResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchPoolsRequest {
  account_id: string;
  body: string;
}

export const PatchPoolsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.String.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/load_balancers/pools" }),
).annotations({ identifier: "PatchPoolsRequest" }) as unknown as Schema.Schema<PatchPoolsRequest>;

export interface PatchPoolsResponse {
  result: { check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "SAS" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; created_on?: string; description?: string; disabled_at?: string; enabled?: boolean; id?: string; latitude?: number; load_shedding?: { default_percent?: number; default_policy?: "random" | "hash"; session_percent?: number; session_policy?: "hash" }; longitude?: number; minimum_origins?: number; modified_on?: string; monitor?: string; monitor_group?: string; name?: string; networks?: string[]; notification_email?: string; notification_filter?: { origin?: { disable?: boolean; healthy?: boolean }; pool?: { disable?: boolean; healthy?: boolean } }; origin_steering?: { policy?: "random" | "hash" | "least_outstanding_requests" | "least_connections" }; origins?: { address?: string; disabled_at?: string; enabled?: boolean; header?: { Host?: string[] }; name?: string; port?: number; virtual_network_id?: string; weight?: number }[] }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchPoolsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "SAS", "SEAS", "NEAS", "ALL_REGIONS"))),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  latitude: Schema.optional(Schema.Number),
  load_shedding: Schema.optional(Schema.Struct({
  default_percent: Schema.optional(Schema.Number),
  default_policy: Schema.optional(Schema.Literal("random", "hash")),
  session_percent: Schema.optional(Schema.Number),
  session_policy: Schema.optional(Schema.Literal("hash"))
})),
  longitude: Schema.optional(Schema.Number),
  minimum_origins: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  monitor: Schema.optional(Schema.String),
  monitor_group: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(Schema.Array(Schema.String)),
  notification_email: Schema.optional(Schema.String),
  notification_filter: Schema.optional(Schema.Struct({
  origin: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
})),
  pool: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
}))
})),
  origin_steering: Schema.optional(Schema.Struct({
  policy: Schema.optional(Schema.Literal("random", "hash", "least_outstanding_requests", "least_connections"))
})),
  origins: Schema.optional(Schema.Array(Schema.Struct({
  address: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Struct({
  Host: Schema.optional(Schema.Array(Schema.String))
})),
  name: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  virtual_network_id: Schema.optional(Schema.String),
  weight: Schema.optional(Schema.Number)
})))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchPoolsResponse" }) as unknown as Schema.Schema<PatchPoolsResponse>;

export const patchPools: (
  input: PatchPoolsRequest
) => Effect.Effect<
  PatchPoolsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchPoolsRequest,
  output: PatchPoolsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountLoadBalancerPoolsPoolDetailsRequest {
  pool_id: string;
  account_id: string;
}

export const AccountLoadBalancerPoolsPoolDetailsRequest = Schema.Struct({
  pool_id: Schema.String.pipe(T.HttpPath("pool_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/load_balancers/pools/{pool_id}" }),
).annotations({ identifier: "AccountLoadBalancerPoolsPoolDetailsRequest" }) as unknown as Schema.Schema<AccountLoadBalancerPoolsPoolDetailsRequest>;

export interface AccountLoadBalancerPoolsPoolDetailsResponse {
  result: { check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "SAS" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; created_on?: string; description?: string; disabled_at?: string; enabled?: boolean; id?: string; latitude?: number; load_shedding?: { default_percent?: number; default_policy?: "random" | "hash"; session_percent?: number; session_policy?: "hash" }; longitude?: number; minimum_origins?: number; modified_on?: string; monitor?: string; monitor_group?: string; name?: string; networks?: string[]; notification_email?: string; notification_filter?: { origin?: { disable?: boolean; healthy?: boolean }; pool?: { disable?: boolean; healthy?: boolean } }; origin_steering?: { policy?: "random" | "hash" | "least_outstanding_requests" | "least_connections" }; origins?: { address?: string; disabled_at?: string; enabled?: boolean; header?: { Host?: string[] }; name?: string; port?: number; virtual_network_id?: string; weight?: number }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountLoadBalancerPoolsPoolDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "SAS", "SEAS", "NEAS", "ALL_REGIONS"))),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  latitude: Schema.optional(Schema.Number),
  load_shedding: Schema.optional(Schema.Struct({
  default_percent: Schema.optional(Schema.Number),
  default_policy: Schema.optional(Schema.Literal("random", "hash")),
  session_percent: Schema.optional(Schema.Number),
  session_policy: Schema.optional(Schema.Literal("hash"))
})),
  longitude: Schema.optional(Schema.Number),
  minimum_origins: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  monitor: Schema.optional(Schema.String),
  monitor_group: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(Schema.Array(Schema.String)),
  notification_email: Schema.optional(Schema.String),
  notification_filter: Schema.optional(Schema.Struct({
  origin: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
})),
  pool: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
}))
})),
  origin_steering: Schema.optional(Schema.Struct({
  policy: Schema.optional(Schema.Literal("random", "hash", "least_outstanding_requests", "least_connections"))
})),
  origins: Schema.optional(Schema.Array(Schema.Struct({
  address: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Struct({
  Host: Schema.optional(Schema.Array(Schema.String))
})),
  name: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  virtual_network_id: Schema.optional(Schema.String),
  weight: Schema.optional(Schema.Number)
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountLoadBalancerPoolsPoolDetailsResponse" }) as unknown as Schema.Schema<AccountLoadBalancerPoolsPoolDetailsResponse>;

export const accountLoadBalancerPoolsPoolDetails: (
  input: AccountLoadBalancerPoolsPoolDetailsRequest
) => Effect.Effect<
  AccountLoadBalancerPoolsPoolDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountLoadBalancerPoolsPoolDetailsRequest,
  output: AccountLoadBalancerPoolsPoolDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatePoolRequest {
  pool_id: string;
  account_id: string;
  body: { check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "SAS" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; description?: string; disabled_at?: string; enabled?: boolean; latitude?: number; load_shedding?: { default_percent?: number; default_policy?: "random" | "hash"; session_percent?: number; session_policy?: "hash" }; longitude?: number; minimum_origins?: number; monitor?: string; monitor_group?: string; name: string; notification_email?: string; notification_filter?: { origin?: { disable?: boolean; healthy?: boolean }; pool?: { disable?: boolean; healthy?: boolean } }; origin_steering?: { policy?: "random" | "hash" | "least_outstanding_requests" | "least_connections" }; origins: { address?: string; disabled_at?: string; enabled?: boolean; header?: { Host?: string[] }; name?: string; port?: number; virtual_network_id?: string; weight?: number }[] };
}

export const UpdatePoolRequest = Schema.Struct({
  pool_id: Schema.String.pipe(T.HttpPath("pool_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "SAS", "SEAS", "NEAS", "ALL_REGIONS"))),
  description: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  latitude: Schema.optional(Schema.Number),
  load_shedding: Schema.optional(Schema.Struct({
  default_percent: Schema.optional(Schema.Number),
  default_policy: Schema.optional(Schema.Literal("random", "hash")),
  session_percent: Schema.optional(Schema.Number),
  session_policy: Schema.optional(Schema.Literal("hash"))
})),
  longitude: Schema.optional(Schema.Number),
  minimum_origins: Schema.optional(Schema.Number),
  monitor: Schema.optional(Schema.String),
  monitor_group: Schema.optional(Schema.String),
  name: Schema.String,
  notification_email: Schema.optional(Schema.String),
  notification_filter: Schema.optional(Schema.Struct({
  origin: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
})),
  pool: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
}))
})),
  origin_steering: Schema.optional(Schema.Struct({
  policy: Schema.optional(Schema.Literal("random", "hash", "least_outstanding_requests", "least_connections"))
})),
  origins: Schema.Array(Schema.Struct({
  address: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Struct({
  Host: Schema.optional(Schema.Array(Schema.String))
})),
  name: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  virtual_network_id: Schema.optional(Schema.String),
  weight: Schema.optional(Schema.Number)
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/load_balancers/pools/{pool_id}" }),
).annotations({ identifier: "UpdatePoolRequest" }) as unknown as Schema.Schema<UpdatePoolRequest>;

export interface UpdatePoolResponse {
  result: { check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "SAS" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; created_on?: string; description?: string; disabled_at?: string; enabled?: boolean; id?: string; latitude?: number; load_shedding?: { default_percent?: number; default_policy?: "random" | "hash"; session_percent?: number; session_policy?: "hash" }; longitude?: number; minimum_origins?: number; modified_on?: string; monitor?: string; monitor_group?: string; name?: string; networks?: string[]; notification_email?: string; notification_filter?: { origin?: { disable?: boolean; healthy?: boolean }; pool?: { disable?: boolean; healthy?: boolean } }; origin_steering?: { policy?: "random" | "hash" | "least_outstanding_requests" | "least_connections" }; origins?: { address?: string; disabled_at?: string; enabled?: boolean; header?: { Host?: string[] }; name?: string; port?: number; virtual_network_id?: string; weight?: number }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatePoolResponse = Schema.Struct({
  result: Schema.Struct({
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "SAS", "SEAS", "NEAS", "ALL_REGIONS"))),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  latitude: Schema.optional(Schema.Number),
  load_shedding: Schema.optional(Schema.Struct({
  default_percent: Schema.optional(Schema.Number),
  default_policy: Schema.optional(Schema.Literal("random", "hash")),
  session_percent: Schema.optional(Schema.Number),
  session_policy: Schema.optional(Schema.Literal("hash"))
})),
  longitude: Schema.optional(Schema.Number),
  minimum_origins: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  monitor: Schema.optional(Schema.String),
  monitor_group: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(Schema.Array(Schema.String)),
  notification_email: Schema.optional(Schema.String),
  notification_filter: Schema.optional(Schema.Struct({
  origin: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
})),
  pool: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
}))
})),
  origin_steering: Schema.optional(Schema.Struct({
  policy: Schema.optional(Schema.Literal("random", "hash", "least_outstanding_requests", "least_connections"))
})),
  origins: Schema.optional(Schema.Array(Schema.Struct({
  address: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Struct({
  Host: Schema.optional(Schema.Array(Schema.String))
})),
  name: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  virtual_network_id: Schema.optional(Schema.String),
  weight: Schema.optional(Schema.Number)
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatePoolResponse" }) as unknown as Schema.Schema<UpdatePoolResponse>;

export const updatePool: (
  input: UpdatePoolRequest
) => Effect.Effect<
  UpdatePoolResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatePoolRequest,
  output: UpdatePoolResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletePoolRequest {
  pool_id: string;
  account_id: string;
}

export const DeletePoolRequest = Schema.Struct({
  pool_id: Schema.String.pipe(T.HttpPath("pool_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/load_balancers/pools/{pool_id}" }),
).annotations({ identifier: "DeletePoolRequest" }) as unknown as Schema.Schema<DeletePoolRequest>;

export interface DeletePoolResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletePoolResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletePoolResponse" }) as unknown as Schema.Schema<DeletePoolResponse>;

export const deletePool: (
  input: DeletePoolRequest
) => Effect.Effect<
  DeletePoolResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletePoolRequest,
  output: DeletePoolResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchPoolRequest {
  pool_id: string;
  account_id: string;
  body: { check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "SAS" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; description?: string; disabled_at?: string; enabled?: boolean; latitude?: number; load_shedding?: { default_percent?: number; default_policy?: "random" | "hash"; session_percent?: number; session_policy?: "hash" }; longitude?: number; minimum_origins?: number; monitor?: string; monitor_group?: string; name?: string; notification_email?: string; notification_filter?: { origin?: { disable?: boolean; healthy?: boolean }; pool?: { disable?: boolean; healthy?: boolean } }; origin_steering?: { policy?: "random" | "hash" | "least_outstanding_requests" | "least_connections" }; origins?: { address?: string; disabled_at?: string; enabled?: boolean; header?: { Host?: string[] }; name?: string; port?: number; virtual_network_id?: string; weight?: number }[] };
}

export const PatchPoolRequest = Schema.Struct({
  pool_id: Schema.String.pipe(T.HttpPath("pool_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "SAS", "SEAS", "NEAS", "ALL_REGIONS"))),
  description: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  latitude: Schema.optional(Schema.Number),
  load_shedding: Schema.optional(Schema.Struct({
  default_percent: Schema.optional(Schema.Number),
  default_policy: Schema.optional(Schema.Literal("random", "hash")),
  session_percent: Schema.optional(Schema.Number),
  session_policy: Schema.optional(Schema.Literal("hash"))
})),
  longitude: Schema.optional(Schema.Number),
  minimum_origins: Schema.optional(Schema.Number),
  monitor: Schema.optional(Schema.String),
  monitor_group: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  notification_email: Schema.optional(Schema.String),
  notification_filter: Schema.optional(Schema.Struct({
  origin: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
})),
  pool: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
}))
})),
  origin_steering: Schema.optional(Schema.Struct({
  policy: Schema.optional(Schema.Literal("random", "hash", "least_outstanding_requests", "least_connections"))
})),
  origins: Schema.optional(Schema.Array(Schema.Struct({
  address: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Struct({
  Host: Schema.optional(Schema.Array(Schema.String))
})),
  name: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  virtual_network_id: Schema.optional(Schema.String),
  weight: Schema.optional(Schema.Number)
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/load_balancers/pools/{pool_id}" }),
).annotations({ identifier: "PatchPoolRequest" }) as unknown as Schema.Schema<PatchPoolRequest>;

export interface PatchPoolResponse {
  result: { check_regions?: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "SAS" | "SEAS" | "NEAS" | "ALL_REGIONS"[]; created_on?: string; description?: string; disabled_at?: string; enabled?: boolean; id?: string; latitude?: number; load_shedding?: { default_percent?: number; default_policy?: "random" | "hash"; session_percent?: number; session_policy?: "hash" }; longitude?: number; minimum_origins?: number; modified_on?: string; monitor?: string; monitor_group?: string; name?: string; networks?: string[]; notification_email?: string; notification_filter?: { origin?: { disable?: boolean; healthy?: boolean }; pool?: { disable?: boolean; healthy?: boolean } }; origin_steering?: { policy?: "random" | "hash" | "least_outstanding_requests" | "least_connections" }; origins?: { address?: string; disabled_at?: string; enabled?: boolean; header?: { Host?: string[] }; name?: string; port?: number; virtual_network_id?: string; weight?: number }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchPoolResponse = Schema.Struct({
  result: Schema.Struct({
  check_regions: Schema.optional(Schema.Array(Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "SAS", "SEAS", "NEAS", "ALL_REGIONS"))),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  latitude: Schema.optional(Schema.Number),
  load_shedding: Schema.optional(Schema.Struct({
  default_percent: Schema.optional(Schema.Number),
  default_policy: Schema.optional(Schema.Literal("random", "hash")),
  session_percent: Schema.optional(Schema.Number),
  session_policy: Schema.optional(Schema.Literal("hash"))
})),
  longitude: Schema.optional(Schema.Number),
  minimum_origins: Schema.optional(Schema.Number),
  modified_on: Schema.optional(Schema.Date),
  monitor: Schema.optional(Schema.String),
  monitor_group: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(Schema.Array(Schema.String)),
  notification_email: Schema.optional(Schema.String),
  notification_filter: Schema.optional(Schema.Struct({
  origin: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
})),
  pool: Schema.optional(Schema.Struct({
  disable: Schema.optional(Schema.Boolean),
  healthy: Schema.optional(Schema.Boolean)
}))
})),
  origin_steering: Schema.optional(Schema.Struct({
  policy: Schema.optional(Schema.Literal("random", "hash", "least_outstanding_requests", "least_connections"))
})),
  origins: Schema.optional(Schema.Array(Schema.Struct({
  address: Schema.optional(Schema.String),
  disabled_at: Schema.optional(Schema.Date),
  enabled: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Struct({
  Host: Schema.optional(Schema.Array(Schema.String))
})),
  name: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  virtual_network_id: Schema.optional(Schema.String),
  weight: Schema.optional(Schema.Number)
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchPoolResponse" }) as unknown as Schema.Schema<PatchPoolResponse>;

export const patchPool: (
  input: PatchPoolRequest
) => Effect.Effect<
  PatchPoolResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchPoolRequest,
  output: PatchPoolResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountLoadBalancerPoolsPoolHealthDetailsRequest {
  pool_id: string;
  account_id: string;
}

export const AccountLoadBalancerPoolsPoolHealthDetailsRequest = Schema.Struct({
  pool_id: Schema.String.pipe(T.HttpPath("pool_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/load_balancers/pools/{pool_id}/health" }),
).annotations({ identifier: "AccountLoadBalancerPoolsPoolHealthDetailsRequest" }) as unknown as Schema.Schema<AccountLoadBalancerPoolsPoolHealthDetailsRequest>;

export interface AccountLoadBalancerPoolsPoolHealthDetailsResponse {
  result: { pool_id?: string; pop_health?: { healthy?: boolean; origins?: { ip?: { failure_reason?: string; healthy?: boolean; response_code?: number; rtt?: string } }[] } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountLoadBalancerPoolsPoolHealthDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  pool_id: Schema.optional(Schema.String),
  pop_health: Schema.optional(Schema.Struct({
  healthy: Schema.optional(Schema.Boolean),
  origins: Schema.optional(Schema.Array(Schema.Struct({
  ip: Schema.optional(Schema.Struct({
  failure_reason: Schema.optional(Schema.String),
  healthy: Schema.optional(Schema.Boolean),
  response_code: Schema.optional(Schema.Number),
  rtt: Schema.optional(Schema.String)
}))
})))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountLoadBalancerPoolsPoolHealthDetailsResponse" }) as unknown as Schema.Schema<AccountLoadBalancerPoolsPoolHealthDetailsResponse>;

export const accountLoadBalancerPoolsPoolHealthDetails: (
  input: AccountLoadBalancerPoolsPoolHealthDetailsRequest
) => Effect.Effect<
  AccountLoadBalancerPoolsPoolHealthDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountLoadBalancerPoolsPoolHealthDetailsRequest,
  output: AccountLoadBalancerPoolsPoolHealthDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountLoadBalancerPoolsPreviewPoolRequest {
  pool_id: string;
  account_id: string;
  body: unknown;
}

export const AccountLoadBalancerPoolsPreviewPoolRequest = Schema.Struct({
  pool_id: Schema.String.pipe(T.HttpPath("pool_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  allow_insecure: Schema.optional(Schema.Boolean),
  consecutive_down: Schema.optional(Schema.Number),
  consecutive_up: Schema.optional(Schema.Number),
  description: Schema.optional(Schema.String),
  expected_body: Schema.optional(Schema.String),
  expected_codes: Schema.optional(Schema.String),
  follow_redirects: Schema.optional(Schema.Boolean),
  header: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) })),
  interval: Schema.optional(Schema.Number),
  method: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  probe_zone: Schema.optional(Schema.String),
  retries: Schema.optional(Schema.Number),
  timeout: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("http", "https", "tcp", "udp_icmp", "icmp_ping", "smtp"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/load_balancers/pools/{pool_id}/preview" }),
).annotations({ identifier: "AccountLoadBalancerPoolsPreviewPoolRequest" }) as unknown as Schema.Schema<AccountLoadBalancerPoolsPreviewPoolRequest>;

export interface AccountLoadBalancerPoolsPreviewPoolResponse {
  result: { pools?: Record<string, unknown>; preview_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountLoadBalancerPoolsPreviewPoolResponse = Schema.Struct({
  result: Schema.Struct({
  pools: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  preview_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountLoadBalancerPoolsPreviewPoolResponse" }) as unknown as Schema.Schema<AccountLoadBalancerPoolsPreviewPoolResponse>;

export const accountLoadBalancerPoolsPreviewPool: (
  input: AccountLoadBalancerPoolsPreviewPoolRequest
) => Effect.Effect<
  AccountLoadBalancerPoolsPreviewPoolResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountLoadBalancerPoolsPreviewPoolRequest,
  output: AccountLoadBalancerPoolsPreviewPoolResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListPoolReferencesRequest {
  pool_id: string;
  account_id: string;
}

export const ListPoolReferencesRequest = Schema.Struct({
  pool_id: Schema.String.pipe(T.HttpPath("pool_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/load_balancers/pools/{pool_id}/references" }),
).annotations({ identifier: "ListPoolReferencesRequest" }) as unknown as Schema.Schema<ListPoolReferencesRequest>;

export interface ListPoolReferencesResponse {
  result: { reference_type?: "*" | "referral" | "referrer"; resource_id?: string; resource_name?: string; resource_type?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListPoolReferencesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  reference_type: Schema.optional(Schema.Literal("*", "referral", "referrer")),
  resource_id: Schema.optional(Schema.String),
  resource_name: Schema.optional(Schema.String),
  resource_type: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListPoolReferencesResponse" }) as unknown as Schema.Schema<ListPoolReferencesResponse>;

export const listPoolReferences: (
  input: ListPoolReferencesRequest
) => Effect.Effect<
  ListPoolReferencesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListPoolReferencesRequest,
  output: ListPoolReferencesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountLoadBalancerMonitorsPreviewResultRequest {
  preview_id: string;
  account_id: string;
}

export const AccountLoadBalancerMonitorsPreviewResultRequest = Schema.Struct({
  preview_id: Schema.String.pipe(T.HttpPath("preview_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/load_balancers/preview/{preview_id}" }),
).annotations({ identifier: "AccountLoadBalancerMonitorsPreviewResultRequest" }) as unknown as Schema.Schema<AccountLoadBalancerMonitorsPreviewResultRequest>;

export interface AccountLoadBalancerMonitorsPreviewResultResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountLoadBalancerMonitorsPreviewResultResponse = Schema.Struct({
  result: Schema.Record({ key: Schema.String, value: Schema.Struct({
  healthy: Schema.optional(Schema.Boolean),
  origins: Schema.optional(Schema.Array(Schema.Record({ key: Schema.String, value: Schema.Struct({
  failure_reason: Schema.optional(Schema.String),
  healthy: Schema.optional(Schema.Boolean),
  response_code: Schema.optional(Schema.Number),
  rtt: Schema.optional(Schema.String)
}) })))
}) }),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountLoadBalancerMonitorsPreviewResultResponse" }) as unknown as Schema.Schema<AccountLoadBalancerMonitorsPreviewResultResponse>;

export const accountLoadBalancerMonitorsPreviewResult: (
  input: AccountLoadBalancerMonitorsPreviewResultRequest
) => Effect.Effect<
  AccountLoadBalancerMonitorsPreviewResultResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountLoadBalancerMonitorsPreviewResultRequest,
  output: AccountLoadBalancerMonitorsPreviewResultResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListRegions1Request {
  account_id: string;
  subdivision_code?: string;
  subdivision_code_a2?: string;
  country_code_a2?: string;
}

export const ListRegions1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  subdivision_code: Schema.optional(Schema.String).pipe(T.HttpQuery("subdivision_code")),
  subdivision_code_a2: Schema.optional(Schema.String).pipe(T.HttpQuery("subdivision_code_a2")),
  country_code_a2: Schema.optional(Schema.String).pipe(T.HttpQuery("country_code_a2"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/load_balancers/regions" }),
).annotations({ identifier: "ListRegions1Request" }) as unknown as Schema.Schema<ListRegions1Request>;

export interface ListRegions1Response {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListRegions1Response = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListRegions1Response" }) as unknown as Schema.Schema<ListRegions1Response>;

export const listRegions1: (
  input: ListRegions1Request
) => Effect.Effect<
  ListRegions1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListRegions1Request,
  output: ListRegions1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetRegionRequest {
  region_id: "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "SAS" | "SEAS" | "NEAS";
  account_id: string;
}

export const GetRegionRequest = Schema.Struct({
  region_id: Schema.Literal("WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "SAS", "SEAS", "NEAS").pipe(T.HttpPath("region_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/load_balancers/regions/{region_id}" }),
).annotations({ identifier: "GetRegionRequest" }) as unknown as Schema.Schema<GetRegionRequest>;

export interface GetRegionResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetRegionResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetRegionResponse" }) as unknown as Schema.Schema<GetRegionResponse>;

export const getRegion: (
  input: GetRegionRequest
) => Effect.Effect<
  GetRegionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRegionRequest,
  output: GetRegionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountLoadBalancerSearchSearchResourcesRequest {
  account_id: string;
  query?: string;
  references?: "" | "*" | "referral" | "referrer";
  page?: number;
  per_page?: number;
}

export const AccountLoadBalancerSearchSearchResourcesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  query: Schema.optional(Schema.String).pipe(T.HttpQuery("query")),
  references: Schema.optional(Schema.Literal("", "*", "referral", "referrer")).pipe(T.HttpQuery("references")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/load_balancers/search" }),
).annotations({ identifier: "AccountLoadBalancerSearchSearchResourcesRequest" }) as unknown as Schema.Schema<AccountLoadBalancerSearchSearchResourcesRequest>;

export interface AccountLoadBalancerSearchSearchResourcesResponse {
  result: { resources?: { reference_type?: "referral" | "referrer"; references?: Record<string, unknown>[]; resource_id?: string; resource_name?: string; resource_type?: "load_balancer" | "monitor" | "pool" }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountLoadBalancerSearchSearchResourcesResponse = Schema.Struct({
  result: Schema.Struct({
  resources: Schema.optional(Schema.Array(Schema.Struct({
  reference_type: Schema.optional(Schema.Literal("referral", "referrer")),
  references: Schema.optional(Schema.Array(Schema.Struct({}))),
  resource_id: Schema.optional(Schema.String),
  resource_name: Schema.optional(Schema.String),
  resource_type: Schema.optional(Schema.Literal("load_balancer", "monitor", "pool"))
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountLoadBalancerSearchSearchResourcesResponse" }) as unknown as Schema.Schema<AccountLoadBalancerSearchSearchResourcesResponse>;

export const accountLoadBalancerSearchSearchResources: (
  input: AccountLoadBalancerSearchSearchResourcesRequest
) => Effect.Effect<
  AccountLoadBalancerSearchSearchResourcesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountLoadBalancerSearchSearchResourcesRequest,
  output: AccountLoadBalancerSearchSearchResourcesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsRequest {
  dataset_id: "access_requests" | "audit_logs" | "audit_logs_v2" | "biso_user_actions" | "casb_findings" | "device_posture_results" | "dex_application_tests" | "dex_device_state_events" | "dlp_forensic_copies" | "dns_firewall_logs" | "dns_logs" | "email_security_alerts" | "firewall_events" | "gateway_dns" | "gateway_http" | "gateway_network" | "http_requests" | "ipsec_logs" | "magic_ids_detections" | "nel_reports" | "network_analytics_logs" | "page_shield_events" | "sinkhole_http_logs" | "spectrum_events" | "ssh_logs" | "warp_config_changes" | "warp_toggle_changes" | "workers_trace_events" | "zaraz_events" | "zero_trust_network_sessions";
  account_id: string;
}

export const GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsRequest = Schema.Struct({
  dataset_id: Schema.Literal("access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions").pipe(T.HttpPath("dataset_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/logpush/datasets/{dataset_id}/fields" }),
).annotations({ identifier: "GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsRequest>;

export interface GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsResponse>;

export const getAccountsAccountIdLogpushDatasetsDatasetIdFields: (
  input: GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsRequest
) => Effect.Effect<
  GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsRequest,
  output: GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdLogpushDatasetsDatasetIdJobsRequest {
  dataset_id: "access_requests" | "audit_logs" | "audit_logs_v2" | "biso_user_actions" | "casb_findings" | "device_posture_results" | "dex_application_tests" | "dex_device_state_events" | "dlp_forensic_copies" | "dns_firewall_logs" | "dns_logs" | "email_security_alerts" | "firewall_events" | "gateway_dns" | "gateway_http" | "gateway_network" | "http_requests" | "ipsec_logs" | "magic_ids_detections" | "nel_reports" | "network_analytics_logs" | "page_shield_events" | "sinkhole_http_logs" | "spectrum_events" | "ssh_logs" | "warp_config_changes" | "warp_toggle_changes" | "workers_trace_events" | "zaraz_events" | "zero_trust_network_sessions";
  account_id: string;
}

export const GetAccountsAccountIdLogpushDatasetsDatasetIdJobsRequest = Schema.Struct({
  dataset_id: Schema.Literal("access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions").pipe(T.HttpPath("dataset_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/logpush/datasets/{dataset_id}/jobs" }),
).annotations({ identifier: "GetAccountsAccountIdLogpushDatasetsDatasetIdJobsRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdLogpushDatasetsDatasetIdJobsRequest>;

export interface GetAccountsAccountIdLogpushDatasetsDatasetIdJobsResponse {
  result: { dataset?: "access_requests" | "audit_logs" | "audit_logs_v2" | "biso_user_actions" | "casb_findings" | "device_posture_results" | "dex_application_tests" | "dex_device_state_events" | "dlp_forensic_copies" | "dns_firewall_logs" | "dns_logs" | "email_security_alerts" | "firewall_events" | "gateway_dns" | "gateway_http" | "gateway_network" | "http_requests" | "ipsec_logs" | "magic_ids_detections" | "nel_reports" | "network_analytics_logs" | "page_shield_events" | "sinkhole_http_logs" | "spectrum_events" | "ssh_logs" | "warp_config_changes" | "warp_toggle_changes" | "workers_trace_events" | "zaraz_events" | "zero_trust_network_sessions"; destination_conf?: string; enabled?: boolean; error_message?: string; frequency?: "high" | "low"; id?: number; kind?: "" | "edge"; last_complete?: string; last_error?: string; logpull_options?: string; max_upload_bytes?: number; max_upload_interval_seconds?: number; max_upload_records?: number; name?: string; output_options?: { "CVE-2021-44228"?: boolean; batch_prefix?: string; batch_suffix?: string; field_delimiter?: string; field_names?: string[]; output_type?: "ndjson" | "csv"; record_delimiter?: string; record_prefix?: string; record_suffix?: string; record_template?: string; sample_rate?: number; timestamp_format?: "unixnano" | "unix" | "rfc3339" } }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdLogpushDatasetsDatasetIdJobsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  dataset: Schema.optional(Schema.Literal("access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions")),
  destination_conf: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  error_message: Schema.optional(Schema.String),
  frequency: Schema.optional(Schema.Literal("high", "low")),
  id: Schema.optional(Schema.Number),
  kind: Schema.optional(Schema.Literal("", "edge")),
  last_complete: Schema.optional(Schema.Date),
  last_error: Schema.optional(Schema.Date),
  logpull_options: Schema.optional(Schema.String),
  max_upload_bytes: Schema.optional(Schema.Number),
  max_upload_interval_seconds: Schema.optional(Schema.Number),
  max_upload_records: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  output_options: Schema.optional(Schema.Struct({
  "CVE-2021-44228": Schema.optional(Schema.Boolean),
  batch_prefix: Schema.optional(Schema.String),
  batch_suffix: Schema.optional(Schema.String),
  field_delimiter: Schema.optional(Schema.String),
  field_names: Schema.optional(Schema.Array(Schema.String)),
  output_type: Schema.optional(Schema.Literal("ndjson", "csv")),
  record_delimiter: Schema.optional(Schema.String),
  record_prefix: Schema.optional(Schema.String),
  record_suffix: Schema.optional(Schema.String),
  record_template: Schema.optional(Schema.String),
  sample_rate: Schema.optional(Schema.Number),
  timestamp_format: Schema.optional(Schema.Literal("unixnano", "unix", "rfc3339"))
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdLogpushDatasetsDatasetIdJobsResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdLogpushDatasetsDatasetIdJobsResponse>;

export const getAccountsAccountIdLogpushDatasetsDatasetIdJobs: (
  input: GetAccountsAccountIdLogpushDatasetsDatasetIdJobsRequest
) => Effect.Effect<
  GetAccountsAccountIdLogpushDatasetsDatasetIdJobsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdLogpushDatasetsDatasetIdJobsRequest,
  output: GetAccountsAccountIdLogpushDatasetsDatasetIdJobsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdLogpushJobsRequest {
  account_id: string;
}

export const GetAccountsAccountIdLogpushJobsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/logpush/jobs" }),
).annotations({ identifier: "GetAccountsAccountIdLogpushJobsRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdLogpushJobsRequest>;

export interface GetAccountsAccountIdLogpushJobsResponse {
  result: { dataset?: "access_requests" | "audit_logs" | "audit_logs_v2" | "biso_user_actions" | "casb_findings" | "device_posture_results" | "dex_application_tests" | "dex_device_state_events" | "dlp_forensic_copies" | "dns_firewall_logs" | "dns_logs" | "email_security_alerts" | "firewall_events" | "gateway_dns" | "gateway_http" | "gateway_network" | "http_requests" | "ipsec_logs" | "magic_ids_detections" | "nel_reports" | "network_analytics_logs" | "page_shield_events" | "sinkhole_http_logs" | "spectrum_events" | "ssh_logs" | "warp_config_changes" | "warp_toggle_changes" | "workers_trace_events" | "zaraz_events" | "zero_trust_network_sessions"; destination_conf?: string; enabled?: boolean; error_message?: string; frequency?: "high" | "low"; id?: number; kind?: "" | "edge"; last_complete?: string; last_error?: string; logpull_options?: string; max_upload_bytes?: number; max_upload_interval_seconds?: number; max_upload_records?: number; name?: string; output_options?: { "CVE-2021-44228"?: boolean; batch_prefix?: string; batch_suffix?: string; field_delimiter?: string; field_names?: string[]; output_type?: "ndjson" | "csv"; record_delimiter?: string; record_prefix?: string; record_suffix?: string; record_template?: string; sample_rate?: number; timestamp_format?: "unixnano" | "unix" | "rfc3339" } }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdLogpushJobsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  dataset: Schema.optional(Schema.Literal("access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions")),
  destination_conf: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  error_message: Schema.optional(Schema.String),
  frequency: Schema.optional(Schema.Literal("high", "low")),
  id: Schema.optional(Schema.Number),
  kind: Schema.optional(Schema.Literal("", "edge")),
  last_complete: Schema.optional(Schema.Date),
  last_error: Schema.optional(Schema.Date),
  logpull_options: Schema.optional(Schema.String),
  max_upload_bytes: Schema.optional(Schema.Number),
  max_upload_interval_seconds: Schema.optional(Schema.Number),
  max_upload_records: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  output_options: Schema.optional(Schema.Struct({
  "CVE-2021-44228": Schema.optional(Schema.Boolean),
  batch_prefix: Schema.optional(Schema.String),
  batch_suffix: Schema.optional(Schema.String),
  field_delimiter: Schema.optional(Schema.String),
  field_names: Schema.optional(Schema.Array(Schema.String)),
  output_type: Schema.optional(Schema.Literal("ndjson", "csv")),
  record_delimiter: Schema.optional(Schema.String),
  record_prefix: Schema.optional(Schema.String),
  record_suffix: Schema.optional(Schema.String),
  record_template: Schema.optional(Schema.String),
  sample_rate: Schema.optional(Schema.Number),
  timestamp_format: Schema.optional(Schema.Literal("unixnano", "unix", "rfc3339"))
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdLogpushJobsResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdLogpushJobsResponse>;

export const getAccountsAccountIdLogpushJobs: (
  input: GetAccountsAccountIdLogpushJobsRequest
) => Effect.Effect<
  GetAccountsAccountIdLogpushJobsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdLogpushJobsRequest,
  output: GetAccountsAccountIdLogpushJobsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostAccountsAccountIdLogpushJobsRequest {
  account_id: string;
  body: { dataset?: "access_requests" | "audit_logs" | "audit_logs_v2" | "biso_user_actions" | "casb_findings" | "device_posture_results" | "dex_application_tests" | "dex_device_state_events" | "dlp_forensic_copies" | "dns_firewall_logs" | "dns_logs" | "email_security_alerts" | "firewall_events" | "gateway_dns" | "gateway_http" | "gateway_network" | "http_requests" | "ipsec_logs" | "magic_ids_detections" | "nel_reports" | "network_analytics_logs" | "page_shield_events" | "sinkhole_http_logs" | "spectrum_events" | "ssh_logs" | "warp_config_changes" | "warp_toggle_changes" | "workers_trace_events" | "zaraz_events" | "zero_trust_network_sessions"; destination_conf: string; enabled?: boolean; filter?: string; frequency?: "high" | "low"; kind?: "" | "edge"; logpull_options?: string; max_upload_bytes?: number; max_upload_interval_seconds?: number; max_upload_records?: number; name?: string; output_options?: { "CVE-2021-44228"?: boolean; batch_prefix?: string; batch_suffix?: string; field_delimiter?: string; field_names?: string[]; output_type?: "ndjson" | "csv"; record_delimiter?: string; record_prefix?: string; record_suffix?: string; record_template?: string; sample_rate?: number; timestamp_format?: "unixnano" | "unix" | "rfc3339" }; ownership_challenge?: string };
}

export const PostAccountsAccountIdLogpushJobsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  dataset: Schema.optional(Schema.Literal("access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions")),
  destination_conf: Schema.String,
  enabled: Schema.optional(Schema.Boolean),
  filter: Schema.optional(Schema.String),
  frequency: Schema.optional(Schema.Literal("high", "low")),
  kind: Schema.optional(Schema.Literal("", "edge")),
  logpull_options: Schema.optional(Schema.String),
  max_upload_bytes: Schema.optional(Schema.Number),
  max_upload_interval_seconds: Schema.optional(Schema.Number),
  max_upload_records: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  output_options: Schema.optional(Schema.Struct({
  "CVE-2021-44228": Schema.optional(Schema.Boolean),
  batch_prefix: Schema.optional(Schema.String),
  batch_suffix: Schema.optional(Schema.String),
  field_delimiter: Schema.optional(Schema.String),
  field_names: Schema.optional(Schema.Array(Schema.String)),
  output_type: Schema.optional(Schema.Literal("ndjson", "csv")),
  record_delimiter: Schema.optional(Schema.String),
  record_prefix: Schema.optional(Schema.String),
  record_suffix: Schema.optional(Schema.String),
  record_template: Schema.optional(Schema.String),
  sample_rate: Schema.optional(Schema.Number),
  timestamp_format: Schema.optional(Schema.Literal("unixnano", "unix", "rfc3339"))
})),
  ownership_challenge: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/logpush/jobs" }),
).annotations({ identifier: "PostAccountsAccountIdLogpushJobsRequest" }) as unknown as Schema.Schema<PostAccountsAccountIdLogpushJobsRequest>;

export interface PostAccountsAccountIdLogpushJobsResponse {
  result: { dataset?: "access_requests" | "audit_logs" | "audit_logs_v2" | "biso_user_actions" | "casb_findings" | "device_posture_results" | "dex_application_tests" | "dex_device_state_events" | "dlp_forensic_copies" | "dns_firewall_logs" | "dns_logs" | "email_security_alerts" | "firewall_events" | "gateway_dns" | "gateway_http" | "gateway_network" | "http_requests" | "ipsec_logs" | "magic_ids_detections" | "nel_reports" | "network_analytics_logs" | "page_shield_events" | "sinkhole_http_logs" | "spectrum_events" | "ssh_logs" | "warp_config_changes" | "warp_toggle_changes" | "workers_trace_events" | "zaraz_events" | "zero_trust_network_sessions"; destination_conf?: string; enabled?: boolean; error_message?: string; frequency?: "high" | "low"; id?: number; kind?: "" | "edge"; last_complete?: string; last_error?: string; logpull_options?: string; max_upload_bytes?: number; max_upload_interval_seconds?: number; max_upload_records?: number; name?: string; output_options?: { "CVE-2021-44228"?: boolean; batch_prefix?: string; batch_suffix?: string; field_delimiter?: string; field_names?: string[]; output_type?: "ndjson" | "csv"; record_delimiter?: string; record_prefix?: string; record_suffix?: string; record_template?: string; sample_rate?: number; timestamp_format?: "unixnano" | "unix" | "rfc3339" } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostAccountsAccountIdLogpushJobsResponse = Schema.Struct({
  result: Schema.Struct({
  dataset: Schema.optional(Schema.Literal("access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions")),
  destination_conf: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  error_message: Schema.optional(Schema.String),
  frequency: Schema.optional(Schema.Literal("high", "low")),
  id: Schema.optional(Schema.Number),
  kind: Schema.optional(Schema.Literal("", "edge")),
  last_complete: Schema.optional(Schema.Date),
  last_error: Schema.optional(Schema.Date),
  logpull_options: Schema.optional(Schema.String),
  max_upload_bytes: Schema.optional(Schema.Number),
  max_upload_interval_seconds: Schema.optional(Schema.Number),
  max_upload_records: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  output_options: Schema.optional(Schema.Struct({
  "CVE-2021-44228": Schema.optional(Schema.Boolean),
  batch_prefix: Schema.optional(Schema.String),
  batch_suffix: Schema.optional(Schema.String),
  field_delimiter: Schema.optional(Schema.String),
  field_names: Schema.optional(Schema.Array(Schema.String)),
  output_type: Schema.optional(Schema.Literal("ndjson", "csv")),
  record_delimiter: Schema.optional(Schema.String),
  record_prefix: Schema.optional(Schema.String),
  record_suffix: Schema.optional(Schema.String),
  record_template: Schema.optional(Schema.String),
  sample_rate: Schema.optional(Schema.Number),
  timestamp_format: Schema.optional(Schema.Literal("unixnano", "unix", "rfc3339"))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostAccountsAccountIdLogpushJobsResponse" }) as unknown as Schema.Schema<PostAccountsAccountIdLogpushJobsResponse>;

export const postAccountsAccountIdLogpushJobs: (
  input: PostAccountsAccountIdLogpushJobsRequest
) => Effect.Effect<
  PostAccountsAccountIdLogpushJobsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostAccountsAccountIdLogpushJobsRequest,
  output: PostAccountsAccountIdLogpushJobsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdLogpushJobsJobIdRequest {
  job_id: number;
  account_id: string;
}

export const GetAccountsAccountIdLogpushJobsJobIdRequest = Schema.Struct({
  job_id: Schema.Number.pipe(T.HttpPath("job_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/logpush/jobs/{job_id}" }),
).annotations({ identifier: "GetAccountsAccountIdLogpushJobsJobIdRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdLogpushJobsJobIdRequest>;

export interface GetAccountsAccountIdLogpushJobsJobIdResponse {
  result: { dataset?: "access_requests" | "audit_logs" | "audit_logs_v2" | "biso_user_actions" | "casb_findings" | "device_posture_results" | "dex_application_tests" | "dex_device_state_events" | "dlp_forensic_copies" | "dns_firewall_logs" | "dns_logs" | "email_security_alerts" | "firewall_events" | "gateway_dns" | "gateway_http" | "gateway_network" | "http_requests" | "ipsec_logs" | "magic_ids_detections" | "nel_reports" | "network_analytics_logs" | "page_shield_events" | "sinkhole_http_logs" | "spectrum_events" | "ssh_logs" | "warp_config_changes" | "warp_toggle_changes" | "workers_trace_events" | "zaraz_events" | "zero_trust_network_sessions"; destination_conf?: string; enabled?: boolean; error_message?: string; frequency?: "high" | "low"; id?: number; kind?: "" | "edge"; last_complete?: string; last_error?: string; logpull_options?: string; max_upload_bytes?: number; max_upload_interval_seconds?: number; max_upload_records?: number; name?: string; output_options?: { "CVE-2021-44228"?: boolean; batch_prefix?: string; batch_suffix?: string; field_delimiter?: string; field_names?: string[]; output_type?: "ndjson" | "csv"; record_delimiter?: string; record_prefix?: string; record_suffix?: string; record_template?: string; sample_rate?: number; timestamp_format?: "unixnano" | "unix" | "rfc3339" } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdLogpushJobsJobIdResponse = Schema.Struct({
  result: Schema.Struct({
  dataset: Schema.optional(Schema.Literal("access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions")),
  destination_conf: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  error_message: Schema.optional(Schema.String),
  frequency: Schema.optional(Schema.Literal("high", "low")),
  id: Schema.optional(Schema.Number),
  kind: Schema.optional(Schema.Literal("", "edge")),
  last_complete: Schema.optional(Schema.Date),
  last_error: Schema.optional(Schema.Date),
  logpull_options: Schema.optional(Schema.String),
  max_upload_bytes: Schema.optional(Schema.Number),
  max_upload_interval_seconds: Schema.optional(Schema.Number),
  max_upload_records: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  output_options: Schema.optional(Schema.Struct({
  "CVE-2021-44228": Schema.optional(Schema.Boolean),
  batch_prefix: Schema.optional(Schema.String),
  batch_suffix: Schema.optional(Schema.String),
  field_delimiter: Schema.optional(Schema.String),
  field_names: Schema.optional(Schema.Array(Schema.String)),
  output_type: Schema.optional(Schema.Literal("ndjson", "csv")),
  record_delimiter: Schema.optional(Schema.String),
  record_prefix: Schema.optional(Schema.String),
  record_suffix: Schema.optional(Schema.String),
  record_template: Schema.optional(Schema.String),
  sample_rate: Schema.optional(Schema.Number),
  timestamp_format: Schema.optional(Schema.Literal("unixnano", "unix", "rfc3339"))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdLogpushJobsJobIdResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdLogpushJobsJobIdResponse>;

export const getAccountsAccountIdLogpushJobsJobId: (
  input: GetAccountsAccountIdLogpushJobsJobIdRequest
) => Effect.Effect<
  GetAccountsAccountIdLogpushJobsJobIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdLogpushJobsJobIdRequest,
  output: GetAccountsAccountIdLogpushJobsJobIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PutAccountsAccountIdLogpushJobsJobIdRequest {
  job_id: number;
  account_id: string;
  body: { destination_conf?: string; enabled?: boolean; filter?: string; frequency?: "high" | "low"; kind?: "" | "edge"; logpull_options?: string; max_upload_bytes?: number; max_upload_interval_seconds?: number; max_upload_records?: number; name?: string; output_options?: { "CVE-2021-44228"?: boolean; batch_prefix?: string; batch_suffix?: string; field_delimiter?: string; field_names?: string[]; output_type?: "ndjson" | "csv"; record_delimiter?: string; record_prefix?: string; record_suffix?: string; record_template?: string; sample_rate?: number; timestamp_format?: "unixnano" | "unix" | "rfc3339" }; ownership_challenge?: string };
}

export const PutAccountsAccountIdLogpushJobsJobIdRequest = Schema.Struct({
  job_id: Schema.Number.pipe(T.HttpPath("job_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  destination_conf: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  filter: Schema.optional(Schema.String),
  frequency: Schema.optional(Schema.Literal("high", "low")),
  kind: Schema.optional(Schema.Literal("", "edge")),
  logpull_options: Schema.optional(Schema.String),
  max_upload_bytes: Schema.optional(Schema.Number),
  max_upload_interval_seconds: Schema.optional(Schema.Number),
  max_upload_records: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  output_options: Schema.optional(Schema.Struct({
  "CVE-2021-44228": Schema.optional(Schema.Boolean),
  batch_prefix: Schema.optional(Schema.String),
  batch_suffix: Schema.optional(Schema.String),
  field_delimiter: Schema.optional(Schema.String),
  field_names: Schema.optional(Schema.Array(Schema.String)),
  output_type: Schema.optional(Schema.Literal("ndjson", "csv")),
  record_delimiter: Schema.optional(Schema.String),
  record_prefix: Schema.optional(Schema.String),
  record_suffix: Schema.optional(Schema.String),
  record_template: Schema.optional(Schema.String),
  sample_rate: Schema.optional(Schema.Number),
  timestamp_format: Schema.optional(Schema.Literal("unixnano", "unix", "rfc3339"))
})),
  ownership_challenge: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/logpush/jobs/{job_id}" }),
).annotations({ identifier: "PutAccountsAccountIdLogpushJobsJobIdRequest" }) as unknown as Schema.Schema<PutAccountsAccountIdLogpushJobsJobIdRequest>;

export interface PutAccountsAccountIdLogpushJobsJobIdResponse {
  result: { dataset?: "access_requests" | "audit_logs" | "audit_logs_v2" | "biso_user_actions" | "casb_findings" | "device_posture_results" | "dex_application_tests" | "dex_device_state_events" | "dlp_forensic_copies" | "dns_firewall_logs" | "dns_logs" | "email_security_alerts" | "firewall_events" | "gateway_dns" | "gateway_http" | "gateway_network" | "http_requests" | "ipsec_logs" | "magic_ids_detections" | "nel_reports" | "network_analytics_logs" | "page_shield_events" | "sinkhole_http_logs" | "spectrum_events" | "ssh_logs" | "warp_config_changes" | "warp_toggle_changes" | "workers_trace_events" | "zaraz_events" | "zero_trust_network_sessions"; destination_conf?: string; enabled?: boolean; error_message?: string; frequency?: "high" | "low"; id?: number; kind?: "" | "edge"; last_complete?: string; last_error?: string; logpull_options?: string; max_upload_bytes?: number; max_upload_interval_seconds?: number; max_upload_records?: number; name?: string; output_options?: { "CVE-2021-44228"?: boolean; batch_prefix?: string; batch_suffix?: string; field_delimiter?: string; field_names?: string[]; output_type?: "ndjson" | "csv"; record_delimiter?: string; record_prefix?: string; record_suffix?: string; record_template?: string; sample_rate?: number; timestamp_format?: "unixnano" | "unix" | "rfc3339" } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PutAccountsAccountIdLogpushJobsJobIdResponse = Schema.Struct({
  result: Schema.Struct({
  dataset: Schema.optional(Schema.Literal("access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions")),
  destination_conf: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  error_message: Schema.optional(Schema.String),
  frequency: Schema.optional(Schema.Literal("high", "low")),
  id: Schema.optional(Schema.Number),
  kind: Schema.optional(Schema.Literal("", "edge")),
  last_complete: Schema.optional(Schema.Date),
  last_error: Schema.optional(Schema.Date),
  logpull_options: Schema.optional(Schema.String),
  max_upload_bytes: Schema.optional(Schema.Number),
  max_upload_interval_seconds: Schema.optional(Schema.Number),
  max_upload_records: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  output_options: Schema.optional(Schema.Struct({
  "CVE-2021-44228": Schema.optional(Schema.Boolean),
  batch_prefix: Schema.optional(Schema.String),
  batch_suffix: Schema.optional(Schema.String),
  field_delimiter: Schema.optional(Schema.String),
  field_names: Schema.optional(Schema.Array(Schema.String)),
  output_type: Schema.optional(Schema.Literal("ndjson", "csv")),
  record_delimiter: Schema.optional(Schema.String),
  record_prefix: Schema.optional(Schema.String),
  record_suffix: Schema.optional(Schema.String),
  record_template: Schema.optional(Schema.String),
  sample_rate: Schema.optional(Schema.Number),
  timestamp_format: Schema.optional(Schema.Literal("unixnano", "unix", "rfc3339"))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PutAccountsAccountIdLogpushJobsJobIdResponse" }) as unknown as Schema.Schema<PutAccountsAccountIdLogpushJobsJobIdResponse>;

export const putAccountsAccountIdLogpushJobsJobId: (
  input: PutAccountsAccountIdLogpushJobsJobIdRequest
) => Effect.Effect<
  PutAccountsAccountIdLogpushJobsJobIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutAccountsAccountIdLogpushJobsJobIdRequest,
  output: PutAccountsAccountIdLogpushJobsJobIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAccountsAccountIdLogpushJobsJobIdRequest {
  job_id: number;
  account_id: string;
}

export const DeleteAccountsAccountIdLogpushJobsJobIdRequest = Schema.Struct({
  job_id: Schema.Number.pipe(T.HttpPath("job_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/logpush/jobs/{job_id}" }),
).annotations({ identifier: "DeleteAccountsAccountIdLogpushJobsJobIdRequest" }) as unknown as Schema.Schema<DeleteAccountsAccountIdLogpushJobsJobIdRequest>;

export interface DeleteAccountsAccountIdLogpushJobsJobIdResponse {
  result: { id?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAccountsAccountIdLogpushJobsJobIdResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAccountsAccountIdLogpushJobsJobIdResponse" }) as unknown as Schema.Schema<DeleteAccountsAccountIdLogpushJobsJobIdResponse>;

export const deleteAccountsAccountIdLogpushJobsJobId: (
  input: DeleteAccountsAccountIdLogpushJobsJobIdRequest
) => Effect.Effect<
  DeleteAccountsAccountIdLogpushJobsJobIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccountsAccountIdLogpushJobsJobIdRequest,
  output: DeleteAccountsAccountIdLogpushJobsJobIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostAccountsAccountIdLogpushOwnershipRequest {
  account_id: string;
  body: { destination_conf: string };
}

export const PostAccountsAccountIdLogpushOwnershipRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  destination_conf: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/logpush/ownership" }),
).annotations({ identifier: "PostAccountsAccountIdLogpushOwnershipRequest" }) as unknown as Schema.Schema<PostAccountsAccountIdLogpushOwnershipRequest>;

export interface PostAccountsAccountIdLogpushOwnershipResponse {
  result: { filename?: string; message?: string; valid?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostAccountsAccountIdLogpushOwnershipResponse = Schema.Struct({
  result: Schema.Struct({
  filename: Schema.optional(Schema.String),
  message: Schema.optional(Schema.String),
  valid: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostAccountsAccountIdLogpushOwnershipResponse" }) as unknown as Schema.Schema<PostAccountsAccountIdLogpushOwnershipResponse>;

export const postAccountsAccountIdLogpushOwnership: (
  input: PostAccountsAccountIdLogpushOwnershipRequest
) => Effect.Effect<
  PostAccountsAccountIdLogpushOwnershipResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostAccountsAccountIdLogpushOwnershipRequest,
  output: PostAccountsAccountIdLogpushOwnershipResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostAccountsAccountIdLogpushOwnershipValidateRequest {
  account_id: string;
  body: { destination_conf: string; ownership_challenge: string };
}

export const PostAccountsAccountIdLogpushOwnershipValidateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  destination_conf: Schema.String,
  ownership_challenge: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/logpush/ownership/validate" }),
).annotations({ identifier: "PostAccountsAccountIdLogpushOwnershipValidateRequest" }) as unknown as Schema.Schema<PostAccountsAccountIdLogpushOwnershipValidateRequest>;

export interface PostAccountsAccountIdLogpushOwnershipValidateResponse {
  result: { valid?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostAccountsAccountIdLogpushOwnershipValidateResponse = Schema.Struct({
  result: Schema.Struct({
  valid: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostAccountsAccountIdLogpushOwnershipValidateResponse" }) as unknown as Schema.Schema<PostAccountsAccountIdLogpushOwnershipValidateResponse>;

export const postAccountsAccountIdLogpushOwnershipValidate: (
  input: PostAccountsAccountIdLogpushOwnershipValidateRequest
) => Effect.Effect<
  PostAccountsAccountIdLogpushOwnershipValidateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostAccountsAccountIdLogpushOwnershipValidateRequest,
  output: PostAccountsAccountIdLogpushOwnershipValidateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAccountsAccountIdLogpushValidateDestinationRequest {
  account_id: string;
  body: { destination_conf: string };
}

export const DeleteAccountsAccountIdLogpushValidateDestinationRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  destination_conf: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/logpush/validate/destination" }),
).annotations({ identifier: "DeleteAccountsAccountIdLogpushValidateDestinationRequest" }) as unknown as Schema.Schema<DeleteAccountsAccountIdLogpushValidateDestinationRequest>;

export interface DeleteAccountsAccountIdLogpushValidateDestinationResponse {
  result: { message?: string; valid?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAccountsAccountIdLogpushValidateDestinationResponse = Schema.Struct({
  result: Schema.Struct({
  message: Schema.optional(Schema.String),
  valid: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAccountsAccountIdLogpushValidateDestinationResponse" }) as unknown as Schema.Schema<DeleteAccountsAccountIdLogpushValidateDestinationResponse>;

export const deleteAccountsAccountIdLogpushValidateDestination: (
  input: DeleteAccountsAccountIdLogpushValidateDestinationRequest
) => Effect.Effect<
  DeleteAccountsAccountIdLogpushValidateDestinationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccountsAccountIdLogpushValidateDestinationRequest,
  output: DeleteAccountsAccountIdLogpushValidateDestinationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAccountsAccountIdLogpushValidateDestinationExistsRequest {
  account_id: string;
  body: { destination_conf: string };
}

export const DeleteAccountsAccountIdLogpushValidateDestinationExistsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  destination_conf: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/logpush/validate/destination/exists" }),
).annotations({ identifier: "DeleteAccountsAccountIdLogpushValidateDestinationExistsRequest" }) as unknown as Schema.Schema<DeleteAccountsAccountIdLogpushValidateDestinationExistsRequest>;

export interface DeleteAccountsAccountIdLogpushValidateDestinationExistsResponse {
  result: { exists?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAccountsAccountIdLogpushValidateDestinationExistsResponse = Schema.Struct({
  result: Schema.Struct({
  exists: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAccountsAccountIdLogpushValidateDestinationExistsResponse" }) as unknown as Schema.Schema<DeleteAccountsAccountIdLogpushValidateDestinationExistsResponse>;

export const deleteAccountsAccountIdLogpushValidateDestinationExists: (
  input: DeleteAccountsAccountIdLogpushValidateDestinationExistsRequest
) => Effect.Effect<
  DeleteAccountsAccountIdLogpushValidateDestinationExistsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccountsAccountIdLogpushValidateDestinationExistsRequest,
  output: DeleteAccountsAccountIdLogpushValidateDestinationExistsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostAccountsAccountIdLogpushValidateOriginRequest {
  account_id: string;
  body: { logpull_options: string };
}

export const PostAccountsAccountIdLogpushValidateOriginRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  logpull_options: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/logpush/validate/origin" }),
).annotations({ identifier: "PostAccountsAccountIdLogpushValidateOriginRequest" }) as unknown as Schema.Schema<PostAccountsAccountIdLogpushValidateOriginRequest>;

export interface PostAccountsAccountIdLogpushValidateOriginResponse {
  result: { message?: string; valid?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostAccountsAccountIdLogpushValidateOriginResponse = Schema.Struct({
  result: Schema.Struct({
  message: Schema.optional(Schema.String),
  valid: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostAccountsAccountIdLogpushValidateOriginResponse" }) as unknown as Schema.Schema<PostAccountsAccountIdLogpushValidateOriginResponse>;

export const postAccountsAccountIdLogpushValidateOrigin: (
  input: PostAccountsAccountIdLogpushValidateOriginRequest
) => Effect.Effect<
  PostAccountsAccountIdLogpushValidateOriginResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostAccountsAccountIdLogpushValidateOriginRequest,
  output: PostAccountsAccountIdLogpushValidateOriginResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountAuditLogs1Request {
  account_id: string;
  account_name?: string[];
  action_result?: "success" | "failure"[];
  action_type?: "create" | "delete" | "view" | "update"[];
  actor_context?: "api_key" | "api_token" | "dash" | "oauth" | "origin_ca_key"[];
  actor_email?: string[];
  actor_id?: string[];
  actor_ip_address?: string[];
  actor_token_id?: string[];
  actor_token_name?: string[];
  actor_type?: "account" | "cloudflare_admin" | "system" | "user"[];
  audit_log_id?: string[];
  id?: string[];
  raw_cf_ray_id?: string[];
  raw_method?: string[];
  raw_status_code?: number[];
  raw_uri?: string[];
  resource_id?: string[];
  resource_product?: string[];
  resource_type?: string[];
  resource_scope?: "accounts" | "user" | "zones" | "memberships"[];
  zone_id?: string[];
  zone_name?: string[];
  "account_name.not"?: string[];
  "action_result.not"?: "success" | "failure"[];
  "action_type.not"?: "create" | "delete" | "view" | "update"[];
  "actor_context.not"?: "api_key" | "api_token" | "dash" | "oauth" | "origin_ca_key"[];
  "actor_email.not"?: string[];
  "actor_id.not"?: string[];
  "actor_ip_address.not"?: string[];
  "actor_token_id.not"?: string[];
  "actor_token_name.not"?: string[];
  "actor_type.not"?: "account" | "cloudflare_admin" | "system" | "user"[];
  "audit_log_id.not"?: string[];
  "id.not"?: string[];
  "raw_cf_ray_id.not"?: string[];
  "raw_method.not"?: string[];
  "raw_status_code.not"?: number[];
  "raw_uri.not"?: string[];
  "resource_id.not"?: string[];
  "resource_product.not"?: string[];
  "resource_type.not"?: string[];
  "resource_scope.not"?: "accounts" | "user" | "zones"[];
  "zone_id.not"?: string[];
  "zone_name.not"?: string[];
  since: string;
  before: string;
  direction?: "desc" | "asc";
  limit?: number;
  cursor?: string;
}

export const GetAccountAuditLogs1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  account_name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("account_name")),
  action_result: Schema.optional(Schema.Array(Schema.Literal("success", "failure"))).pipe(T.HttpQuery("action_result")),
  action_type: Schema.optional(Schema.Array(Schema.Literal("create", "delete", "view", "update"))).pipe(T.HttpQuery("action_type")),
  actor_context: Schema.optional(Schema.Array(Schema.Literal("api_key", "api_token", "dash", "oauth", "origin_ca_key"))).pipe(T.HttpQuery("actor_context")),
  actor_email: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("actor_email")),
  actor_id: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("actor_id")),
  actor_ip_address: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("actor_ip_address")),
  actor_token_id: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("actor_token_id")),
  actor_token_name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("actor_token_name")),
  actor_type: Schema.optional(Schema.Array(Schema.Literal("account", "cloudflare_admin", "system", "user"))).pipe(T.HttpQuery("actor_type")),
  audit_log_id: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("audit_log_id")),
  id: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("id")),
  raw_cf_ray_id: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("raw_cf_ray_id")),
  raw_method: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("raw_method")),
  raw_status_code: Schema.optional(Schema.Array(Schema.Number)).pipe(T.HttpQuery("raw_status_code")),
  raw_uri: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("raw_uri")),
  resource_id: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("resource_id")),
  resource_product: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("resource_product")),
  resource_type: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("resource_type")),
  resource_scope: Schema.optional(Schema.Array(Schema.Literal("accounts", "user", "zones", "memberships"))).pipe(T.HttpQuery("resource_scope")),
  zone_id: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("zone_id")),
  zone_name: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("zone_name")),
  "account_name.not": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("account_name.not")),
  "action_result.not": Schema.optional(Schema.Array(Schema.Literal("success", "failure"))).pipe(T.HttpQuery("action_result.not")),
  "action_type.not": Schema.optional(Schema.Array(Schema.Literal("create", "delete", "view", "update"))).pipe(T.HttpQuery("action_type.not")),
  "actor_context.not": Schema.optional(Schema.Array(Schema.Literal("api_key", "api_token", "dash", "oauth", "origin_ca_key"))).pipe(T.HttpQuery("actor_context.not")),
  "actor_email.not": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("actor_email.not")),
  "actor_id.not": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("actor_id.not")),
  "actor_ip_address.not": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("actor_ip_address.not")),
  "actor_token_id.not": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("actor_token_id.not")),
  "actor_token_name.not": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("actor_token_name.not")),
  "actor_type.not": Schema.optional(Schema.Array(Schema.Literal("account", "cloudflare_admin", "system", "user"))).pipe(T.HttpQuery("actor_type.not")),
  "audit_log_id.not": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("audit_log_id.not")),
  "id.not": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("id.not")),
  "raw_cf_ray_id.not": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("raw_cf_ray_id.not")),
  "raw_method.not": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("raw_method.not")),
  "raw_status_code.not": Schema.optional(Schema.Array(Schema.Number)).pipe(T.HttpQuery("raw_status_code.not")),
  "raw_uri.not": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("raw_uri.not")),
  "resource_id.not": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("resource_id.not")),
  "resource_product.not": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("resource_product.not")),
  "resource_type.not": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("resource_type.not")),
  "resource_scope.not": Schema.optional(Schema.Array(Schema.Literal("accounts", "user", "zones"))).pipe(T.HttpQuery("resource_scope.not")),
  "zone_id.not": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("zone_id.not")),
  "zone_name.not": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("zone_name.not")),
  since: Schema.Date.pipe(T.HttpQuery("since")),
  before: Schema.Date.pipe(T.HttpQuery("before")),
  direction: Schema.optional(Schema.Literal("desc", "asc")).pipe(T.HttpQuery("direction")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  cursor: Schema.optional(Schema.String).pipe(T.HttpQuery("cursor"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/logs/audit" }),
).annotations({ identifier: "GetAccountAuditLogs1Request" }) as unknown as Schema.Schema<GetAccountAuditLogs1Request>;

export interface GetAccountAuditLogs1Response {
  result: { account?: { id?: string; name?: string }; action?: { description?: string; result?: string; time?: string; type?: string }; actor?: { context?: "api_key" | "api_token" | "dash" | "oauth" | "origin_ca_key"; email?: string; id?: string; ip_address?: string; token_id?: string; token_name?: string; type?: "account" | "cloudflare_admin" | "system" | "user" }; id?: string; raw?: { cf_ray_id?: string; method?: string; status_code?: number; uri?: string; user_agent?: string }; resource?: { id?: string; product?: string; request?: Record<string, unknown>; response?: Record<string, unknown>; scope?: Record<string, unknown>; type?: string }; zone?: { id?: string; name?: string } }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountAuditLogs1Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  account: Schema.optional(Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
})),
  action: Schema.optional(Schema.Struct({
  description: Schema.optional(Schema.String),
  result: Schema.optional(Schema.String),
  time: Schema.optional(Schema.Date),
  type: Schema.optional(Schema.String)
})),
  actor: Schema.optional(Schema.Struct({
  context: Schema.optional(Schema.Literal("api_key", "api_token", "dash", "oauth", "origin_ca_key")),
  email: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  ip_address: Schema.optional(Schema.String),
  token_id: Schema.optional(Schema.String),
  token_name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("account", "cloudflare_admin", "system", "user"))
})),
  id: Schema.optional(Schema.String),
  raw: Schema.optional(Schema.Struct({
  cf_ray_id: Schema.optional(Schema.String),
  method: Schema.optional(Schema.String),
  status_code: Schema.optional(Schema.Number),
  uri: Schema.optional(Schema.String),
  user_agent: Schema.optional(Schema.String)
})),
  resource: Schema.optional(Schema.Struct({
  id: Schema.optional(Schema.String),
  product: Schema.optional(Schema.String),
  request: Schema.optional(Schema.Struct({})),
  response: Schema.optional(Schema.Struct({})),
  scope: Schema.optional(Schema.Struct({})),
  type: Schema.optional(Schema.String)
})),
  zone: Schema.optional(Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountAuditLogs1Response" }) as unknown as Schema.Schema<GetAccountAuditLogs1Response>;

export const getAccountAuditLogs1: (
  input: GetAccountAuditLogs1Request
) => Effect.Effect<
  GetAccountAuditLogs1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountAuditLogs1Request,
  output: GetAccountAuditLogs1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAccountsAccountIdLogsControlCmbConfigRequest {
  account_id: string;
}

export const GetAccountsAccountIdLogsControlCmbConfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/logs/control/cmb/config" }),
).annotations({ identifier: "GetAccountsAccountIdLogsControlCmbConfigRequest" }) as unknown as Schema.Schema<GetAccountsAccountIdLogsControlCmbConfigRequest>;

export interface GetAccountsAccountIdLogsControlCmbConfigResponse {
  result: { allow_out_of_region_access?: boolean; regions?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAccountsAccountIdLogsControlCmbConfigResponse = Schema.Struct({
  result: Schema.Struct({
  allow_out_of_region_access: Schema.optional(Schema.Boolean),
  regions: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAccountsAccountIdLogsControlCmbConfigResponse" }) as unknown as Schema.Schema<GetAccountsAccountIdLogsControlCmbConfigResponse>;

export const getAccountsAccountIdLogsControlCmbConfig: (
  input: GetAccountsAccountIdLogsControlCmbConfigRequest
) => Effect.Effect<
  GetAccountsAccountIdLogsControlCmbConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccountsAccountIdLogsControlCmbConfigRequest,
  output: GetAccountsAccountIdLogsControlCmbConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostAccountsAccountIdLogsControlCmbConfigRequest {
  account_id: string;
  body: { allow_out_of_region_access?: boolean; regions?: string };
}

export const PostAccountsAccountIdLogsControlCmbConfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  allow_out_of_region_access: Schema.optional(Schema.Boolean),
  regions: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/logs/control/cmb/config" }),
).annotations({ identifier: "PostAccountsAccountIdLogsControlCmbConfigRequest" }) as unknown as Schema.Schema<PostAccountsAccountIdLogsControlCmbConfigRequest>;

export interface PostAccountsAccountIdLogsControlCmbConfigResponse {
  result: { allow_out_of_region_access?: boolean; regions?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostAccountsAccountIdLogsControlCmbConfigResponse = Schema.Struct({
  result: Schema.Struct({
  allow_out_of_region_access: Schema.optional(Schema.Boolean),
  regions: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostAccountsAccountIdLogsControlCmbConfigResponse" }) as unknown as Schema.Schema<PostAccountsAccountIdLogsControlCmbConfigResponse>;

export const postAccountsAccountIdLogsControlCmbConfig: (
  input: PostAccountsAccountIdLogsControlCmbConfigRequest
) => Effect.Effect<
  PostAccountsAccountIdLogsControlCmbConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostAccountsAccountIdLogsControlCmbConfigRequest,
  output: PostAccountsAccountIdLogsControlCmbConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAccountsAccountIdLogsControlCmbConfigRequest {
  account_id: string;
}

export const DeleteAccountsAccountIdLogsControlCmbConfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/logs/control/cmb/config" }),
).annotations({ identifier: "DeleteAccountsAccountIdLogsControlCmbConfigRequest" }) as unknown as Schema.Schema<DeleteAccountsAccountIdLogsControlCmbConfigRequest>;

export interface DeleteAccountsAccountIdLogsControlCmbConfigResponse {
  result: null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAccountsAccountIdLogsControlCmbConfigResponse = Schema.Struct({
  result: Schema.Literal(null),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAccountsAccountIdLogsControlCmbConfigResponse" }) as unknown as Schema.Schema<DeleteAccountsAccountIdLogsControlCmbConfigResponse>;

export const deleteAccountsAccountIdLogsControlCmbConfig: (
  input: DeleteAccountsAccountIdLogsControlCmbConfigRequest
) => Effect.Effect<
  DeleteAccountsAccountIdLogsControlCmbConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccountsAccountIdLogsControlCmbConfigRequest,
  output: DeleteAccountsAccountIdLogsControlCmbConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListdnsprotectionrulesforaccountRequest {
  account_id: string;
  page?: number;
  per_page?: number;
  order?: string;
  direction?: string;
}

export const ListdnsprotectionrulesforaccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.String).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.String).pipe(T.HttpQuery("direction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/advanced_dns_protection/configs/dns_protection/rules" }),
).annotations({ identifier: "ListdnsprotectionrulesforaccountRequest" }) as unknown as Schema.Schema<ListdnsprotectionrulesforaccountRequest>;

export interface ListdnsprotectionrulesforaccountResponse {
  result: { burst_sensitivity: string; created_on: string; id: string; mode: string; modified_on: string; name: string; profile_sensitivity: string; rate_sensitivity: string; scope: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListdnsprotectionrulesforaccountResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  burst_sensitivity: Schema.String,
  created_on: Schema.Date,
  id: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date,
  name: Schema.String,
  profile_sensitivity: Schema.String,
  rate_sensitivity: Schema.String,
  scope: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListdnsprotectionrulesforaccountResponse" }) as unknown as Schema.Schema<ListdnsprotectionrulesforaccountResponse>;

export const listdnsprotectionrulesforaccount: (
  input: ListdnsprotectionrulesforaccountRequest
) => Effect.Effect<
  ListdnsprotectionrulesforaccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListdnsprotectionrulesforaccountRequest,
  output: ListdnsprotectionrulesforaccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatednsprotectionruleRequest {
  account_id: string;
  body: { burst_sensitivity: string; mode: string; name: string; profile_sensitivity: string; rate_sensitivity: string; scope: string };
}

export const CreatednsprotectionruleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  burst_sensitivity: Schema.String,
  mode: Schema.String,
  name: Schema.String,
  profile_sensitivity: Schema.String,
  rate_sensitivity: Schema.String,
  scope: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/advanced_dns_protection/configs/dns_protection/rules" }),
).annotations({ identifier: "CreatednsprotectionruleRequest" }) as unknown as Schema.Schema<CreatednsprotectionruleRequest>;

export interface CreatednsprotectionruleResponse {
  result: { burst_sensitivity: string; created_on: string; id: string; mode: string; modified_on: string; name: string; profile_sensitivity: string; rate_sensitivity: string; scope: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatednsprotectionruleResponse = Schema.Struct({
  result: Schema.Struct({
  burst_sensitivity: Schema.String,
  created_on: Schema.Date,
  id: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date,
  name: Schema.String,
  profile_sensitivity: Schema.String,
  rate_sensitivity: Schema.String,
  scope: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatednsprotectionruleResponse" }) as unknown as Schema.Schema<CreatednsprotectionruleResponse>;

export const creatednsprotectionrule: (
  input: CreatednsprotectionruleRequest
) => Effect.Effect<
  CreatednsprotectionruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatednsprotectionruleRequest,
  output: CreatednsprotectionruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletednsprotectionrulesforaccountRequest {
  account_id: string;
}

export const DeletednsprotectionrulesforaccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/advanced_dns_protection/configs/dns_protection/rules" }),
).annotations({ identifier: "DeletednsprotectionrulesforaccountRequest" }) as unknown as Schema.Schema<DeletednsprotectionrulesforaccountRequest>;

export interface DeletednsprotectionrulesforaccountResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletednsprotectionrulesforaccountResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletednsprotectionrulesforaccountResponse" }) as unknown as Schema.Schema<DeletednsprotectionrulesforaccountResponse>;

export const deletednsprotectionrulesforaccount: (
  input: DeletednsprotectionrulesforaccountRequest
) => Effect.Effect<
  DeletednsprotectionrulesforaccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletednsprotectionrulesforaccountRequest,
  output: DeletednsprotectionrulesforaccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetdnsprotectionruleRequest {
  account_id: string;
  rule_id: string;
}

export const GetdnsprotectionruleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  rule_id: Schema.String.pipe(T.HttpPath("rule_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/advanced_dns_protection/configs/dns_protection/rules/{rule_id}" }),
).annotations({ identifier: "GetdnsprotectionruleRequest" }) as unknown as Schema.Schema<GetdnsprotectionruleRequest>;

export interface GetdnsprotectionruleResponse {
  result: { burst_sensitivity: string; created_on: string; id: string; mode: string; modified_on: string; name: string; profile_sensitivity: string; rate_sensitivity: string; scope: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetdnsprotectionruleResponse = Schema.Struct({
  result: Schema.Struct({
  burst_sensitivity: Schema.String,
  created_on: Schema.Date,
  id: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date,
  name: Schema.String,
  profile_sensitivity: Schema.String,
  rate_sensitivity: Schema.String,
  scope: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetdnsprotectionruleResponse" }) as unknown as Schema.Schema<GetdnsprotectionruleResponse>;

export const getdnsprotectionrule: (
  input: GetdnsprotectionruleRequest
) => Effect.Effect<
  GetdnsprotectionruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetdnsprotectionruleRequest,
  output: GetdnsprotectionruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletednsprotectionruleRequest {
  account_id: string;
  rule_id: string;
}

export const DeletednsprotectionruleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  rule_id: Schema.String.pipe(T.HttpPath("rule_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/advanced_dns_protection/configs/dns_protection/rules/{rule_id}" }),
).annotations({ identifier: "DeletednsprotectionruleRequest" }) as unknown as Schema.Schema<DeletednsprotectionruleRequest>;

export interface DeletednsprotectionruleResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletednsprotectionruleResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletednsprotectionruleResponse" }) as unknown as Schema.Schema<DeletednsprotectionruleResponse>;

export const deletednsprotectionrule: (
  input: DeletednsprotectionruleRequest
) => Effect.Effect<
  DeletednsprotectionruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletednsprotectionruleRequest,
  output: DeletednsprotectionruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatednsprotectionruleRequest {
  account_id: string;
  rule_id: string;
  body: { burst_sensitivity?: string; mode?: string; profile_sensitivity?: string; rate_sensitivity?: string };
}

export const UpdatednsprotectionruleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  body: Schema.Struct({
  burst_sensitivity: Schema.optional(Schema.String),
  mode: Schema.optional(Schema.String),
  profile_sensitivity: Schema.optional(Schema.String),
  rate_sensitivity: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/advanced_dns_protection/configs/dns_protection/rules/{rule_id}" }),
).annotations({ identifier: "UpdatednsprotectionruleRequest" }) as unknown as Schema.Schema<UpdatednsprotectionruleRequest>;

export interface UpdatednsprotectionruleResponse {
  result: { burst_sensitivity: string; created_on: string; id: string; mode: string; modified_on: string; name: string; profile_sensitivity: string; rate_sensitivity: string; scope: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatednsprotectionruleResponse = Schema.Struct({
  result: Schema.Struct({
  burst_sensitivity: Schema.String,
  created_on: Schema.Date,
  id: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date,
  name: Schema.String,
  profile_sensitivity: Schema.String,
  rate_sensitivity: Schema.String,
  scope: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatednsprotectionruleResponse" }) as unknown as Schema.Schema<UpdatednsprotectionruleResponse>;

export const updatednsprotectionrule: (
  input: UpdatednsprotectionruleRequest
) => Effect.Effect<
  UpdatednsprotectionruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatednsprotectionruleRequest,
  output: UpdatednsprotectionruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListallowlistprefixesforaccountRequest {
  account_id: string;
  page?: number;
  per_page?: number;
  order?: string;
  direction?: string;
}

export const ListallowlistprefixesforaccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.String).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.String).pipe(T.HttpQuery("direction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/allowlist" }),
).annotations({ identifier: "ListallowlistprefixesforaccountRequest" }) as unknown as Schema.Schema<ListallowlistprefixesforaccountRequest>;

export interface ListallowlistprefixesforaccountResponse {
  result: { comment: string; created_on: string; enabled: boolean; id: string; modified_on: string; prefix: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListallowlistprefixesforaccountResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  comment: Schema.String,
  created_on: Schema.Date,
  enabled: Schema.Boolean,
  id: Schema.String,
  modified_on: Schema.Date,
  prefix: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListallowlistprefixesforaccountResponse" }) as unknown as Schema.Schema<ListallowlistprefixesforaccountResponse>;

export const listallowlistprefixesforaccount: (
  input: ListallowlistprefixesforaccountRequest
) => Effect.Effect<
  ListallowlistprefixesforaccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListallowlistprefixesforaccountRequest,
  output: ListallowlistprefixesforaccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateallowlistedprefixRequest {
  account_id: string;
  body: { comment: string; enabled: boolean; prefix: string };
}

export const CreateallowlistedprefixRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  comment: Schema.String,
  enabled: Schema.Boolean,
  prefix: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/allowlist" }),
).annotations({ identifier: "CreateallowlistedprefixRequest" }) as unknown as Schema.Schema<CreateallowlistedprefixRequest>;

export interface CreateallowlistedprefixResponse {
  result: { comment: string; created_on: string; enabled: boolean; id: string; modified_on: string; prefix: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateallowlistedprefixResponse = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.String,
  created_on: Schema.Date,
  enabled: Schema.Boolean,
  id: Schema.String,
  modified_on: Schema.Date,
  prefix: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateallowlistedprefixResponse" }) as unknown as Schema.Schema<CreateallowlistedprefixResponse>;

export const createallowlistedprefix: (
  input: CreateallowlistedprefixRequest
) => Effect.Effect<
  CreateallowlistedprefixResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateallowlistedprefixRequest,
  output: CreateallowlistedprefixResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteallowlistprefixesforaccountRequest {
  account_id: string;
}

export const DeleteallowlistprefixesforaccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/allowlist" }),
).annotations({ identifier: "DeleteallowlistprefixesforaccountRequest" }) as unknown as Schema.Schema<DeleteallowlistprefixesforaccountRequest>;

export interface DeleteallowlistprefixesforaccountResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteallowlistprefixesforaccountResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteallowlistprefixesforaccountResponse" }) as unknown as Schema.Schema<DeleteallowlistprefixesforaccountResponse>;

export const deleteallowlistprefixesforaccount: (
  input: DeleteallowlistprefixesforaccountRequest
) => Effect.Effect<
  DeleteallowlistprefixesforaccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteallowlistprefixesforaccountRequest,
  output: DeleteallowlistprefixesforaccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetallowlistprefixRequest {
  account_id: string;
  prefix_id: string;
}

export const GetallowlistprefixRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/allowlist/{prefix_id}" }),
).annotations({ identifier: "GetallowlistprefixRequest" }) as unknown as Schema.Schema<GetallowlistprefixRequest>;

export interface GetallowlistprefixResponse {
  result: { comment: string; created_on: string; enabled: boolean; id: string; modified_on: string; prefix: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetallowlistprefixResponse = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.String,
  created_on: Schema.Date,
  enabled: Schema.Boolean,
  id: Schema.String,
  modified_on: Schema.Date,
  prefix: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetallowlistprefixResponse" }) as unknown as Schema.Schema<GetallowlistprefixResponse>;

export const getallowlistprefix: (
  input: GetallowlistprefixRequest
) => Effect.Effect<
  GetallowlistprefixResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetallowlistprefixRequest,
  output: GetallowlistprefixResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteallowlistprefixRequest {
  account_id: string;
  prefix_id: string;
}

export const DeleteallowlistprefixRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/allowlist/{prefix_id}" }),
).annotations({ identifier: "DeleteallowlistprefixRequest" }) as unknown as Schema.Schema<DeleteallowlistprefixRequest>;

export interface DeleteallowlistprefixResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteallowlistprefixResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteallowlistprefixResponse" }) as unknown as Schema.Schema<DeleteallowlistprefixResponse>;

export const deleteallowlistprefix: (
  input: DeleteallowlistprefixRequest
) => Effect.Effect<
  DeleteallowlistprefixResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteallowlistprefixRequest,
  output: DeleteallowlistprefixResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateallowlistprefixRequest {
  account_id: string;
  prefix_id: string;
  body: { comment?: string; enabled?: boolean };
}

export const UpdateallowlistprefixRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  body: Schema.Struct({
  comment: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/allowlist/{prefix_id}" }),
).annotations({ identifier: "UpdateallowlistprefixRequest" }) as unknown as Schema.Schema<UpdateallowlistprefixRequest>;

export interface UpdateallowlistprefixResponse {
  result: { comment: string; created_on: string; enabled: boolean; id: string; modified_on: string; prefix: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateallowlistprefixResponse = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.String,
  created_on: Schema.Date,
  enabled: Schema.Boolean,
  id: Schema.String,
  modified_on: Schema.Date,
  prefix: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateallowlistprefixResponse" }) as unknown as Schema.Schema<UpdateallowlistprefixResponse>;

export const updateallowlistprefix: (
  input: UpdateallowlistprefixRequest
) => Effect.Effect<
  UpdateallowlistprefixResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateallowlistprefixRequest,
  output: UpdateallowlistprefixResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListprefixesforaccountRequest {
  account_id: string;
  page?: number;
  per_page?: number;
  order?: string;
  direction?: string;
}

export const ListprefixesforaccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.String).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.String).pipe(T.HttpQuery("direction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/prefixes" }),
).annotations({ identifier: "ListprefixesforaccountRequest" }) as unknown as Schema.Schema<ListprefixesforaccountRequest>;

export interface ListprefixesforaccountResponse {
  result: { comment: string; created_on: string; excluded: boolean; id: string; modified_on: string; prefix: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListprefixesforaccountResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  comment: Schema.String,
  created_on: Schema.Date,
  excluded: Schema.Boolean,
  id: Schema.String,
  modified_on: Schema.Date,
  prefix: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListprefixesforaccountResponse" }) as unknown as Schema.Schema<ListprefixesforaccountResponse>;

export const listprefixesforaccount: (
  input: ListprefixesforaccountRequest
) => Effect.Effect<
  ListprefixesforaccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListprefixesforaccountRequest,
  output: ListprefixesforaccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateprefixRequest {
  account_id: string;
  body: { comment: string; excluded: boolean; prefix: string };
}

export const CreateprefixRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  comment: Schema.String,
  excluded: Schema.Boolean,
  prefix: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/prefixes" }),
).annotations({ identifier: "CreateprefixRequest" }) as unknown as Schema.Schema<CreateprefixRequest>;

export interface CreateprefixResponse {
  result: { comment: string; created_on: string; excluded: boolean; id: string; modified_on: string; prefix: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateprefixResponse = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.String,
  created_on: Schema.Date,
  excluded: Schema.Boolean,
  id: Schema.String,
  modified_on: Schema.Date,
  prefix: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateprefixResponse" }) as unknown as Schema.Schema<CreateprefixResponse>;

export const createprefix: (
  input: CreateprefixRequest
) => Effect.Effect<
  CreateprefixResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateprefixRequest,
  output: CreateprefixResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteprefixesforaccountRequest {
  account_id: string;
}

export const DeleteprefixesforaccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/prefixes" }),
).annotations({ identifier: "DeleteprefixesforaccountRequest" }) as unknown as Schema.Schema<DeleteprefixesforaccountRequest>;

export interface DeleteprefixesforaccountResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteprefixesforaccountResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteprefixesforaccountResponse" }) as unknown as Schema.Schema<DeleteprefixesforaccountResponse>;

export const deleteprefixesforaccount: (
  input: DeleteprefixesforaccountRequest
) => Effect.Effect<
  DeleteprefixesforaccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteprefixesforaccountRequest,
  output: DeleteprefixesforaccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface BulkcreateprefixesRequest {
  account_id: string;
  body: { comment: string; excluded: boolean; prefix: string }[];
}

export const BulkcreateprefixesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Struct({
  comment: Schema.String,
  excluded: Schema.Boolean,
  prefix: Schema.String
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/prefixes/bulk" }),
).annotations({ identifier: "BulkcreateprefixesRequest" }) as unknown as Schema.Schema<BulkcreateprefixesRequest>;

export interface BulkcreateprefixesResponse {
  result: { comment: string; created_on: string; excluded: boolean; id: string; modified_on: string; prefix: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const BulkcreateprefixesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  comment: Schema.String,
  created_on: Schema.Date,
  excluded: Schema.Boolean,
  id: Schema.String,
  modified_on: Schema.Date,
  prefix: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "BulkcreateprefixesResponse" }) as unknown as Schema.Schema<BulkcreateprefixesResponse>;

export const bulkcreateprefixes: (
  input: BulkcreateprefixesRequest
) => Effect.Effect<
  BulkcreateprefixesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: BulkcreateprefixesRequest,
  output: BulkcreateprefixesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetprefixRequest {
  account_id: string;
  prefix_id: string;
}

export const GetprefixRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/prefixes/{prefix_id}" }),
).annotations({ identifier: "GetprefixRequest" }) as unknown as Schema.Schema<GetprefixRequest>;

export interface GetprefixResponse {
  result: { comment: string; created_on: string; excluded: boolean; id: string; modified_on: string; prefix: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetprefixResponse = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.String,
  created_on: Schema.Date,
  excluded: Schema.Boolean,
  id: Schema.String,
  modified_on: Schema.Date,
  prefix: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetprefixResponse" }) as unknown as Schema.Schema<GetprefixResponse>;

export const getprefix: (
  input: GetprefixRequest
) => Effect.Effect<
  GetprefixResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetprefixRequest,
  output: GetprefixResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteprefixRequest {
  account_id: string;
  prefix_id: string;
}

export const DeleteprefixRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/prefixes/{prefix_id}" }),
).annotations({ identifier: "DeleteprefixRequest" }) as unknown as Schema.Schema<DeleteprefixRequest>;

export interface DeleteprefixResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteprefixResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteprefixResponse" }) as unknown as Schema.Schema<DeleteprefixResponse>;

export const deleteprefix: (
  input: DeleteprefixRequest
) => Effect.Effect<
  DeleteprefixResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteprefixRequest,
  output: DeleteprefixResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateprefixRequest {
  account_id: string;
  prefix_id: string;
  body: { comment?: string; excluded?: boolean };
}

export const UpdateprefixRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  prefix_id: Schema.String.pipe(T.HttpPath("prefix_id")),
  body: Schema.Struct({
  comment: Schema.optional(Schema.String),
  excluded: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/prefixes/{prefix_id}" }),
).annotations({ identifier: "UpdateprefixRequest" }) as unknown as Schema.Schema<UpdateprefixRequest>;

export interface UpdateprefixResponse {
  result: { comment: string; created_on: string; excluded: boolean; id: string; modified_on: string; prefix: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateprefixResponse = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.String,
  created_on: Schema.Date,
  excluded: Schema.Boolean,
  id: Schema.String,
  modified_on: Schema.Date,
  prefix: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateprefixResponse" }) as unknown as Schema.Schema<UpdateprefixResponse>;

export const updateprefix: (
  input: UpdateprefixRequest
) => Effect.Effect<
  UpdateprefixResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateprefixRequest,
  output: UpdateprefixResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListsynprotectionfiltersforaccountRequest {
  account_id: string;
  mode?: string;
  page?: number;
  per_page?: number;
  order?: string;
  direction?: string;
}

export const ListsynprotectionfiltersforaccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  mode: Schema.optional(Schema.String).pipe(T.HttpQuery("mode")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.String).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.String).pipe(T.HttpQuery("direction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/syn_protection/filters" }),
).annotations({ identifier: "ListsynprotectionfiltersforaccountRequest" }) as unknown as Schema.Schema<ListsynprotectionfiltersforaccountRequest>;

export interface ListsynprotectionfiltersforaccountResponse {
  result: { created_on: string; expression: string; id: string; mode: string; modified_on: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListsynprotectionfiltersforaccountResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_on: Schema.Date,
  expression: Schema.String,
  id: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListsynprotectionfiltersforaccountResponse" }) as unknown as Schema.Schema<ListsynprotectionfiltersforaccountResponse>;

export const listsynprotectionfiltersforaccount: (
  input: ListsynprotectionfiltersforaccountRequest
) => Effect.Effect<
  ListsynprotectionfiltersforaccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListsynprotectionfiltersforaccountRequest,
  output: ListsynprotectionfiltersforaccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatesynprotectionfilterRequest {
  account_id: string;
  body: { expression: string; mode: string };
}

export const CreatesynprotectionfilterRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  expression: Schema.String,
  mode: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/syn_protection/filters" }),
).annotations({ identifier: "CreatesynprotectionfilterRequest" }) as unknown as Schema.Schema<CreatesynprotectionfilterRequest>;

export interface CreatesynprotectionfilterResponse {
  result: { created_on: string; expression: string; id: string; mode: string; modified_on: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatesynprotectionfilterResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.Date,
  expression: Schema.String,
  id: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatesynprotectionfilterResponse" }) as unknown as Schema.Schema<CreatesynprotectionfilterResponse>;

export const createsynprotectionfilter: (
  input: CreatesynprotectionfilterRequest
) => Effect.Effect<
  CreatesynprotectionfilterResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatesynprotectionfilterRequest,
  output: CreatesynprotectionfilterResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletesynprotectionfiltersforaccountRequest {
  account_id: string;
}

export const DeletesynprotectionfiltersforaccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/syn_protection/filters" }),
).annotations({ identifier: "DeletesynprotectionfiltersforaccountRequest" }) as unknown as Schema.Schema<DeletesynprotectionfiltersforaccountRequest>;

export interface DeletesynprotectionfiltersforaccountResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletesynprotectionfiltersforaccountResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletesynprotectionfiltersforaccountResponse" }) as unknown as Schema.Schema<DeletesynprotectionfiltersforaccountResponse>;

export const deletesynprotectionfiltersforaccount: (
  input: DeletesynprotectionfiltersforaccountRequest
) => Effect.Effect<
  DeletesynprotectionfiltersforaccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletesynprotectionfiltersforaccountRequest,
  output: DeletesynprotectionfiltersforaccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetsynprotectionfilterRequest {
  account_id: string;
  filter_id: string;
}

export const GetsynprotectionfilterRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  filter_id: Schema.String.pipe(T.HttpPath("filter_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/syn_protection/filters/{filter_id}" }),
).annotations({ identifier: "GetsynprotectionfilterRequest" }) as unknown as Schema.Schema<GetsynprotectionfilterRequest>;

export interface GetsynprotectionfilterResponse {
  result: { created_on: string; expression: string; id: string; mode: string; modified_on: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetsynprotectionfilterResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.Date,
  expression: Schema.String,
  id: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetsynprotectionfilterResponse" }) as unknown as Schema.Schema<GetsynprotectionfilterResponse>;

export const getsynprotectionfilter: (
  input: GetsynprotectionfilterRequest
) => Effect.Effect<
  GetsynprotectionfilterResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetsynprotectionfilterRequest,
  output: GetsynprotectionfilterResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletesynprotectionfilterRequest {
  account_id: string;
  filter_id: string;
}

export const DeletesynprotectionfilterRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  filter_id: Schema.String.pipe(T.HttpPath("filter_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/syn_protection/filters/{filter_id}" }),
).annotations({ identifier: "DeletesynprotectionfilterRequest" }) as unknown as Schema.Schema<DeletesynprotectionfilterRequest>;

export interface DeletesynprotectionfilterResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletesynprotectionfilterResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletesynprotectionfilterResponse" }) as unknown as Schema.Schema<DeletesynprotectionfilterResponse>;

export const deletesynprotectionfilter: (
  input: DeletesynprotectionfilterRequest
) => Effect.Effect<
  DeletesynprotectionfilterResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletesynprotectionfilterRequest,
  output: DeletesynprotectionfilterResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatesynprotectionfilterRequest {
  account_id: string;
  filter_id: string;
  body: { expression?: string; mode?: string };
}

export const UpdatesynprotectionfilterRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  filter_id: Schema.String.pipe(T.HttpPath("filter_id")),
  body: Schema.Struct({
  expression: Schema.optional(Schema.String),
  mode: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/syn_protection/filters/{filter_id}" }),
).annotations({ identifier: "UpdatesynprotectionfilterRequest" }) as unknown as Schema.Schema<UpdatesynprotectionfilterRequest>;

export interface UpdatesynprotectionfilterResponse {
  result: { created_on: string; expression: string; id: string; mode: string; modified_on: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatesynprotectionfilterResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.Date,
  expression: Schema.String,
  id: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatesynprotectionfilterResponse" }) as unknown as Schema.Schema<UpdatesynprotectionfilterResponse>;

export const updatesynprotectionfilter: (
  input: UpdatesynprotectionfilterRequest
) => Effect.Effect<
  UpdatesynprotectionfilterResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatesynprotectionfilterRequest,
  output: UpdatesynprotectionfilterResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListsynprotectionrulesforaccountRequest {
  account_id: string;
  page?: number;
  per_page?: number;
  order?: string;
  direction?: string;
}

export const ListsynprotectionrulesforaccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.String).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.String).pipe(T.HttpQuery("direction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/syn_protection/rules" }),
).annotations({ identifier: "ListsynprotectionrulesforaccountRequest" }) as unknown as Schema.Schema<ListsynprotectionrulesforaccountRequest>;

export interface ListsynprotectionrulesforaccountResponse {
  result: { burst_sensitivity: string; created_on: string; id: string; mitigation_type: string; mode: string; modified_on: string; name: string; rate_sensitivity: string; scope: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListsynprotectionrulesforaccountResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  burst_sensitivity: Schema.String,
  created_on: Schema.Date,
  id: Schema.String,
  mitigation_type: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date,
  name: Schema.String,
  rate_sensitivity: Schema.String,
  scope: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListsynprotectionrulesforaccountResponse" }) as unknown as Schema.Schema<ListsynprotectionrulesforaccountResponse>;

export const listsynprotectionrulesforaccount: (
  input: ListsynprotectionrulesforaccountRequest
) => Effect.Effect<
  ListsynprotectionrulesforaccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListsynprotectionrulesforaccountRequest,
  output: ListsynprotectionrulesforaccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatesynprotectionruleRequest {
  account_id: string;
  body: { burst_sensitivity: string; mitigation_type?: string; mode: string; name: string; rate_sensitivity: string; scope: string };
}

export const CreatesynprotectionruleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  burst_sensitivity: Schema.String,
  mitigation_type: Schema.optional(Schema.String),
  mode: Schema.String,
  name: Schema.String,
  rate_sensitivity: Schema.String,
  scope: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/syn_protection/rules" }),
).annotations({ identifier: "CreatesynprotectionruleRequest" }) as unknown as Schema.Schema<CreatesynprotectionruleRequest>;

export interface CreatesynprotectionruleResponse {
  result: { burst_sensitivity: string; created_on: string; id: string; mitigation_type: string; mode: string; modified_on: string; name: string; rate_sensitivity: string; scope: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatesynprotectionruleResponse = Schema.Struct({
  result: Schema.Struct({
  burst_sensitivity: Schema.String,
  created_on: Schema.Date,
  id: Schema.String,
  mitigation_type: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date,
  name: Schema.String,
  rate_sensitivity: Schema.String,
  scope: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatesynprotectionruleResponse" }) as unknown as Schema.Schema<CreatesynprotectionruleResponse>;

export const createsynprotectionrule: (
  input: CreatesynprotectionruleRequest
) => Effect.Effect<
  CreatesynprotectionruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatesynprotectionruleRequest,
  output: CreatesynprotectionruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletesynprotectionrulesforaccountRequest {
  account_id: string;
}

export const DeletesynprotectionrulesforaccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/syn_protection/rules" }),
).annotations({ identifier: "DeletesynprotectionrulesforaccountRequest" }) as unknown as Schema.Schema<DeletesynprotectionrulesforaccountRequest>;

export interface DeletesynprotectionrulesforaccountResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletesynprotectionrulesforaccountResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletesynprotectionrulesforaccountResponse" }) as unknown as Schema.Schema<DeletesynprotectionrulesforaccountResponse>;

export const deletesynprotectionrulesforaccount: (
  input: DeletesynprotectionrulesforaccountRequest
) => Effect.Effect<
  DeletesynprotectionrulesforaccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletesynprotectionrulesforaccountRequest,
  output: DeletesynprotectionrulesforaccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetsynprotectionruleRequest {
  account_id: string;
  rule_id: string;
}

export const GetsynprotectionruleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  rule_id: Schema.String.pipe(T.HttpPath("rule_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/syn_protection/rules/{rule_id}" }),
).annotations({ identifier: "GetsynprotectionruleRequest" }) as unknown as Schema.Schema<GetsynprotectionruleRequest>;

export interface GetsynprotectionruleResponse {
  result: { burst_sensitivity: string; created_on: string; id: string; mitigation_type: string; mode: string; modified_on: string; name: string; rate_sensitivity: string; scope: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetsynprotectionruleResponse = Schema.Struct({
  result: Schema.Struct({
  burst_sensitivity: Schema.String,
  created_on: Schema.Date,
  id: Schema.String,
  mitigation_type: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date,
  name: Schema.String,
  rate_sensitivity: Schema.String,
  scope: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetsynprotectionruleResponse" }) as unknown as Schema.Schema<GetsynprotectionruleResponse>;

export const getsynprotectionrule: (
  input: GetsynprotectionruleRequest
) => Effect.Effect<
  GetsynprotectionruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetsynprotectionruleRequest,
  output: GetsynprotectionruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletesynprotectionruleRequest {
  account_id: string;
  rule_id: string;
}

export const DeletesynprotectionruleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  rule_id: Schema.String.pipe(T.HttpPath("rule_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/syn_protection/rules/{rule_id}" }),
).annotations({ identifier: "DeletesynprotectionruleRequest" }) as unknown as Schema.Schema<DeletesynprotectionruleRequest>;

export interface DeletesynprotectionruleResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletesynprotectionruleResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletesynprotectionruleResponse" }) as unknown as Schema.Schema<DeletesynprotectionruleResponse>;

export const deletesynprotectionrule: (
  input: DeletesynprotectionruleRequest
) => Effect.Effect<
  DeletesynprotectionruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletesynprotectionruleRequest,
  output: DeletesynprotectionruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatesynprotectionruleRequest {
  account_id: string;
  rule_id: string;
  body: { burst_sensitivity?: string; mitigation_type?: string; mode?: string; rate_sensitivity?: string };
}

export const UpdatesynprotectionruleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  body: Schema.Struct({
  burst_sensitivity: Schema.optional(Schema.String),
  mitigation_type: Schema.optional(Schema.String),
  mode: Schema.optional(Schema.String),
  rate_sensitivity: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/syn_protection/rules/{rule_id}" }),
).annotations({ identifier: "UpdatesynprotectionruleRequest" }) as unknown as Schema.Schema<UpdatesynprotectionruleRequest>;

export interface UpdatesynprotectionruleResponse {
  result: { burst_sensitivity: string; created_on: string; id: string; mitigation_type: string; mode: string; modified_on: string; name: string; rate_sensitivity: string; scope: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatesynprotectionruleResponse = Schema.Struct({
  result: Schema.Struct({
  burst_sensitivity: Schema.String,
  created_on: Schema.Date,
  id: Schema.String,
  mitigation_type: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date,
  name: Schema.String,
  rate_sensitivity: Schema.String,
  scope: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatesynprotectionruleResponse" }) as unknown as Schema.Schema<UpdatesynprotectionruleResponse>;

export const updatesynprotectionrule: (
  input: UpdatesynprotectionruleRequest
) => Effect.Effect<
  UpdatesynprotectionruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatesynprotectionruleRequest,
  output: UpdatesynprotectionruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListtcpflowprotectionfiltersforaccountRequest {
  account_id: string;
  mode?: string;
  page?: number;
  per_page?: number;
  order?: string;
  direction?: string;
}

export const ListtcpflowprotectionfiltersforaccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  mode: Schema.optional(Schema.String).pipe(T.HttpQuery("mode")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.String).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.String).pipe(T.HttpQuery("direction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/tcp_flow_protection/filters" }),
).annotations({ identifier: "ListtcpflowprotectionfiltersforaccountRequest" }) as unknown as Schema.Schema<ListtcpflowprotectionfiltersforaccountRequest>;

export interface ListtcpflowprotectionfiltersforaccountResponse {
  result: { created_on: string; expression: string; id: string; mode: string; modified_on: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListtcpflowprotectionfiltersforaccountResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_on: Schema.Date,
  expression: Schema.String,
  id: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListtcpflowprotectionfiltersforaccountResponse" }) as unknown as Schema.Schema<ListtcpflowprotectionfiltersforaccountResponse>;

export const listtcpflowprotectionfiltersforaccount: (
  input: ListtcpflowprotectionfiltersforaccountRequest
) => Effect.Effect<
  ListtcpflowprotectionfiltersforaccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListtcpflowprotectionfiltersforaccountRequest,
  output: ListtcpflowprotectionfiltersforaccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatetcpflowprotectionfilterRequest {
  account_id: string;
  body: { expression: string; mode: string };
}

export const CreatetcpflowprotectionfilterRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  expression: Schema.String,
  mode: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/tcp_flow_protection/filters" }),
).annotations({ identifier: "CreatetcpflowprotectionfilterRequest" }) as unknown as Schema.Schema<CreatetcpflowprotectionfilterRequest>;

export interface CreatetcpflowprotectionfilterResponse {
  result: { created_on: string; expression: string; id: string; mode: string; modified_on: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatetcpflowprotectionfilterResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.Date,
  expression: Schema.String,
  id: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatetcpflowprotectionfilterResponse" }) as unknown as Schema.Schema<CreatetcpflowprotectionfilterResponse>;

export const createtcpflowprotectionfilter: (
  input: CreatetcpflowprotectionfilterRequest
) => Effect.Effect<
  CreatetcpflowprotectionfilterResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatetcpflowprotectionfilterRequest,
  output: CreatetcpflowprotectionfilterResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletetcpflowprotectionfiltersforaccountRequest {
  account_id: string;
}

export const DeletetcpflowprotectionfiltersforaccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/tcp_flow_protection/filters" }),
).annotations({ identifier: "DeletetcpflowprotectionfiltersforaccountRequest" }) as unknown as Schema.Schema<DeletetcpflowprotectionfiltersforaccountRequest>;

export interface DeletetcpflowprotectionfiltersforaccountResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletetcpflowprotectionfiltersforaccountResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletetcpflowprotectionfiltersforaccountResponse" }) as unknown as Schema.Schema<DeletetcpflowprotectionfiltersforaccountResponse>;

export const deletetcpflowprotectionfiltersforaccount: (
  input: DeletetcpflowprotectionfiltersforaccountRequest
) => Effect.Effect<
  DeletetcpflowprotectionfiltersforaccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletetcpflowprotectionfiltersforaccountRequest,
  output: DeletetcpflowprotectionfiltersforaccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GettcpflowprotectionfilterRequest {
  account_id: string;
  filter_id: string;
}

export const GettcpflowprotectionfilterRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  filter_id: Schema.String.pipe(T.HttpPath("filter_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/tcp_flow_protection/filters/{filter_id}" }),
).annotations({ identifier: "GettcpflowprotectionfilterRequest" }) as unknown as Schema.Schema<GettcpflowprotectionfilterRequest>;

export interface GettcpflowprotectionfilterResponse {
  result: { created_on: string; expression: string; id: string; mode: string; modified_on: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GettcpflowprotectionfilterResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.Date,
  expression: Schema.String,
  id: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GettcpflowprotectionfilterResponse" }) as unknown as Schema.Schema<GettcpflowprotectionfilterResponse>;

export const gettcpflowprotectionfilter: (
  input: GettcpflowprotectionfilterRequest
) => Effect.Effect<
  GettcpflowprotectionfilterResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GettcpflowprotectionfilterRequest,
  output: GettcpflowprotectionfilterResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletetcpflowprotectionfilterRequest {
  account_id: string;
  filter_id: string;
}

export const DeletetcpflowprotectionfilterRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  filter_id: Schema.String.pipe(T.HttpPath("filter_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/tcp_flow_protection/filters/{filter_id}" }),
).annotations({ identifier: "DeletetcpflowprotectionfilterRequest" }) as unknown as Schema.Schema<DeletetcpflowprotectionfilterRequest>;

export interface DeletetcpflowprotectionfilterResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletetcpflowprotectionfilterResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletetcpflowprotectionfilterResponse" }) as unknown as Schema.Schema<DeletetcpflowprotectionfilterResponse>;

export const deletetcpflowprotectionfilter: (
  input: DeletetcpflowprotectionfilterRequest
) => Effect.Effect<
  DeletetcpflowprotectionfilterResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletetcpflowprotectionfilterRequest,
  output: DeletetcpflowprotectionfilterResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatetcpflowprotectionfilterRequest {
  account_id: string;
  filter_id: string;
  body: { expression?: string; mode?: string };
}

export const UpdatetcpflowprotectionfilterRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  filter_id: Schema.String.pipe(T.HttpPath("filter_id")),
  body: Schema.Struct({
  expression: Schema.optional(Schema.String),
  mode: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/tcp_flow_protection/filters/{filter_id}" }),
).annotations({ identifier: "UpdatetcpflowprotectionfilterRequest" }) as unknown as Schema.Schema<UpdatetcpflowprotectionfilterRequest>;

export interface UpdatetcpflowprotectionfilterResponse {
  result: { created_on: string; expression: string; id: string; mode: string; modified_on: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatetcpflowprotectionfilterResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.Date,
  expression: Schema.String,
  id: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatetcpflowprotectionfilterResponse" }) as unknown as Schema.Schema<UpdatetcpflowprotectionfilterResponse>;

export const updatetcpflowprotectionfilter: (
  input: UpdatetcpflowprotectionfilterRequest
) => Effect.Effect<
  UpdatetcpflowprotectionfilterResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatetcpflowprotectionfilterRequest,
  output: UpdatetcpflowprotectionfilterResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListtcpflowprotectionrulesforaccountRequest {
  account_id: string;
  page?: number;
  per_page?: number;
  order?: string;
  direction?: string;
}

export const ListtcpflowprotectionrulesforaccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  order: Schema.optional(Schema.String).pipe(T.HttpQuery("order")),
  direction: Schema.optional(Schema.String).pipe(T.HttpQuery("direction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/tcp_flow_protection/rules" }),
).annotations({ identifier: "ListtcpflowprotectionrulesforaccountRequest" }) as unknown as Schema.Schema<ListtcpflowprotectionrulesforaccountRequest>;

export interface ListtcpflowprotectionrulesforaccountResponse {
  result: { burst_sensitivity: string; created_on: string; id: string; mode: string; modified_on: string; name: string; rate_sensitivity: string; scope: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListtcpflowprotectionrulesforaccountResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  burst_sensitivity: Schema.String,
  created_on: Schema.Date,
  id: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date,
  name: Schema.String,
  rate_sensitivity: Schema.String,
  scope: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListtcpflowprotectionrulesforaccountResponse" }) as unknown as Schema.Schema<ListtcpflowprotectionrulesforaccountResponse>;

export const listtcpflowprotectionrulesforaccount: (
  input: ListtcpflowprotectionrulesforaccountRequest
) => Effect.Effect<
  ListtcpflowprotectionrulesforaccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListtcpflowprotectionrulesforaccountRequest,
  output: ListtcpflowprotectionrulesforaccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatetcpflowprotectionruleRequest {
  account_id: string;
  body: { burst_sensitivity: string; mode: string; name: string; rate_sensitivity: string; scope: string };
}

export const CreatetcpflowprotectionruleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  burst_sensitivity: Schema.String,
  mode: Schema.String,
  name: Schema.String,
  rate_sensitivity: Schema.String,
  scope: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/tcp_flow_protection/rules" }),
).annotations({ identifier: "CreatetcpflowprotectionruleRequest" }) as unknown as Schema.Schema<CreatetcpflowprotectionruleRequest>;

export interface CreatetcpflowprotectionruleResponse {
  result: { burst_sensitivity: string; created_on: string; id: string; mode: string; modified_on: string; name: string; rate_sensitivity: string; scope: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatetcpflowprotectionruleResponse = Schema.Struct({
  result: Schema.Struct({
  burst_sensitivity: Schema.String,
  created_on: Schema.Date,
  id: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date,
  name: Schema.String,
  rate_sensitivity: Schema.String,
  scope: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatetcpflowprotectionruleResponse" }) as unknown as Schema.Schema<CreatetcpflowprotectionruleResponse>;

export const createtcpflowprotectionrule: (
  input: CreatetcpflowprotectionruleRequest
) => Effect.Effect<
  CreatetcpflowprotectionruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatetcpflowprotectionruleRequest,
  output: CreatetcpflowprotectionruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletetcpflowprotectionrulesforaccountRequest {
  account_id: string;
}

export const DeletetcpflowprotectionrulesforaccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/tcp_flow_protection/rules" }),
).annotations({ identifier: "DeletetcpflowprotectionrulesforaccountRequest" }) as unknown as Schema.Schema<DeletetcpflowprotectionrulesforaccountRequest>;

export interface DeletetcpflowprotectionrulesforaccountResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletetcpflowprotectionrulesforaccountResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletetcpflowprotectionrulesforaccountResponse" }) as unknown as Schema.Schema<DeletetcpflowprotectionrulesforaccountResponse>;

export const deletetcpflowprotectionrulesforaccount: (
  input: DeletetcpflowprotectionrulesforaccountRequest
) => Effect.Effect<
  DeletetcpflowprotectionrulesforaccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletetcpflowprotectionrulesforaccountRequest,
  output: DeletetcpflowprotectionrulesforaccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GettcpflowprotectionruleRequest {
  account_id: string;
  rule_id: string;
}

export const GettcpflowprotectionruleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  rule_id: Schema.String.pipe(T.HttpPath("rule_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/tcp_flow_protection/rules/{rule_id}" }),
).annotations({ identifier: "GettcpflowprotectionruleRequest" }) as unknown as Schema.Schema<GettcpflowprotectionruleRequest>;

export interface GettcpflowprotectionruleResponse {
  result: { burst_sensitivity: string; created_on: string; id: string; mode: string; modified_on: string; name: string; rate_sensitivity: string; scope: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GettcpflowprotectionruleResponse = Schema.Struct({
  result: Schema.Struct({
  burst_sensitivity: Schema.String,
  created_on: Schema.Date,
  id: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date,
  name: Schema.String,
  rate_sensitivity: Schema.String,
  scope: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GettcpflowprotectionruleResponse" }) as unknown as Schema.Schema<GettcpflowprotectionruleResponse>;

export const gettcpflowprotectionrule: (
  input: GettcpflowprotectionruleRequest
) => Effect.Effect<
  GettcpflowprotectionruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GettcpflowprotectionruleRequest,
  output: GettcpflowprotectionruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletetcpflowprotectionruleRequest {
  account_id: string;
  rule_id: string;
}

export const DeletetcpflowprotectionruleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  rule_id: Schema.String.pipe(T.HttpPath("rule_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/tcp_flow_protection/rules/{rule_id}" }),
).annotations({ identifier: "DeletetcpflowprotectionruleRequest" }) as unknown as Schema.Schema<DeletetcpflowprotectionruleRequest>;

export interface DeletetcpflowprotectionruleResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletetcpflowprotectionruleResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletetcpflowprotectionruleResponse" }) as unknown as Schema.Schema<DeletetcpflowprotectionruleResponse>;

export const deletetcpflowprotectionrule: (
  input: DeletetcpflowprotectionruleRequest
) => Effect.Effect<
  DeletetcpflowprotectionruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletetcpflowprotectionruleRequest,
  output: DeletetcpflowprotectionruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatetcpflowprotectionruleRequest {
  account_id: string;
  rule_id: string;
  body: { burst_sensitivity?: string; mode?: string; rate_sensitivity?: string };
}

export const UpdatetcpflowprotectionruleRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  body: Schema.Struct({
  burst_sensitivity: Schema.optional(Schema.String),
  mode: Schema.optional(Schema.String),
  rate_sensitivity: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/tcp_flow_protection/rules/{rule_id}" }),
).annotations({ identifier: "UpdatetcpflowprotectionruleRequest" }) as unknown as Schema.Schema<UpdatetcpflowprotectionruleRequest>;

export interface UpdatetcpflowprotectionruleResponse {
  result: { burst_sensitivity: string; created_on: string; id: string; mode: string; modified_on: string; name: string; rate_sensitivity: string; scope: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatetcpflowprotectionruleResponse = Schema.Struct({
  result: Schema.Struct({
  burst_sensitivity: Schema.String,
  created_on: Schema.Date,
  id: Schema.String,
  mode: Schema.String,
  modified_on: Schema.Date,
  name: Schema.String,
  rate_sensitivity: Schema.String,
  scope: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatetcpflowprotectionruleResponse" }) as unknown as Schema.Schema<UpdatetcpflowprotectionruleResponse>;

export const updatetcpflowprotectionrule: (
  input: UpdatetcpflowprotectionruleRequest
) => Effect.Effect<
  UpdatetcpflowprotectionruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatetcpflowprotectionruleRequest,
  output: UpdatetcpflowprotectionruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetprotectionstatusRequest {
  account_id: string;
}

export const GetprotectionstatusRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/tcp_protection_status" }),
).annotations({ identifier: "GetprotectionstatusRequest" }) as unknown as Schema.Schema<GetprotectionstatusRequest>;

export interface GetprotectionstatusResponse {
  result: { enabled: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetprotectionstatusResponse = Schema.Struct({
  result: Schema.Struct({
  enabled: Schema.Boolean
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetprotectionstatusResponse" }) as unknown as Schema.Schema<GetprotectionstatusResponse>;

export const getprotectionstatus: (
  input: GetprotectionstatusRequest
) => Effect.Effect<
  GetprotectionstatusResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetprotectionstatusRequest,
  output: GetprotectionstatusResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateprotectionstatusRequest {
  account_id: string;
  body: { enabled: boolean };
}

export const UpdateprotectionstatusRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  enabled: Schema.Boolean
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/advanced_tcp_protection/configs/tcp_protection_status" }),
).annotations({ identifier: "UpdateprotectionstatusRequest" }) as unknown as Schema.Schema<UpdateprotectionstatusRequest>;

export interface UpdateprotectionstatusResponse {
  result: { enabled: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateprotectionstatusResponse = Schema.Struct({
  result: Schema.Struct({
  enabled: Schema.Boolean
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateprotectionstatusResponse" }) as unknown as Schema.Schema<UpdateprotectionstatusResponse>;

export const updateprotectionstatus: (
  input: UpdateprotectionstatusRequest
) => Effect.Effect<
  UpdateprotectionstatusResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateprotectionstatusRequest,
  output: UpdateprotectionstatusResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAppsRequest {
  account_id: string;
}

export const ListAppsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/apps" }),
).annotations({ identifier: "ListAppsRequest" }) as unknown as Schema.Schema<ListAppsRequest>;

export interface ListAppsResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAppsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAppsResponse" }) as unknown as Schema.Schema<ListAppsResponse>;

export const listApps: (
  input: ListAppsRequest
) => Effect.Effect<
  ListAppsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAppsRequest,
  output: ListAppsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MagicAccountAppsAddAppRequest {
  account_id: string;
  body: { hostnames?: string[]; ip_subnets?: unknown[]; name: string; type: string };
}

export const MagicAccountAppsAddAppRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  hostnames: Schema.optional(Schema.Array(Schema.String)),
  ip_subnets: Schema.optional(Schema.Array(Schema.Unknown)),
  name: Schema.String,
  type: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/apps" }),
).annotations({ identifier: "MagicAccountAppsAddAppRequest" }) as unknown as Schema.Schema<MagicAccountAppsAddAppRequest>;

export interface MagicAccountAppsAddAppResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MagicAccountAppsAddAppResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MagicAccountAppsAddAppResponse" }) as unknown as Schema.Schema<MagicAccountAppsAddAppResponse>;

export const magicAccountAppsAddApp: (
  input: MagicAccountAppsAddAppRequest
) => Effect.Effect<
  MagicAccountAppsAddAppResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MagicAccountAppsAddAppRequest,
  output: MagicAccountAppsAddAppResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAppRequest {
  account_id: string;
  account_app_id: string;
  body: { hostnames?: string[]; ip_subnets?: unknown[]; name?: string; type?: string };
}

export const UpdateAppRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  account_app_id: Schema.String.pipe(T.HttpPath("account_app_id")),
  body: Schema.Struct({
  hostnames: Schema.optional(Schema.Array(Schema.String)),
  ip_subnets: Schema.optional(Schema.Array(Schema.Unknown)),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/apps/{account_app_id}" }),
).annotations({ identifier: "UpdateAppRequest" }) as unknown as Schema.Schema<UpdateAppRequest>;

export interface UpdateAppResponse {
  result: { account_app_id: string; hostnames?: string[]; ip_subnets?: unknown[]; name?: string; type?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAppResponse = Schema.Struct({
  result: Schema.Struct({
  account_app_id: Schema.String,
  hostnames: Schema.optional(Schema.Array(Schema.String)),
  ip_subnets: Schema.optional(Schema.Array(Schema.Unknown)),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAppResponse" }) as unknown as Schema.Schema<UpdateAppResponse>;

export const updateApp: (
  input: UpdateAppRequest
) => Effect.Effect<
  UpdateAppResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAppRequest,
  output: UpdateAppResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteApp1Request {
  account_id: string;
  account_app_id: string;
}

export const DeleteApp1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  account_app_id: Schema.String.pipe(T.HttpPath("account_app_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/apps/{account_app_id}" }),
).annotations({ identifier: "DeleteApp1Request" }) as unknown as Schema.Schema<DeleteApp1Request>;

export interface DeleteApp1Response {
  result: { account_app_id: string; hostnames?: string[]; ip_subnets?: unknown[]; name?: string; type?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteApp1Response = Schema.Struct({
  result: Schema.Struct({
  account_app_id: Schema.String,
  hostnames: Schema.optional(Schema.Array(Schema.String)),
  ip_subnets: Schema.optional(Schema.Array(Schema.Unknown)),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteApp1Response" }) as unknown as Schema.Schema<DeleteApp1Response>;

export const deleteApp1: (
  input: DeleteApp1Request
) => Effect.Effect<
  DeleteApp1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteApp1Request,
  output: DeleteApp1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchAppRequest {
  account_id: string;
  account_app_id: string;
  body: { hostnames?: string[]; ip_subnets?: unknown[]; name?: string; type?: string };
}

export const PatchAppRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  account_app_id: Schema.String.pipe(T.HttpPath("account_app_id")),
  body: Schema.Struct({
  hostnames: Schema.optional(Schema.Array(Schema.String)),
  ip_subnets: Schema.optional(Schema.Array(Schema.Unknown)),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/apps/{account_app_id}" }),
).annotations({ identifier: "PatchAppRequest" }) as unknown as Schema.Schema<PatchAppRequest>;

export interface PatchAppResponse {
  result: { account_app_id: string; hostnames?: string[]; ip_subnets?: unknown[]; name?: string; type?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchAppResponse = Schema.Struct({
  result: Schema.Struct({
  account_app_id: Schema.String,
  hostnames: Schema.optional(Schema.Array(Schema.String)),
  ip_subnets: Schema.optional(Schema.Array(Schema.Unknown)),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchAppResponse" }) as unknown as Schema.Schema<PatchAppResponse>;

export const patchApp: (
  input: PatchAppRequest
) => Effect.Effect<
  PatchAppResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchAppRequest,
  output: PatchAppResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListInterconnects1Request {
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
}

export const ListInterconnects1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/cf_interconnects" }),
).annotations({ identifier: "ListInterconnects1Request" }) as unknown as Schema.Schema<ListInterconnects1Request>;

export interface ListInterconnects1Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListInterconnects1Response = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListInterconnects1Response" }) as unknown as Schema.Schema<ListInterconnects1Response>;

export const listInterconnects1: (
  input: ListInterconnects1Request
) => Effect.Effect<
  ListInterconnects1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListInterconnects1Request,
  output: ListInterconnects1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateMultipleInterconnectsRequest {
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
  body: unknown;
}

export const UpdateMultipleInterconnectsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/cf_interconnects" }),
).annotations({ identifier: "UpdateMultipleInterconnectsRequest" }) as unknown as Schema.Schema<UpdateMultipleInterconnectsRequest>;

export interface UpdateMultipleInterconnectsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateMultipleInterconnectsResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateMultipleInterconnectsResponse" }) as unknown as Schema.Schema<UpdateMultipleInterconnectsResponse>;

export const updateMultipleInterconnects: (
  input: UpdateMultipleInterconnectsRequest
) => Effect.Effect<
  UpdateMultipleInterconnectsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateMultipleInterconnectsRequest,
  output: UpdateMultipleInterconnectsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListInterconnectDetailsRequest {
  cf_interconnect_id: string;
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
}

export const ListInterconnectDetailsRequest = Schema.Struct({
  cf_interconnect_id: Schema.String.pipe(T.HttpPath("cf_interconnect_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/cf_interconnects/{cf_interconnect_id}" }),
).annotations({ identifier: "ListInterconnectDetailsRequest" }) as unknown as Schema.Schema<ListInterconnectDetailsRequest>;

export interface ListInterconnectDetailsResponse {
  result: { interconnect?: { automatic_return_routing?: boolean; colo_name?: string; created_on?: string; description?: string; gre?: { cloudflare_endpoint?: string }; health_check?: string; id?: string; interface_address?: string; interface_address6?: string; modified_on?: string; mtu?: number; name?: string } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListInterconnectDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  interconnect: Schema.optional(Schema.Struct({
  automatic_return_routing: Schema.optional(Schema.Boolean),
  colo_name: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  gre: Schema.optional(Schema.Struct({
  cloudflare_endpoint: Schema.optional(Schema.String)
})),
  health_check: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  interface_address: Schema.optional(Schema.String),
  interface_address6: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  mtu: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListInterconnectDetailsResponse" }) as unknown as Schema.Schema<ListInterconnectDetailsResponse>;

export const listInterconnectDetails: (
  input: ListInterconnectDetailsRequest
) => Effect.Effect<
  ListInterconnectDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListInterconnectDetailsRequest,
  output: ListInterconnectDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateInterconnectRequest {
  cf_interconnect_id: string;
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
  body: { automatic_return_routing?: boolean; description?: string; gre?: { cloudflare_endpoint?: string }; health_check?: string; interface_address?: string; interface_address6?: string; mtu?: number };
}

export const UpdateInterconnectRequest = Schema.Struct({
  cf_interconnect_id: Schema.String.pipe(T.HttpPath("cf_interconnect_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target")),
  body: Schema.Struct({
  automatic_return_routing: Schema.optional(Schema.Boolean),
  description: Schema.optional(Schema.String),
  gre: Schema.optional(Schema.Struct({
  cloudflare_endpoint: Schema.optional(Schema.String)
})),
  health_check: Schema.optional(Schema.String),
  interface_address: Schema.optional(Schema.String),
  interface_address6: Schema.optional(Schema.String),
  mtu: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/cf_interconnects/{cf_interconnect_id}" }),
).annotations({ identifier: "UpdateInterconnectRequest" }) as unknown as Schema.Schema<UpdateInterconnectRequest>;

export interface UpdateInterconnectResponse {
  result: { modified?: boolean; modified_interconnect?: { automatic_return_routing?: boolean; colo_name?: string; created_on?: string; description?: string; gre?: { cloudflare_endpoint?: string }; health_check?: string; id?: string; interface_address?: string; interface_address6?: string; modified_on?: string; mtu?: number; name?: string } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateInterconnectResponse = Schema.Struct({
  result: Schema.Struct({
  modified: Schema.optional(Schema.Boolean),
  modified_interconnect: Schema.optional(Schema.Struct({
  automatic_return_routing: Schema.optional(Schema.Boolean),
  colo_name: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  gre: Schema.optional(Schema.Struct({
  cloudflare_endpoint: Schema.optional(Schema.String)
})),
  health_check: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  interface_address: Schema.optional(Schema.String),
  interface_address6: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  mtu: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateInterconnectResponse" }) as unknown as Schema.Schema<UpdateInterconnectResponse>;

export const updateInterconnect: (
  input: UpdateInterconnectRequest
) => Effect.Effect<
  UpdateInterconnectResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateInterconnectRequest,
  output: UpdateInterconnectResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List27Request {
  account_id: string;
}

export const List27Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/cloud/catalog-syncs" }),
).annotations({ identifier: "List27Request" }) as unknown as Schema.Schema<List27Request>;

export interface List27Response {
  result: { description: string; destination_id: string; destination_type: "NONE" | "ZERO_TRUST_LIST"; errors?: Record<string, unknown>; id: string; includes_discoveries_until?: string; last_attempted_update_at?: string; last_successful_update_at?: string; last_user_update_at: string; name: string; policy: string; update_mode: "AUTO" | "MANUAL" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List27Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  description: Schema.String,
  destination_id: Schema.UUID,
  destination_type: Schema.Literal("NONE", "ZERO_TRUST_LIST"),
  errors: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  code: Schema.Literal(1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 5001, 5002, 5003, 5004, 102000, 102001, 102002, 102003, 102004, 102005, 102006, 102007, 102008, 102009, 102010, 102011, 102012, 102013, 102014, 102015, 102016, 102017, 102018, 102019, 102020, 102021, 102022, 102023, 102024, 102025, 102026, 102027, 102028, 102029, 102030, 102031, 102032, 102033, 102034, 102035, 102036, 102037, 102038, 102039, 102040, 102041, 102042, 102043, 102044, 102045, 102046, 102047, 102048, 102049, 102050, 102051, 102052, 102053, 102054, 102055, 102056, 102057, 102058, 102059, 102060, 102061, 102062, 102063, 102064, 102065, 102066, 103001, 103002, 103003, 103004, 103005, 103006, 103007, 103008),
  documentation_url: Schema.optional(Schema.String),
  message: Schema.String,
  meta: Schema.optional(Schema.Struct({
  l10n_key: Schema.optional(Schema.String),
  loggable_error: Schema.optional(Schema.String),
  template_data: Schema.optional(Schema.Struct({})),
  trace_id: Schema.optional(Schema.String)
})),
  source: Schema.optional(Schema.Struct({
  parameter: Schema.optional(Schema.String),
  parameter_value_index: Schema.optional(Schema.Number),
  pointer: Schema.optional(Schema.String)
}))
}) })),
  id: Schema.UUID,
  includes_discoveries_until: Schema.optional(Schema.String),
  last_attempted_update_at: Schema.optional(Schema.String),
  last_successful_update_at: Schema.optional(Schema.String),
  last_user_update_at: Schema.String,
  name: Schema.String,
  policy: Schema.String,
  update_mode: Schema.Literal("AUTO", "MANUAL")
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List27Response" }) as unknown as Schema.Schema<List27Response>;

export const list27: (
  input: List27Request
) => Effect.Effect<
  List27Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List27Request,
  output: List27Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create9Request {
  account_id: string;
  forwarded?: string;
  body: { description?: string; destination_type: "NONE" | "ZERO_TRUST_LIST"; name: string; policy?: string; update_mode: "AUTO" | "MANUAL" };
}

export const Create9Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  forwarded: Schema.optional(Schema.String).pipe(T.HttpHeader("forwarded")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  destination_type: Schema.Literal("NONE", "ZERO_TRUST_LIST"),
  name: Schema.String,
  policy: Schema.optional(Schema.String),
  update_mode: Schema.Literal("AUTO", "MANUAL")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/cloud/catalog-syncs" }),
).annotations({ identifier: "Create9Request" }) as unknown as Schema.Schema<Create9Request>;

export interface Create9Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create9Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create9Response" }) as unknown as Schema.Schema<Create9Response>;

export const create9: (
  input: Create9Request
) => Effect.Effect<
  Create9Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create9Request,
  output: Create9Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List28Request {
  account_id: string;
  destination_type?: "NONE" | "ZERO_TRUST_LIST";
}

export const List28Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  destination_type: Schema.optional(Schema.Literal("NONE", "ZERO_TRUST_LIST")).pipe(T.HttpQuery("destination_type"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/cloud/catalog-syncs/prebuilt-policies" }),
).annotations({ identifier: "List28Request" }) as unknown as Schema.Schema<List28Request>;

export interface List28Response {
  result: { applicable_destinations: "NONE" | "ZERO_TRUST_LIST"[]; policy_description: string; policy_name: string; policy_string: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List28Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  applicable_destinations: Schema.Array(Schema.Literal("NONE", "ZERO_TRUST_LIST")),
  policy_description: Schema.String,
  policy_name: Schema.String,
  policy_string: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List28Response" }) as unknown as Schema.Schema<List28Response>;

export const list28: (
  input: List28Request
) => Effect.Effect<
  List28Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List28Request,
  output: List28Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CatalogSyncsReadRequest {
  account_id: string;
  sync_id: string;
}

export const CatalogSyncsReadRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  sync_id: Schema.UUID.pipe(T.HttpPath("sync_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/cloud/catalog-syncs/{sync_id}" }),
).annotations({ identifier: "CatalogSyncsReadRequest" }) as unknown as Schema.Schema<CatalogSyncsReadRequest>;

export interface CatalogSyncsReadResponse {
  result: { description: string; destination_id: string; destination_type: "NONE" | "ZERO_TRUST_LIST"; errors?: Record<string, unknown>; id: string; includes_discoveries_until?: string; last_attempted_update_at?: string; last_successful_update_at?: string; last_user_update_at: string; name: string; policy: string; update_mode: "AUTO" | "MANUAL" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CatalogSyncsReadResponse = Schema.Struct({
  result: Schema.Struct({
  description: Schema.String,
  destination_id: Schema.UUID,
  destination_type: Schema.Literal("NONE", "ZERO_TRUST_LIST"),
  errors: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  code: Schema.Literal(1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 5001, 5002, 5003, 5004, 102000, 102001, 102002, 102003, 102004, 102005, 102006, 102007, 102008, 102009, 102010, 102011, 102012, 102013, 102014, 102015, 102016, 102017, 102018, 102019, 102020, 102021, 102022, 102023, 102024, 102025, 102026, 102027, 102028, 102029, 102030, 102031, 102032, 102033, 102034, 102035, 102036, 102037, 102038, 102039, 102040, 102041, 102042, 102043, 102044, 102045, 102046, 102047, 102048, 102049, 102050, 102051, 102052, 102053, 102054, 102055, 102056, 102057, 102058, 102059, 102060, 102061, 102062, 102063, 102064, 102065, 102066, 103001, 103002, 103003, 103004, 103005, 103006, 103007, 103008),
  documentation_url: Schema.optional(Schema.String),
  message: Schema.String,
  meta: Schema.optional(Schema.Struct({
  l10n_key: Schema.optional(Schema.String),
  loggable_error: Schema.optional(Schema.String),
  template_data: Schema.optional(Schema.Struct({})),
  trace_id: Schema.optional(Schema.String)
})),
  source: Schema.optional(Schema.Struct({
  parameter: Schema.optional(Schema.String),
  parameter_value_index: Schema.optional(Schema.Number),
  pointer: Schema.optional(Schema.String)
}))
}) })),
  id: Schema.UUID,
  includes_discoveries_until: Schema.optional(Schema.String),
  last_attempted_update_at: Schema.optional(Schema.String),
  last_successful_update_at: Schema.optional(Schema.String),
  last_user_update_at: Schema.String,
  name: Schema.String,
  policy: Schema.String,
  update_mode: Schema.Literal("AUTO", "MANUAL")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CatalogSyncsReadResponse" }) as unknown as Schema.Schema<CatalogSyncsReadResponse>;

export const catalogSyncsRead: (
  input: CatalogSyncsReadRequest
) => Effect.Effect<
  CatalogSyncsReadResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CatalogSyncsReadRequest,
  output: CatalogSyncsReadResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update12Request {
  account_id: string;
  sync_id: string;
  body: { description?: string; name?: string; policy?: string; update_mode?: "AUTO" | "MANUAL" };
}

export const Update12Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  sync_id: Schema.UUID.pipe(T.HttpPath("sync_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  policy: Schema.optional(Schema.String),
  update_mode: Schema.optional(Schema.Literal("AUTO", "MANUAL"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/cloud/catalog-syncs/{sync_id}" }),
).annotations({ identifier: "Update12Request" }) as unknown as Schema.Schema<Update12Request>;

export interface Update12Response {
  result: { description: string; destination_id: string; destination_type: "NONE" | "ZERO_TRUST_LIST"; errors?: Record<string, unknown>; id: string; includes_discoveries_until?: string; last_attempted_update_at?: string; last_successful_update_at?: string; last_user_update_at: string; name: string; policy: string; update_mode: "AUTO" | "MANUAL" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update12Response = Schema.Struct({
  result: Schema.Struct({
  description: Schema.String,
  destination_id: Schema.UUID,
  destination_type: Schema.Literal("NONE", "ZERO_TRUST_LIST"),
  errors: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  code: Schema.Literal(1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 5001, 5002, 5003, 5004, 102000, 102001, 102002, 102003, 102004, 102005, 102006, 102007, 102008, 102009, 102010, 102011, 102012, 102013, 102014, 102015, 102016, 102017, 102018, 102019, 102020, 102021, 102022, 102023, 102024, 102025, 102026, 102027, 102028, 102029, 102030, 102031, 102032, 102033, 102034, 102035, 102036, 102037, 102038, 102039, 102040, 102041, 102042, 102043, 102044, 102045, 102046, 102047, 102048, 102049, 102050, 102051, 102052, 102053, 102054, 102055, 102056, 102057, 102058, 102059, 102060, 102061, 102062, 102063, 102064, 102065, 102066, 103001, 103002, 103003, 103004, 103005, 103006, 103007, 103008),
  documentation_url: Schema.optional(Schema.String),
  message: Schema.String,
  meta: Schema.optional(Schema.Struct({
  l10n_key: Schema.optional(Schema.String),
  loggable_error: Schema.optional(Schema.String),
  template_data: Schema.optional(Schema.Struct({})),
  trace_id: Schema.optional(Schema.String)
})),
  source: Schema.optional(Schema.Struct({
  parameter: Schema.optional(Schema.String),
  parameter_value_index: Schema.optional(Schema.Number),
  pointer: Schema.optional(Schema.String)
}))
}) })),
  id: Schema.UUID,
  includes_discoveries_until: Schema.optional(Schema.String),
  last_attempted_update_at: Schema.optional(Schema.String),
  last_successful_update_at: Schema.optional(Schema.String),
  last_user_update_at: Schema.String,
  name: Schema.String,
  policy: Schema.String,
  update_mode: Schema.Literal("AUTO", "MANUAL")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update12Response" }) as unknown as Schema.Schema<Update12Response>;

export const update12: (
  input: Update12Request
) => Effect.Effect<
  Update12Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update12Request,
  output: Update12Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_14Request {
  account_id: string;
  sync_id: string;
  delete_destination?: boolean;
}

export const Delete_14Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  sync_id: Schema.UUID.pipe(T.HttpPath("sync_id")),
  delete_destination: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("delete_destination"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/cloud/catalog-syncs/{sync_id}" }),
).annotations({ identifier: "Delete_14Request" }) as unknown as Schema.Schema<Delete_14Request>;

export interface Delete_14Response {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_14Response = Schema.Struct({
  result: Schema.Struct({
  id: Schema.UUID
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_14Response" }) as unknown as Schema.Schema<Delete_14Response>;

export const delete_14: (
  input: Delete_14Request
) => Effect.Effect<
  Delete_14Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_14Request,
  output: Delete_14Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Patch1Request {
  account_id: string;
  sync_id: string;
  body: { description?: string; name?: string; policy?: string; update_mode?: "AUTO" | "MANUAL" };
}

export const Patch1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  sync_id: Schema.UUID.pipe(T.HttpPath("sync_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  policy: Schema.optional(Schema.String),
  update_mode: Schema.optional(Schema.Literal("AUTO", "MANUAL"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/cloud/catalog-syncs/{sync_id}" }),
).annotations({ identifier: "Patch1Request" }) as unknown as Schema.Schema<Patch1Request>;

export interface Patch1Response {
  result: { description: string; destination_id: string; destination_type: "NONE" | "ZERO_TRUST_LIST"; errors?: Record<string, unknown>; id: string; includes_discoveries_until?: string; last_attempted_update_at?: string; last_successful_update_at?: string; last_user_update_at: string; name: string; policy: string; update_mode: "AUTO" | "MANUAL" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Patch1Response = Schema.Struct({
  result: Schema.Struct({
  description: Schema.String,
  destination_id: Schema.UUID,
  destination_type: Schema.Literal("NONE", "ZERO_TRUST_LIST"),
  errors: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  code: Schema.Literal(1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 5001, 5002, 5003, 5004, 102000, 102001, 102002, 102003, 102004, 102005, 102006, 102007, 102008, 102009, 102010, 102011, 102012, 102013, 102014, 102015, 102016, 102017, 102018, 102019, 102020, 102021, 102022, 102023, 102024, 102025, 102026, 102027, 102028, 102029, 102030, 102031, 102032, 102033, 102034, 102035, 102036, 102037, 102038, 102039, 102040, 102041, 102042, 102043, 102044, 102045, 102046, 102047, 102048, 102049, 102050, 102051, 102052, 102053, 102054, 102055, 102056, 102057, 102058, 102059, 102060, 102061, 102062, 102063, 102064, 102065, 102066, 103001, 103002, 103003, 103004, 103005, 103006, 103007, 103008),
  documentation_url: Schema.optional(Schema.String),
  message: Schema.String,
  meta: Schema.optional(Schema.Struct({
  l10n_key: Schema.optional(Schema.String),
  loggable_error: Schema.optional(Schema.String),
  template_data: Schema.optional(Schema.Struct({})),
  trace_id: Schema.optional(Schema.String)
})),
  source: Schema.optional(Schema.Struct({
  parameter: Schema.optional(Schema.String),
  parameter_value_index: Schema.optional(Schema.Number),
  pointer: Schema.optional(Schema.String)
}))
}) })),
  id: Schema.UUID,
  includes_discoveries_until: Schema.optional(Schema.String),
  last_attempted_update_at: Schema.optional(Schema.String),
  last_successful_update_at: Schema.optional(Schema.String),
  last_user_update_at: Schema.String,
  name: Schema.String,
  policy: Schema.String,
  update_mode: Schema.Literal("AUTO", "MANUAL")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Patch1Response" }) as unknown as Schema.Schema<Patch1Response>;

export const patch1: (
  input: Patch1Request
) => Effect.Effect<
  Patch1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Patch1Request,
  output: Patch1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CatalogSyncsRefreshRequest {
  account_id: string;
  sync_id: string;
}

export const CatalogSyncsRefreshRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  sync_id: Schema.UUID.pipe(T.HttpPath("sync_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/cloud/catalog-syncs/{sync_id}/refresh" }),
).annotations({ identifier: "CatalogSyncsRefreshRequest" }) as unknown as Schema.Schema<CatalogSyncsRefreshRequest>;

export interface CatalogSyncsRefreshResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CatalogSyncsRefreshResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CatalogSyncsRefreshResponse" }) as unknown as Schema.Schema<CatalogSyncsRefreshResponse>;

export const catalogSyncsRefresh: (
  input: CatalogSyncsRefreshRequest
) => Effect.Effect<
  CatalogSyncsRefreshResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CatalogSyncsRefreshRequest,
  output: CatalogSyncsRefreshResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List29Request {
  account_id: string;
  order_by?: string;
  desc?: boolean;
  status?: boolean;
  vpcs?: boolean;
}

export const List29Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  order_by: Schema.optional(Schema.String).pipe(T.HttpQuery("order_by")),
  desc: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("desc")),
  status: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("status")),
  vpcs: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("vpcs"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/cloud/onramps" }),
).annotations({ identifier: "List29Request" }) as unknown as Schema.Schema<List29Request>;

export interface List29Response {
  result: { attached_hubs?: string[]; attached_vpcs?: string[]; cloud_type: "AWS" | "AZURE" | "GOOGLE"; description?: string; hub?: string; id: string; install_routes_in_cloud: boolean; install_routes_in_magic_wan: boolean; last_applied_at?: string; last_exported_at?: string; last_planned_at?: string; manage_hub_to_hub_attachments?: boolean; manage_vpc_to_hub_attachments?: boolean; name: string; planned_monthly_cost_estimate?: { currency: string; current_monthly_cost: number; diff: number; proposed_monthly_cost: number }; planned_resources?: { diff: { diff: string; left_description: string; left_yaml: string; right_description: string; right_yaml: string }; keys_require_replace: string[]; monthly_cost_estimate_diff: { currency: string; current_monthly_cost: number; diff: number; proposed_monthly_cost: number }; planned_action: "no_op" | "create" | "update" | "replace" | "destroy"; resource: { cloud_type: "AWS" | "AZURE" | "GOOGLE" | "CLOUDFLARE"; detail: string; id: string; name: string; resource_type: "aws_customer_gateway" | "aws_egress_only_internet_gateway" | "aws_internet_gateway" | "aws_instance" | "aws_network_interface" | "aws_route" | "aws_route_table" | "aws_route_table_association" | "aws_subnet" | "aws_vpc" | "aws_vpc_ipv4_cidr_block_association" | "aws_vpn_connection" | "aws_vpn_connection_route" | "aws_vpn_gateway" | "aws_security_group" | "aws_vpc_security_group_ingress_rule" | "aws_vpc_security_group_egress_rule" | "aws_ec2_managed_prefix_list" | "aws_ec2_transit_gateway" | "aws_ec2_transit_gateway_prefix_list_reference" | "aws_ec2_transit_gateway_vpc_attachment" | "azurerm_application_security_group" | "azurerm_lb" | "azurerm_lb_backend_address_pool" | "azurerm_lb_nat_pool" | "azurerm_lb_nat_rule" | "azurerm_lb_rule" | "azurerm_local_network_gateway" | "azurerm_network_interface" | "azurerm_network_interface_application_security_group_association" | "azurerm_network_interface_backend_address_pool_association" | "azurerm_network_interface_security_group_association" | "azurerm_network_security_group" | "azurerm_public_ip" | "azurerm_route" | "azurerm_route_table" | "azurerm_subnet" | "azurerm_subnet_route_table_association" | "azurerm_virtual_machine" | "azurerm_virtual_network_gateway_connection" | "azurerm_virtual_network" | "azurerm_virtual_network_gateway" | "google_compute_network" | "google_compute_subnetwork" | "google_compute_vpn_gateway" | "google_compute_vpn_tunnel" | "google_compute_route" | "google_compute_address" | "google_compute_global_address" | "google_compute_router" | "google_compute_interconnect_attachment" | "google_compute_ha_vpn_gateway" | "google_compute_forwarding_rule" | "google_compute_network_firewall_policy" | "google_compute_network_firewall_policy_rule" | "cloudflare_static_route" | "cloudflare_ipsec_tunnel"; title: string } }[]; planned_resources_unavailable?: boolean; post_apply_monthly_cost_estimate?: { currency: string; monthly_cost: number }; post_apply_resources?: Record<string, unknown>; post_apply_resources_unavailable?: boolean; region?: string; status?: { apply_progress: { done: number; total: number }; lifecycle_errors?: Record<string, unknown>; lifecycle_state: "OnrampNeedsApply" | "OnrampPendingPlan" | "OnrampPlanning" | "OnrampPlanFailed" | "OnrampPendingApproval" | "OnrampPendingApply" | "OnrampApplying" | "OnrampApplyFailed" | "OnrampActive" | "OnrampPendingDestroy" | "OnrampDestroying" | "OnrampDestroyFailed"; plan_progress: { done: number; total: number }; routes: string[]; tunnels: string[] }; type: "OnrampTypeSingle" | "OnrampTypeHub"; updated_at: string; vpc?: string; vpcs_by_id?: Record<string, unknown>; vpcs_by_id_unavailable?: string[] }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List29Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  attached_hubs: Schema.optional(Schema.Array(Schema.UUID)),
  attached_vpcs: Schema.optional(Schema.Array(Schema.UUID)),
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE"),
  description: Schema.optional(Schema.String),
  hub: Schema.optional(Schema.UUID),
  id: Schema.UUID,
  install_routes_in_cloud: Schema.Boolean,
  install_routes_in_magic_wan: Schema.Boolean,
  last_applied_at: Schema.optional(Schema.String),
  last_exported_at: Schema.optional(Schema.String),
  last_planned_at: Schema.optional(Schema.String),
  manage_hub_to_hub_attachments: Schema.optional(Schema.Boolean),
  manage_vpc_to_hub_attachments: Schema.optional(Schema.Boolean),
  name: Schema.String,
  planned_monthly_cost_estimate: Schema.optional(Schema.Struct({
  currency: Schema.String,
  current_monthly_cost: Schema.Number,
  diff: Schema.Number,
  proposed_monthly_cost: Schema.Number
})),
  planned_resources: Schema.optional(Schema.Array(Schema.Struct({
  diff: Schema.Struct({
  diff: Schema.String,
  left_description: Schema.String,
  left_yaml: Schema.String,
  right_description: Schema.String,
  right_yaml: Schema.String
}),
  keys_require_replace: Schema.Array(Schema.String),
  monthly_cost_estimate_diff: Schema.Struct({
  currency: Schema.String,
  current_monthly_cost: Schema.Number,
  diff: Schema.Number,
  proposed_monthly_cost: Schema.Number
}),
  planned_action: Schema.Literal("no_op", "create", "update", "replace", "destroy"),
  resource: Schema.Struct({
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  detail: Schema.String,
  id: Schema.UUID,
  name: Schema.String,
  resource_type: Schema.Literal("aws_customer_gateway", "aws_egress_only_internet_gateway", "aws_internet_gateway", "aws_instance", "aws_network_interface", "aws_route", "aws_route_table", "aws_route_table_association", "aws_subnet", "aws_vpc", "aws_vpc_ipv4_cidr_block_association", "aws_vpn_connection", "aws_vpn_connection_route", "aws_vpn_gateway", "aws_security_group", "aws_vpc_security_group_ingress_rule", "aws_vpc_security_group_egress_rule", "aws_ec2_managed_prefix_list", "aws_ec2_transit_gateway", "aws_ec2_transit_gateway_prefix_list_reference", "aws_ec2_transit_gateway_vpc_attachment", "azurerm_application_security_group", "azurerm_lb", "azurerm_lb_backend_address_pool", "azurerm_lb_nat_pool", "azurerm_lb_nat_rule", "azurerm_lb_rule", "azurerm_local_network_gateway", "azurerm_network_interface", "azurerm_network_interface_application_security_group_association", "azurerm_network_interface_backend_address_pool_association", "azurerm_network_interface_security_group_association", "azurerm_network_security_group", "azurerm_public_ip", "azurerm_route", "azurerm_route_table", "azurerm_subnet", "azurerm_subnet_route_table_association", "azurerm_virtual_machine", "azurerm_virtual_network_gateway_connection", "azurerm_virtual_network", "azurerm_virtual_network_gateway", "google_compute_network", "google_compute_subnetwork", "google_compute_vpn_gateway", "google_compute_vpn_tunnel", "google_compute_route", "google_compute_address", "google_compute_global_address", "google_compute_router", "google_compute_interconnect_attachment", "google_compute_ha_vpn_gateway", "google_compute_forwarding_rule", "google_compute_network_firewall_policy", "google_compute_network_firewall_policy_rule", "cloudflare_static_route", "cloudflare_ipsec_tunnel"),
  title: Schema.String
})
}))),
  planned_resources_unavailable: Schema.optional(Schema.Boolean),
  post_apply_monthly_cost_estimate: Schema.optional(Schema.Struct({
  currency: Schema.String,
  monthly_cost: Schema.Number
})),
  post_apply_resources: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  account_id: Schema.String,
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  config: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  deployment_provider: Schema.UUID,
  id: Schema.UUID,
  managed: Schema.Boolean,
  managed_by: Schema.optional(Schema.Array(Schema.Struct({
  client_type: Schema.Literal("MAGIC_WAN_CLOUD_ONRAMP"),
  id: Schema.UUID,
  name: Schema.String
}))),
  monthly_cost_estimate: Schema.Struct({
  currency: Schema.String,
  monthly_cost: Schema.Number
}),
  name: Schema.String,
  native_id: Schema.String,
  observations: Schema.Record({ key: Schema.String, value: Schema.Struct({
  first_observed_at: Schema.String,
  last_observed_at: Schema.String,
  provider_id: Schema.UUID,
  resource_id: Schema.UUID
}) }),
  provider_ids: Schema.Array(Schema.UUID),
  provider_names_by_id: Schema.Record({ key: Schema.String, value: Schema.String }),
  region: Schema.String,
  resource_group: Schema.String,
  resource_type: Schema.Literal("aws_customer_gateway", "aws_egress_only_internet_gateway", "aws_internet_gateway", "aws_instance", "aws_network_interface", "aws_route", "aws_route_table", "aws_route_table_association", "aws_subnet", "aws_vpc", "aws_vpc_ipv4_cidr_block_association", "aws_vpn_connection", "aws_vpn_connection_route", "aws_vpn_gateway", "aws_security_group", "aws_vpc_security_group_ingress_rule", "aws_vpc_security_group_egress_rule", "aws_ec2_managed_prefix_list", "aws_ec2_transit_gateway", "aws_ec2_transit_gateway_prefix_list_reference", "aws_ec2_transit_gateway_vpc_attachment", "azurerm_application_security_group", "azurerm_lb", "azurerm_lb_backend_address_pool", "azurerm_lb_nat_pool", "azurerm_lb_nat_rule", "azurerm_lb_rule", "azurerm_local_network_gateway", "azurerm_network_interface", "azurerm_network_interface_application_security_group_association", "azurerm_network_interface_backend_address_pool_association", "azurerm_network_interface_security_group_association", "azurerm_network_security_group", "azurerm_public_ip", "azurerm_route", "azurerm_route_table", "azurerm_subnet", "azurerm_subnet_route_table_association", "azurerm_virtual_machine", "azurerm_virtual_network_gateway_connection", "azurerm_virtual_network", "azurerm_virtual_network_gateway", "google_compute_network", "google_compute_subnetwork", "google_compute_vpn_gateway", "google_compute_vpn_tunnel", "google_compute_route", "google_compute_address", "google_compute_global_address", "google_compute_router", "google_compute_interconnect_attachment", "google_compute_ha_vpn_gateway", "google_compute_forwarding_rule", "google_compute_network_firewall_policy", "google_compute_network_firewall_policy_rule", "cloudflare_static_route", "cloudflare_ipsec_tunnel"),
  sections: Schema.Array(Schema.Struct({
  help_text: Schema.optional(Schema.String),
  hidden_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
})),
  name: Schema.String,
  visible_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
}))
})),
  state: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  tags: Schema.Record({ key: Schema.String, value: Schema.String }),
  updated_at: Schema.String,
  url: Schema.String
}) })),
  post_apply_resources_unavailable: Schema.optional(Schema.Boolean),
  region: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Struct({
  apply_progress: Schema.Struct({
  done: Schema.Number,
  total: Schema.Number
}),
  lifecycle_errors: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  code: Schema.Literal(1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 5001, 5002, 5003, 5004, 102000, 102001, 102002, 102003, 102004, 102005, 102006, 102007, 102008, 102009, 102010, 102011, 102012, 102013, 102014, 102015, 102016, 102017, 102018, 102019, 102020, 102021, 102022, 102023, 102024, 102025, 102026, 102027, 102028, 102029, 102030, 102031, 102032, 102033, 102034, 102035, 102036, 102037, 102038, 102039, 102040, 102041, 102042, 102043, 102044, 102045, 102046, 102047, 102048, 102049, 102050, 102051, 102052, 102053, 102054, 102055, 102056, 102057, 102058, 102059, 102060, 102061, 102062, 102063, 102064, 102065, 102066, 103001, 103002, 103003, 103004, 103005, 103006, 103007, 103008),
  documentation_url: Schema.optional(Schema.String),
  message: Schema.String,
  meta: Schema.optional(Schema.Struct({
  l10n_key: Schema.optional(Schema.String),
  loggable_error: Schema.optional(Schema.String),
  template_data: Schema.optional(Schema.Struct({})),
  trace_id: Schema.optional(Schema.String)
})),
  source: Schema.optional(Schema.Struct({
  parameter: Schema.optional(Schema.String),
  parameter_value_index: Schema.optional(Schema.Number),
  pointer: Schema.optional(Schema.String)
}))
}) })),
  lifecycle_state: Schema.Literal("OnrampNeedsApply", "OnrampPendingPlan", "OnrampPlanning", "OnrampPlanFailed", "OnrampPendingApproval", "OnrampPendingApply", "OnrampApplying", "OnrampApplyFailed", "OnrampActive", "OnrampPendingDestroy", "OnrampDestroying", "OnrampDestroyFailed"),
  plan_progress: Schema.Struct({
  done: Schema.Number,
  total: Schema.Number
}),
  routes: Schema.Array(Schema.UUID),
  tunnels: Schema.Array(Schema.UUID)
})),
  type: Schema.Literal("OnrampTypeSingle", "OnrampTypeHub"),
  updated_at: Schema.String,
  vpc: Schema.optional(Schema.UUID),
  vpcs_by_id: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  account_id: Schema.String,
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  config: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  deployment_provider: Schema.UUID,
  id: Schema.UUID,
  managed: Schema.Boolean,
  managed_by: Schema.optional(Schema.Array(Schema.Struct({
  client_type: Schema.Literal("MAGIC_WAN_CLOUD_ONRAMP"),
  id: Schema.UUID,
  name: Schema.String
}))),
  monthly_cost_estimate: Schema.Struct({
  currency: Schema.String,
  monthly_cost: Schema.Number
}),
  name: Schema.String,
  native_id: Schema.String,
  observations: Schema.Record({ key: Schema.String, value: Schema.Struct({
  first_observed_at: Schema.String,
  last_observed_at: Schema.String,
  provider_id: Schema.UUID,
  resource_id: Schema.UUID
}) }),
  provider_ids: Schema.Array(Schema.UUID),
  provider_names_by_id: Schema.Record({ key: Schema.String, value: Schema.String }),
  region: Schema.String,
  resource_group: Schema.String,
  resource_type: Schema.Literal("aws_customer_gateway", "aws_egress_only_internet_gateway", "aws_internet_gateway", "aws_instance", "aws_network_interface", "aws_route", "aws_route_table", "aws_route_table_association", "aws_subnet", "aws_vpc", "aws_vpc_ipv4_cidr_block_association", "aws_vpn_connection", "aws_vpn_connection_route", "aws_vpn_gateway", "aws_security_group", "aws_vpc_security_group_ingress_rule", "aws_vpc_security_group_egress_rule", "aws_ec2_managed_prefix_list", "aws_ec2_transit_gateway", "aws_ec2_transit_gateway_prefix_list_reference", "aws_ec2_transit_gateway_vpc_attachment", "azurerm_application_security_group", "azurerm_lb", "azurerm_lb_backend_address_pool", "azurerm_lb_nat_pool", "azurerm_lb_nat_rule", "azurerm_lb_rule", "azurerm_local_network_gateway", "azurerm_network_interface", "azurerm_network_interface_application_security_group_association", "azurerm_network_interface_backend_address_pool_association", "azurerm_network_interface_security_group_association", "azurerm_network_security_group", "azurerm_public_ip", "azurerm_route", "azurerm_route_table", "azurerm_subnet", "azurerm_subnet_route_table_association", "azurerm_virtual_machine", "azurerm_virtual_network_gateway_connection", "azurerm_virtual_network", "azurerm_virtual_network_gateway", "google_compute_network", "google_compute_subnetwork", "google_compute_vpn_gateway", "google_compute_vpn_tunnel", "google_compute_route", "google_compute_address", "google_compute_global_address", "google_compute_router", "google_compute_interconnect_attachment", "google_compute_ha_vpn_gateway", "google_compute_forwarding_rule", "google_compute_network_firewall_policy", "google_compute_network_firewall_policy_rule", "cloudflare_static_route", "cloudflare_ipsec_tunnel"),
  sections: Schema.Array(Schema.Struct({
  help_text: Schema.optional(Schema.String),
  hidden_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
})),
  name: Schema.String,
  visible_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
}))
})),
  state: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  tags: Schema.Record({ key: Schema.String, value: Schema.String }),
  updated_at: Schema.String,
  url: Schema.String
}) })),
  vpcs_by_id_unavailable: Schema.optional(Schema.Array(Schema.UUID))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List29Response" }) as unknown as Schema.Schema<List29Response>;

export const list29: (
  input: List29Request
) => Effect.Effect<
  List29Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List29Request,
  output: List29Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create10Request {
  account_id: string;
  forwarded?: string;
  body: { adopted_hub_id?: string; attached_hubs?: string[]; attached_vpcs?: string[]; cloud_type: "AWS" | "AZURE" | "GOOGLE"; description?: string; hub_provider_id?: string; install_routes_in_cloud: boolean; install_routes_in_magic_wan: boolean; manage_hub_to_hub_attachments?: boolean; manage_vpc_to_hub_attachments?: boolean; name: string; region?: string; type: "OnrampTypeSingle" | "OnrampTypeHub"; vpc?: string };
}

export const Create10Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  forwarded: Schema.optional(Schema.String).pipe(T.HttpHeader("forwarded")),
  body: Schema.Struct({
  adopted_hub_id: Schema.optional(Schema.UUID),
  attached_hubs: Schema.optional(Schema.Array(Schema.UUID)),
  attached_vpcs: Schema.optional(Schema.Array(Schema.UUID)),
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE"),
  description: Schema.optional(Schema.String),
  hub_provider_id: Schema.optional(Schema.UUID),
  install_routes_in_cloud: Schema.Boolean,
  install_routes_in_magic_wan: Schema.Boolean,
  manage_hub_to_hub_attachments: Schema.optional(Schema.Boolean),
  manage_vpc_to_hub_attachments: Schema.optional(Schema.Boolean),
  name: Schema.String,
  region: Schema.optional(Schema.String),
  type: Schema.Literal("OnrampTypeSingle", "OnrampTypeHub"),
  vpc: Schema.optional(Schema.UUID)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/cloud/onramps" }),
).annotations({ identifier: "Create10Request" }) as unknown as Schema.Schema<Create10Request>;

export interface Create10Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create10Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create10Response" }) as unknown as Schema.Schema<Create10Response>;

export const create10: (
  input: Create10Request
) => Effect.Effect<
  Create10Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create10Request,
  output: Create10Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface OnrampsMwanAddrSpaceReadRequest {
  account_id: string;
}

export const OnrampsMwanAddrSpaceReadRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/cloud/onramps/magic_wan_address_space" }),
).annotations({ identifier: "OnrampsMwanAddrSpaceReadRequest" }) as unknown as Schema.Schema<OnrampsMwanAddrSpaceReadRequest>;

export interface OnrampsMwanAddrSpaceReadResponse {
  result: { prefixes: string[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const OnrampsMwanAddrSpaceReadResponse = Schema.Struct({
  result: Schema.Struct({
  prefixes: Schema.Array(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "OnrampsMwanAddrSpaceReadResponse" }) as unknown as Schema.Schema<OnrampsMwanAddrSpaceReadResponse>;

export const onrampsMwanAddrSpaceRead: (
  input: OnrampsMwanAddrSpaceReadRequest
) => Effect.Effect<
  OnrampsMwanAddrSpaceReadResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: OnrampsMwanAddrSpaceReadRequest,
  output: OnrampsMwanAddrSpaceReadResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update13Request {
  account_id: string;
  body: { prefixes: string[] };
}

export const Update13Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  prefixes: Schema.Array(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/cloud/onramps/magic_wan_address_space" }),
).annotations({ identifier: "Update13Request" }) as unknown as Schema.Schema<Update13Request>;

export interface Update13Response {
  result: { prefixes: string[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update13Response = Schema.Struct({
  result: Schema.Struct({
  prefixes: Schema.Array(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update13Response" }) as unknown as Schema.Schema<Update13Response>;

export const update13: (
  input: Update13Request
) => Effect.Effect<
  Update13Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update13Request,
  output: Update13Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Patch2Request {
  account_id: string;
  body: { prefixes: string[] };
}

export const Patch2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  prefixes: Schema.Array(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/cloud/onramps/magic_wan_address_space" }),
).annotations({ identifier: "Patch2Request" }) as unknown as Schema.Schema<Patch2Request>;

export interface Patch2Response {
  result: { prefixes: string[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Patch2Response = Schema.Struct({
  result: Schema.Struct({
  prefixes: Schema.Array(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Patch2Response" }) as unknown as Schema.Schema<Patch2Response>;

export const patch2: (
  input: Patch2Request
) => Effect.Effect<
  Patch2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Patch2Request,
  output: Patch2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface OnrampsReadRequest {
  account_id: string;
  onramp_id: string;
  status?: boolean;
  vpcs?: boolean;
  post_apply_resources?: boolean;
  planned_resources?: boolean;
}

export const OnrampsReadRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  onramp_id: Schema.UUID.pipe(T.HttpPath("onramp_id")),
  status: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("status")),
  vpcs: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("vpcs")),
  post_apply_resources: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("post_apply_resources")),
  planned_resources: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("planned_resources"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/cloud/onramps/{onramp_id}" }),
).annotations({ identifier: "OnrampsReadRequest" }) as unknown as Schema.Schema<OnrampsReadRequest>;

export interface OnrampsReadResponse {
  result: { attached_hubs?: string[]; attached_vpcs?: string[]; cloud_type: "AWS" | "AZURE" | "GOOGLE"; description?: string; hub?: string; id: string; install_routes_in_cloud: boolean; install_routes_in_magic_wan: boolean; last_applied_at?: string; last_exported_at?: string; last_planned_at?: string; manage_hub_to_hub_attachments?: boolean; manage_vpc_to_hub_attachments?: boolean; name: string; planned_monthly_cost_estimate?: { currency: string; current_monthly_cost: number; diff: number; proposed_monthly_cost: number }; planned_resources?: { diff: { diff: string; left_description: string; left_yaml: string; right_description: string; right_yaml: string }; keys_require_replace: string[]; monthly_cost_estimate_diff: { currency: string; current_monthly_cost: number; diff: number; proposed_monthly_cost: number }; planned_action: "no_op" | "create" | "update" | "replace" | "destroy"; resource: { cloud_type: "AWS" | "AZURE" | "GOOGLE" | "CLOUDFLARE"; detail: string; id: string; name: string; resource_type: "aws_customer_gateway" | "aws_egress_only_internet_gateway" | "aws_internet_gateway" | "aws_instance" | "aws_network_interface" | "aws_route" | "aws_route_table" | "aws_route_table_association" | "aws_subnet" | "aws_vpc" | "aws_vpc_ipv4_cidr_block_association" | "aws_vpn_connection" | "aws_vpn_connection_route" | "aws_vpn_gateway" | "aws_security_group" | "aws_vpc_security_group_ingress_rule" | "aws_vpc_security_group_egress_rule" | "aws_ec2_managed_prefix_list" | "aws_ec2_transit_gateway" | "aws_ec2_transit_gateway_prefix_list_reference" | "aws_ec2_transit_gateway_vpc_attachment" | "azurerm_application_security_group" | "azurerm_lb" | "azurerm_lb_backend_address_pool" | "azurerm_lb_nat_pool" | "azurerm_lb_nat_rule" | "azurerm_lb_rule" | "azurerm_local_network_gateway" | "azurerm_network_interface" | "azurerm_network_interface_application_security_group_association" | "azurerm_network_interface_backend_address_pool_association" | "azurerm_network_interface_security_group_association" | "azurerm_network_security_group" | "azurerm_public_ip" | "azurerm_route" | "azurerm_route_table" | "azurerm_subnet" | "azurerm_subnet_route_table_association" | "azurerm_virtual_machine" | "azurerm_virtual_network_gateway_connection" | "azurerm_virtual_network" | "azurerm_virtual_network_gateway" | "google_compute_network" | "google_compute_subnetwork" | "google_compute_vpn_gateway" | "google_compute_vpn_tunnel" | "google_compute_route" | "google_compute_address" | "google_compute_global_address" | "google_compute_router" | "google_compute_interconnect_attachment" | "google_compute_ha_vpn_gateway" | "google_compute_forwarding_rule" | "google_compute_network_firewall_policy" | "google_compute_network_firewall_policy_rule" | "cloudflare_static_route" | "cloudflare_ipsec_tunnel"; title: string } }[]; planned_resources_unavailable?: boolean; post_apply_monthly_cost_estimate?: { currency: string; monthly_cost: number }; post_apply_resources?: Record<string, unknown>; post_apply_resources_unavailable?: boolean; region?: string; status?: { apply_progress: { done: number; total: number }; lifecycle_errors?: Record<string, unknown>; lifecycle_state: "OnrampNeedsApply" | "OnrampPendingPlan" | "OnrampPlanning" | "OnrampPlanFailed" | "OnrampPendingApproval" | "OnrampPendingApply" | "OnrampApplying" | "OnrampApplyFailed" | "OnrampActive" | "OnrampPendingDestroy" | "OnrampDestroying" | "OnrampDestroyFailed"; plan_progress: { done: number; total: number }; routes: string[]; tunnels: string[] }; type: "OnrampTypeSingle" | "OnrampTypeHub"; updated_at: string; vpc?: string; vpcs_by_id?: Record<string, unknown>; vpcs_by_id_unavailable?: string[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const OnrampsReadResponse = Schema.Struct({
  result: Schema.Struct({
  attached_hubs: Schema.optional(Schema.Array(Schema.UUID)),
  attached_vpcs: Schema.optional(Schema.Array(Schema.UUID)),
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE"),
  description: Schema.optional(Schema.String),
  hub: Schema.optional(Schema.UUID),
  id: Schema.UUID,
  install_routes_in_cloud: Schema.Boolean,
  install_routes_in_magic_wan: Schema.Boolean,
  last_applied_at: Schema.optional(Schema.String),
  last_exported_at: Schema.optional(Schema.String),
  last_planned_at: Schema.optional(Schema.String),
  manage_hub_to_hub_attachments: Schema.optional(Schema.Boolean),
  manage_vpc_to_hub_attachments: Schema.optional(Schema.Boolean),
  name: Schema.String,
  planned_monthly_cost_estimate: Schema.optional(Schema.Struct({
  currency: Schema.String,
  current_monthly_cost: Schema.Number,
  diff: Schema.Number,
  proposed_monthly_cost: Schema.Number
})),
  planned_resources: Schema.optional(Schema.Array(Schema.Struct({
  diff: Schema.Struct({
  diff: Schema.String,
  left_description: Schema.String,
  left_yaml: Schema.String,
  right_description: Schema.String,
  right_yaml: Schema.String
}),
  keys_require_replace: Schema.Array(Schema.String),
  monthly_cost_estimate_diff: Schema.Struct({
  currency: Schema.String,
  current_monthly_cost: Schema.Number,
  diff: Schema.Number,
  proposed_monthly_cost: Schema.Number
}),
  planned_action: Schema.Literal("no_op", "create", "update", "replace", "destroy"),
  resource: Schema.Struct({
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  detail: Schema.String,
  id: Schema.UUID,
  name: Schema.String,
  resource_type: Schema.Literal("aws_customer_gateway", "aws_egress_only_internet_gateway", "aws_internet_gateway", "aws_instance", "aws_network_interface", "aws_route", "aws_route_table", "aws_route_table_association", "aws_subnet", "aws_vpc", "aws_vpc_ipv4_cidr_block_association", "aws_vpn_connection", "aws_vpn_connection_route", "aws_vpn_gateway", "aws_security_group", "aws_vpc_security_group_ingress_rule", "aws_vpc_security_group_egress_rule", "aws_ec2_managed_prefix_list", "aws_ec2_transit_gateway", "aws_ec2_transit_gateway_prefix_list_reference", "aws_ec2_transit_gateway_vpc_attachment", "azurerm_application_security_group", "azurerm_lb", "azurerm_lb_backend_address_pool", "azurerm_lb_nat_pool", "azurerm_lb_nat_rule", "azurerm_lb_rule", "azurerm_local_network_gateway", "azurerm_network_interface", "azurerm_network_interface_application_security_group_association", "azurerm_network_interface_backend_address_pool_association", "azurerm_network_interface_security_group_association", "azurerm_network_security_group", "azurerm_public_ip", "azurerm_route", "azurerm_route_table", "azurerm_subnet", "azurerm_subnet_route_table_association", "azurerm_virtual_machine", "azurerm_virtual_network_gateway_connection", "azurerm_virtual_network", "azurerm_virtual_network_gateway", "google_compute_network", "google_compute_subnetwork", "google_compute_vpn_gateway", "google_compute_vpn_tunnel", "google_compute_route", "google_compute_address", "google_compute_global_address", "google_compute_router", "google_compute_interconnect_attachment", "google_compute_ha_vpn_gateway", "google_compute_forwarding_rule", "google_compute_network_firewall_policy", "google_compute_network_firewall_policy_rule", "cloudflare_static_route", "cloudflare_ipsec_tunnel"),
  title: Schema.String
})
}))),
  planned_resources_unavailable: Schema.optional(Schema.Boolean),
  post_apply_monthly_cost_estimate: Schema.optional(Schema.Struct({
  currency: Schema.String,
  monthly_cost: Schema.Number
})),
  post_apply_resources: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  account_id: Schema.String,
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  config: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  deployment_provider: Schema.UUID,
  id: Schema.UUID,
  managed: Schema.Boolean,
  managed_by: Schema.optional(Schema.Array(Schema.Struct({
  client_type: Schema.Literal("MAGIC_WAN_CLOUD_ONRAMP"),
  id: Schema.UUID,
  name: Schema.String
}))),
  monthly_cost_estimate: Schema.Struct({
  currency: Schema.String,
  monthly_cost: Schema.Number
}),
  name: Schema.String,
  native_id: Schema.String,
  observations: Schema.Record({ key: Schema.String, value: Schema.Struct({
  first_observed_at: Schema.String,
  last_observed_at: Schema.String,
  provider_id: Schema.UUID,
  resource_id: Schema.UUID
}) }),
  provider_ids: Schema.Array(Schema.UUID),
  provider_names_by_id: Schema.Record({ key: Schema.String, value: Schema.String }),
  region: Schema.String,
  resource_group: Schema.String,
  resource_type: Schema.Literal("aws_customer_gateway", "aws_egress_only_internet_gateway", "aws_internet_gateway", "aws_instance", "aws_network_interface", "aws_route", "aws_route_table", "aws_route_table_association", "aws_subnet", "aws_vpc", "aws_vpc_ipv4_cidr_block_association", "aws_vpn_connection", "aws_vpn_connection_route", "aws_vpn_gateway", "aws_security_group", "aws_vpc_security_group_ingress_rule", "aws_vpc_security_group_egress_rule", "aws_ec2_managed_prefix_list", "aws_ec2_transit_gateway", "aws_ec2_transit_gateway_prefix_list_reference", "aws_ec2_transit_gateway_vpc_attachment", "azurerm_application_security_group", "azurerm_lb", "azurerm_lb_backend_address_pool", "azurerm_lb_nat_pool", "azurerm_lb_nat_rule", "azurerm_lb_rule", "azurerm_local_network_gateway", "azurerm_network_interface", "azurerm_network_interface_application_security_group_association", "azurerm_network_interface_backend_address_pool_association", "azurerm_network_interface_security_group_association", "azurerm_network_security_group", "azurerm_public_ip", "azurerm_route", "azurerm_route_table", "azurerm_subnet", "azurerm_subnet_route_table_association", "azurerm_virtual_machine", "azurerm_virtual_network_gateway_connection", "azurerm_virtual_network", "azurerm_virtual_network_gateway", "google_compute_network", "google_compute_subnetwork", "google_compute_vpn_gateway", "google_compute_vpn_tunnel", "google_compute_route", "google_compute_address", "google_compute_global_address", "google_compute_router", "google_compute_interconnect_attachment", "google_compute_ha_vpn_gateway", "google_compute_forwarding_rule", "google_compute_network_firewall_policy", "google_compute_network_firewall_policy_rule", "cloudflare_static_route", "cloudflare_ipsec_tunnel"),
  sections: Schema.Array(Schema.Struct({
  help_text: Schema.optional(Schema.String),
  hidden_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
})),
  name: Schema.String,
  visible_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
}))
})),
  state: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  tags: Schema.Record({ key: Schema.String, value: Schema.String }),
  updated_at: Schema.String,
  url: Schema.String
}) })),
  post_apply_resources_unavailable: Schema.optional(Schema.Boolean),
  region: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Struct({
  apply_progress: Schema.Struct({
  done: Schema.Number,
  total: Schema.Number
}),
  lifecycle_errors: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  code: Schema.Literal(1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 5001, 5002, 5003, 5004, 102000, 102001, 102002, 102003, 102004, 102005, 102006, 102007, 102008, 102009, 102010, 102011, 102012, 102013, 102014, 102015, 102016, 102017, 102018, 102019, 102020, 102021, 102022, 102023, 102024, 102025, 102026, 102027, 102028, 102029, 102030, 102031, 102032, 102033, 102034, 102035, 102036, 102037, 102038, 102039, 102040, 102041, 102042, 102043, 102044, 102045, 102046, 102047, 102048, 102049, 102050, 102051, 102052, 102053, 102054, 102055, 102056, 102057, 102058, 102059, 102060, 102061, 102062, 102063, 102064, 102065, 102066, 103001, 103002, 103003, 103004, 103005, 103006, 103007, 103008),
  documentation_url: Schema.optional(Schema.String),
  message: Schema.String,
  meta: Schema.optional(Schema.Struct({
  l10n_key: Schema.optional(Schema.String),
  loggable_error: Schema.optional(Schema.String),
  template_data: Schema.optional(Schema.Struct({})),
  trace_id: Schema.optional(Schema.String)
})),
  source: Schema.optional(Schema.Struct({
  parameter: Schema.optional(Schema.String),
  parameter_value_index: Schema.optional(Schema.Number),
  pointer: Schema.optional(Schema.String)
}))
}) })),
  lifecycle_state: Schema.Literal("OnrampNeedsApply", "OnrampPendingPlan", "OnrampPlanning", "OnrampPlanFailed", "OnrampPendingApproval", "OnrampPendingApply", "OnrampApplying", "OnrampApplyFailed", "OnrampActive", "OnrampPendingDestroy", "OnrampDestroying", "OnrampDestroyFailed"),
  plan_progress: Schema.Struct({
  done: Schema.Number,
  total: Schema.Number
}),
  routes: Schema.Array(Schema.UUID),
  tunnels: Schema.Array(Schema.UUID)
})),
  type: Schema.Literal("OnrampTypeSingle", "OnrampTypeHub"),
  updated_at: Schema.String,
  vpc: Schema.optional(Schema.UUID),
  vpcs_by_id: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  account_id: Schema.String,
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  config: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  deployment_provider: Schema.UUID,
  id: Schema.UUID,
  managed: Schema.Boolean,
  managed_by: Schema.optional(Schema.Array(Schema.Struct({
  client_type: Schema.Literal("MAGIC_WAN_CLOUD_ONRAMP"),
  id: Schema.UUID,
  name: Schema.String
}))),
  monthly_cost_estimate: Schema.Struct({
  currency: Schema.String,
  monthly_cost: Schema.Number
}),
  name: Schema.String,
  native_id: Schema.String,
  observations: Schema.Record({ key: Schema.String, value: Schema.Struct({
  first_observed_at: Schema.String,
  last_observed_at: Schema.String,
  provider_id: Schema.UUID,
  resource_id: Schema.UUID
}) }),
  provider_ids: Schema.Array(Schema.UUID),
  provider_names_by_id: Schema.Record({ key: Schema.String, value: Schema.String }),
  region: Schema.String,
  resource_group: Schema.String,
  resource_type: Schema.Literal("aws_customer_gateway", "aws_egress_only_internet_gateway", "aws_internet_gateway", "aws_instance", "aws_network_interface", "aws_route", "aws_route_table", "aws_route_table_association", "aws_subnet", "aws_vpc", "aws_vpc_ipv4_cidr_block_association", "aws_vpn_connection", "aws_vpn_connection_route", "aws_vpn_gateway", "aws_security_group", "aws_vpc_security_group_ingress_rule", "aws_vpc_security_group_egress_rule", "aws_ec2_managed_prefix_list", "aws_ec2_transit_gateway", "aws_ec2_transit_gateway_prefix_list_reference", "aws_ec2_transit_gateway_vpc_attachment", "azurerm_application_security_group", "azurerm_lb", "azurerm_lb_backend_address_pool", "azurerm_lb_nat_pool", "azurerm_lb_nat_rule", "azurerm_lb_rule", "azurerm_local_network_gateway", "azurerm_network_interface", "azurerm_network_interface_application_security_group_association", "azurerm_network_interface_backend_address_pool_association", "azurerm_network_interface_security_group_association", "azurerm_network_security_group", "azurerm_public_ip", "azurerm_route", "azurerm_route_table", "azurerm_subnet", "azurerm_subnet_route_table_association", "azurerm_virtual_machine", "azurerm_virtual_network_gateway_connection", "azurerm_virtual_network", "azurerm_virtual_network_gateway", "google_compute_network", "google_compute_subnetwork", "google_compute_vpn_gateway", "google_compute_vpn_tunnel", "google_compute_route", "google_compute_address", "google_compute_global_address", "google_compute_router", "google_compute_interconnect_attachment", "google_compute_ha_vpn_gateway", "google_compute_forwarding_rule", "google_compute_network_firewall_policy", "google_compute_network_firewall_policy_rule", "cloudflare_static_route", "cloudflare_ipsec_tunnel"),
  sections: Schema.Array(Schema.Struct({
  help_text: Schema.optional(Schema.String),
  hidden_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
})),
  name: Schema.String,
  visible_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
}))
})),
  state: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  tags: Schema.Record({ key: Schema.String, value: Schema.String }),
  updated_at: Schema.String,
  url: Schema.String
}) })),
  vpcs_by_id_unavailable: Schema.optional(Schema.Array(Schema.UUID))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "OnrampsReadResponse" }) as unknown as Schema.Schema<OnrampsReadResponse>;

export const onrampsRead: (
  input: OnrampsReadRequest
) => Effect.Effect<
  OnrampsReadResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: OnrampsReadRequest,
  output: OnrampsReadResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update14Request {
  account_id: string;
  onramp_id: string;
  body: { attached_hubs?: string[]; attached_vpcs?: string[]; description?: string; install_routes_in_cloud?: boolean; install_routes_in_magic_wan?: boolean; manage_hub_to_hub_attachments?: boolean; manage_vpc_to_hub_attachments?: boolean; name?: string; vpc?: string };
}

export const Update14Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  onramp_id: Schema.UUID.pipe(T.HttpPath("onramp_id")),
  body: Schema.Struct({
  attached_hubs: Schema.optional(Schema.Array(Schema.UUID)),
  attached_vpcs: Schema.optional(Schema.Array(Schema.UUID)),
  description: Schema.optional(Schema.String),
  install_routes_in_cloud: Schema.optional(Schema.Boolean),
  install_routes_in_magic_wan: Schema.optional(Schema.Boolean),
  manage_hub_to_hub_attachments: Schema.optional(Schema.Boolean),
  manage_vpc_to_hub_attachments: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  vpc: Schema.optional(Schema.UUID)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/cloud/onramps/{onramp_id}" }),
).annotations({ identifier: "Update14Request" }) as unknown as Schema.Schema<Update14Request>;

export interface Update14Response {
  result: { attached_hubs?: string[]; attached_vpcs?: string[]; cloud_type: "AWS" | "AZURE" | "GOOGLE"; description?: string; hub?: string; id: string; install_routes_in_cloud: boolean; install_routes_in_magic_wan: boolean; last_applied_at?: string; last_exported_at?: string; last_planned_at?: string; manage_hub_to_hub_attachments?: boolean; manage_vpc_to_hub_attachments?: boolean; name: string; planned_monthly_cost_estimate?: { currency: string; current_monthly_cost: number; diff: number; proposed_monthly_cost: number }; planned_resources?: { diff: { diff: string; left_description: string; left_yaml: string; right_description: string; right_yaml: string }; keys_require_replace: string[]; monthly_cost_estimate_diff: { currency: string; current_monthly_cost: number; diff: number; proposed_monthly_cost: number }; planned_action: "no_op" | "create" | "update" | "replace" | "destroy"; resource: { cloud_type: "AWS" | "AZURE" | "GOOGLE" | "CLOUDFLARE"; detail: string; id: string; name: string; resource_type: "aws_customer_gateway" | "aws_egress_only_internet_gateway" | "aws_internet_gateway" | "aws_instance" | "aws_network_interface" | "aws_route" | "aws_route_table" | "aws_route_table_association" | "aws_subnet" | "aws_vpc" | "aws_vpc_ipv4_cidr_block_association" | "aws_vpn_connection" | "aws_vpn_connection_route" | "aws_vpn_gateway" | "aws_security_group" | "aws_vpc_security_group_ingress_rule" | "aws_vpc_security_group_egress_rule" | "aws_ec2_managed_prefix_list" | "aws_ec2_transit_gateway" | "aws_ec2_transit_gateway_prefix_list_reference" | "aws_ec2_transit_gateway_vpc_attachment" | "azurerm_application_security_group" | "azurerm_lb" | "azurerm_lb_backend_address_pool" | "azurerm_lb_nat_pool" | "azurerm_lb_nat_rule" | "azurerm_lb_rule" | "azurerm_local_network_gateway" | "azurerm_network_interface" | "azurerm_network_interface_application_security_group_association" | "azurerm_network_interface_backend_address_pool_association" | "azurerm_network_interface_security_group_association" | "azurerm_network_security_group" | "azurerm_public_ip" | "azurerm_route" | "azurerm_route_table" | "azurerm_subnet" | "azurerm_subnet_route_table_association" | "azurerm_virtual_machine" | "azurerm_virtual_network_gateway_connection" | "azurerm_virtual_network" | "azurerm_virtual_network_gateway" | "google_compute_network" | "google_compute_subnetwork" | "google_compute_vpn_gateway" | "google_compute_vpn_tunnel" | "google_compute_route" | "google_compute_address" | "google_compute_global_address" | "google_compute_router" | "google_compute_interconnect_attachment" | "google_compute_ha_vpn_gateway" | "google_compute_forwarding_rule" | "google_compute_network_firewall_policy" | "google_compute_network_firewall_policy_rule" | "cloudflare_static_route" | "cloudflare_ipsec_tunnel"; title: string } }[]; planned_resources_unavailable?: boolean; post_apply_monthly_cost_estimate?: { currency: string; monthly_cost: number }; post_apply_resources?: Record<string, unknown>; post_apply_resources_unavailable?: boolean; region?: string; status?: { apply_progress: { done: number; total: number }; lifecycle_errors?: Record<string, unknown>; lifecycle_state: "OnrampNeedsApply" | "OnrampPendingPlan" | "OnrampPlanning" | "OnrampPlanFailed" | "OnrampPendingApproval" | "OnrampPendingApply" | "OnrampApplying" | "OnrampApplyFailed" | "OnrampActive" | "OnrampPendingDestroy" | "OnrampDestroying" | "OnrampDestroyFailed"; plan_progress: { done: number; total: number }; routes: string[]; tunnels: string[] }; type: "OnrampTypeSingle" | "OnrampTypeHub"; updated_at: string; vpc?: string; vpcs_by_id?: Record<string, unknown>; vpcs_by_id_unavailable?: string[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update14Response = Schema.Struct({
  result: Schema.Struct({
  attached_hubs: Schema.optional(Schema.Array(Schema.UUID)),
  attached_vpcs: Schema.optional(Schema.Array(Schema.UUID)),
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE"),
  description: Schema.optional(Schema.String),
  hub: Schema.optional(Schema.UUID),
  id: Schema.UUID,
  install_routes_in_cloud: Schema.Boolean,
  install_routes_in_magic_wan: Schema.Boolean,
  last_applied_at: Schema.optional(Schema.String),
  last_exported_at: Schema.optional(Schema.String),
  last_planned_at: Schema.optional(Schema.String),
  manage_hub_to_hub_attachments: Schema.optional(Schema.Boolean),
  manage_vpc_to_hub_attachments: Schema.optional(Schema.Boolean),
  name: Schema.String,
  planned_monthly_cost_estimate: Schema.optional(Schema.Struct({
  currency: Schema.String,
  current_monthly_cost: Schema.Number,
  diff: Schema.Number,
  proposed_monthly_cost: Schema.Number
})),
  planned_resources: Schema.optional(Schema.Array(Schema.Struct({
  diff: Schema.Struct({
  diff: Schema.String,
  left_description: Schema.String,
  left_yaml: Schema.String,
  right_description: Schema.String,
  right_yaml: Schema.String
}),
  keys_require_replace: Schema.Array(Schema.String),
  monthly_cost_estimate_diff: Schema.Struct({
  currency: Schema.String,
  current_monthly_cost: Schema.Number,
  diff: Schema.Number,
  proposed_monthly_cost: Schema.Number
}),
  planned_action: Schema.Literal("no_op", "create", "update", "replace", "destroy"),
  resource: Schema.Struct({
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  detail: Schema.String,
  id: Schema.UUID,
  name: Schema.String,
  resource_type: Schema.Literal("aws_customer_gateway", "aws_egress_only_internet_gateway", "aws_internet_gateway", "aws_instance", "aws_network_interface", "aws_route", "aws_route_table", "aws_route_table_association", "aws_subnet", "aws_vpc", "aws_vpc_ipv4_cidr_block_association", "aws_vpn_connection", "aws_vpn_connection_route", "aws_vpn_gateway", "aws_security_group", "aws_vpc_security_group_ingress_rule", "aws_vpc_security_group_egress_rule", "aws_ec2_managed_prefix_list", "aws_ec2_transit_gateway", "aws_ec2_transit_gateway_prefix_list_reference", "aws_ec2_transit_gateway_vpc_attachment", "azurerm_application_security_group", "azurerm_lb", "azurerm_lb_backend_address_pool", "azurerm_lb_nat_pool", "azurerm_lb_nat_rule", "azurerm_lb_rule", "azurerm_local_network_gateway", "azurerm_network_interface", "azurerm_network_interface_application_security_group_association", "azurerm_network_interface_backend_address_pool_association", "azurerm_network_interface_security_group_association", "azurerm_network_security_group", "azurerm_public_ip", "azurerm_route", "azurerm_route_table", "azurerm_subnet", "azurerm_subnet_route_table_association", "azurerm_virtual_machine", "azurerm_virtual_network_gateway_connection", "azurerm_virtual_network", "azurerm_virtual_network_gateway", "google_compute_network", "google_compute_subnetwork", "google_compute_vpn_gateway", "google_compute_vpn_tunnel", "google_compute_route", "google_compute_address", "google_compute_global_address", "google_compute_router", "google_compute_interconnect_attachment", "google_compute_ha_vpn_gateway", "google_compute_forwarding_rule", "google_compute_network_firewall_policy", "google_compute_network_firewall_policy_rule", "cloudflare_static_route", "cloudflare_ipsec_tunnel"),
  title: Schema.String
})
}))),
  planned_resources_unavailable: Schema.optional(Schema.Boolean),
  post_apply_monthly_cost_estimate: Schema.optional(Schema.Struct({
  currency: Schema.String,
  monthly_cost: Schema.Number
})),
  post_apply_resources: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  account_id: Schema.String,
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  config: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  deployment_provider: Schema.UUID,
  id: Schema.UUID,
  managed: Schema.Boolean,
  managed_by: Schema.optional(Schema.Array(Schema.Struct({
  client_type: Schema.Literal("MAGIC_WAN_CLOUD_ONRAMP"),
  id: Schema.UUID,
  name: Schema.String
}))),
  monthly_cost_estimate: Schema.Struct({
  currency: Schema.String,
  monthly_cost: Schema.Number
}),
  name: Schema.String,
  native_id: Schema.String,
  observations: Schema.Record({ key: Schema.String, value: Schema.Struct({
  first_observed_at: Schema.String,
  last_observed_at: Schema.String,
  provider_id: Schema.UUID,
  resource_id: Schema.UUID
}) }),
  provider_ids: Schema.Array(Schema.UUID),
  provider_names_by_id: Schema.Record({ key: Schema.String, value: Schema.String }),
  region: Schema.String,
  resource_group: Schema.String,
  resource_type: Schema.Literal("aws_customer_gateway", "aws_egress_only_internet_gateway", "aws_internet_gateway", "aws_instance", "aws_network_interface", "aws_route", "aws_route_table", "aws_route_table_association", "aws_subnet", "aws_vpc", "aws_vpc_ipv4_cidr_block_association", "aws_vpn_connection", "aws_vpn_connection_route", "aws_vpn_gateway", "aws_security_group", "aws_vpc_security_group_ingress_rule", "aws_vpc_security_group_egress_rule", "aws_ec2_managed_prefix_list", "aws_ec2_transit_gateway", "aws_ec2_transit_gateway_prefix_list_reference", "aws_ec2_transit_gateway_vpc_attachment", "azurerm_application_security_group", "azurerm_lb", "azurerm_lb_backend_address_pool", "azurerm_lb_nat_pool", "azurerm_lb_nat_rule", "azurerm_lb_rule", "azurerm_local_network_gateway", "azurerm_network_interface", "azurerm_network_interface_application_security_group_association", "azurerm_network_interface_backend_address_pool_association", "azurerm_network_interface_security_group_association", "azurerm_network_security_group", "azurerm_public_ip", "azurerm_route", "azurerm_route_table", "azurerm_subnet", "azurerm_subnet_route_table_association", "azurerm_virtual_machine", "azurerm_virtual_network_gateway_connection", "azurerm_virtual_network", "azurerm_virtual_network_gateway", "google_compute_network", "google_compute_subnetwork", "google_compute_vpn_gateway", "google_compute_vpn_tunnel", "google_compute_route", "google_compute_address", "google_compute_global_address", "google_compute_router", "google_compute_interconnect_attachment", "google_compute_ha_vpn_gateway", "google_compute_forwarding_rule", "google_compute_network_firewall_policy", "google_compute_network_firewall_policy_rule", "cloudflare_static_route", "cloudflare_ipsec_tunnel"),
  sections: Schema.Array(Schema.Struct({
  help_text: Schema.optional(Schema.String),
  hidden_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
})),
  name: Schema.String,
  visible_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
}))
})),
  state: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  tags: Schema.Record({ key: Schema.String, value: Schema.String }),
  updated_at: Schema.String,
  url: Schema.String
}) })),
  post_apply_resources_unavailable: Schema.optional(Schema.Boolean),
  region: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Struct({
  apply_progress: Schema.Struct({
  done: Schema.Number,
  total: Schema.Number
}),
  lifecycle_errors: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  code: Schema.Literal(1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 5001, 5002, 5003, 5004, 102000, 102001, 102002, 102003, 102004, 102005, 102006, 102007, 102008, 102009, 102010, 102011, 102012, 102013, 102014, 102015, 102016, 102017, 102018, 102019, 102020, 102021, 102022, 102023, 102024, 102025, 102026, 102027, 102028, 102029, 102030, 102031, 102032, 102033, 102034, 102035, 102036, 102037, 102038, 102039, 102040, 102041, 102042, 102043, 102044, 102045, 102046, 102047, 102048, 102049, 102050, 102051, 102052, 102053, 102054, 102055, 102056, 102057, 102058, 102059, 102060, 102061, 102062, 102063, 102064, 102065, 102066, 103001, 103002, 103003, 103004, 103005, 103006, 103007, 103008),
  documentation_url: Schema.optional(Schema.String),
  message: Schema.String,
  meta: Schema.optional(Schema.Struct({
  l10n_key: Schema.optional(Schema.String),
  loggable_error: Schema.optional(Schema.String),
  template_data: Schema.optional(Schema.Struct({})),
  trace_id: Schema.optional(Schema.String)
})),
  source: Schema.optional(Schema.Struct({
  parameter: Schema.optional(Schema.String),
  parameter_value_index: Schema.optional(Schema.Number),
  pointer: Schema.optional(Schema.String)
}))
}) })),
  lifecycle_state: Schema.Literal("OnrampNeedsApply", "OnrampPendingPlan", "OnrampPlanning", "OnrampPlanFailed", "OnrampPendingApproval", "OnrampPendingApply", "OnrampApplying", "OnrampApplyFailed", "OnrampActive", "OnrampPendingDestroy", "OnrampDestroying", "OnrampDestroyFailed"),
  plan_progress: Schema.Struct({
  done: Schema.Number,
  total: Schema.Number
}),
  routes: Schema.Array(Schema.UUID),
  tunnels: Schema.Array(Schema.UUID)
})),
  type: Schema.Literal("OnrampTypeSingle", "OnrampTypeHub"),
  updated_at: Schema.String,
  vpc: Schema.optional(Schema.UUID),
  vpcs_by_id: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  account_id: Schema.String,
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  config: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  deployment_provider: Schema.UUID,
  id: Schema.UUID,
  managed: Schema.Boolean,
  managed_by: Schema.optional(Schema.Array(Schema.Struct({
  client_type: Schema.Literal("MAGIC_WAN_CLOUD_ONRAMP"),
  id: Schema.UUID,
  name: Schema.String
}))),
  monthly_cost_estimate: Schema.Struct({
  currency: Schema.String,
  monthly_cost: Schema.Number
}),
  name: Schema.String,
  native_id: Schema.String,
  observations: Schema.Record({ key: Schema.String, value: Schema.Struct({
  first_observed_at: Schema.String,
  last_observed_at: Schema.String,
  provider_id: Schema.UUID,
  resource_id: Schema.UUID
}) }),
  provider_ids: Schema.Array(Schema.UUID),
  provider_names_by_id: Schema.Record({ key: Schema.String, value: Schema.String }),
  region: Schema.String,
  resource_group: Schema.String,
  resource_type: Schema.Literal("aws_customer_gateway", "aws_egress_only_internet_gateway", "aws_internet_gateway", "aws_instance", "aws_network_interface", "aws_route", "aws_route_table", "aws_route_table_association", "aws_subnet", "aws_vpc", "aws_vpc_ipv4_cidr_block_association", "aws_vpn_connection", "aws_vpn_connection_route", "aws_vpn_gateway", "aws_security_group", "aws_vpc_security_group_ingress_rule", "aws_vpc_security_group_egress_rule", "aws_ec2_managed_prefix_list", "aws_ec2_transit_gateway", "aws_ec2_transit_gateway_prefix_list_reference", "aws_ec2_transit_gateway_vpc_attachment", "azurerm_application_security_group", "azurerm_lb", "azurerm_lb_backend_address_pool", "azurerm_lb_nat_pool", "azurerm_lb_nat_rule", "azurerm_lb_rule", "azurerm_local_network_gateway", "azurerm_network_interface", "azurerm_network_interface_application_security_group_association", "azurerm_network_interface_backend_address_pool_association", "azurerm_network_interface_security_group_association", "azurerm_network_security_group", "azurerm_public_ip", "azurerm_route", "azurerm_route_table", "azurerm_subnet", "azurerm_subnet_route_table_association", "azurerm_virtual_machine", "azurerm_virtual_network_gateway_connection", "azurerm_virtual_network", "azurerm_virtual_network_gateway", "google_compute_network", "google_compute_subnetwork", "google_compute_vpn_gateway", "google_compute_vpn_tunnel", "google_compute_route", "google_compute_address", "google_compute_global_address", "google_compute_router", "google_compute_interconnect_attachment", "google_compute_ha_vpn_gateway", "google_compute_forwarding_rule", "google_compute_network_firewall_policy", "google_compute_network_firewall_policy_rule", "cloudflare_static_route", "cloudflare_ipsec_tunnel"),
  sections: Schema.Array(Schema.Struct({
  help_text: Schema.optional(Schema.String),
  hidden_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
})),
  name: Schema.String,
  visible_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
}))
})),
  state: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  tags: Schema.Record({ key: Schema.String, value: Schema.String }),
  updated_at: Schema.String,
  url: Schema.String
}) })),
  vpcs_by_id_unavailable: Schema.optional(Schema.Array(Schema.UUID))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update14Response" }) as unknown as Schema.Schema<Update14Response>;

export const update14: (
  input: Update14Request
) => Effect.Effect<
  Update14Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update14Request,
  output: Update14Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_15Request {
  account_id: string;
  onramp_id: string;
  destroy?: boolean;
  force?: boolean;
}

export const Delete_15Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  onramp_id: Schema.UUID.pipe(T.HttpPath("onramp_id")),
  destroy: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("destroy")),
  force: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("force"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/cloud/onramps/{onramp_id}" }),
).annotations({ identifier: "Delete_15Request" }) as unknown as Schema.Schema<Delete_15Request>;

export interface Delete_15Response {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_15Response = Schema.Struct({
  result: Schema.Struct({
  id: Schema.UUID
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_15Response" }) as unknown as Schema.Schema<Delete_15Response>;

export const delete_15: (
  input: Delete_15Request
) => Effect.Effect<
  Delete_15Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_15Request,
  output: Delete_15Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Patch3Request {
  account_id: string;
  onramp_id: string;
  body: { attached_hubs?: string[]; attached_vpcs?: string[]; description?: string; install_routes_in_cloud?: boolean; install_routes_in_magic_wan?: boolean; manage_hub_to_hub_attachments?: boolean; manage_vpc_to_hub_attachments?: boolean; name?: string; vpc?: string };
}

export const Patch3Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  onramp_id: Schema.UUID.pipe(T.HttpPath("onramp_id")),
  body: Schema.Struct({
  attached_hubs: Schema.optional(Schema.Array(Schema.UUID)),
  attached_vpcs: Schema.optional(Schema.Array(Schema.UUID)),
  description: Schema.optional(Schema.String),
  install_routes_in_cloud: Schema.optional(Schema.Boolean),
  install_routes_in_magic_wan: Schema.optional(Schema.Boolean),
  manage_hub_to_hub_attachments: Schema.optional(Schema.Boolean),
  manage_vpc_to_hub_attachments: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  vpc: Schema.optional(Schema.UUID)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/cloud/onramps/{onramp_id}" }),
).annotations({ identifier: "Patch3Request" }) as unknown as Schema.Schema<Patch3Request>;

export interface Patch3Response {
  result: { attached_hubs?: string[]; attached_vpcs?: string[]; cloud_type: "AWS" | "AZURE" | "GOOGLE"; description?: string; hub?: string; id: string; install_routes_in_cloud: boolean; install_routes_in_magic_wan: boolean; last_applied_at?: string; last_exported_at?: string; last_planned_at?: string; manage_hub_to_hub_attachments?: boolean; manage_vpc_to_hub_attachments?: boolean; name: string; planned_monthly_cost_estimate?: { currency: string; current_monthly_cost: number; diff: number; proposed_monthly_cost: number }; planned_resources?: { diff: { diff: string; left_description: string; left_yaml: string; right_description: string; right_yaml: string }; keys_require_replace: string[]; monthly_cost_estimate_diff: { currency: string; current_monthly_cost: number; diff: number; proposed_monthly_cost: number }; planned_action: "no_op" | "create" | "update" | "replace" | "destroy"; resource: { cloud_type: "AWS" | "AZURE" | "GOOGLE" | "CLOUDFLARE"; detail: string; id: string; name: string; resource_type: "aws_customer_gateway" | "aws_egress_only_internet_gateway" | "aws_internet_gateway" | "aws_instance" | "aws_network_interface" | "aws_route" | "aws_route_table" | "aws_route_table_association" | "aws_subnet" | "aws_vpc" | "aws_vpc_ipv4_cidr_block_association" | "aws_vpn_connection" | "aws_vpn_connection_route" | "aws_vpn_gateway" | "aws_security_group" | "aws_vpc_security_group_ingress_rule" | "aws_vpc_security_group_egress_rule" | "aws_ec2_managed_prefix_list" | "aws_ec2_transit_gateway" | "aws_ec2_transit_gateway_prefix_list_reference" | "aws_ec2_transit_gateway_vpc_attachment" | "azurerm_application_security_group" | "azurerm_lb" | "azurerm_lb_backend_address_pool" | "azurerm_lb_nat_pool" | "azurerm_lb_nat_rule" | "azurerm_lb_rule" | "azurerm_local_network_gateway" | "azurerm_network_interface" | "azurerm_network_interface_application_security_group_association" | "azurerm_network_interface_backend_address_pool_association" | "azurerm_network_interface_security_group_association" | "azurerm_network_security_group" | "azurerm_public_ip" | "azurerm_route" | "azurerm_route_table" | "azurerm_subnet" | "azurerm_subnet_route_table_association" | "azurerm_virtual_machine" | "azurerm_virtual_network_gateway_connection" | "azurerm_virtual_network" | "azurerm_virtual_network_gateway" | "google_compute_network" | "google_compute_subnetwork" | "google_compute_vpn_gateway" | "google_compute_vpn_tunnel" | "google_compute_route" | "google_compute_address" | "google_compute_global_address" | "google_compute_router" | "google_compute_interconnect_attachment" | "google_compute_ha_vpn_gateway" | "google_compute_forwarding_rule" | "google_compute_network_firewall_policy" | "google_compute_network_firewall_policy_rule" | "cloudflare_static_route" | "cloudflare_ipsec_tunnel"; title: string } }[]; planned_resources_unavailable?: boolean; post_apply_monthly_cost_estimate?: { currency: string; monthly_cost: number }; post_apply_resources?: Record<string, unknown>; post_apply_resources_unavailable?: boolean; region?: string; status?: { apply_progress: { done: number; total: number }; lifecycle_errors?: Record<string, unknown>; lifecycle_state: "OnrampNeedsApply" | "OnrampPendingPlan" | "OnrampPlanning" | "OnrampPlanFailed" | "OnrampPendingApproval" | "OnrampPendingApply" | "OnrampApplying" | "OnrampApplyFailed" | "OnrampActive" | "OnrampPendingDestroy" | "OnrampDestroying" | "OnrampDestroyFailed"; plan_progress: { done: number; total: number }; routes: string[]; tunnels: string[] }; type: "OnrampTypeSingle" | "OnrampTypeHub"; updated_at: string; vpc?: string; vpcs_by_id?: Record<string, unknown>; vpcs_by_id_unavailable?: string[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Patch3Response = Schema.Struct({
  result: Schema.Struct({
  attached_hubs: Schema.optional(Schema.Array(Schema.UUID)),
  attached_vpcs: Schema.optional(Schema.Array(Schema.UUID)),
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE"),
  description: Schema.optional(Schema.String),
  hub: Schema.optional(Schema.UUID),
  id: Schema.UUID,
  install_routes_in_cloud: Schema.Boolean,
  install_routes_in_magic_wan: Schema.Boolean,
  last_applied_at: Schema.optional(Schema.String),
  last_exported_at: Schema.optional(Schema.String),
  last_planned_at: Schema.optional(Schema.String),
  manage_hub_to_hub_attachments: Schema.optional(Schema.Boolean),
  manage_vpc_to_hub_attachments: Schema.optional(Schema.Boolean),
  name: Schema.String,
  planned_monthly_cost_estimate: Schema.optional(Schema.Struct({
  currency: Schema.String,
  current_monthly_cost: Schema.Number,
  diff: Schema.Number,
  proposed_monthly_cost: Schema.Number
})),
  planned_resources: Schema.optional(Schema.Array(Schema.Struct({
  diff: Schema.Struct({
  diff: Schema.String,
  left_description: Schema.String,
  left_yaml: Schema.String,
  right_description: Schema.String,
  right_yaml: Schema.String
}),
  keys_require_replace: Schema.Array(Schema.String),
  monthly_cost_estimate_diff: Schema.Struct({
  currency: Schema.String,
  current_monthly_cost: Schema.Number,
  diff: Schema.Number,
  proposed_monthly_cost: Schema.Number
}),
  planned_action: Schema.Literal("no_op", "create", "update", "replace", "destroy"),
  resource: Schema.Struct({
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  detail: Schema.String,
  id: Schema.UUID,
  name: Schema.String,
  resource_type: Schema.Literal("aws_customer_gateway", "aws_egress_only_internet_gateway", "aws_internet_gateway", "aws_instance", "aws_network_interface", "aws_route", "aws_route_table", "aws_route_table_association", "aws_subnet", "aws_vpc", "aws_vpc_ipv4_cidr_block_association", "aws_vpn_connection", "aws_vpn_connection_route", "aws_vpn_gateway", "aws_security_group", "aws_vpc_security_group_ingress_rule", "aws_vpc_security_group_egress_rule", "aws_ec2_managed_prefix_list", "aws_ec2_transit_gateway", "aws_ec2_transit_gateway_prefix_list_reference", "aws_ec2_transit_gateway_vpc_attachment", "azurerm_application_security_group", "azurerm_lb", "azurerm_lb_backend_address_pool", "azurerm_lb_nat_pool", "azurerm_lb_nat_rule", "azurerm_lb_rule", "azurerm_local_network_gateway", "azurerm_network_interface", "azurerm_network_interface_application_security_group_association", "azurerm_network_interface_backend_address_pool_association", "azurerm_network_interface_security_group_association", "azurerm_network_security_group", "azurerm_public_ip", "azurerm_route", "azurerm_route_table", "azurerm_subnet", "azurerm_subnet_route_table_association", "azurerm_virtual_machine", "azurerm_virtual_network_gateway_connection", "azurerm_virtual_network", "azurerm_virtual_network_gateway", "google_compute_network", "google_compute_subnetwork", "google_compute_vpn_gateway", "google_compute_vpn_tunnel", "google_compute_route", "google_compute_address", "google_compute_global_address", "google_compute_router", "google_compute_interconnect_attachment", "google_compute_ha_vpn_gateway", "google_compute_forwarding_rule", "google_compute_network_firewall_policy", "google_compute_network_firewall_policy_rule", "cloudflare_static_route", "cloudflare_ipsec_tunnel"),
  title: Schema.String
})
}))),
  planned_resources_unavailable: Schema.optional(Schema.Boolean),
  post_apply_monthly_cost_estimate: Schema.optional(Schema.Struct({
  currency: Schema.String,
  monthly_cost: Schema.Number
})),
  post_apply_resources: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  account_id: Schema.String,
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  config: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  deployment_provider: Schema.UUID,
  id: Schema.UUID,
  managed: Schema.Boolean,
  managed_by: Schema.optional(Schema.Array(Schema.Struct({
  client_type: Schema.Literal("MAGIC_WAN_CLOUD_ONRAMP"),
  id: Schema.UUID,
  name: Schema.String
}))),
  monthly_cost_estimate: Schema.Struct({
  currency: Schema.String,
  monthly_cost: Schema.Number
}),
  name: Schema.String,
  native_id: Schema.String,
  observations: Schema.Record({ key: Schema.String, value: Schema.Struct({
  first_observed_at: Schema.String,
  last_observed_at: Schema.String,
  provider_id: Schema.UUID,
  resource_id: Schema.UUID
}) }),
  provider_ids: Schema.Array(Schema.UUID),
  provider_names_by_id: Schema.Record({ key: Schema.String, value: Schema.String }),
  region: Schema.String,
  resource_group: Schema.String,
  resource_type: Schema.Literal("aws_customer_gateway", "aws_egress_only_internet_gateway", "aws_internet_gateway", "aws_instance", "aws_network_interface", "aws_route", "aws_route_table", "aws_route_table_association", "aws_subnet", "aws_vpc", "aws_vpc_ipv4_cidr_block_association", "aws_vpn_connection", "aws_vpn_connection_route", "aws_vpn_gateway", "aws_security_group", "aws_vpc_security_group_ingress_rule", "aws_vpc_security_group_egress_rule", "aws_ec2_managed_prefix_list", "aws_ec2_transit_gateway", "aws_ec2_transit_gateway_prefix_list_reference", "aws_ec2_transit_gateway_vpc_attachment", "azurerm_application_security_group", "azurerm_lb", "azurerm_lb_backend_address_pool", "azurerm_lb_nat_pool", "azurerm_lb_nat_rule", "azurerm_lb_rule", "azurerm_local_network_gateway", "azurerm_network_interface", "azurerm_network_interface_application_security_group_association", "azurerm_network_interface_backend_address_pool_association", "azurerm_network_interface_security_group_association", "azurerm_network_security_group", "azurerm_public_ip", "azurerm_route", "azurerm_route_table", "azurerm_subnet", "azurerm_subnet_route_table_association", "azurerm_virtual_machine", "azurerm_virtual_network_gateway_connection", "azurerm_virtual_network", "azurerm_virtual_network_gateway", "google_compute_network", "google_compute_subnetwork", "google_compute_vpn_gateway", "google_compute_vpn_tunnel", "google_compute_route", "google_compute_address", "google_compute_global_address", "google_compute_router", "google_compute_interconnect_attachment", "google_compute_ha_vpn_gateway", "google_compute_forwarding_rule", "google_compute_network_firewall_policy", "google_compute_network_firewall_policy_rule", "cloudflare_static_route", "cloudflare_ipsec_tunnel"),
  sections: Schema.Array(Schema.Struct({
  help_text: Schema.optional(Schema.String),
  hidden_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
})),
  name: Schema.String,
  visible_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
}))
})),
  state: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  tags: Schema.Record({ key: Schema.String, value: Schema.String }),
  updated_at: Schema.String,
  url: Schema.String
}) })),
  post_apply_resources_unavailable: Schema.optional(Schema.Boolean),
  region: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Struct({
  apply_progress: Schema.Struct({
  done: Schema.Number,
  total: Schema.Number
}),
  lifecycle_errors: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  code: Schema.Literal(1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 5001, 5002, 5003, 5004, 102000, 102001, 102002, 102003, 102004, 102005, 102006, 102007, 102008, 102009, 102010, 102011, 102012, 102013, 102014, 102015, 102016, 102017, 102018, 102019, 102020, 102021, 102022, 102023, 102024, 102025, 102026, 102027, 102028, 102029, 102030, 102031, 102032, 102033, 102034, 102035, 102036, 102037, 102038, 102039, 102040, 102041, 102042, 102043, 102044, 102045, 102046, 102047, 102048, 102049, 102050, 102051, 102052, 102053, 102054, 102055, 102056, 102057, 102058, 102059, 102060, 102061, 102062, 102063, 102064, 102065, 102066, 103001, 103002, 103003, 103004, 103005, 103006, 103007, 103008),
  documentation_url: Schema.optional(Schema.String),
  message: Schema.String,
  meta: Schema.optional(Schema.Struct({
  l10n_key: Schema.optional(Schema.String),
  loggable_error: Schema.optional(Schema.String),
  template_data: Schema.optional(Schema.Struct({})),
  trace_id: Schema.optional(Schema.String)
})),
  source: Schema.optional(Schema.Struct({
  parameter: Schema.optional(Schema.String),
  parameter_value_index: Schema.optional(Schema.Number),
  pointer: Schema.optional(Schema.String)
}))
}) })),
  lifecycle_state: Schema.Literal("OnrampNeedsApply", "OnrampPendingPlan", "OnrampPlanning", "OnrampPlanFailed", "OnrampPendingApproval", "OnrampPendingApply", "OnrampApplying", "OnrampApplyFailed", "OnrampActive", "OnrampPendingDestroy", "OnrampDestroying", "OnrampDestroyFailed"),
  plan_progress: Schema.Struct({
  done: Schema.Number,
  total: Schema.Number
}),
  routes: Schema.Array(Schema.UUID),
  tunnels: Schema.Array(Schema.UUID)
})),
  type: Schema.Literal("OnrampTypeSingle", "OnrampTypeHub"),
  updated_at: Schema.String,
  vpc: Schema.optional(Schema.UUID),
  vpcs_by_id: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Struct({
  account_id: Schema.String,
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  config: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  deployment_provider: Schema.UUID,
  id: Schema.UUID,
  managed: Schema.Boolean,
  managed_by: Schema.optional(Schema.Array(Schema.Struct({
  client_type: Schema.Literal("MAGIC_WAN_CLOUD_ONRAMP"),
  id: Schema.UUID,
  name: Schema.String
}))),
  monthly_cost_estimate: Schema.Struct({
  currency: Schema.String,
  monthly_cost: Schema.Number
}),
  name: Schema.String,
  native_id: Schema.String,
  observations: Schema.Record({ key: Schema.String, value: Schema.Struct({
  first_observed_at: Schema.String,
  last_observed_at: Schema.String,
  provider_id: Schema.UUID,
  resource_id: Schema.UUID
}) }),
  provider_ids: Schema.Array(Schema.UUID),
  provider_names_by_id: Schema.Record({ key: Schema.String, value: Schema.String }),
  region: Schema.String,
  resource_group: Schema.String,
  resource_type: Schema.Literal("aws_customer_gateway", "aws_egress_only_internet_gateway", "aws_internet_gateway", "aws_instance", "aws_network_interface", "aws_route", "aws_route_table", "aws_route_table_association", "aws_subnet", "aws_vpc", "aws_vpc_ipv4_cidr_block_association", "aws_vpn_connection", "aws_vpn_connection_route", "aws_vpn_gateway", "aws_security_group", "aws_vpc_security_group_ingress_rule", "aws_vpc_security_group_egress_rule", "aws_ec2_managed_prefix_list", "aws_ec2_transit_gateway", "aws_ec2_transit_gateway_prefix_list_reference", "aws_ec2_transit_gateway_vpc_attachment", "azurerm_application_security_group", "azurerm_lb", "azurerm_lb_backend_address_pool", "azurerm_lb_nat_pool", "azurerm_lb_nat_rule", "azurerm_lb_rule", "azurerm_local_network_gateway", "azurerm_network_interface", "azurerm_network_interface_application_security_group_association", "azurerm_network_interface_backend_address_pool_association", "azurerm_network_interface_security_group_association", "azurerm_network_security_group", "azurerm_public_ip", "azurerm_route", "azurerm_route_table", "azurerm_subnet", "azurerm_subnet_route_table_association", "azurerm_virtual_machine", "azurerm_virtual_network_gateway_connection", "azurerm_virtual_network", "azurerm_virtual_network_gateway", "google_compute_network", "google_compute_subnetwork", "google_compute_vpn_gateway", "google_compute_vpn_tunnel", "google_compute_route", "google_compute_address", "google_compute_global_address", "google_compute_router", "google_compute_interconnect_attachment", "google_compute_ha_vpn_gateway", "google_compute_forwarding_rule", "google_compute_network_firewall_policy", "google_compute_network_firewall_policy_rule", "cloudflare_static_route", "cloudflare_ipsec_tunnel"),
  sections: Schema.Array(Schema.Struct({
  help_text: Schema.optional(Schema.String),
  hidden_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
})),
  name: Schema.String,
  visible_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
}))
})),
  state: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  tags: Schema.Record({ key: Schema.String, value: Schema.String }),
  updated_at: Schema.String,
  url: Schema.String
}) })),
  vpcs_by_id_unavailable: Schema.optional(Schema.Array(Schema.UUID))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Patch3Response" }) as unknown as Schema.Schema<Patch3Response>;

export const patch3: (
  input: Patch3Request
) => Effect.Effect<
  Patch3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Patch3Request,
  output: Patch3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface OnrampsApplyRequest {
  account_id: string;
  onramp_id: string;
}

export const OnrampsApplyRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  onramp_id: Schema.UUID.pipe(T.HttpPath("onramp_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/cloud/onramps/{onramp_id}/apply" }),
).annotations({ identifier: "OnrampsApplyRequest" }) as unknown as Schema.Schema<OnrampsApplyRequest>;

export interface OnrampsApplyResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const OnrampsApplyResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "OnrampsApplyResponse" }) as unknown as Schema.Schema<OnrampsApplyResponse>;

export const onrampsApply: (
  input: OnrampsApplyRequest
) => Effect.Effect<
  OnrampsApplyResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: OnrampsApplyRequest,
  output: OnrampsApplyResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface OnrampsExportRequest {
  account_id: string;
  onramp_id: string;
}

export const OnrampsExportRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  onramp_id: Schema.UUID.pipe(T.HttpPath("onramp_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/cloud/onramps/{onramp_id}/export" }),
).annotations({ identifier: "OnrampsExportRequest" }) as unknown as Schema.Schema<OnrampsExportRequest>;

export interface OnrampsExportResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const OnrampsExportResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "OnrampsExportResponse" }) as unknown as Schema.Schema<OnrampsExportResponse>;

export const onrampsExport: (
  input: OnrampsExportRequest
) => Effect.Effect<
  OnrampsExportResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: OnrampsExportRequest,
  output: OnrampsExportResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface OnrampsPlanRequest {
  account_id: string;
  onramp_id: string;
}

export const OnrampsPlanRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  onramp_id: Schema.UUID.pipe(T.HttpPath("onramp_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/cloud/onramps/{onramp_id}/plan" }),
).annotations({ identifier: "OnrampsPlanRequest" }) as unknown as Schema.Schema<OnrampsPlanRequest>;

export interface OnrampsPlanResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const OnrampsPlanResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "OnrampsPlanResponse" }) as unknown as Schema.Schema<OnrampsPlanResponse>;

export const onrampsPlan: (
  input: OnrampsPlanRequest
) => Effect.Effect<
  OnrampsPlanResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: OnrampsPlanRequest,
  output: OnrampsPlanResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List30Request {
  account_id: string;
  status?: boolean;
  order_by?: string;
  desc?: boolean;
  cloudflare?: boolean;
}

export const List30Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  status: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("status")),
  order_by: Schema.optional(Schema.String).pipe(T.HttpQuery("order_by")),
  desc: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("desc")),
  cloudflare: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("cloudflare"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/cloud/providers" }),
).annotations({ identifier: "List30Request" }) as unknown as Schema.Schema<List30Request>;

export interface List30Response {
  result: { aws_arn?: string; azure_subscription_id?: string; azure_tenant_id?: string; cloud_type: "AWS" | "AZURE" | "GOOGLE" | "CLOUDFLARE"; description?: string; friendly_name: string; gcp_project_id?: string; gcp_service_account_email?: string; id: string; last_updated: string; lifecycle_state: "ACTIVE" | "PENDING_SETUP" | "RETIRED"; state: "UNSPECIFIED" | "PENDING" | "DISCOVERING" | "FAILED" | "SUCCEEDED"; state_v2: "UNSPECIFIED" | "PENDING" | "DISCOVERING" | "FAILED" | "SUCCEEDED"; status?: { credentials_good_since?: string; credentials_missing_since?: string; credentials_rejected_since?: string; discovery_message?: string; discovery_message_v2?: string; discovery_progress: { done: number; total: number; unit: string }; discovery_progress_v2: { done: number; total: number; unit: string }; in_use_by?: { client_type: "MAGIC_WAN_CLOUD_ONRAMP"; id: string; name: string }[]; last_discovery_completed_at?: string; last_discovery_completed_at_v2?: string; last_discovery_started_at?: string; last_discovery_started_at_v2?: string; last_discovery_status: "UNSPECIFIED" | "PENDING" | "DISCOVERING" | "FAILED" | "SUCCEEDED"; last_discovery_status_v2: "UNSPECIFIED" | "PENDING" | "DISCOVERING" | "FAILED" | "SUCCEEDED"; last_updated?: string; regions: string[] } }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List30Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  aws_arn: Schema.optional(Schema.String),
  azure_subscription_id: Schema.optional(Schema.String),
  azure_tenant_id: Schema.optional(Schema.String),
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  description: Schema.optional(Schema.String),
  friendly_name: Schema.String,
  gcp_project_id: Schema.optional(Schema.String),
  gcp_service_account_email: Schema.optional(Schema.String),
  id: Schema.UUID,
  last_updated: Schema.String,
  lifecycle_state: Schema.Literal("ACTIVE", "PENDING_SETUP", "RETIRED"),
  state: Schema.Literal("UNSPECIFIED", "PENDING", "DISCOVERING", "FAILED", "SUCCEEDED"),
  state_v2: Schema.Literal("UNSPECIFIED", "PENDING", "DISCOVERING", "FAILED", "SUCCEEDED"),
  status: Schema.optional(Schema.Struct({
  credentials_good_since: Schema.optional(Schema.String),
  credentials_missing_since: Schema.optional(Schema.String),
  credentials_rejected_since: Schema.optional(Schema.String),
  discovery_message: Schema.optional(Schema.String),
  discovery_message_v2: Schema.optional(Schema.String),
  discovery_progress: Schema.Struct({
  done: Schema.Number,
  total: Schema.Number,
  unit: Schema.String
}),
  discovery_progress_v2: Schema.Struct({
  done: Schema.Number,
  total: Schema.Number,
  unit: Schema.String
}),
  in_use_by: Schema.optional(Schema.Array(Schema.Struct({
  client_type: Schema.Literal("MAGIC_WAN_CLOUD_ONRAMP"),
  id: Schema.UUID,
  name: Schema.String
}))),
  last_discovery_completed_at: Schema.optional(Schema.String),
  last_discovery_completed_at_v2: Schema.optional(Schema.String),
  last_discovery_started_at: Schema.optional(Schema.String),
  last_discovery_started_at_v2: Schema.optional(Schema.String),
  last_discovery_status: Schema.Literal("UNSPECIFIED", "PENDING", "DISCOVERING", "FAILED", "SUCCEEDED"),
  last_discovery_status_v2: Schema.Literal("UNSPECIFIED", "PENDING", "DISCOVERING", "FAILED", "SUCCEEDED"),
  last_updated: Schema.optional(Schema.String),
  regions: Schema.Array(Schema.String)
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List30Response" }) as unknown as Schema.Schema<List30Response>;

export const list30: (
  input: List30Request
) => Effect.Effect<
  List30Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List30Request,
  output: List30Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create11Request {
  account_id: string;
  forwarded?: string;
  body: { cloud_type: "AWS" | "AZURE" | "GOOGLE" | "CLOUDFLARE"; description?: string; friendly_name: string };
}

export const Create11Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  forwarded: Schema.optional(Schema.String).pipe(T.HttpHeader("forwarded")),
  body: Schema.Struct({
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  description: Schema.optional(Schema.String),
  friendly_name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/cloud/providers" }),
).annotations({ identifier: "Create11Request" }) as unknown as Schema.Schema<Create11Request>;

export interface Create11Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create11Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create11Response" }) as unknown as Schema.Schema<Create11Response>;

export const create11: (
  input: Create11Request
) => Effect.Effect<
  Create11Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create11Request,
  output: Create11Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ProvidersDiscoverAllRequest {
  account_id: string;
}

export const ProvidersDiscoverAllRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/cloud/providers/discover" }),
).annotations({ identifier: "ProvidersDiscoverAllRequest" }) as unknown as Schema.Schema<ProvidersDiscoverAllRequest>;

export interface ProvidersDiscoverAllResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ProvidersDiscoverAllResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ProvidersDiscoverAllResponse" }) as unknown as Schema.Schema<ProvidersDiscoverAllResponse>;

export const providersDiscoverAll: (
  input: ProvidersDiscoverAllRequest
) => Effect.Effect<
  ProvidersDiscoverAllResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ProvidersDiscoverAllRequest,
  output: ProvidersDiscoverAllResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ProvidersReadRequest {
  account_id: string;
  provider_id: string;
  status?: boolean;
}

export const ProvidersReadRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  provider_id: Schema.UUID.pipe(T.HttpPath("provider_id")),
  status: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("status"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/cloud/providers/{provider_id}" }),
).annotations({ identifier: "ProvidersReadRequest" }) as unknown as Schema.Schema<ProvidersReadRequest>;

export interface ProvidersReadResponse {
  result: { aws_arn?: string; azure_subscription_id?: string; azure_tenant_id?: string; cloud_type: "AWS" | "AZURE" | "GOOGLE" | "CLOUDFLARE"; description?: string; friendly_name: string; gcp_project_id?: string; gcp_service_account_email?: string; id: string; last_updated: string; lifecycle_state: "ACTIVE" | "PENDING_SETUP" | "RETIRED"; state: "UNSPECIFIED" | "PENDING" | "DISCOVERING" | "FAILED" | "SUCCEEDED"; state_v2: "UNSPECIFIED" | "PENDING" | "DISCOVERING" | "FAILED" | "SUCCEEDED"; status?: { credentials_good_since?: string; credentials_missing_since?: string; credentials_rejected_since?: string; discovery_message?: string; discovery_message_v2?: string; discovery_progress: { done: number; total: number; unit: string }; discovery_progress_v2: { done: number; total: number; unit: string }; in_use_by?: { client_type: "MAGIC_WAN_CLOUD_ONRAMP"; id: string; name: string }[]; last_discovery_completed_at?: string; last_discovery_completed_at_v2?: string; last_discovery_started_at?: string; last_discovery_started_at_v2?: string; last_discovery_status: "UNSPECIFIED" | "PENDING" | "DISCOVERING" | "FAILED" | "SUCCEEDED"; last_discovery_status_v2: "UNSPECIFIED" | "PENDING" | "DISCOVERING" | "FAILED" | "SUCCEEDED"; last_updated?: string; regions: string[] } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ProvidersReadResponse = Schema.Struct({
  result: Schema.Struct({
  aws_arn: Schema.optional(Schema.String),
  azure_subscription_id: Schema.optional(Schema.String),
  azure_tenant_id: Schema.optional(Schema.String),
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  description: Schema.optional(Schema.String),
  friendly_name: Schema.String,
  gcp_project_id: Schema.optional(Schema.String),
  gcp_service_account_email: Schema.optional(Schema.String),
  id: Schema.UUID,
  last_updated: Schema.String,
  lifecycle_state: Schema.Literal("ACTIVE", "PENDING_SETUP", "RETIRED"),
  state: Schema.Literal("UNSPECIFIED", "PENDING", "DISCOVERING", "FAILED", "SUCCEEDED"),
  state_v2: Schema.Literal("UNSPECIFIED", "PENDING", "DISCOVERING", "FAILED", "SUCCEEDED"),
  status: Schema.optional(Schema.Struct({
  credentials_good_since: Schema.optional(Schema.String),
  credentials_missing_since: Schema.optional(Schema.String),
  credentials_rejected_since: Schema.optional(Schema.String),
  discovery_message: Schema.optional(Schema.String),
  discovery_message_v2: Schema.optional(Schema.String),
  discovery_progress: Schema.Struct({
  done: Schema.Number,
  total: Schema.Number,
  unit: Schema.String
}),
  discovery_progress_v2: Schema.Struct({
  done: Schema.Number,
  total: Schema.Number,
  unit: Schema.String
}),
  in_use_by: Schema.optional(Schema.Array(Schema.Struct({
  client_type: Schema.Literal("MAGIC_WAN_CLOUD_ONRAMP"),
  id: Schema.UUID,
  name: Schema.String
}))),
  last_discovery_completed_at: Schema.optional(Schema.String),
  last_discovery_completed_at_v2: Schema.optional(Schema.String),
  last_discovery_started_at: Schema.optional(Schema.String),
  last_discovery_started_at_v2: Schema.optional(Schema.String),
  last_discovery_status: Schema.Literal("UNSPECIFIED", "PENDING", "DISCOVERING", "FAILED", "SUCCEEDED"),
  last_discovery_status_v2: Schema.Literal("UNSPECIFIED", "PENDING", "DISCOVERING", "FAILED", "SUCCEEDED"),
  last_updated: Schema.optional(Schema.String),
  regions: Schema.Array(Schema.String)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ProvidersReadResponse" }) as unknown as Schema.Schema<ProvidersReadResponse>;

export const providersRead: (
  input: ProvidersReadRequest
) => Effect.Effect<
  ProvidersReadResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ProvidersReadRequest,
  output: ProvidersReadResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update15Request {
  account_id: string;
  provider_id: string;
  body: { aws_arn?: string; azure_subscription_id?: string; azure_tenant_id?: string; description?: string; friendly_name?: string; gcp_project_id?: string; gcp_service_account_email?: string };
}

export const Update15Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  provider_id: Schema.UUID.pipe(T.HttpPath("provider_id")),
  body: Schema.Struct({
  aws_arn: Schema.optional(Schema.String),
  azure_subscription_id: Schema.optional(Schema.String),
  azure_tenant_id: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  friendly_name: Schema.optional(Schema.String),
  gcp_project_id: Schema.optional(Schema.String),
  gcp_service_account_email: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/cloud/providers/{provider_id}" }),
).annotations({ identifier: "Update15Request" }) as unknown as Schema.Schema<Update15Request>;

export interface Update15Response {
  result: { aws_arn?: string; azure_subscription_id?: string; azure_tenant_id?: string; cloud_type: "AWS" | "AZURE" | "GOOGLE" | "CLOUDFLARE"; description?: string; friendly_name: string; gcp_project_id?: string; gcp_service_account_email?: string; id: string; last_updated: string; lifecycle_state: "ACTIVE" | "PENDING_SETUP" | "RETIRED"; state: "UNSPECIFIED" | "PENDING" | "DISCOVERING" | "FAILED" | "SUCCEEDED"; state_v2: "UNSPECIFIED" | "PENDING" | "DISCOVERING" | "FAILED" | "SUCCEEDED"; status?: { credentials_good_since?: string; credentials_missing_since?: string; credentials_rejected_since?: string; discovery_message?: string; discovery_message_v2?: string; discovery_progress: { done: number; total: number; unit: string }; discovery_progress_v2: { done: number; total: number; unit: string }; in_use_by?: { client_type: "MAGIC_WAN_CLOUD_ONRAMP"; id: string; name: string }[]; last_discovery_completed_at?: string; last_discovery_completed_at_v2?: string; last_discovery_started_at?: string; last_discovery_started_at_v2?: string; last_discovery_status: "UNSPECIFIED" | "PENDING" | "DISCOVERING" | "FAILED" | "SUCCEEDED"; last_discovery_status_v2: "UNSPECIFIED" | "PENDING" | "DISCOVERING" | "FAILED" | "SUCCEEDED"; last_updated?: string; regions: string[] } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update15Response = Schema.Struct({
  result: Schema.Struct({
  aws_arn: Schema.optional(Schema.String),
  azure_subscription_id: Schema.optional(Schema.String),
  azure_tenant_id: Schema.optional(Schema.String),
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  description: Schema.optional(Schema.String),
  friendly_name: Schema.String,
  gcp_project_id: Schema.optional(Schema.String),
  gcp_service_account_email: Schema.optional(Schema.String),
  id: Schema.UUID,
  last_updated: Schema.String,
  lifecycle_state: Schema.Literal("ACTIVE", "PENDING_SETUP", "RETIRED"),
  state: Schema.Literal("UNSPECIFIED", "PENDING", "DISCOVERING", "FAILED", "SUCCEEDED"),
  state_v2: Schema.Literal("UNSPECIFIED", "PENDING", "DISCOVERING", "FAILED", "SUCCEEDED"),
  status: Schema.optional(Schema.Struct({
  credentials_good_since: Schema.optional(Schema.String),
  credentials_missing_since: Schema.optional(Schema.String),
  credentials_rejected_since: Schema.optional(Schema.String),
  discovery_message: Schema.optional(Schema.String),
  discovery_message_v2: Schema.optional(Schema.String),
  discovery_progress: Schema.Struct({
  done: Schema.Number,
  total: Schema.Number,
  unit: Schema.String
}),
  discovery_progress_v2: Schema.Struct({
  done: Schema.Number,
  total: Schema.Number,
  unit: Schema.String
}),
  in_use_by: Schema.optional(Schema.Array(Schema.Struct({
  client_type: Schema.Literal("MAGIC_WAN_CLOUD_ONRAMP"),
  id: Schema.UUID,
  name: Schema.String
}))),
  last_discovery_completed_at: Schema.optional(Schema.String),
  last_discovery_completed_at_v2: Schema.optional(Schema.String),
  last_discovery_started_at: Schema.optional(Schema.String),
  last_discovery_started_at_v2: Schema.optional(Schema.String),
  last_discovery_status: Schema.Literal("UNSPECIFIED", "PENDING", "DISCOVERING", "FAILED", "SUCCEEDED"),
  last_discovery_status_v2: Schema.Literal("UNSPECIFIED", "PENDING", "DISCOVERING", "FAILED", "SUCCEEDED"),
  last_updated: Schema.optional(Schema.String),
  regions: Schema.Array(Schema.String)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update15Response" }) as unknown as Schema.Schema<Update15Response>;

export const update15: (
  input: Update15Request
) => Effect.Effect<
  Update15Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update15Request,
  output: Update15Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_16Request {
  account_id: string;
  provider_id: string;
}

export const Delete_16Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  provider_id: Schema.UUID.pipe(T.HttpPath("provider_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/cloud/providers/{provider_id}" }),
).annotations({ identifier: "Delete_16Request" }) as unknown as Schema.Schema<Delete_16Request>;

export interface Delete_16Response {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_16Response = Schema.Struct({
  result: Schema.Struct({
  id: Schema.UUID
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_16Response" }) as unknown as Schema.Schema<Delete_16Response>;

export const delete_16: (
  input: Delete_16Request
) => Effect.Effect<
  Delete_16Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_16Request,
  output: Delete_16Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Patch4Request {
  account_id: string;
  provider_id: string;
  body: { aws_arn?: string; azure_subscription_id?: string; azure_tenant_id?: string; description?: string; friendly_name?: string; gcp_project_id?: string; gcp_service_account_email?: string };
}

export const Patch4Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  provider_id: Schema.UUID.pipe(T.HttpPath("provider_id")),
  body: Schema.Struct({
  aws_arn: Schema.optional(Schema.String),
  azure_subscription_id: Schema.optional(Schema.String),
  azure_tenant_id: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  friendly_name: Schema.optional(Schema.String),
  gcp_project_id: Schema.optional(Schema.String),
  gcp_service_account_email: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/cloud/providers/{provider_id}" }),
).annotations({ identifier: "Patch4Request" }) as unknown as Schema.Schema<Patch4Request>;

export interface Patch4Response {
  result: { aws_arn?: string; azure_subscription_id?: string; azure_tenant_id?: string; cloud_type: "AWS" | "AZURE" | "GOOGLE" | "CLOUDFLARE"; description?: string; friendly_name: string; gcp_project_id?: string; gcp_service_account_email?: string; id: string; last_updated: string; lifecycle_state: "ACTIVE" | "PENDING_SETUP" | "RETIRED"; state: "UNSPECIFIED" | "PENDING" | "DISCOVERING" | "FAILED" | "SUCCEEDED"; state_v2: "UNSPECIFIED" | "PENDING" | "DISCOVERING" | "FAILED" | "SUCCEEDED"; status?: { credentials_good_since?: string; credentials_missing_since?: string; credentials_rejected_since?: string; discovery_message?: string; discovery_message_v2?: string; discovery_progress: { done: number; total: number; unit: string }; discovery_progress_v2: { done: number; total: number; unit: string }; in_use_by?: { client_type: "MAGIC_WAN_CLOUD_ONRAMP"; id: string; name: string }[]; last_discovery_completed_at?: string; last_discovery_completed_at_v2?: string; last_discovery_started_at?: string; last_discovery_started_at_v2?: string; last_discovery_status: "UNSPECIFIED" | "PENDING" | "DISCOVERING" | "FAILED" | "SUCCEEDED"; last_discovery_status_v2: "UNSPECIFIED" | "PENDING" | "DISCOVERING" | "FAILED" | "SUCCEEDED"; last_updated?: string; regions: string[] } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Patch4Response = Schema.Struct({
  result: Schema.Struct({
  aws_arn: Schema.optional(Schema.String),
  azure_subscription_id: Schema.optional(Schema.String),
  azure_tenant_id: Schema.optional(Schema.String),
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  description: Schema.optional(Schema.String),
  friendly_name: Schema.String,
  gcp_project_id: Schema.optional(Schema.String),
  gcp_service_account_email: Schema.optional(Schema.String),
  id: Schema.UUID,
  last_updated: Schema.String,
  lifecycle_state: Schema.Literal("ACTIVE", "PENDING_SETUP", "RETIRED"),
  state: Schema.Literal("UNSPECIFIED", "PENDING", "DISCOVERING", "FAILED", "SUCCEEDED"),
  state_v2: Schema.Literal("UNSPECIFIED", "PENDING", "DISCOVERING", "FAILED", "SUCCEEDED"),
  status: Schema.optional(Schema.Struct({
  credentials_good_since: Schema.optional(Schema.String),
  credentials_missing_since: Schema.optional(Schema.String),
  credentials_rejected_since: Schema.optional(Schema.String),
  discovery_message: Schema.optional(Schema.String),
  discovery_message_v2: Schema.optional(Schema.String),
  discovery_progress: Schema.Struct({
  done: Schema.Number,
  total: Schema.Number,
  unit: Schema.String
}),
  discovery_progress_v2: Schema.Struct({
  done: Schema.Number,
  total: Schema.Number,
  unit: Schema.String
}),
  in_use_by: Schema.optional(Schema.Array(Schema.Struct({
  client_type: Schema.Literal("MAGIC_WAN_CLOUD_ONRAMP"),
  id: Schema.UUID,
  name: Schema.String
}))),
  last_discovery_completed_at: Schema.optional(Schema.String),
  last_discovery_completed_at_v2: Schema.optional(Schema.String),
  last_discovery_started_at: Schema.optional(Schema.String),
  last_discovery_started_at_v2: Schema.optional(Schema.String),
  last_discovery_status: Schema.Literal("UNSPECIFIED", "PENDING", "DISCOVERING", "FAILED", "SUCCEEDED"),
  last_discovery_status_v2: Schema.Literal("UNSPECIFIED", "PENDING", "DISCOVERING", "FAILED", "SUCCEEDED"),
  last_updated: Schema.optional(Schema.String),
  regions: Schema.Array(Schema.String)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Patch4Response" }) as unknown as Schema.Schema<Patch4Response>;

export const patch4: (
  input: Patch4Request
) => Effect.Effect<
  Patch4Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Patch4Request,
  output: Patch4Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ProvidersDiscoverRequest {
  account_id: string;
  provider_id: string;
  v2?: boolean;
}

export const ProvidersDiscoverRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  provider_id: Schema.UUID.pipe(T.HttpPath("provider_id")),
  v2: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("v2"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/cloud/providers/{provider_id}/discover" }),
).annotations({ identifier: "ProvidersDiscoverRequest" }) as unknown as Schema.Schema<ProvidersDiscoverRequest>;

export interface ProvidersDiscoverResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ProvidersDiscoverResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ProvidersDiscoverResponse" }) as unknown as Schema.Schema<ProvidersDiscoverResponse>;

export const providersDiscover: (
  input: ProvidersDiscoverRequest
) => Effect.Effect<
  ProvidersDiscoverResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ProvidersDiscoverRequest,
  output: ProvidersDiscoverResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ProvidersInitialSetupRequest {
  account_id: string;
  provider_id: string;
}

export const ProvidersInitialSetupRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  provider_id: Schema.UUID.pipe(T.HttpPath("provider_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/cloud/providers/{provider_id}/initial_setup" }),
).annotations({ identifier: "ProvidersInitialSetupRequest" }) as unknown as Schema.Schema<ProvidersInitialSetupRequest>;

export interface ProvidersInitialSetupResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ProvidersInitialSetupResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ProvidersInitialSetupResponse" }) as unknown as Schema.Schema<ProvidersInitialSetupResponse>;

export const providersInitialSetup: (
  input: ProvidersInitialSetupRequest
) => Effect.Effect<
  ProvidersInitialSetupResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ProvidersInitialSetupRequest,
  output: ProvidersInitialSetupResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List31Request {
  account_id: string;
  provider_id?: string;
  resource_type?: "aws_customer_gateway" | "aws_egress_only_internet_gateway" | "aws_internet_gateway" | "aws_instance" | "aws_network_interface" | "aws_route" | "aws_route_table" | "aws_route_table_association" | "aws_subnet" | "aws_vpc" | "aws_vpc_ipv4_cidr_block_association" | "aws_vpn_connection" | "aws_vpn_connection_route" | "aws_vpn_gateway" | "aws_security_group" | "aws_vpc_security_group_ingress_rule" | "aws_vpc_security_group_egress_rule" | "aws_ec2_managed_prefix_list" | "aws_ec2_transit_gateway" | "aws_ec2_transit_gateway_prefix_list_reference" | "aws_ec2_transit_gateway_vpc_attachment" | "azurerm_application_security_group" | "azurerm_lb" | "azurerm_lb_backend_address_pool" | "azurerm_lb_nat_pool" | "azurerm_lb_nat_rule" | "azurerm_lb_rule" | "azurerm_local_network_gateway" | "azurerm_network_interface" | "azurerm_network_interface_application_security_group_association" | "azurerm_network_interface_backend_address_pool_association" | "azurerm_network_interface_security_group_association" | "azurerm_network_security_group" | "azurerm_public_ip" | "azurerm_route" | "azurerm_route_table" | "azurerm_subnet" | "azurerm_subnet_route_table_association" | "azurerm_virtual_machine" | "azurerm_virtual_network_gateway_connection" | "azurerm_virtual_network" | "azurerm_virtual_network_gateway" | "google_compute_network" | "google_compute_subnetwork" | "google_compute_vpn_gateway" | "google_compute_vpn_tunnel" | "google_compute_route" | "google_compute_address" | "google_compute_global_address" | "google_compute_router" | "google_compute_interconnect_attachment" | "google_compute_ha_vpn_gateway" | "google_compute_forwarding_rule" | "google_compute_network_firewall_policy" | "google_compute_network_firewall_policy_rule" | "cloudflare_static_route" | "cloudflare_ipsec_tunnel"[];
  resource_id?: string[];
  region?: string;
  resource_group?: string;
  managed?: boolean;
  search?: string[];
  order_by?: string;
  desc?: boolean;
  per_page?: number;
  page?: number;
  cloudflare?: boolean;
  v2?: boolean;
}

export const List31Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  provider_id: Schema.optional(Schema.String).pipe(T.HttpQuery("provider_id")),
  resource_type: Schema.optional(Schema.Array(Schema.Literal("aws_customer_gateway", "aws_egress_only_internet_gateway", "aws_internet_gateway", "aws_instance", "aws_network_interface", "aws_route", "aws_route_table", "aws_route_table_association", "aws_subnet", "aws_vpc", "aws_vpc_ipv4_cidr_block_association", "aws_vpn_connection", "aws_vpn_connection_route", "aws_vpn_gateway", "aws_security_group", "aws_vpc_security_group_ingress_rule", "aws_vpc_security_group_egress_rule", "aws_ec2_managed_prefix_list", "aws_ec2_transit_gateway", "aws_ec2_transit_gateway_prefix_list_reference", "aws_ec2_transit_gateway_vpc_attachment", "azurerm_application_security_group", "azurerm_lb", "azurerm_lb_backend_address_pool", "azurerm_lb_nat_pool", "azurerm_lb_nat_rule", "azurerm_lb_rule", "azurerm_local_network_gateway", "azurerm_network_interface", "azurerm_network_interface_application_security_group_association", "azurerm_network_interface_backend_address_pool_association", "azurerm_network_interface_security_group_association", "azurerm_network_security_group", "azurerm_public_ip", "azurerm_route", "azurerm_route_table", "azurerm_subnet", "azurerm_subnet_route_table_association", "azurerm_virtual_machine", "azurerm_virtual_network_gateway_connection", "azurerm_virtual_network", "azurerm_virtual_network_gateway", "google_compute_network", "google_compute_subnetwork", "google_compute_vpn_gateway", "google_compute_vpn_tunnel", "google_compute_route", "google_compute_address", "google_compute_global_address", "google_compute_router", "google_compute_interconnect_attachment", "google_compute_ha_vpn_gateway", "google_compute_forwarding_rule", "google_compute_network_firewall_policy", "google_compute_network_firewall_policy_rule", "cloudflare_static_route", "cloudflare_ipsec_tunnel"))).pipe(T.HttpQuery("resource_type")),
  resource_id: Schema.optional(Schema.Array(Schema.UUID)).pipe(T.HttpQuery("resource_id")),
  region: Schema.optional(Schema.String).pipe(T.HttpQuery("region")),
  resource_group: Schema.optional(Schema.String).pipe(T.HttpQuery("resource_group")),
  managed: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("managed")),
  search: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("search")),
  order_by: Schema.optional(Schema.String).pipe(T.HttpQuery("order_by")),
  desc: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("desc")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  cloudflare: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("cloudflare")),
  v2: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("v2"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/cloud/resources" }),
).annotations({ identifier: "List31Request" }) as unknown as Schema.Schema<List31Request>;

export interface List31Response {
  result: { account_id: string; cloud_type: "AWS" | "AZURE" | "GOOGLE" | "CLOUDFLARE"; config: Record<string, unknown>; deployment_provider: string; id: string; managed: boolean; managed_by?: { client_type: "MAGIC_WAN_CLOUD_ONRAMP"; id: string; name: string }[]; monthly_cost_estimate: { currency: string; monthly_cost: number }; name: string; native_id: string; observations: Record<string, unknown>; provider_ids: string[]; provider_names_by_id: Record<string, unknown>; region: string; resource_group: string; resource_type: "aws_customer_gateway" | "aws_egress_only_internet_gateway" | "aws_internet_gateway" | "aws_instance" | "aws_network_interface" | "aws_route" | "aws_route_table" | "aws_route_table_association" | "aws_subnet" | "aws_vpc" | "aws_vpc_ipv4_cidr_block_association" | "aws_vpn_connection" | "aws_vpn_connection_route" | "aws_vpn_gateway" | "aws_security_group" | "aws_vpc_security_group_ingress_rule" | "aws_vpc_security_group_egress_rule" | "aws_ec2_managed_prefix_list" | "aws_ec2_transit_gateway" | "aws_ec2_transit_gateway_prefix_list_reference" | "aws_ec2_transit_gateway_vpc_attachment" | "azurerm_application_security_group" | "azurerm_lb" | "azurerm_lb_backend_address_pool" | "azurerm_lb_nat_pool" | "azurerm_lb_nat_rule" | "azurerm_lb_rule" | "azurerm_local_network_gateway" | "azurerm_network_interface" | "azurerm_network_interface_application_security_group_association" | "azurerm_network_interface_backend_address_pool_association" | "azurerm_network_interface_security_group_association" | "azurerm_network_security_group" | "azurerm_public_ip" | "azurerm_route" | "azurerm_route_table" | "azurerm_subnet" | "azurerm_subnet_route_table_association" | "azurerm_virtual_machine" | "azurerm_virtual_network_gateway_connection" | "azurerm_virtual_network" | "azurerm_virtual_network_gateway" | "google_compute_network" | "google_compute_subnetwork" | "google_compute_vpn_gateway" | "google_compute_vpn_tunnel" | "google_compute_route" | "google_compute_address" | "google_compute_global_address" | "google_compute_router" | "google_compute_interconnect_attachment" | "google_compute_ha_vpn_gateway" | "google_compute_forwarding_rule" | "google_compute_network_firewall_policy" | "google_compute_network_firewall_policy_rule" | "cloudflare_static_route" | "cloudflare_ipsec_tunnel"; sections: { help_text?: string; hidden_items: { helpText?: string; name?: string; value?: Record<string, unknown> }[]; name: string; visible_items: { helpText?: string; name?: string; value?: Record<string, unknown> }[] }[]; state: Record<string, unknown>; tags: Record<string, unknown>; updated_at: string; url: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List31Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  account_id: Schema.String,
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  config: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  deployment_provider: Schema.UUID,
  id: Schema.UUID,
  managed: Schema.Boolean,
  managed_by: Schema.optional(Schema.Array(Schema.Struct({
  client_type: Schema.Literal("MAGIC_WAN_CLOUD_ONRAMP"),
  id: Schema.UUID,
  name: Schema.String
}))),
  monthly_cost_estimate: Schema.Struct({
  currency: Schema.String,
  monthly_cost: Schema.Number
}),
  name: Schema.String,
  native_id: Schema.String,
  observations: Schema.Record({ key: Schema.String, value: Schema.Struct({
  first_observed_at: Schema.String,
  last_observed_at: Schema.String,
  provider_id: Schema.UUID,
  resource_id: Schema.UUID
}) }),
  provider_ids: Schema.Array(Schema.UUID),
  provider_names_by_id: Schema.Record({ key: Schema.String, value: Schema.String }),
  region: Schema.String,
  resource_group: Schema.String,
  resource_type: Schema.Literal("aws_customer_gateway", "aws_egress_only_internet_gateway", "aws_internet_gateway", "aws_instance", "aws_network_interface", "aws_route", "aws_route_table", "aws_route_table_association", "aws_subnet", "aws_vpc", "aws_vpc_ipv4_cidr_block_association", "aws_vpn_connection", "aws_vpn_connection_route", "aws_vpn_gateway", "aws_security_group", "aws_vpc_security_group_ingress_rule", "aws_vpc_security_group_egress_rule", "aws_ec2_managed_prefix_list", "aws_ec2_transit_gateway", "aws_ec2_transit_gateway_prefix_list_reference", "aws_ec2_transit_gateway_vpc_attachment", "azurerm_application_security_group", "azurerm_lb", "azurerm_lb_backend_address_pool", "azurerm_lb_nat_pool", "azurerm_lb_nat_rule", "azurerm_lb_rule", "azurerm_local_network_gateway", "azurerm_network_interface", "azurerm_network_interface_application_security_group_association", "azurerm_network_interface_backend_address_pool_association", "azurerm_network_interface_security_group_association", "azurerm_network_security_group", "azurerm_public_ip", "azurerm_route", "azurerm_route_table", "azurerm_subnet", "azurerm_subnet_route_table_association", "azurerm_virtual_machine", "azurerm_virtual_network_gateway_connection", "azurerm_virtual_network", "azurerm_virtual_network_gateway", "google_compute_network", "google_compute_subnetwork", "google_compute_vpn_gateway", "google_compute_vpn_tunnel", "google_compute_route", "google_compute_address", "google_compute_global_address", "google_compute_router", "google_compute_interconnect_attachment", "google_compute_ha_vpn_gateway", "google_compute_forwarding_rule", "google_compute_network_firewall_policy", "google_compute_network_firewall_policy_rule", "cloudflare_static_route", "cloudflare_ipsec_tunnel"),
  sections: Schema.Array(Schema.Struct({
  help_text: Schema.optional(Schema.String),
  hidden_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
})),
  name: Schema.String,
  visible_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
}))
})),
  state: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  tags: Schema.Record({ key: Schema.String, value: Schema.String }),
  updated_at: Schema.String,
  url: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List31Response" }) as unknown as Schema.Schema<List31Response>;

export const list31: (
  input: List31Request
) => Effect.Effect<
  List31Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List31Request,
  output: List31Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ResourcesCatalogExportRequest {
  account_id: string;
  provider_id?: string;
  resource_type?: "aws_customer_gateway" | "aws_egress_only_internet_gateway" | "aws_internet_gateway" | "aws_instance" | "aws_network_interface" | "aws_route" | "aws_route_table" | "aws_route_table_association" | "aws_subnet" | "aws_vpc" | "aws_vpc_ipv4_cidr_block_association" | "aws_vpn_connection" | "aws_vpn_connection_route" | "aws_vpn_gateway" | "aws_security_group" | "aws_vpc_security_group_ingress_rule" | "aws_vpc_security_group_egress_rule" | "aws_ec2_managed_prefix_list" | "aws_ec2_transit_gateway" | "aws_ec2_transit_gateway_prefix_list_reference" | "aws_ec2_transit_gateway_vpc_attachment" | "azurerm_application_security_group" | "azurerm_lb" | "azurerm_lb_backend_address_pool" | "azurerm_lb_nat_pool" | "azurerm_lb_nat_rule" | "azurerm_lb_rule" | "azurerm_local_network_gateway" | "azurerm_network_interface" | "azurerm_network_interface_application_security_group_association" | "azurerm_network_interface_backend_address_pool_association" | "azurerm_network_interface_security_group_association" | "azurerm_network_security_group" | "azurerm_public_ip" | "azurerm_route" | "azurerm_route_table" | "azurerm_subnet" | "azurerm_subnet_route_table_association" | "azurerm_virtual_machine" | "azurerm_virtual_network_gateway_connection" | "azurerm_virtual_network" | "azurerm_virtual_network_gateway" | "google_compute_network" | "google_compute_subnetwork" | "google_compute_vpn_gateway" | "google_compute_vpn_tunnel" | "google_compute_route" | "google_compute_address" | "google_compute_global_address" | "google_compute_router" | "google_compute_interconnect_attachment" | "google_compute_ha_vpn_gateway" | "google_compute_forwarding_rule" | "google_compute_network_firewall_policy" | "google_compute_network_firewall_policy_rule" | "cloudflare_static_route" | "cloudflare_ipsec_tunnel"[];
  resource_id?: string[];
  region?: string;
  resource_group?: string;
  search?: string[];
  order_by?: string;
  desc?: boolean;
  v2?: boolean;
}

export const ResourcesCatalogExportRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  provider_id: Schema.optional(Schema.String).pipe(T.HttpQuery("provider_id")),
  resource_type: Schema.optional(Schema.Array(Schema.Literal("aws_customer_gateway", "aws_egress_only_internet_gateway", "aws_internet_gateway", "aws_instance", "aws_network_interface", "aws_route", "aws_route_table", "aws_route_table_association", "aws_subnet", "aws_vpc", "aws_vpc_ipv4_cidr_block_association", "aws_vpn_connection", "aws_vpn_connection_route", "aws_vpn_gateway", "aws_security_group", "aws_vpc_security_group_ingress_rule", "aws_vpc_security_group_egress_rule", "aws_ec2_managed_prefix_list", "aws_ec2_transit_gateway", "aws_ec2_transit_gateway_prefix_list_reference", "aws_ec2_transit_gateway_vpc_attachment", "azurerm_application_security_group", "azurerm_lb", "azurerm_lb_backend_address_pool", "azurerm_lb_nat_pool", "azurerm_lb_nat_rule", "azurerm_lb_rule", "azurerm_local_network_gateway", "azurerm_network_interface", "azurerm_network_interface_application_security_group_association", "azurerm_network_interface_backend_address_pool_association", "azurerm_network_interface_security_group_association", "azurerm_network_security_group", "azurerm_public_ip", "azurerm_route", "azurerm_route_table", "azurerm_subnet", "azurerm_subnet_route_table_association", "azurerm_virtual_machine", "azurerm_virtual_network_gateway_connection", "azurerm_virtual_network", "azurerm_virtual_network_gateway", "google_compute_network", "google_compute_subnetwork", "google_compute_vpn_gateway", "google_compute_vpn_tunnel", "google_compute_route", "google_compute_address", "google_compute_global_address", "google_compute_router", "google_compute_interconnect_attachment", "google_compute_ha_vpn_gateway", "google_compute_forwarding_rule", "google_compute_network_firewall_policy", "google_compute_network_firewall_policy_rule", "cloudflare_static_route", "cloudflare_ipsec_tunnel"))).pipe(T.HttpQuery("resource_type")),
  resource_id: Schema.optional(Schema.Array(Schema.UUID)).pipe(T.HttpQuery("resource_id")),
  region: Schema.optional(Schema.String).pipe(T.HttpQuery("region")),
  resource_group: Schema.optional(Schema.String).pipe(T.HttpQuery("resource_group")),
  search: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("search")),
  order_by: Schema.optional(Schema.String).pipe(T.HttpQuery("order_by")),
  desc: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("desc")),
  v2: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("v2"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/cloud/resources/export" }),
).annotations({ identifier: "ResourcesCatalogExportRequest" }) as unknown as Schema.Schema<ResourcesCatalogExportRequest>;

export interface ResourcesCatalogExportResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ResourcesCatalogExportResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ResourcesCatalogExportResponse" }) as unknown as Schema.Schema<ResourcesCatalogExportResponse>;

export const resourcesCatalogExport: (
  input: ResourcesCatalogExportRequest
) => Effect.Effect<
  ResourcesCatalogExportResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ResourcesCatalogExportRequest,
  output: ResourcesCatalogExportResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ResourcesCatalogPolicyPreviewRequest {
  account_id: string;
  body: { policy: string };
}

export const ResourcesCatalogPolicyPreviewRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  policy: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/cloud/resources/policy-preview" }),
).annotations({ identifier: "ResourcesCatalogPolicyPreviewRequest" }) as unknown as Schema.Schema<ResourcesCatalogPolicyPreviewRequest>;

export interface ResourcesCatalogPolicyPreviewResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ResourcesCatalogPolicyPreviewResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ResourcesCatalogPolicyPreviewResponse" }) as unknown as Schema.Schema<ResourcesCatalogPolicyPreviewResponse>;

export const resourcesCatalogPolicyPreview: (
  input: ResourcesCatalogPolicyPreviewRequest
) => Effect.Effect<
  ResourcesCatalogPolicyPreviewResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ResourcesCatalogPolicyPreviewRequest,
  output: ResourcesCatalogPolicyPreviewResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ResourcesCatalogReadRequest {
  account_id: string;
  resource_id: string;
  v2?: boolean;
}

export const ResourcesCatalogReadRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  resource_id: Schema.UUID.pipe(T.HttpPath("resource_id")),
  v2: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("v2"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/cloud/resources/{resource_id}" }),
).annotations({ identifier: "ResourcesCatalogReadRequest" }) as unknown as Schema.Schema<ResourcesCatalogReadRequest>;

export interface ResourcesCatalogReadResponse {
  result: { account_id: string; cloud_type: "AWS" | "AZURE" | "GOOGLE" | "CLOUDFLARE"; config: Record<string, unknown>; deployment_provider: string; id: string; managed: boolean; managed_by?: { client_type: "MAGIC_WAN_CLOUD_ONRAMP"; id: string; name: string }[]; monthly_cost_estimate: { currency: string; monthly_cost: number }; name: string; native_id: string; observations: Record<string, unknown>; provider_ids: string[]; provider_names_by_id: Record<string, unknown>; region: string; resource_group: string; resource_type: "aws_customer_gateway" | "aws_egress_only_internet_gateway" | "aws_internet_gateway" | "aws_instance" | "aws_network_interface" | "aws_route" | "aws_route_table" | "aws_route_table_association" | "aws_subnet" | "aws_vpc" | "aws_vpc_ipv4_cidr_block_association" | "aws_vpn_connection" | "aws_vpn_connection_route" | "aws_vpn_gateway" | "aws_security_group" | "aws_vpc_security_group_ingress_rule" | "aws_vpc_security_group_egress_rule" | "aws_ec2_managed_prefix_list" | "aws_ec2_transit_gateway" | "aws_ec2_transit_gateway_prefix_list_reference" | "aws_ec2_transit_gateway_vpc_attachment" | "azurerm_application_security_group" | "azurerm_lb" | "azurerm_lb_backend_address_pool" | "azurerm_lb_nat_pool" | "azurerm_lb_nat_rule" | "azurerm_lb_rule" | "azurerm_local_network_gateway" | "azurerm_network_interface" | "azurerm_network_interface_application_security_group_association" | "azurerm_network_interface_backend_address_pool_association" | "azurerm_network_interface_security_group_association" | "azurerm_network_security_group" | "azurerm_public_ip" | "azurerm_route" | "azurerm_route_table" | "azurerm_subnet" | "azurerm_subnet_route_table_association" | "azurerm_virtual_machine" | "azurerm_virtual_network_gateway_connection" | "azurerm_virtual_network" | "azurerm_virtual_network_gateway" | "google_compute_network" | "google_compute_subnetwork" | "google_compute_vpn_gateway" | "google_compute_vpn_tunnel" | "google_compute_route" | "google_compute_address" | "google_compute_global_address" | "google_compute_router" | "google_compute_interconnect_attachment" | "google_compute_ha_vpn_gateway" | "google_compute_forwarding_rule" | "google_compute_network_firewall_policy" | "google_compute_network_firewall_policy_rule" | "cloudflare_static_route" | "cloudflare_ipsec_tunnel"; sections: { help_text?: string; hidden_items: { helpText?: string; name?: string; value?: Record<string, unknown> }[]; name: string; visible_items: { helpText?: string; name?: string; value?: Record<string, unknown> }[] }[]; state: Record<string, unknown>; tags: Record<string, unknown>; updated_at: string; url: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ResourcesCatalogReadResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  cloud_type: Schema.Literal("AWS", "AZURE", "GOOGLE", "CLOUDFLARE"),
  config: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  deployment_provider: Schema.UUID,
  id: Schema.UUID,
  managed: Schema.Boolean,
  managed_by: Schema.optional(Schema.Array(Schema.Struct({
  client_type: Schema.Literal("MAGIC_WAN_CLOUD_ONRAMP"),
  id: Schema.UUID,
  name: Schema.String
}))),
  monthly_cost_estimate: Schema.Struct({
  currency: Schema.String,
  monthly_cost: Schema.Number
}),
  name: Schema.String,
  native_id: Schema.String,
  observations: Schema.Record({ key: Schema.String, value: Schema.Struct({
  first_observed_at: Schema.String,
  last_observed_at: Schema.String,
  provider_id: Schema.UUID,
  resource_id: Schema.UUID
}) }),
  provider_ids: Schema.Array(Schema.UUID),
  provider_names_by_id: Schema.Record({ key: Schema.String, value: Schema.String }),
  region: Schema.String,
  resource_group: Schema.String,
  resource_type: Schema.Literal("aws_customer_gateway", "aws_egress_only_internet_gateway", "aws_internet_gateway", "aws_instance", "aws_network_interface", "aws_route", "aws_route_table", "aws_route_table_association", "aws_subnet", "aws_vpc", "aws_vpc_ipv4_cidr_block_association", "aws_vpn_connection", "aws_vpn_connection_route", "aws_vpn_gateway", "aws_security_group", "aws_vpc_security_group_ingress_rule", "aws_vpc_security_group_egress_rule", "aws_ec2_managed_prefix_list", "aws_ec2_transit_gateway", "aws_ec2_transit_gateway_prefix_list_reference", "aws_ec2_transit_gateway_vpc_attachment", "azurerm_application_security_group", "azurerm_lb", "azurerm_lb_backend_address_pool", "azurerm_lb_nat_pool", "azurerm_lb_nat_rule", "azurerm_lb_rule", "azurerm_local_network_gateway", "azurerm_network_interface", "azurerm_network_interface_application_security_group_association", "azurerm_network_interface_backend_address_pool_association", "azurerm_network_interface_security_group_association", "azurerm_network_security_group", "azurerm_public_ip", "azurerm_route", "azurerm_route_table", "azurerm_subnet", "azurerm_subnet_route_table_association", "azurerm_virtual_machine", "azurerm_virtual_network_gateway_connection", "azurerm_virtual_network", "azurerm_virtual_network_gateway", "google_compute_network", "google_compute_subnetwork", "google_compute_vpn_gateway", "google_compute_vpn_tunnel", "google_compute_route", "google_compute_address", "google_compute_global_address", "google_compute_router", "google_compute_interconnect_attachment", "google_compute_ha_vpn_gateway", "google_compute_forwarding_rule", "google_compute_network_firewall_policy", "google_compute_network_firewall_policy_rule", "cloudflare_static_route", "cloudflare_ipsec_tunnel"),
  sections: Schema.Array(Schema.Struct({
  help_text: Schema.optional(Schema.String),
  hidden_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
})),
  name: Schema.String,
  visible_items: Schema.Array(Schema.Struct({
  helpText: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  value: Schema.optional(Schema.Struct({}))
}))
})),
  state: Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  tags: Schema.Record({ key: Schema.String, value: Schema.String }),
  updated_at: Schema.String,
  url: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ResourcesCatalogReadResponse" }) as unknown as Schema.Schema<ResourcesCatalogReadResponse>;

export const resourcesCatalogRead: (
  input: ResourcesCatalogReadRequest
) => Effect.Effect<
  ResourcesCatalogReadResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ResourcesCatalogReadRequest,
  output: ResourcesCatalogReadResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List32Request {
  account_id: string;
}

export const List32Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/connectors" }),
).annotations({ identifier: "List32Request" }) as unknown as Schema.Schema<List32Request>;

export interface List32Response {
  result: { activated: boolean; device?: { id: string; serial_number?: string }; id: string; interrupt_window_duration_hours: number; interrupt_window_hour_of_day: number; last_heartbeat?: string; last_seen_version?: string; last_updated: string; license_key?: string; notes: string; timezone: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List32Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  activated: Schema.Boolean,
  device: Schema.optional(Schema.Struct({
  id: Schema.String,
  serial_number: Schema.optional(Schema.String)
})),
  id: Schema.String,
  interrupt_window_duration_hours: Schema.Number,
  interrupt_window_hour_of_day: Schema.Number,
  last_heartbeat: Schema.optional(Schema.String),
  last_seen_version: Schema.optional(Schema.String),
  last_updated: Schema.String,
  license_key: Schema.optional(Schema.String),
  notes: Schema.String,
  timezone: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List32Response" }) as unknown as Schema.Schema<List32Response>;

export const list32: (
  input: List32Request
) => Effect.Effect<
  List32Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List32Request,
  output: List32Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create12Request {
  account_id: string;
  body: Record<string, unknown>;
}

export const Create12Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/connectors" }),
).annotations({ identifier: "Create12Request" }) as unknown as Schema.Schema<Create12Request>;

export interface Create12Response {
  result: { activated: boolean; device?: { id: string; serial_number?: string }; id: string; interrupt_window_duration_hours: number; interrupt_window_hour_of_day: number; last_heartbeat?: string; last_seen_version?: string; last_updated: string; license_key?: string; notes: string; timezone: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create12Response = Schema.Struct({
  result: Schema.Struct({
  activated: Schema.Boolean,
  device: Schema.optional(Schema.Struct({
  id: Schema.String,
  serial_number: Schema.optional(Schema.String)
})),
  id: Schema.String,
  interrupt_window_duration_hours: Schema.Number,
  interrupt_window_hour_of_day: Schema.Number,
  last_heartbeat: Schema.optional(Schema.String),
  last_seen_version: Schema.optional(Schema.String),
  last_updated: Schema.String,
  license_key: Schema.optional(Schema.String),
  notes: Schema.String,
  timezone: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create12Response" }) as unknown as Schema.Schema<Create12Response>;

export const create12: (
  input: Create12Request
) => Effect.Effect<
  Create12Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create12Request,
  output: Create12Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MconnConnectorFetchRequest {
  account_id: string;
  connector_id: string;
}

export const MconnConnectorFetchRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  connector_id: Schema.String.pipe(T.HttpPath("connector_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/connectors/{connector_id}" }),
).annotations({ identifier: "MconnConnectorFetchRequest" }) as unknown as Schema.Schema<MconnConnectorFetchRequest>;

export interface MconnConnectorFetchResponse {
  result: { activated: boolean; device?: { id: string; serial_number?: string }; id: string; interrupt_window_duration_hours: number; interrupt_window_hour_of_day: number; last_heartbeat?: string; last_seen_version?: string; last_updated: string; license_key?: string; notes: string; timezone: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MconnConnectorFetchResponse = Schema.Struct({
  result: Schema.Struct({
  activated: Schema.Boolean,
  device: Schema.optional(Schema.Struct({
  id: Schema.String,
  serial_number: Schema.optional(Schema.String)
})),
  id: Schema.String,
  interrupt_window_duration_hours: Schema.Number,
  interrupt_window_hour_of_day: Schema.Number,
  last_heartbeat: Schema.optional(Schema.String),
  last_seen_version: Schema.optional(Schema.String),
  last_updated: Schema.String,
  license_key: Schema.optional(Schema.String),
  notes: Schema.String,
  timezone: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MconnConnectorFetchResponse" }) as unknown as Schema.Schema<MconnConnectorFetchResponse>;

export const mconnConnectorFetch: (
  input: MconnConnectorFetchRequest
) => Effect.Effect<
  MconnConnectorFetchResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MconnConnectorFetchRequest,
  output: MconnConnectorFetchResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MconnConnectorReplaceRequest {
  account_id: string;
  connector_id: string;
  body: Record<string, unknown>;
}

export const MconnConnectorReplaceRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  connector_id: Schema.String.pipe(T.HttpPath("connector_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/connectors/{connector_id}" }),
).annotations({ identifier: "MconnConnectorReplaceRequest" }) as unknown as Schema.Schema<MconnConnectorReplaceRequest>;

export interface MconnConnectorReplaceResponse {
  result: { activated: boolean; device?: { id: string; serial_number?: string }; id: string; interrupt_window_duration_hours: number; interrupt_window_hour_of_day: number; last_heartbeat?: string; last_seen_version?: string; last_updated: string; license_key?: string; notes: string; timezone: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MconnConnectorReplaceResponse = Schema.Struct({
  result: Schema.Struct({
  activated: Schema.Boolean,
  device: Schema.optional(Schema.Struct({
  id: Schema.String,
  serial_number: Schema.optional(Schema.String)
})),
  id: Schema.String,
  interrupt_window_duration_hours: Schema.Number,
  interrupt_window_hour_of_day: Schema.Number,
  last_heartbeat: Schema.optional(Schema.String),
  last_seen_version: Schema.optional(Schema.String),
  last_updated: Schema.String,
  license_key: Schema.optional(Schema.String),
  notes: Schema.String,
  timezone: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MconnConnectorReplaceResponse" }) as unknown as Schema.Schema<MconnConnectorReplaceResponse>;

export const mconnConnectorReplace: (
  input: MconnConnectorReplaceRequest
) => Effect.Effect<
  MconnConnectorReplaceResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MconnConnectorReplaceRequest,
  output: MconnConnectorReplaceResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_17Request {
  account_id: string;
  connector_id: string;
}

export const Delete_17Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  connector_id: Schema.String.pipe(T.HttpPath("connector_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/connectors/{connector_id}" }),
).annotations({ identifier: "Delete_17Request" }) as unknown as Schema.Schema<Delete_17Request>;

export interface Delete_17Response {
  result: { activated: boolean; device?: { id: string; serial_number?: string }; id: string; interrupt_window_duration_hours: number; interrupt_window_hour_of_day: number; last_heartbeat?: string; last_seen_version?: string; last_updated: string; license_key?: string; notes: string; timezone: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_17Response = Schema.Struct({
  result: Schema.Struct({
  activated: Schema.Boolean,
  device: Schema.optional(Schema.Struct({
  id: Schema.String,
  serial_number: Schema.optional(Schema.String)
})),
  id: Schema.String,
  interrupt_window_duration_hours: Schema.Number,
  interrupt_window_hour_of_day: Schema.Number,
  last_heartbeat: Schema.optional(Schema.String),
  last_seen_version: Schema.optional(Schema.String),
  last_updated: Schema.String,
  license_key: Schema.optional(Schema.String),
  notes: Schema.String,
  timezone: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_17Response" }) as unknown as Schema.Schema<Delete_17Response>;

export const delete_17: (
  input: Delete_17Request
) => Effect.Effect<
  Delete_17Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_17Request,
  output: Delete_17Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update16Request {
  account_id: string;
  connector_id: string;
  body: Record<string, unknown>;
}

export const Update16Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  connector_id: Schema.String.pipe(T.HttpPath("connector_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/connectors/{connector_id}" }),
).annotations({ identifier: "Update16Request" }) as unknown as Schema.Schema<Update16Request>;

export interface Update16Response {
  result: { activated: boolean; device?: { id: string; serial_number?: string }; id: string; interrupt_window_duration_hours: number; interrupt_window_hour_of_day: number; last_heartbeat?: string; last_seen_version?: string; last_updated: string; license_key?: string; notes: string; timezone: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update16Response = Schema.Struct({
  result: Schema.Struct({
  activated: Schema.Boolean,
  device: Schema.optional(Schema.Struct({
  id: Schema.String,
  serial_number: Schema.optional(Schema.String)
})),
  id: Schema.String,
  interrupt_window_duration_hours: Schema.Number,
  interrupt_window_hour_of_day: Schema.Number,
  last_heartbeat: Schema.optional(Schema.String),
  last_seen_version: Schema.optional(Schema.String),
  last_updated: Schema.String,
  license_key: Schema.optional(Schema.String),
  notes: Schema.String,
  timezone: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update16Response" }) as unknown as Schema.Schema<Update16Response>;

export const update16: (
  input: Update16Request
) => Effect.Effect<
  Update16Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update16Request,
  output: Update16Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List33Request {
  account_id: string;
  connector_id: string;
  from: number;
  to: number;
  limit?: number;
  cursor?: string;
  k?: string;
}

export const List33Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  connector_id: Schema.String.pipe(T.HttpPath("connector_id")),
  from: Schema.Number.pipe(T.HttpQuery("from")),
  to: Schema.Number.pipe(T.HttpQuery("to")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  cursor: Schema.optional(Schema.String).pipe(T.HttpQuery("cursor")),
  k: Schema.optional(Schema.String).pipe(T.HttpQuery("k"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/connectors/{connector_id}/telemetry/events" }),
).annotations({ identifier: "List33Request" }) as unknown as Schema.Schema<List33Request>;

export interface List33Response {
  result: { count: number; cursor?: string; items: { a: number; k: string; n: number; t: number }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List33Response = Schema.Struct({
  result: Schema.Struct({
  count: Schema.Number,
  cursor: Schema.optional(Schema.String),
  items: Schema.Array(Schema.Struct({
  a: Schema.Number,
  k: Schema.String,
  n: Schema.Number,
  t: Schema.Number
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List33Response" }) as unknown as Schema.Schema<List33Response>;

export const list33: (
  input: List33Request
) => Effect.Effect<
  List33Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List33Request,
  output: List33Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MconnConnectorTelemetryEventsListlatestRequest {
  account_id: string;
  connector_id: string;
}

export const MconnConnectorTelemetryEventsListlatestRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  connector_id: Schema.String.pipe(T.HttpPath("connector_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/connectors/{connector_id}/telemetry/events/latest" }),
).annotations({ identifier: "MconnConnectorTelemetryEventsListlatestRequest" }) as unknown as Schema.Schema<MconnConnectorTelemetryEventsListlatestRequest>;

export interface MconnConnectorTelemetryEventsListlatestResponse {
  result: { count: number; items: { e: Record<string, unknown>; n: number; t: number }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MconnConnectorTelemetryEventsListlatestResponse = Schema.Struct({
  result: Schema.Struct({
  count: Schema.Number,
  items: Schema.Array(Schema.Struct({
  e: Schema.Struct({}),
  n: Schema.Number,
  t: Schema.Number
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MconnConnectorTelemetryEventsListlatestResponse" }) as unknown as Schema.Schema<MconnConnectorTelemetryEventsListlatestResponse>;

export const mconnConnectorTelemetryEventsListlatest: (
  input: MconnConnectorTelemetryEventsListlatestRequest
) => Effect.Effect<
  MconnConnectorTelemetryEventsListlatestResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MconnConnectorTelemetryEventsListlatestRequest,
  output: MconnConnectorTelemetryEventsListlatestResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_10Request {
  account_id: string;
  connector_id: string;
  event_t: number;
  event_n: number;
}

export const Get_10Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  connector_id: Schema.String.pipe(T.HttpPath("connector_id")),
  event_t: Schema.Number.pipe(T.HttpPath("event_t")),
  event_n: Schema.Number.pipe(T.HttpPath("event_n"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/connectors/{connector_id}/telemetry/events/{event_t}.{event_n}" }),
).annotations({ identifier: "Get_10Request" }) as unknown as Schema.Schema<Get_10Request>;

export interface Get_10Response {
  result: { e: Record<string, unknown>; n: number; t: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_10Response = Schema.Struct({
  result: Schema.Struct({
  e: Schema.Struct({}),
  n: Schema.Number,
  t: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_10Response" }) as unknown as Schema.Schema<Get_10Response>;

export const get_10: (
  input: Get_10Request
) => Effect.Effect<
  Get_10Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_10Request,
  output: Get_10Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List34Request {
  account_id: string;
  connector_id: string;
  from: number;
  to: number;
  limit?: number;
  cursor?: string;
}

export const List34Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  connector_id: Schema.String.pipe(T.HttpPath("connector_id")),
  from: Schema.Number.pipe(T.HttpQuery("from")),
  to: Schema.Number.pipe(T.HttpQuery("to")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  cursor: Schema.optional(Schema.String).pipe(T.HttpQuery("cursor"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/connectors/{connector_id}/telemetry/snapshots" }),
).annotations({ identifier: "List34Request" }) as unknown as Schema.Schema<List34Request>;

export interface List34Response {
  result: { count: number; cursor?: string; items: { a: number; t: number }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List34Response = Schema.Struct({
  result: Schema.Struct({
  count: Schema.Number,
  cursor: Schema.optional(Schema.String),
  items: Schema.Array(Schema.Struct({
  a: Schema.Number,
  t: Schema.Number
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List34Response" }) as unknown as Schema.Schema<List34Response>;

export const list34: (
  input: List34Request
) => Effect.Effect<
  List34Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List34Request,
  output: List34Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MconnConnectorTelemetrySnapshotsListlatestRequest {
  account_id: string;
  connector_id: string;
}

export const MconnConnectorTelemetrySnapshotsListlatestRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  connector_id: Schema.String.pipe(T.HttpPath("connector_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/connectors/{connector_id}/telemetry/snapshots/latest" }),
).annotations({ identifier: "MconnConnectorTelemetrySnapshotsListlatestRequest" }) as unknown as Schema.Schema<MconnConnectorTelemetrySnapshotsListlatestRequest>;

export interface MconnConnectorTelemetrySnapshotsListlatestResponse {
  result: { count: number; items: { bonds?: { name: string; status: string }[]; count_reclaim_failures: number; count_reclaimed_paths: number; count_record_failed: number; count_transmit_failures: number; cpu_count?: number; cpu_pressure_10s?: number; cpu_pressure_300s?: number; cpu_pressure_60s?: number; cpu_pressure_total_us?: number; cpu_time_guest_ms?: number; cpu_time_guest_nice_ms?: number; cpu_time_idle_ms?: number; cpu_time_iowait_ms?: number; cpu_time_irq_ms?: number; cpu_time_nice_ms?: number; cpu_time_softirq_ms?: number; cpu_time_steal_ms?: number; cpu_time_system_ms?: number; cpu_time_user_ms?: number; dhcp_leases?: { client_id: string; connector_id?: string; expiry_time: number; hostname: string; interface_name: string; ip_address: string; mac_address: string }[]; disks?: { connector_id?: string; discards?: number; discards_merged?: number; flushes?: number; in_progress: number; major: number; merged: number; minor: number; name: string; reads: number; sectors_discarded?: number; sectors_read: number; sectors_written: number; time_discarding_ms?: number; time_flushing_ms?: number; time_in_progress_ms: number; time_reading_ms: number; time_writing_ms: number; weighted_time_in_progress_ms: number; writes: number; writes_merged: number }[]; ha_state?: string; ha_value?: number; interfaces?: { connector_id?: string; ip_addresses?: { connector_id?: string; interface_name: string; ip_address: string }[]; name: string; operstate: string; speed?: number }[]; io_pressure_full_10s?: number; io_pressure_full_300s?: number; io_pressure_full_60s?: number; io_pressure_full_total_us?: number; io_pressure_some_10s?: number; io_pressure_some_300s?: number; io_pressure_some_60s?: number; io_pressure_some_total_us?: number; kernel_btime?: number; kernel_ctxt?: number; kernel_processes?: number; kernel_processes_blocked?: number; kernel_processes_running?: number; load_average_15m?: number; load_average_1m?: number; load_average_5m?: number; load_average_cur?: number; load_average_max?: number; memory_active_bytes?: number; memory_anon_hugepages_bytes?: number; memory_anon_pages_bytes?: number; memory_available_bytes?: number; memory_bounce_bytes?: number; memory_buffers_bytes?: number; memory_cached_bytes?: number; memory_cma_free_bytes?: number; memory_cma_total_bytes?: number; memory_commit_limit_bytes?: number; memory_committed_as_bytes?: number; memory_dirty_bytes?: number; memory_free_bytes?: number; memory_high_free_bytes?: number; memory_high_total_bytes?: number; memory_hugepages_free?: number; memory_hugepages_rsvd?: number; memory_hugepages_surp?: number; memory_hugepages_total?: number; memory_hugepagesize_bytes?: number; memory_inactive_bytes?: number; memory_k_reclaimable_bytes?: number; memory_kernel_stack_bytes?: number; memory_low_free_bytes?: number; memory_low_total_bytes?: number; memory_mapped_bytes?: number; memory_page_tables_bytes?: number; memory_per_cpu_bytes?: number; memory_pressure_full_10s?: number; memory_pressure_full_300s?: number; memory_pressure_full_60s?: number; memory_pressure_full_total_us?: number; memory_pressure_some_10s?: number; memory_pressure_some_300s?: number; memory_pressure_some_60s?: number; memory_pressure_some_total_us?: number; memory_s_reclaimable_bytes?: number; memory_s_unreclaim_bytes?: number; memory_secondary_page_tables_bytes?: number; memory_shmem_bytes?: number; memory_shmem_hugepages_bytes?: number; memory_shmem_pmd_mapped_bytes?: number; memory_slab_bytes?: number; memory_swap_cached_bytes?: number; memory_swap_free_bytes?: number; memory_swap_total_bytes?: number; memory_total_bytes?: number; memory_vmalloc_chunk_bytes?: number; memory_vmalloc_total_bytes?: number; memory_vmalloc_used_bytes?: number; memory_writeback_bytes?: number; memory_writeback_tmp_bytes?: number; memory_z_swap_bytes?: number; memory_z_swapped_bytes?: number; mounts?: { available_bytes?: number; connector_id?: string; file_system: string; is_read_only?: boolean; is_removable?: boolean; kind: string; mount_point: string; name: string; total_bytes?: number }[]; netdevs?: { connector_id?: string; name: string; recv_bytes: number; recv_compressed: number; recv_drop: number; recv_errs: number; recv_fifo: number; recv_frame: number; recv_multicast: number; recv_packets: number; sent_bytes: number; sent_carrier: number; sent_colls: number; sent_compressed: number; sent_drop: number; sent_errs: number; sent_fifo: number; sent_packets: number }[]; snmp_icmp_in_addr_mask_reps?: number; snmp_icmp_in_addr_masks?: number; snmp_icmp_in_csum_errors?: number; snmp_icmp_in_dest_unreachs?: number; snmp_icmp_in_echo_reps?: number; snmp_icmp_in_echos?: number; snmp_icmp_in_errors?: number; snmp_icmp_in_msgs?: number; snmp_icmp_in_parm_probs?: number; snmp_icmp_in_redirects?: number; snmp_icmp_in_src_quenchs?: number; snmp_icmp_in_time_excds?: number; snmp_icmp_in_timestamp_reps?: number; snmp_icmp_in_timestamps?: number; snmp_icmp_out_addr_mask_reps?: number; snmp_icmp_out_addr_masks?: number; snmp_icmp_out_dest_unreachs?: number; snmp_icmp_out_echo_reps?: number; snmp_icmp_out_echos?: number; snmp_icmp_out_errors?: number; snmp_icmp_out_msgs?: number; snmp_icmp_out_parm_probs?: number; snmp_icmp_out_redirects?: number; snmp_icmp_out_src_quenchs?: number; snmp_icmp_out_time_excds?: number; snmp_icmp_out_timestamp_reps?: number; snmp_icmp_out_timestamps?: number; snmp_ip_default_ttl?: number; snmp_ip_forw_datagrams?: number; snmp_ip_forwarding_enabled?: boolean; snmp_ip_frag_creates?: number; snmp_ip_frag_fails?: number; snmp_ip_frag_oks?: number; snmp_ip_in_addr_errors?: number; snmp_ip_in_delivers?: number; snmp_ip_in_discards?: number; snmp_ip_in_hdr_errors?: number; snmp_ip_in_receives?: number; snmp_ip_in_unknown_protos?: number; snmp_ip_out_discards?: number; snmp_ip_out_no_routes?: number; snmp_ip_out_requests?: number; snmp_ip_reasm_fails?: number; snmp_ip_reasm_oks?: number; snmp_ip_reasm_reqds?: number; snmp_ip_reasm_timeout?: number; snmp_tcp_active_opens?: number; snmp_tcp_attempt_fails?: number; snmp_tcp_curr_estab?: number; snmp_tcp_estab_resets?: number; snmp_tcp_in_csum_errors?: number; snmp_tcp_in_errs?: number; snmp_tcp_in_segs?: number; snmp_tcp_max_conn?: number; snmp_tcp_out_rsts?: number; snmp_tcp_out_segs?: number; snmp_tcp_passive_opens?: number; snmp_tcp_retrans_segs?: number; snmp_tcp_rto_max?: number; snmp_tcp_rto_min?: number; snmp_udp_in_datagrams?: number; snmp_udp_in_errors?: number; snmp_udp_no_ports?: number; snmp_udp_out_datagrams?: number; system_boot_time_s?: number; t: number; thermals?: { connector_id?: string; critical_celcius?: number; current_celcius?: number; label: string; max_celcius?: number }[]; tunnels?: { connector_id?: string; health_state: string; health_value: number; interface_name: string; probed_mtu?: number; tunnel_id: string }[]; uptime_idle_ms?: number; uptime_total_ms?: number; v: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MconnConnectorTelemetrySnapshotsListlatestResponse = Schema.Struct({
  result: Schema.Struct({
  count: Schema.Number,
  items: Schema.Array(Schema.Struct({
  bonds: Schema.optional(Schema.Array(Schema.Struct({
  name: Schema.String,
  status: Schema.String
}))),
  count_reclaim_failures: Schema.Number,
  count_reclaimed_paths: Schema.Number,
  count_record_failed: Schema.Number,
  count_transmit_failures: Schema.Number,
  cpu_count: Schema.optional(Schema.Number),
  cpu_pressure_10s: Schema.optional(Schema.Number),
  cpu_pressure_300s: Schema.optional(Schema.Number),
  cpu_pressure_60s: Schema.optional(Schema.Number),
  cpu_pressure_total_us: Schema.optional(Schema.Number),
  cpu_time_guest_ms: Schema.optional(Schema.Number),
  cpu_time_guest_nice_ms: Schema.optional(Schema.Number),
  cpu_time_idle_ms: Schema.optional(Schema.Number),
  cpu_time_iowait_ms: Schema.optional(Schema.Number),
  cpu_time_irq_ms: Schema.optional(Schema.Number),
  cpu_time_nice_ms: Schema.optional(Schema.Number),
  cpu_time_softirq_ms: Schema.optional(Schema.Number),
  cpu_time_steal_ms: Schema.optional(Schema.Number),
  cpu_time_system_ms: Schema.optional(Schema.Number),
  cpu_time_user_ms: Schema.optional(Schema.Number),
  dhcp_leases: Schema.optional(Schema.Array(Schema.Struct({
  client_id: Schema.String,
  connector_id: Schema.optional(Schema.String),
  expiry_time: Schema.Number,
  hostname: Schema.String,
  interface_name: Schema.String,
  ip_address: Schema.String,
  mac_address: Schema.String
}))),
  disks: Schema.optional(Schema.Array(Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  discards: Schema.optional(Schema.Number),
  discards_merged: Schema.optional(Schema.Number),
  flushes: Schema.optional(Schema.Number),
  in_progress: Schema.Number,
  major: Schema.Number,
  merged: Schema.Number,
  minor: Schema.Number,
  name: Schema.String,
  reads: Schema.Number,
  sectors_discarded: Schema.optional(Schema.Number),
  sectors_read: Schema.Number,
  sectors_written: Schema.Number,
  time_discarding_ms: Schema.optional(Schema.Number),
  time_flushing_ms: Schema.optional(Schema.Number),
  time_in_progress_ms: Schema.Number,
  time_reading_ms: Schema.Number,
  time_writing_ms: Schema.Number,
  weighted_time_in_progress_ms: Schema.Number,
  writes: Schema.Number,
  writes_merged: Schema.Number
}))),
  ha_state: Schema.optional(Schema.String),
  ha_value: Schema.optional(Schema.Number),
  interfaces: Schema.optional(Schema.Array(Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  ip_addresses: Schema.optional(Schema.Array(Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  interface_name: Schema.String,
  ip_address: Schema.String
}))),
  name: Schema.String,
  operstate: Schema.String,
  speed: Schema.optional(Schema.Number)
}))),
  io_pressure_full_10s: Schema.optional(Schema.Number),
  io_pressure_full_300s: Schema.optional(Schema.Number),
  io_pressure_full_60s: Schema.optional(Schema.Number),
  io_pressure_full_total_us: Schema.optional(Schema.Number),
  io_pressure_some_10s: Schema.optional(Schema.Number),
  io_pressure_some_300s: Schema.optional(Schema.Number),
  io_pressure_some_60s: Schema.optional(Schema.Number),
  io_pressure_some_total_us: Schema.optional(Schema.Number),
  kernel_btime: Schema.optional(Schema.Number),
  kernel_ctxt: Schema.optional(Schema.Number),
  kernel_processes: Schema.optional(Schema.Number),
  kernel_processes_blocked: Schema.optional(Schema.Number),
  kernel_processes_running: Schema.optional(Schema.Number),
  load_average_15m: Schema.optional(Schema.Number),
  load_average_1m: Schema.optional(Schema.Number),
  load_average_5m: Schema.optional(Schema.Number),
  load_average_cur: Schema.optional(Schema.Number),
  load_average_max: Schema.optional(Schema.Number),
  memory_active_bytes: Schema.optional(Schema.Number),
  memory_anon_hugepages_bytes: Schema.optional(Schema.Number),
  memory_anon_pages_bytes: Schema.optional(Schema.Number),
  memory_available_bytes: Schema.optional(Schema.Number),
  memory_bounce_bytes: Schema.optional(Schema.Number),
  memory_buffers_bytes: Schema.optional(Schema.Number),
  memory_cached_bytes: Schema.optional(Schema.Number),
  memory_cma_free_bytes: Schema.optional(Schema.Number),
  memory_cma_total_bytes: Schema.optional(Schema.Number),
  memory_commit_limit_bytes: Schema.optional(Schema.Number),
  memory_committed_as_bytes: Schema.optional(Schema.Number),
  memory_dirty_bytes: Schema.optional(Schema.Number),
  memory_free_bytes: Schema.optional(Schema.Number),
  memory_high_free_bytes: Schema.optional(Schema.Number),
  memory_high_total_bytes: Schema.optional(Schema.Number),
  memory_hugepages_free: Schema.optional(Schema.Number),
  memory_hugepages_rsvd: Schema.optional(Schema.Number),
  memory_hugepages_surp: Schema.optional(Schema.Number),
  memory_hugepages_total: Schema.optional(Schema.Number),
  memory_hugepagesize_bytes: Schema.optional(Schema.Number),
  memory_inactive_bytes: Schema.optional(Schema.Number),
  memory_k_reclaimable_bytes: Schema.optional(Schema.Number),
  memory_kernel_stack_bytes: Schema.optional(Schema.Number),
  memory_low_free_bytes: Schema.optional(Schema.Number),
  memory_low_total_bytes: Schema.optional(Schema.Number),
  memory_mapped_bytes: Schema.optional(Schema.Number),
  memory_page_tables_bytes: Schema.optional(Schema.Number),
  memory_per_cpu_bytes: Schema.optional(Schema.Number),
  memory_pressure_full_10s: Schema.optional(Schema.Number),
  memory_pressure_full_300s: Schema.optional(Schema.Number),
  memory_pressure_full_60s: Schema.optional(Schema.Number),
  memory_pressure_full_total_us: Schema.optional(Schema.Number),
  memory_pressure_some_10s: Schema.optional(Schema.Number),
  memory_pressure_some_300s: Schema.optional(Schema.Number),
  memory_pressure_some_60s: Schema.optional(Schema.Number),
  memory_pressure_some_total_us: Schema.optional(Schema.Number),
  memory_s_reclaimable_bytes: Schema.optional(Schema.Number),
  memory_s_unreclaim_bytes: Schema.optional(Schema.Number),
  memory_secondary_page_tables_bytes: Schema.optional(Schema.Number),
  memory_shmem_bytes: Schema.optional(Schema.Number),
  memory_shmem_hugepages_bytes: Schema.optional(Schema.Number),
  memory_shmem_pmd_mapped_bytes: Schema.optional(Schema.Number),
  memory_slab_bytes: Schema.optional(Schema.Number),
  memory_swap_cached_bytes: Schema.optional(Schema.Number),
  memory_swap_free_bytes: Schema.optional(Schema.Number),
  memory_swap_total_bytes: Schema.optional(Schema.Number),
  memory_total_bytes: Schema.optional(Schema.Number),
  memory_vmalloc_chunk_bytes: Schema.optional(Schema.Number),
  memory_vmalloc_total_bytes: Schema.optional(Schema.Number),
  memory_vmalloc_used_bytes: Schema.optional(Schema.Number),
  memory_writeback_bytes: Schema.optional(Schema.Number),
  memory_writeback_tmp_bytes: Schema.optional(Schema.Number),
  memory_z_swap_bytes: Schema.optional(Schema.Number),
  memory_z_swapped_bytes: Schema.optional(Schema.Number),
  mounts: Schema.optional(Schema.Array(Schema.Struct({
  available_bytes: Schema.optional(Schema.Number),
  connector_id: Schema.optional(Schema.String),
  file_system: Schema.String,
  is_read_only: Schema.optional(Schema.Boolean),
  is_removable: Schema.optional(Schema.Boolean),
  kind: Schema.String,
  mount_point: Schema.String,
  name: Schema.String,
  total_bytes: Schema.optional(Schema.Number)
}))),
  netdevs: Schema.optional(Schema.Array(Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  name: Schema.String,
  recv_bytes: Schema.Number,
  recv_compressed: Schema.Number,
  recv_drop: Schema.Number,
  recv_errs: Schema.Number,
  recv_fifo: Schema.Number,
  recv_frame: Schema.Number,
  recv_multicast: Schema.Number,
  recv_packets: Schema.Number,
  sent_bytes: Schema.Number,
  sent_carrier: Schema.Number,
  sent_colls: Schema.Number,
  sent_compressed: Schema.Number,
  sent_drop: Schema.Number,
  sent_errs: Schema.Number,
  sent_fifo: Schema.Number,
  sent_packets: Schema.Number
}))),
  snmp_icmp_in_addr_mask_reps: Schema.optional(Schema.Number),
  snmp_icmp_in_addr_masks: Schema.optional(Schema.Number),
  snmp_icmp_in_csum_errors: Schema.optional(Schema.Number),
  snmp_icmp_in_dest_unreachs: Schema.optional(Schema.Number),
  snmp_icmp_in_echo_reps: Schema.optional(Schema.Number),
  snmp_icmp_in_echos: Schema.optional(Schema.Number),
  snmp_icmp_in_errors: Schema.optional(Schema.Number),
  snmp_icmp_in_msgs: Schema.optional(Schema.Number),
  snmp_icmp_in_parm_probs: Schema.optional(Schema.Number),
  snmp_icmp_in_redirects: Schema.optional(Schema.Number),
  snmp_icmp_in_src_quenchs: Schema.optional(Schema.Number),
  snmp_icmp_in_time_excds: Schema.optional(Schema.Number),
  snmp_icmp_in_timestamp_reps: Schema.optional(Schema.Number),
  snmp_icmp_in_timestamps: Schema.optional(Schema.Number),
  snmp_icmp_out_addr_mask_reps: Schema.optional(Schema.Number),
  snmp_icmp_out_addr_masks: Schema.optional(Schema.Number),
  snmp_icmp_out_dest_unreachs: Schema.optional(Schema.Number),
  snmp_icmp_out_echo_reps: Schema.optional(Schema.Number),
  snmp_icmp_out_echos: Schema.optional(Schema.Number),
  snmp_icmp_out_errors: Schema.optional(Schema.Number),
  snmp_icmp_out_msgs: Schema.optional(Schema.Number),
  snmp_icmp_out_parm_probs: Schema.optional(Schema.Number),
  snmp_icmp_out_redirects: Schema.optional(Schema.Number),
  snmp_icmp_out_src_quenchs: Schema.optional(Schema.Number),
  snmp_icmp_out_time_excds: Schema.optional(Schema.Number),
  snmp_icmp_out_timestamp_reps: Schema.optional(Schema.Number),
  snmp_icmp_out_timestamps: Schema.optional(Schema.Number),
  snmp_ip_default_ttl: Schema.optional(Schema.Number),
  snmp_ip_forw_datagrams: Schema.optional(Schema.Number),
  snmp_ip_forwarding_enabled: Schema.optional(Schema.Boolean),
  snmp_ip_frag_creates: Schema.optional(Schema.Number),
  snmp_ip_frag_fails: Schema.optional(Schema.Number),
  snmp_ip_frag_oks: Schema.optional(Schema.Number),
  snmp_ip_in_addr_errors: Schema.optional(Schema.Number),
  snmp_ip_in_delivers: Schema.optional(Schema.Number),
  snmp_ip_in_discards: Schema.optional(Schema.Number),
  snmp_ip_in_hdr_errors: Schema.optional(Schema.Number),
  snmp_ip_in_receives: Schema.optional(Schema.Number),
  snmp_ip_in_unknown_protos: Schema.optional(Schema.Number),
  snmp_ip_out_discards: Schema.optional(Schema.Number),
  snmp_ip_out_no_routes: Schema.optional(Schema.Number),
  snmp_ip_out_requests: Schema.optional(Schema.Number),
  snmp_ip_reasm_fails: Schema.optional(Schema.Number),
  snmp_ip_reasm_oks: Schema.optional(Schema.Number),
  snmp_ip_reasm_reqds: Schema.optional(Schema.Number),
  snmp_ip_reasm_timeout: Schema.optional(Schema.Number),
  snmp_tcp_active_opens: Schema.optional(Schema.Number),
  snmp_tcp_attempt_fails: Schema.optional(Schema.Number),
  snmp_tcp_curr_estab: Schema.optional(Schema.Number),
  snmp_tcp_estab_resets: Schema.optional(Schema.Number),
  snmp_tcp_in_csum_errors: Schema.optional(Schema.Number),
  snmp_tcp_in_errs: Schema.optional(Schema.Number),
  snmp_tcp_in_segs: Schema.optional(Schema.Number),
  snmp_tcp_max_conn: Schema.optional(Schema.Number),
  snmp_tcp_out_rsts: Schema.optional(Schema.Number),
  snmp_tcp_out_segs: Schema.optional(Schema.Number),
  snmp_tcp_passive_opens: Schema.optional(Schema.Number),
  snmp_tcp_retrans_segs: Schema.optional(Schema.Number),
  snmp_tcp_rto_max: Schema.optional(Schema.Number),
  snmp_tcp_rto_min: Schema.optional(Schema.Number),
  snmp_udp_in_datagrams: Schema.optional(Schema.Number),
  snmp_udp_in_errors: Schema.optional(Schema.Number),
  snmp_udp_no_ports: Schema.optional(Schema.Number),
  snmp_udp_out_datagrams: Schema.optional(Schema.Number),
  system_boot_time_s: Schema.optional(Schema.Number),
  t: Schema.Number,
  thermals: Schema.optional(Schema.Array(Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  critical_celcius: Schema.optional(Schema.Number),
  current_celcius: Schema.optional(Schema.Number),
  label: Schema.String,
  max_celcius: Schema.optional(Schema.Number)
}))),
  tunnels: Schema.optional(Schema.Array(Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  health_state: Schema.String,
  health_value: Schema.Number,
  interface_name: Schema.String,
  probed_mtu: Schema.optional(Schema.Number),
  tunnel_id: Schema.String
}))),
  uptime_idle_ms: Schema.optional(Schema.Number),
  uptime_total_ms: Schema.optional(Schema.Number),
  v: Schema.String
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MconnConnectorTelemetrySnapshotsListlatestResponse" }) as unknown as Schema.Schema<MconnConnectorTelemetrySnapshotsListlatestResponse>;

export const mconnConnectorTelemetrySnapshotsListlatest: (
  input: MconnConnectorTelemetrySnapshotsListlatestRequest
) => Effect.Effect<
  MconnConnectorTelemetrySnapshotsListlatestResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MconnConnectorTelemetrySnapshotsListlatestRequest,
  output: MconnConnectorTelemetrySnapshotsListlatestResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_11Request {
  account_id: string;
  connector_id: string;
  snapshot_t: number;
}

export const Get_11Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  connector_id: Schema.String.pipe(T.HttpPath("connector_id")),
  snapshot_t: Schema.Number.pipe(T.HttpPath("snapshot_t"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/connectors/{connector_id}/telemetry/snapshots/{snapshot_t}" }),
).annotations({ identifier: "Get_11Request" }) as unknown as Schema.Schema<Get_11Request>;

export interface Get_11Response {
  result: { bonds?: { name: string; status: string }[]; count_reclaim_failures: number; count_reclaimed_paths: number; count_record_failed: number; count_transmit_failures: number; cpu_count?: number; cpu_pressure_10s?: number; cpu_pressure_300s?: number; cpu_pressure_60s?: number; cpu_pressure_total_us?: number; cpu_time_guest_ms?: number; cpu_time_guest_nice_ms?: number; cpu_time_idle_ms?: number; cpu_time_iowait_ms?: number; cpu_time_irq_ms?: number; cpu_time_nice_ms?: number; cpu_time_softirq_ms?: number; cpu_time_steal_ms?: number; cpu_time_system_ms?: number; cpu_time_user_ms?: number; dhcp_leases?: { client_id: string; connector_id?: string; expiry_time: number; hostname: string; interface_name: string; ip_address: string; mac_address: string }[]; disks?: { connector_id?: string; discards?: number; discards_merged?: number; flushes?: number; in_progress: number; major: number; merged: number; minor: number; name: string; reads: number; sectors_discarded?: number; sectors_read: number; sectors_written: number; time_discarding_ms?: number; time_flushing_ms?: number; time_in_progress_ms: number; time_reading_ms: number; time_writing_ms: number; weighted_time_in_progress_ms: number; writes: number; writes_merged: number }[]; ha_state?: string; ha_value?: number; interfaces?: { connector_id?: string; ip_addresses?: { connector_id?: string; interface_name: string; ip_address: string }[]; name: string; operstate: string; speed?: number }[]; io_pressure_full_10s?: number; io_pressure_full_300s?: number; io_pressure_full_60s?: number; io_pressure_full_total_us?: number; io_pressure_some_10s?: number; io_pressure_some_300s?: number; io_pressure_some_60s?: number; io_pressure_some_total_us?: number; kernel_btime?: number; kernel_ctxt?: number; kernel_processes?: number; kernel_processes_blocked?: number; kernel_processes_running?: number; load_average_15m?: number; load_average_1m?: number; load_average_5m?: number; load_average_cur?: number; load_average_max?: number; memory_active_bytes?: number; memory_anon_hugepages_bytes?: number; memory_anon_pages_bytes?: number; memory_available_bytes?: number; memory_bounce_bytes?: number; memory_buffers_bytes?: number; memory_cached_bytes?: number; memory_cma_free_bytes?: number; memory_cma_total_bytes?: number; memory_commit_limit_bytes?: number; memory_committed_as_bytes?: number; memory_dirty_bytes?: number; memory_free_bytes?: number; memory_high_free_bytes?: number; memory_high_total_bytes?: number; memory_hugepages_free?: number; memory_hugepages_rsvd?: number; memory_hugepages_surp?: number; memory_hugepages_total?: number; memory_hugepagesize_bytes?: number; memory_inactive_bytes?: number; memory_k_reclaimable_bytes?: number; memory_kernel_stack_bytes?: number; memory_low_free_bytes?: number; memory_low_total_bytes?: number; memory_mapped_bytes?: number; memory_page_tables_bytes?: number; memory_per_cpu_bytes?: number; memory_pressure_full_10s?: number; memory_pressure_full_300s?: number; memory_pressure_full_60s?: number; memory_pressure_full_total_us?: number; memory_pressure_some_10s?: number; memory_pressure_some_300s?: number; memory_pressure_some_60s?: number; memory_pressure_some_total_us?: number; memory_s_reclaimable_bytes?: number; memory_s_unreclaim_bytes?: number; memory_secondary_page_tables_bytes?: number; memory_shmem_bytes?: number; memory_shmem_hugepages_bytes?: number; memory_shmem_pmd_mapped_bytes?: number; memory_slab_bytes?: number; memory_swap_cached_bytes?: number; memory_swap_free_bytes?: number; memory_swap_total_bytes?: number; memory_total_bytes?: number; memory_vmalloc_chunk_bytes?: number; memory_vmalloc_total_bytes?: number; memory_vmalloc_used_bytes?: number; memory_writeback_bytes?: number; memory_writeback_tmp_bytes?: number; memory_z_swap_bytes?: number; memory_z_swapped_bytes?: number; mounts?: { available_bytes?: number; connector_id?: string; file_system: string; is_read_only?: boolean; is_removable?: boolean; kind: string; mount_point: string; name: string; total_bytes?: number }[]; netdevs?: { connector_id?: string; name: string; recv_bytes: number; recv_compressed: number; recv_drop: number; recv_errs: number; recv_fifo: number; recv_frame: number; recv_multicast: number; recv_packets: number; sent_bytes: number; sent_carrier: number; sent_colls: number; sent_compressed: number; sent_drop: number; sent_errs: number; sent_fifo: number; sent_packets: number }[]; snmp_icmp_in_addr_mask_reps?: number; snmp_icmp_in_addr_masks?: number; snmp_icmp_in_csum_errors?: number; snmp_icmp_in_dest_unreachs?: number; snmp_icmp_in_echo_reps?: number; snmp_icmp_in_echos?: number; snmp_icmp_in_errors?: number; snmp_icmp_in_msgs?: number; snmp_icmp_in_parm_probs?: number; snmp_icmp_in_redirects?: number; snmp_icmp_in_src_quenchs?: number; snmp_icmp_in_time_excds?: number; snmp_icmp_in_timestamp_reps?: number; snmp_icmp_in_timestamps?: number; snmp_icmp_out_addr_mask_reps?: number; snmp_icmp_out_addr_masks?: number; snmp_icmp_out_dest_unreachs?: number; snmp_icmp_out_echo_reps?: number; snmp_icmp_out_echos?: number; snmp_icmp_out_errors?: number; snmp_icmp_out_msgs?: number; snmp_icmp_out_parm_probs?: number; snmp_icmp_out_redirects?: number; snmp_icmp_out_src_quenchs?: number; snmp_icmp_out_time_excds?: number; snmp_icmp_out_timestamp_reps?: number; snmp_icmp_out_timestamps?: number; snmp_ip_default_ttl?: number; snmp_ip_forw_datagrams?: number; snmp_ip_forwarding_enabled?: boolean; snmp_ip_frag_creates?: number; snmp_ip_frag_fails?: number; snmp_ip_frag_oks?: number; snmp_ip_in_addr_errors?: number; snmp_ip_in_delivers?: number; snmp_ip_in_discards?: number; snmp_ip_in_hdr_errors?: number; snmp_ip_in_receives?: number; snmp_ip_in_unknown_protos?: number; snmp_ip_out_discards?: number; snmp_ip_out_no_routes?: number; snmp_ip_out_requests?: number; snmp_ip_reasm_fails?: number; snmp_ip_reasm_oks?: number; snmp_ip_reasm_reqds?: number; snmp_ip_reasm_timeout?: number; snmp_tcp_active_opens?: number; snmp_tcp_attempt_fails?: number; snmp_tcp_curr_estab?: number; snmp_tcp_estab_resets?: number; snmp_tcp_in_csum_errors?: number; snmp_tcp_in_errs?: number; snmp_tcp_in_segs?: number; snmp_tcp_max_conn?: number; snmp_tcp_out_rsts?: number; snmp_tcp_out_segs?: number; snmp_tcp_passive_opens?: number; snmp_tcp_retrans_segs?: number; snmp_tcp_rto_max?: number; snmp_tcp_rto_min?: number; snmp_udp_in_datagrams?: number; snmp_udp_in_errors?: number; snmp_udp_no_ports?: number; snmp_udp_out_datagrams?: number; system_boot_time_s?: number; t: number; thermals?: { connector_id?: string; critical_celcius?: number; current_celcius?: number; label: string; max_celcius?: number }[]; tunnels?: { connector_id?: string; health_state: string; health_value: number; interface_name: string; probed_mtu?: number; tunnel_id: string }[]; uptime_idle_ms?: number; uptime_total_ms?: number; v: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_11Response = Schema.Struct({
  result: Schema.Struct({
  bonds: Schema.optional(Schema.Array(Schema.Struct({
  name: Schema.String,
  status: Schema.String
}))),
  count_reclaim_failures: Schema.Number,
  count_reclaimed_paths: Schema.Number,
  count_record_failed: Schema.Number,
  count_transmit_failures: Schema.Number,
  cpu_count: Schema.optional(Schema.Number),
  cpu_pressure_10s: Schema.optional(Schema.Number),
  cpu_pressure_300s: Schema.optional(Schema.Number),
  cpu_pressure_60s: Schema.optional(Schema.Number),
  cpu_pressure_total_us: Schema.optional(Schema.Number),
  cpu_time_guest_ms: Schema.optional(Schema.Number),
  cpu_time_guest_nice_ms: Schema.optional(Schema.Number),
  cpu_time_idle_ms: Schema.optional(Schema.Number),
  cpu_time_iowait_ms: Schema.optional(Schema.Number),
  cpu_time_irq_ms: Schema.optional(Schema.Number),
  cpu_time_nice_ms: Schema.optional(Schema.Number),
  cpu_time_softirq_ms: Schema.optional(Schema.Number),
  cpu_time_steal_ms: Schema.optional(Schema.Number),
  cpu_time_system_ms: Schema.optional(Schema.Number),
  cpu_time_user_ms: Schema.optional(Schema.Number),
  dhcp_leases: Schema.optional(Schema.Array(Schema.Struct({
  client_id: Schema.String,
  connector_id: Schema.optional(Schema.String),
  expiry_time: Schema.Number,
  hostname: Schema.String,
  interface_name: Schema.String,
  ip_address: Schema.String,
  mac_address: Schema.String
}))),
  disks: Schema.optional(Schema.Array(Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  discards: Schema.optional(Schema.Number),
  discards_merged: Schema.optional(Schema.Number),
  flushes: Schema.optional(Schema.Number),
  in_progress: Schema.Number,
  major: Schema.Number,
  merged: Schema.Number,
  minor: Schema.Number,
  name: Schema.String,
  reads: Schema.Number,
  sectors_discarded: Schema.optional(Schema.Number),
  sectors_read: Schema.Number,
  sectors_written: Schema.Number,
  time_discarding_ms: Schema.optional(Schema.Number),
  time_flushing_ms: Schema.optional(Schema.Number),
  time_in_progress_ms: Schema.Number,
  time_reading_ms: Schema.Number,
  time_writing_ms: Schema.Number,
  weighted_time_in_progress_ms: Schema.Number,
  writes: Schema.Number,
  writes_merged: Schema.Number
}))),
  ha_state: Schema.optional(Schema.String),
  ha_value: Schema.optional(Schema.Number),
  interfaces: Schema.optional(Schema.Array(Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  ip_addresses: Schema.optional(Schema.Array(Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  interface_name: Schema.String,
  ip_address: Schema.String
}))),
  name: Schema.String,
  operstate: Schema.String,
  speed: Schema.optional(Schema.Number)
}))),
  io_pressure_full_10s: Schema.optional(Schema.Number),
  io_pressure_full_300s: Schema.optional(Schema.Number),
  io_pressure_full_60s: Schema.optional(Schema.Number),
  io_pressure_full_total_us: Schema.optional(Schema.Number),
  io_pressure_some_10s: Schema.optional(Schema.Number),
  io_pressure_some_300s: Schema.optional(Schema.Number),
  io_pressure_some_60s: Schema.optional(Schema.Number),
  io_pressure_some_total_us: Schema.optional(Schema.Number),
  kernel_btime: Schema.optional(Schema.Number),
  kernel_ctxt: Schema.optional(Schema.Number),
  kernel_processes: Schema.optional(Schema.Number),
  kernel_processes_blocked: Schema.optional(Schema.Number),
  kernel_processes_running: Schema.optional(Schema.Number),
  load_average_15m: Schema.optional(Schema.Number),
  load_average_1m: Schema.optional(Schema.Number),
  load_average_5m: Schema.optional(Schema.Number),
  load_average_cur: Schema.optional(Schema.Number),
  load_average_max: Schema.optional(Schema.Number),
  memory_active_bytes: Schema.optional(Schema.Number),
  memory_anon_hugepages_bytes: Schema.optional(Schema.Number),
  memory_anon_pages_bytes: Schema.optional(Schema.Number),
  memory_available_bytes: Schema.optional(Schema.Number),
  memory_bounce_bytes: Schema.optional(Schema.Number),
  memory_buffers_bytes: Schema.optional(Schema.Number),
  memory_cached_bytes: Schema.optional(Schema.Number),
  memory_cma_free_bytes: Schema.optional(Schema.Number),
  memory_cma_total_bytes: Schema.optional(Schema.Number),
  memory_commit_limit_bytes: Schema.optional(Schema.Number),
  memory_committed_as_bytes: Schema.optional(Schema.Number),
  memory_dirty_bytes: Schema.optional(Schema.Number),
  memory_free_bytes: Schema.optional(Schema.Number),
  memory_high_free_bytes: Schema.optional(Schema.Number),
  memory_high_total_bytes: Schema.optional(Schema.Number),
  memory_hugepages_free: Schema.optional(Schema.Number),
  memory_hugepages_rsvd: Schema.optional(Schema.Number),
  memory_hugepages_surp: Schema.optional(Schema.Number),
  memory_hugepages_total: Schema.optional(Schema.Number),
  memory_hugepagesize_bytes: Schema.optional(Schema.Number),
  memory_inactive_bytes: Schema.optional(Schema.Number),
  memory_k_reclaimable_bytes: Schema.optional(Schema.Number),
  memory_kernel_stack_bytes: Schema.optional(Schema.Number),
  memory_low_free_bytes: Schema.optional(Schema.Number),
  memory_low_total_bytes: Schema.optional(Schema.Number),
  memory_mapped_bytes: Schema.optional(Schema.Number),
  memory_page_tables_bytes: Schema.optional(Schema.Number),
  memory_per_cpu_bytes: Schema.optional(Schema.Number),
  memory_pressure_full_10s: Schema.optional(Schema.Number),
  memory_pressure_full_300s: Schema.optional(Schema.Number),
  memory_pressure_full_60s: Schema.optional(Schema.Number),
  memory_pressure_full_total_us: Schema.optional(Schema.Number),
  memory_pressure_some_10s: Schema.optional(Schema.Number),
  memory_pressure_some_300s: Schema.optional(Schema.Number),
  memory_pressure_some_60s: Schema.optional(Schema.Number),
  memory_pressure_some_total_us: Schema.optional(Schema.Number),
  memory_s_reclaimable_bytes: Schema.optional(Schema.Number),
  memory_s_unreclaim_bytes: Schema.optional(Schema.Number),
  memory_secondary_page_tables_bytes: Schema.optional(Schema.Number),
  memory_shmem_bytes: Schema.optional(Schema.Number),
  memory_shmem_hugepages_bytes: Schema.optional(Schema.Number),
  memory_shmem_pmd_mapped_bytes: Schema.optional(Schema.Number),
  memory_slab_bytes: Schema.optional(Schema.Number),
  memory_swap_cached_bytes: Schema.optional(Schema.Number),
  memory_swap_free_bytes: Schema.optional(Schema.Number),
  memory_swap_total_bytes: Schema.optional(Schema.Number),
  memory_total_bytes: Schema.optional(Schema.Number),
  memory_vmalloc_chunk_bytes: Schema.optional(Schema.Number),
  memory_vmalloc_total_bytes: Schema.optional(Schema.Number),
  memory_vmalloc_used_bytes: Schema.optional(Schema.Number),
  memory_writeback_bytes: Schema.optional(Schema.Number),
  memory_writeback_tmp_bytes: Schema.optional(Schema.Number),
  memory_z_swap_bytes: Schema.optional(Schema.Number),
  memory_z_swapped_bytes: Schema.optional(Schema.Number),
  mounts: Schema.optional(Schema.Array(Schema.Struct({
  available_bytes: Schema.optional(Schema.Number),
  connector_id: Schema.optional(Schema.String),
  file_system: Schema.String,
  is_read_only: Schema.optional(Schema.Boolean),
  is_removable: Schema.optional(Schema.Boolean),
  kind: Schema.String,
  mount_point: Schema.String,
  name: Schema.String,
  total_bytes: Schema.optional(Schema.Number)
}))),
  netdevs: Schema.optional(Schema.Array(Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  name: Schema.String,
  recv_bytes: Schema.Number,
  recv_compressed: Schema.Number,
  recv_drop: Schema.Number,
  recv_errs: Schema.Number,
  recv_fifo: Schema.Number,
  recv_frame: Schema.Number,
  recv_multicast: Schema.Number,
  recv_packets: Schema.Number,
  sent_bytes: Schema.Number,
  sent_carrier: Schema.Number,
  sent_colls: Schema.Number,
  sent_compressed: Schema.Number,
  sent_drop: Schema.Number,
  sent_errs: Schema.Number,
  sent_fifo: Schema.Number,
  sent_packets: Schema.Number
}))),
  snmp_icmp_in_addr_mask_reps: Schema.optional(Schema.Number),
  snmp_icmp_in_addr_masks: Schema.optional(Schema.Number),
  snmp_icmp_in_csum_errors: Schema.optional(Schema.Number),
  snmp_icmp_in_dest_unreachs: Schema.optional(Schema.Number),
  snmp_icmp_in_echo_reps: Schema.optional(Schema.Number),
  snmp_icmp_in_echos: Schema.optional(Schema.Number),
  snmp_icmp_in_errors: Schema.optional(Schema.Number),
  snmp_icmp_in_msgs: Schema.optional(Schema.Number),
  snmp_icmp_in_parm_probs: Schema.optional(Schema.Number),
  snmp_icmp_in_redirects: Schema.optional(Schema.Number),
  snmp_icmp_in_src_quenchs: Schema.optional(Schema.Number),
  snmp_icmp_in_time_excds: Schema.optional(Schema.Number),
  snmp_icmp_in_timestamp_reps: Schema.optional(Schema.Number),
  snmp_icmp_in_timestamps: Schema.optional(Schema.Number),
  snmp_icmp_out_addr_mask_reps: Schema.optional(Schema.Number),
  snmp_icmp_out_addr_masks: Schema.optional(Schema.Number),
  snmp_icmp_out_dest_unreachs: Schema.optional(Schema.Number),
  snmp_icmp_out_echo_reps: Schema.optional(Schema.Number),
  snmp_icmp_out_echos: Schema.optional(Schema.Number),
  snmp_icmp_out_errors: Schema.optional(Schema.Number),
  snmp_icmp_out_msgs: Schema.optional(Schema.Number),
  snmp_icmp_out_parm_probs: Schema.optional(Schema.Number),
  snmp_icmp_out_redirects: Schema.optional(Schema.Number),
  snmp_icmp_out_src_quenchs: Schema.optional(Schema.Number),
  snmp_icmp_out_time_excds: Schema.optional(Schema.Number),
  snmp_icmp_out_timestamp_reps: Schema.optional(Schema.Number),
  snmp_icmp_out_timestamps: Schema.optional(Schema.Number),
  snmp_ip_default_ttl: Schema.optional(Schema.Number),
  snmp_ip_forw_datagrams: Schema.optional(Schema.Number),
  snmp_ip_forwarding_enabled: Schema.optional(Schema.Boolean),
  snmp_ip_frag_creates: Schema.optional(Schema.Number),
  snmp_ip_frag_fails: Schema.optional(Schema.Number),
  snmp_ip_frag_oks: Schema.optional(Schema.Number),
  snmp_ip_in_addr_errors: Schema.optional(Schema.Number),
  snmp_ip_in_delivers: Schema.optional(Schema.Number),
  snmp_ip_in_discards: Schema.optional(Schema.Number),
  snmp_ip_in_hdr_errors: Schema.optional(Schema.Number),
  snmp_ip_in_receives: Schema.optional(Schema.Number),
  snmp_ip_in_unknown_protos: Schema.optional(Schema.Number),
  snmp_ip_out_discards: Schema.optional(Schema.Number),
  snmp_ip_out_no_routes: Schema.optional(Schema.Number),
  snmp_ip_out_requests: Schema.optional(Schema.Number),
  snmp_ip_reasm_fails: Schema.optional(Schema.Number),
  snmp_ip_reasm_oks: Schema.optional(Schema.Number),
  snmp_ip_reasm_reqds: Schema.optional(Schema.Number),
  snmp_ip_reasm_timeout: Schema.optional(Schema.Number),
  snmp_tcp_active_opens: Schema.optional(Schema.Number),
  snmp_tcp_attempt_fails: Schema.optional(Schema.Number),
  snmp_tcp_curr_estab: Schema.optional(Schema.Number),
  snmp_tcp_estab_resets: Schema.optional(Schema.Number),
  snmp_tcp_in_csum_errors: Schema.optional(Schema.Number),
  snmp_tcp_in_errs: Schema.optional(Schema.Number),
  snmp_tcp_in_segs: Schema.optional(Schema.Number),
  snmp_tcp_max_conn: Schema.optional(Schema.Number),
  snmp_tcp_out_rsts: Schema.optional(Schema.Number),
  snmp_tcp_out_segs: Schema.optional(Schema.Number),
  snmp_tcp_passive_opens: Schema.optional(Schema.Number),
  snmp_tcp_retrans_segs: Schema.optional(Schema.Number),
  snmp_tcp_rto_max: Schema.optional(Schema.Number),
  snmp_tcp_rto_min: Schema.optional(Schema.Number),
  snmp_udp_in_datagrams: Schema.optional(Schema.Number),
  snmp_udp_in_errors: Schema.optional(Schema.Number),
  snmp_udp_no_ports: Schema.optional(Schema.Number),
  snmp_udp_out_datagrams: Schema.optional(Schema.Number),
  system_boot_time_s: Schema.optional(Schema.Number),
  t: Schema.Number,
  thermals: Schema.optional(Schema.Array(Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  critical_celcius: Schema.optional(Schema.Number),
  current_celcius: Schema.optional(Schema.Number),
  label: Schema.String,
  max_celcius: Schema.optional(Schema.Number)
}))),
  tunnels: Schema.optional(Schema.Array(Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  health_state: Schema.String,
  health_value: Schema.Number,
  interface_name: Schema.String,
  probed_mtu: Schema.optional(Schema.Number),
  tunnel_id: Schema.String
}))),
  uptime_idle_ms: Schema.optional(Schema.Number),
  uptime_total_ms: Schema.optional(Schema.Number),
  v: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_11Response" }) as unknown as Schema.Schema<Get_11Response>;

export const get_11: (
  input: Get_11Request
) => Effect.Effect<
  Get_11Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_11Request,
  output: Get_11Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListGreTunnelsRequest {
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
}

export const ListGreTunnelsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/gre_tunnels" }),
).annotations({ identifier: "ListGreTunnelsRequest" }) as unknown as Schema.Schema<ListGreTunnelsRequest>;

export interface ListGreTunnelsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListGreTunnelsResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListGreTunnelsResponse" }) as unknown as Schema.Schema<ListGreTunnelsResponse>;

export const listGreTunnels: (
  input: ListGreTunnelsRequest
) => Effect.Effect<
  ListGreTunnelsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListGreTunnelsRequest,
  output: ListGreTunnelsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateGreTunnelsRequest {
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
  body: { automatic_return_routing?: boolean; bgp?: { customer_asn: number; extra_prefixes?: string[]; md5_key?: string }; cloudflare_gre_endpoint: string; customer_gre_endpoint: string; description?: string; health_check?: unknown; interface_address: string; interface_address6?: string; mtu?: number; name: string; ttl?: number };
}

export const CreateGreTunnelsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target")),
  body: Schema.Struct({
  automatic_return_routing: Schema.optional(Schema.Boolean),
  bgp: Schema.optional(Schema.Struct({
  customer_asn: Schema.Number,
  extra_prefixes: Schema.optional(Schema.Array(Schema.String)),
  md5_key: Schema.optional(Schema.String)
})),
  cloudflare_gre_endpoint: Schema.String,
  customer_gre_endpoint: Schema.String,
  description: Schema.optional(Schema.String),
  health_check: Schema.optional(Schema.Unknown),
  interface_address: Schema.String,
  interface_address6: Schema.optional(Schema.String),
  mtu: Schema.optional(Schema.Number),
  name: Schema.String,
  ttl: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/gre_tunnels" }),
).annotations({ identifier: "CreateGreTunnelsRequest" }) as unknown as Schema.Schema<CreateGreTunnelsRequest>;

export interface CreateGreTunnelsResponse {
  result: { automatic_return_routing?: boolean; bgp?: { customer_asn: number; extra_prefixes?: string[]; md5_key?: string }; bgp_status?: { bgp_state?: string; cf_speaker_ip?: string; cf_speaker_port?: number; customer_speaker_ip?: string; customer_speaker_port?: number; state: "BGP_DOWN" | "BGP_UP" | "BGP_ESTABLISHING"; tcp_established: boolean; updated_at: string }; cloudflare_gre_endpoint: string; created_on?: string; customer_gre_endpoint: string; description?: string; health_check?: unknown; id: string; interface_address: string; interface_address6?: string; modified_on?: string; mtu?: number; name: string; ttl?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateGreTunnelsResponse = Schema.Struct({
  result: Schema.Struct({
  automatic_return_routing: Schema.optional(Schema.Boolean),
  bgp: Schema.optional(Schema.Struct({
  customer_asn: Schema.Number,
  extra_prefixes: Schema.optional(Schema.Array(Schema.String)),
  md5_key: Schema.optional(Schema.String)
})),
  bgp_status: Schema.optional(Schema.Struct({
  bgp_state: Schema.optional(Schema.String),
  cf_speaker_ip: Schema.optional(Schema.String),
  cf_speaker_port: Schema.optional(Schema.Number),
  customer_speaker_ip: Schema.optional(Schema.String),
  customer_speaker_port: Schema.optional(Schema.Number),
  state: Schema.Literal("BGP_DOWN", "BGP_UP", "BGP_ESTABLISHING"),
  tcp_established: Schema.Boolean,
  updated_at: Schema.Date
})),
  cloudflare_gre_endpoint: Schema.String,
  created_on: Schema.optional(Schema.Date),
  customer_gre_endpoint: Schema.String,
  description: Schema.optional(Schema.String),
  health_check: Schema.optional(Schema.Unknown),
  id: Schema.String,
  interface_address: Schema.String,
  interface_address6: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  mtu: Schema.optional(Schema.Number),
  name: Schema.String,
  ttl: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateGreTunnelsResponse" }) as unknown as Schema.Schema<CreateGreTunnelsResponse>;

export const createGreTunnels: (
  input: CreateGreTunnelsRequest
) => Effect.Effect<
  CreateGreTunnelsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateGreTunnelsRequest,
  output: CreateGreTunnelsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateMultipleGreTunnelsRequest {
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
  body: unknown;
}

export const UpdateMultipleGreTunnelsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/gre_tunnels" }),
).annotations({ identifier: "UpdateMultipleGreTunnelsRequest" }) as unknown as Schema.Schema<UpdateMultipleGreTunnelsRequest>;

export interface UpdateMultipleGreTunnelsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateMultipleGreTunnelsResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateMultipleGreTunnelsResponse" }) as unknown as Schema.Schema<UpdateMultipleGreTunnelsResponse>;

export const updateMultipleGreTunnels: (
  input: UpdateMultipleGreTunnelsRequest
) => Effect.Effect<
  UpdateMultipleGreTunnelsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateMultipleGreTunnelsRequest,
  output: UpdateMultipleGreTunnelsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListGreTunnelDetailsRequest {
  gre_tunnel_id: string;
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
}

export const ListGreTunnelDetailsRequest = Schema.Struct({
  gre_tunnel_id: Schema.String.pipe(T.HttpPath("gre_tunnel_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/gre_tunnels/{gre_tunnel_id}" }),
).annotations({ identifier: "ListGreTunnelDetailsRequest" }) as unknown as Schema.Schema<ListGreTunnelDetailsRequest>;

export interface ListGreTunnelDetailsResponse {
  result: { gre_tunnel?: { automatic_return_routing?: boolean; bgp?: { customer_asn: number; extra_prefixes?: string[]; md5_key?: string }; bgp_status?: { bgp_state?: string; cf_speaker_ip?: string; cf_speaker_port?: number; customer_speaker_ip?: string; customer_speaker_port?: number; state: "BGP_DOWN" | "BGP_UP" | "BGP_ESTABLISHING"; tcp_established: boolean; updated_at: string }; cloudflare_gre_endpoint: string; created_on?: string; customer_gre_endpoint: string; description?: string; health_check?: unknown; id: string; interface_address: string; interface_address6?: string; modified_on?: string; mtu?: number; name: string; ttl?: number } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListGreTunnelDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  gre_tunnel: Schema.optional(Schema.Struct({
  automatic_return_routing: Schema.optional(Schema.Boolean),
  bgp: Schema.optional(Schema.Struct({
  customer_asn: Schema.Number,
  extra_prefixes: Schema.optional(Schema.Array(Schema.String)),
  md5_key: Schema.optional(Schema.String)
})),
  bgp_status: Schema.optional(Schema.Struct({
  bgp_state: Schema.optional(Schema.String),
  cf_speaker_ip: Schema.optional(Schema.String),
  cf_speaker_port: Schema.optional(Schema.Number),
  customer_speaker_ip: Schema.optional(Schema.String),
  customer_speaker_port: Schema.optional(Schema.Number),
  state: Schema.Literal("BGP_DOWN", "BGP_UP", "BGP_ESTABLISHING"),
  tcp_established: Schema.Boolean,
  updated_at: Schema.Date
})),
  cloudflare_gre_endpoint: Schema.String,
  created_on: Schema.optional(Schema.Date),
  customer_gre_endpoint: Schema.String,
  description: Schema.optional(Schema.String),
  health_check: Schema.optional(Schema.Unknown),
  id: Schema.String,
  interface_address: Schema.String,
  interface_address6: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  mtu: Schema.optional(Schema.Number),
  name: Schema.String,
  ttl: Schema.optional(Schema.Number)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListGreTunnelDetailsResponse" }) as unknown as Schema.Schema<ListGreTunnelDetailsResponse>;

export const listGreTunnelDetails: (
  input: ListGreTunnelDetailsRequest
) => Effect.Effect<
  ListGreTunnelDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListGreTunnelDetailsRequest,
  output: ListGreTunnelDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateGreTunnelRequest {
  gre_tunnel_id: string;
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
  body: unknown;
}

export const UpdateGreTunnelRequest = Schema.Struct({
  gre_tunnel_id: Schema.String.pipe(T.HttpPath("gre_tunnel_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target")),
  body: Schema.Struct({
  automatic_return_routing: Schema.optional(Schema.Boolean),
  cloudflare_gre_endpoint: Schema.String,
  customer_gre_endpoint: Schema.String,
  description: Schema.optional(Schema.String),
  health_check: Schema.optional(Schema.Unknown),
  interface_address: Schema.String,
  interface_address6: Schema.optional(Schema.String),
  mtu: Schema.optional(Schema.Number),
  name: Schema.String,
  ttl: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/gre_tunnels/{gre_tunnel_id}" }),
).annotations({ identifier: "UpdateGreTunnelRequest" }) as unknown as Schema.Schema<UpdateGreTunnelRequest>;

export interface UpdateGreTunnelResponse {
  result: { modified?: boolean; modified_gre_tunnel?: { automatic_return_routing?: boolean; bgp?: { customer_asn: number; extra_prefixes?: string[]; md5_key?: string }; bgp_status?: { bgp_state?: string; cf_speaker_ip?: string; cf_speaker_port?: number; customer_speaker_ip?: string; customer_speaker_port?: number; state: "BGP_DOWN" | "BGP_UP" | "BGP_ESTABLISHING"; tcp_established: boolean; updated_at: string }; cloudflare_gre_endpoint: string; created_on?: string; customer_gre_endpoint: string; description?: string; health_check?: unknown; id: string; interface_address: string; interface_address6?: string; modified_on?: string; mtu?: number; name: string; ttl?: number } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateGreTunnelResponse = Schema.Struct({
  result: Schema.Struct({
  modified: Schema.optional(Schema.Boolean),
  modified_gre_tunnel: Schema.optional(Schema.Struct({
  automatic_return_routing: Schema.optional(Schema.Boolean),
  bgp: Schema.optional(Schema.Struct({
  customer_asn: Schema.Number,
  extra_prefixes: Schema.optional(Schema.Array(Schema.String)),
  md5_key: Schema.optional(Schema.String)
})),
  bgp_status: Schema.optional(Schema.Struct({
  bgp_state: Schema.optional(Schema.String),
  cf_speaker_ip: Schema.optional(Schema.String),
  cf_speaker_port: Schema.optional(Schema.Number),
  customer_speaker_ip: Schema.optional(Schema.String),
  customer_speaker_port: Schema.optional(Schema.Number),
  state: Schema.Literal("BGP_DOWN", "BGP_UP", "BGP_ESTABLISHING"),
  tcp_established: Schema.Boolean,
  updated_at: Schema.Date
})),
  cloudflare_gre_endpoint: Schema.String,
  created_on: Schema.optional(Schema.Date),
  customer_gre_endpoint: Schema.String,
  description: Schema.optional(Schema.String),
  health_check: Schema.optional(Schema.Unknown),
  id: Schema.String,
  interface_address: Schema.String,
  interface_address6: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  mtu: Schema.optional(Schema.Number),
  name: Schema.String,
  ttl: Schema.optional(Schema.Number)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateGreTunnelResponse" }) as unknown as Schema.Schema<UpdateGreTunnelResponse>;

export const updateGreTunnel: (
  input: UpdateGreTunnelRequest
) => Effect.Effect<
  UpdateGreTunnelResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateGreTunnelRequest,
  output: UpdateGreTunnelResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteGreTunnelRequest {
  gre_tunnel_id: string;
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
}

export const DeleteGreTunnelRequest = Schema.Struct({
  gre_tunnel_id: Schema.String.pipe(T.HttpPath("gre_tunnel_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/gre_tunnels/{gre_tunnel_id}" }),
).annotations({ identifier: "DeleteGreTunnelRequest" }) as unknown as Schema.Schema<DeleteGreTunnelRequest>;

export interface DeleteGreTunnelResponse {
  result: { deleted?: boolean; deleted_gre_tunnel?: { automatic_return_routing?: boolean; bgp?: { customer_asn: number; extra_prefixes?: string[]; md5_key?: string }; bgp_status?: { bgp_state?: string; cf_speaker_ip?: string; cf_speaker_port?: number; customer_speaker_ip?: string; customer_speaker_port?: number; state: "BGP_DOWN" | "BGP_UP" | "BGP_ESTABLISHING"; tcp_established: boolean; updated_at: string }; cloudflare_gre_endpoint: string; created_on?: string; customer_gre_endpoint: string; description?: string; health_check?: unknown; id: string; interface_address: string; interface_address6?: string; modified_on?: string; mtu?: number; name: string; ttl?: number } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteGreTunnelResponse = Schema.Struct({
  result: Schema.Struct({
  deleted: Schema.optional(Schema.Boolean),
  deleted_gre_tunnel: Schema.optional(Schema.Struct({
  automatic_return_routing: Schema.optional(Schema.Boolean),
  bgp: Schema.optional(Schema.Struct({
  customer_asn: Schema.Number,
  extra_prefixes: Schema.optional(Schema.Array(Schema.String)),
  md5_key: Schema.optional(Schema.String)
})),
  bgp_status: Schema.optional(Schema.Struct({
  bgp_state: Schema.optional(Schema.String),
  cf_speaker_ip: Schema.optional(Schema.String),
  cf_speaker_port: Schema.optional(Schema.Number),
  customer_speaker_ip: Schema.optional(Schema.String),
  customer_speaker_port: Schema.optional(Schema.Number),
  state: Schema.Literal("BGP_DOWN", "BGP_UP", "BGP_ESTABLISHING"),
  tcp_established: Schema.Boolean,
  updated_at: Schema.Date
})),
  cloudflare_gre_endpoint: Schema.String,
  created_on: Schema.optional(Schema.Date),
  customer_gre_endpoint: Schema.String,
  description: Schema.optional(Schema.String),
  health_check: Schema.optional(Schema.Unknown),
  id: Schema.String,
  interface_address: Schema.String,
  interface_address6: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  mtu: Schema.optional(Schema.Number),
  name: Schema.String,
  ttl: Schema.optional(Schema.Number)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteGreTunnelResponse" }) as unknown as Schema.Schema<DeleteGreTunnelResponse>;

export const deleteGreTunnel: (
  input: DeleteGreTunnelRequest
) => Effect.Effect<
  DeleteGreTunnelResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteGreTunnelRequest,
  output: DeleteGreTunnelResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListIpsecTunnelsRequest {
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
}

export const ListIpsecTunnelsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/ipsec_tunnels" }),
).annotations({ identifier: "ListIpsecTunnelsRequest" }) as unknown as Schema.Schema<ListIpsecTunnelsRequest>;

export interface ListIpsecTunnelsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListIpsecTunnelsResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListIpsecTunnelsResponse" }) as unknown as Schema.Schema<ListIpsecTunnelsResponse>;

export const listIpsecTunnels: (
  input: ListIpsecTunnelsRequest
) => Effect.Effect<
  ListIpsecTunnelsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListIpsecTunnelsRequest,
  output: ListIpsecTunnelsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateIpsecTunnelsRequest {
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
  body: unknown;
}

export const CreateIpsecTunnelsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target")),
  body: Schema.Struct({
  automatic_return_routing: Schema.optional(Schema.Boolean),
  bgp: Schema.optional(Schema.Struct({
  customer_asn: Schema.Number,
  extra_prefixes: Schema.optional(Schema.Array(Schema.String)),
  md5_key: Schema.optional(Schema.String)
})),
  cloudflare_endpoint: Schema.String,
  custom_remote_identities: Schema.optional(Schema.Struct({
  fqdn_id: Schema.optional(Schema.String)
})),
  customer_endpoint: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  health_check: Schema.optional(Schema.Unknown),
  interface_address: Schema.String,
  interface_address6: Schema.optional(Schema.String),
  name: Schema.String,
  psk: Schema.optional(Schema.String),
  replay_protection: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/ipsec_tunnels" }),
).annotations({ identifier: "CreateIpsecTunnelsRequest" }) as unknown as Schema.Schema<CreateIpsecTunnelsRequest>;

export interface CreateIpsecTunnelsResponse {
  result: { allow_null_cipher?: boolean; automatic_return_routing?: boolean; bgp?: { customer_asn: number; extra_prefixes?: string[]; md5_key?: string }; bgp_status?: { bgp_state?: string; cf_speaker_ip?: string; cf_speaker_port?: number; customer_speaker_ip?: string; customer_speaker_port?: number; state: "BGP_DOWN" | "BGP_UP" | "BGP_ESTABLISHING"; tcp_established: boolean; updated_at: string }; cloudflare_endpoint: string; created_on?: string; custom_remote_identities?: { fqdn_id?: string }; customer_endpoint?: string; description?: string; health_check?: unknown; id: string; interface_address: string; interface_address6?: string; modified_on?: string; name: string; psk_metadata?: { last_generated_on?: string }; replay_protection?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateIpsecTunnelsResponse = Schema.Struct({
  result: Schema.Struct({
  allow_null_cipher: Schema.optional(Schema.Boolean),
  automatic_return_routing: Schema.optional(Schema.Boolean),
  bgp: Schema.optional(Schema.Struct({
  customer_asn: Schema.Number,
  extra_prefixes: Schema.optional(Schema.Array(Schema.String)),
  md5_key: Schema.optional(Schema.String)
})),
  bgp_status: Schema.optional(Schema.Struct({
  bgp_state: Schema.optional(Schema.String),
  cf_speaker_ip: Schema.optional(Schema.String),
  cf_speaker_port: Schema.optional(Schema.Number),
  customer_speaker_ip: Schema.optional(Schema.String),
  customer_speaker_port: Schema.optional(Schema.Number),
  state: Schema.Literal("BGP_DOWN", "BGP_UP", "BGP_ESTABLISHING"),
  tcp_established: Schema.Boolean,
  updated_at: Schema.Date
})),
  cloudflare_endpoint: Schema.String,
  created_on: Schema.optional(Schema.Date),
  custom_remote_identities: Schema.optional(Schema.Struct({
  fqdn_id: Schema.optional(Schema.String)
})),
  customer_endpoint: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  health_check: Schema.optional(Schema.Unknown),
  id: Schema.String,
  interface_address: Schema.String,
  interface_address6: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.String,
  psk_metadata: Schema.optional(Schema.Struct({
  last_generated_on: Schema.optional(Schema.Date)
})),
  replay_protection: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateIpsecTunnelsResponse" }) as unknown as Schema.Schema<CreateIpsecTunnelsResponse>;

export const createIpsecTunnels: (
  input: CreateIpsecTunnelsRequest
) => Effect.Effect<
  CreateIpsecTunnelsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateIpsecTunnelsRequest,
  output: CreateIpsecTunnelsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateMultipleIpsecTunnelsRequest {
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
  body: unknown;
}

export const UpdateMultipleIpsecTunnelsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/ipsec_tunnels" }),
).annotations({ identifier: "UpdateMultipleIpsecTunnelsRequest" }) as unknown as Schema.Schema<UpdateMultipleIpsecTunnelsRequest>;

export interface UpdateMultipleIpsecTunnelsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateMultipleIpsecTunnelsResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateMultipleIpsecTunnelsResponse" }) as unknown as Schema.Schema<UpdateMultipleIpsecTunnelsResponse>;

export const updateMultipleIpsecTunnels: (
  input: UpdateMultipleIpsecTunnelsRequest
) => Effect.Effect<
  UpdateMultipleIpsecTunnelsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateMultipleIpsecTunnelsRequest,
  output: UpdateMultipleIpsecTunnelsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListIpsecTunnelDetailsRequest {
  ipsec_tunnel_id: string;
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
}

export const ListIpsecTunnelDetailsRequest = Schema.Struct({
  ipsec_tunnel_id: Schema.String.pipe(T.HttpPath("ipsec_tunnel_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/ipsec_tunnels/{ipsec_tunnel_id}" }),
).annotations({ identifier: "ListIpsecTunnelDetailsRequest" }) as unknown as Schema.Schema<ListIpsecTunnelDetailsRequest>;

export interface ListIpsecTunnelDetailsResponse {
  result: { ipsec_tunnel?: { allow_null_cipher?: boolean; automatic_return_routing?: boolean; bgp?: { customer_asn: number; extra_prefixes?: string[]; md5_key?: string }; bgp_status?: { bgp_state?: string; cf_speaker_ip?: string; cf_speaker_port?: number; customer_speaker_ip?: string; customer_speaker_port?: number; state: "BGP_DOWN" | "BGP_UP" | "BGP_ESTABLISHING"; tcp_established: boolean; updated_at: string }; cloudflare_endpoint: string; created_on?: string; custom_remote_identities?: { fqdn_id?: string }; customer_endpoint?: string; description?: string; health_check?: unknown; id: string; interface_address: string; interface_address6?: string; modified_on?: string; name: string; psk_metadata?: { last_generated_on?: string }; replay_protection?: boolean } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListIpsecTunnelDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  ipsec_tunnel: Schema.optional(Schema.Struct({
  allow_null_cipher: Schema.optional(Schema.Boolean),
  automatic_return_routing: Schema.optional(Schema.Boolean),
  bgp: Schema.optional(Schema.Struct({
  customer_asn: Schema.Number,
  extra_prefixes: Schema.optional(Schema.Array(Schema.String)),
  md5_key: Schema.optional(Schema.String)
})),
  bgp_status: Schema.optional(Schema.Struct({
  bgp_state: Schema.optional(Schema.String),
  cf_speaker_ip: Schema.optional(Schema.String),
  cf_speaker_port: Schema.optional(Schema.Number),
  customer_speaker_ip: Schema.optional(Schema.String),
  customer_speaker_port: Schema.optional(Schema.Number),
  state: Schema.Literal("BGP_DOWN", "BGP_UP", "BGP_ESTABLISHING"),
  tcp_established: Schema.Boolean,
  updated_at: Schema.Date
})),
  cloudflare_endpoint: Schema.String,
  created_on: Schema.optional(Schema.Date),
  custom_remote_identities: Schema.optional(Schema.Struct({
  fqdn_id: Schema.optional(Schema.String)
})),
  customer_endpoint: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  health_check: Schema.optional(Schema.Unknown),
  id: Schema.String,
  interface_address: Schema.String,
  interface_address6: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.String,
  psk_metadata: Schema.optional(Schema.Struct({
  last_generated_on: Schema.optional(Schema.Date)
})),
  replay_protection: Schema.optional(Schema.Boolean)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListIpsecTunnelDetailsResponse" }) as unknown as Schema.Schema<ListIpsecTunnelDetailsResponse>;

export const listIpsecTunnelDetails: (
  input: ListIpsecTunnelDetailsRequest
) => Effect.Effect<
  ListIpsecTunnelDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListIpsecTunnelDetailsRequest,
  output: ListIpsecTunnelDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateIpsecTunnelRequest {
  ipsec_tunnel_id: string;
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
  body: { automatic_return_routing?: boolean; bgp?: { customer_asn: number; extra_prefixes?: string[]; md5_key?: string }; cloudflare_endpoint: string; custom_remote_identities?: { fqdn_id?: string }; customer_endpoint?: string; description?: string; health_check?: unknown; interface_address: string; interface_address6?: string; name: string; psk?: string; replay_protection?: boolean };
}

export const UpdateIpsecTunnelRequest = Schema.Struct({
  ipsec_tunnel_id: Schema.String.pipe(T.HttpPath("ipsec_tunnel_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target")),
  body: Schema.Struct({
  automatic_return_routing: Schema.optional(Schema.Boolean),
  bgp: Schema.optional(Schema.Struct({
  customer_asn: Schema.Number,
  extra_prefixes: Schema.optional(Schema.Array(Schema.String)),
  md5_key: Schema.optional(Schema.String)
})),
  cloudflare_endpoint: Schema.String,
  custom_remote_identities: Schema.optional(Schema.Struct({
  fqdn_id: Schema.optional(Schema.String)
})),
  customer_endpoint: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  health_check: Schema.optional(Schema.Unknown),
  interface_address: Schema.String,
  interface_address6: Schema.optional(Schema.String),
  name: Schema.String,
  psk: Schema.optional(Schema.String),
  replay_protection: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/ipsec_tunnels/{ipsec_tunnel_id}" }),
).annotations({ identifier: "UpdateIpsecTunnelRequest" }) as unknown as Schema.Schema<UpdateIpsecTunnelRequest>;

export interface UpdateIpsecTunnelResponse {
  result: { modified?: boolean; modified_ipsec_tunnel?: { allow_null_cipher?: boolean; automatic_return_routing?: boolean; bgp?: { customer_asn: number; extra_prefixes?: string[]; md5_key?: string }; bgp_status?: { bgp_state?: string; cf_speaker_ip?: string; cf_speaker_port?: number; customer_speaker_ip?: string; customer_speaker_port?: number; state: "BGP_DOWN" | "BGP_UP" | "BGP_ESTABLISHING"; tcp_established: boolean; updated_at: string }; cloudflare_endpoint: string; created_on?: string; custom_remote_identities?: { fqdn_id?: string }; customer_endpoint?: string; description?: string; health_check?: unknown; id: string; interface_address: string; interface_address6?: string; modified_on?: string; name: string; psk_metadata?: { last_generated_on?: string }; replay_protection?: boolean } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateIpsecTunnelResponse = Schema.Struct({
  result: Schema.Struct({
  modified: Schema.optional(Schema.Boolean),
  modified_ipsec_tunnel: Schema.optional(Schema.Struct({
  allow_null_cipher: Schema.optional(Schema.Boolean),
  automatic_return_routing: Schema.optional(Schema.Boolean),
  bgp: Schema.optional(Schema.Struct({
  customer_asn: Schema.Number,
  extra_prefixes: Schema.optional(Schema.Array(Schema.String)),
  md5_key: Schema.optional(Schema.String)
})),
  bgp_status: Schema.optional(Schema.Struct({
  bgp_state: Schema.optional(Schema.String),
  cf_speaker_ip: Schema.optional(Schema.String),
  cf_speaker_port: Schema.optional(Schema.Number),
  customer_speaker_ip: Schema.optional(Schema.String),
  customer_speaker_port: Schema.optional(Schema.Number),
  state: Schema.Literal("BGP_DOWN", "BGP_UP", "BGP_ESTABLISHING"),
  tcp_established: Schema.Boolean,
  updated_at: Schema.Date
})),
  cloudflare_endpoint: Schema.String,
  created_on: Schema.optional(Schema.Date),
  custom_remote_identities: Schema.optional(Schema.Struct({
  fqdn_id: Schema.optional(Schema.String)
})),
  customer_endpoint: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  health_check: Schema.optional(Schema.Unknown),
  id: Schema.String,
  interface_address: Schema.String,
  interface_address6: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.String,
  psk_metadata: Schema.optional(Schema.Struct({
  last_generated_on: Schema.optional(Schema.Date)
})),
  replay_protection: Schema.optional(Schema.Boolean)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateIpsecTunnelResponse" }) as unknown as Schema.Schema<UpdateIpsecTunnelResponse>;

export const updateIpsecTunnel: (
  input: UpdateIpsecTunnelRequest
) => Effect.Effect<
  UpdateIpsecTunnelResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateIpsecTunnelRequest,
  output: UpdateIpsecTunnelResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteIpsecTunnelRequest {
  ipsec_tunnel_id: string;
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
}

export const DeleteIpsecTunnelRequest = Schema.Struct({
  ipsec_tunnel_id: Schema.String.pipe(T.HttpPath("ipsec_tunnel_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/ipsec_tunnels/{ipsec_tunnel_id}" }),
).annotations({ identifier: "DeleteIpsecTunnelRequest" }) as unknown as Schema.Schema<DeleteIpsecTunnelRequest>;

export interface DeleteIpsecTunnelResponse {
  result: { deleted?: boolean; deleted_ipsec_tunnel?: { allow_null_cipher?: boolean; automatic_return_routing?: boolean; bgp?: { customer_asn: number; extra_prefixes?: string[]; md5_key?: string }; bgp_status?: { bgp_state?: string; cf_speaker_ip?: string; cf_speaker_port?: number; customer_speaker_ip?: string; customer_speaker_port?: number; state: "BGP_DOWN" | "BGP_UP" | "BGP_ESTABLISHING"; tcp_established: boolean; updated_at: string }; cloudflare_endpoint: string; created_on?: string; custom_remote_identities?: { fqdn_id?: string }; customer_endpoint?: string; description?: string; health_check?: unknown; id: string; interface_address: string; interface_address6?: string; modified_on?: string; name: string; psk_metadata?: { last_generated_on?: string }; replay_protection?: boolean } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteIpsecTunnelResponse = Schema.Struct({
  result: Schema.Struct({
  deleted: Schema.optional(Schema.Boolean),
  deleted_ipsec_tunnel: Schema.optional(Schema.Struct({
  allow_null_cipher: Schema.optional(Schema.Boolean),
  automatic_return_routing: Schema.optional(Schema.Boolean),
  bgp: Schema.optional(Schema.Struct({
  customer_asn: Schema.Number,
  extra_prefixes: Schema.optional(Schema.Array(Schema.String)),
  md5_key: Schema.optional(Schema.String)
})),
  bgp_status: Schema.optional(Schema.Struct({
  bgp_state: Schema.optional(Schema.String),
  cf_speaker_ip: Schema.optional(Schema.String),
  cf_speaker_port: Schema.optional(Schema.Number),
  customer_speaker_ip: Schema.optional(Schema.String),
  customer_speaker_port: Schema.optional(Schema.Number),
  state: Schema.Literal("BGP_DOWN", "BGP_UP", "BGP_ESTABLISHING"),
  tcp_established: Schema.Boolean,
  updated_at: Schema.Date
})),
  cloudflare_endpoint: Schema.String,
  created_on: Schema.optional(Schema.Date),
  custom_remote_identities: Schema.optional(Schema.Struct({
  fqdn_id: Schema.optional(Schema.String)
})),
  customer_endpoint: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  health_check: Schema.optional(Schema.Unknown),
  id: Schema.String,
  interface_address: Schema.String,
  interface_address6: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.String,
  psk_metadata: Schema.optional(Schema.Struct({
  last_generated_on: Schema.optional(Schema.Date)
})),
  replay_protection: Schema.optional(Schema.Boolean)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteIpsecTunnelResponse" }) as unknown as Schema.Schema<DeleteIpsecTunnelResponse>;

export const deleteIpsecTunnel: (
  input: DeleteIpsecTunnelRequest
) => Effect.Effect<
  DeleteIpsecTunnelResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteIpsecTunnelRequest,
  output: DeleteIpsecTunnelResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsRequest {
  ipsec_tunnel_id: string;
  account_id: string;
}

export const MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsRequest = Schema.Struct({
  ipsec_tunnel_id: Schema.String.pipe(T.HttpPath("ipsec_tunnel_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/ipsec_tunnels/{ipsec_tunnel_id}/psk_generate" }),
).annotations({ identifier: "MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsRequest" }) as unknown as Schema.Schema<MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsRequest>;

export interface MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsResponse" }) as unknown as Schema.Schema<MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsResponse>;

export const magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels: (
  input: MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsRequest
) => Effect.Effect<
  MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsRequest,
  output: MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListRoutesRequest {
  account_id: string;
}

export const ListRoutesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/routes" }),
).annotations({ identifier: "ListRoutesRequest" }) as unknown as Schema.Schema<ListRoutesRequest>;

export interface ListRoutesResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListRoutesResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListRoutesResponse" }) as unknown as Schema.Schema<ListRoutesResponse>;

export const listRoutes: (
  input: ListRoutesRequest
) => Effect.Effect<
  ListRoutesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListRoutesRequest,
  output: ListRoutesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateRoutesRequest {
  account_id: string;
  body: { description?: string; nexthop: string; prefix: string; priority: number; scope?: { colo_names?: string[]; colo_regions?: string[] }; weight?: number };
}

export const CreateRoutesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  nexthop: Schema.String,
  prefix: Schema.String,
  priority: Schema.Number,
  scope: Schema.optional(Schema.Struct({
  colo_names: Schema.optional(Schema.Array(Schema.String)),
  colo_regions: Schema.optional(Schema.Array(Schema.String))
})),
  weight: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/routes" }),
).annotations({ identifier: "CreateRoutesRequest" }) as unknown as Schema.Schema<CreateRoutesRequest>;

export interface CreateRoutesResponse {
  result: { created_on?: string; description?: string; id: string; modified_on?: string; nexthop: string; prefix: string; priority: number; scope?: { colo_names?: string[]; colo_regions?: string[] }; weight?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateRoutesResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.String,
  modified_on: Schema.optional(Schema.Date),
  nexthop: Schema.String,
  prefix: Schema.String,
  priority: Schema.Number,
  scope: Schema.optional(Schema.Struct({
  colo_names: Schema.optional(Schema.Array(Schema.String)),
  colo_regions: Schema.optional(Schema.Array(Schema.String))
})),
  weight: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateRoutesResponse" }) as unknown as Schema.Schema<CreateRoutesResponse>;

export const createRoutes: (
  input: CreateRoutesRequest
) => Effect.Effect<
  CreateRoutesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateRoutesRequest,
  output: CreateRoutesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateManyRoutesRequest {
  account_id: string;
  body: { routes: unknown[] };
}

export const UpdateManyRoutesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  routes: Schema.Array(Schema.Unknown)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/routes" }),
).annotations({ identifier: "UpdateManyRoutesRequest" }) as unknown as Schema.Schema<UpdateManyRoutesRequest>;

export interface UpdateManyRoutesResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateManyRoutesResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateManyRoutesResponse" }) as unknown as Schema.Schema<UpdateManyRoutesResponse>;

export const updateManyRoutes: (
  input: UpdateManyRoutesRequest
) => Effect.Effect<
  UpdateManyRoutesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateManyRoutesRequest,
  output: UpdateManyRoutesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteManyRoutesRequest {
  account_id: string;
  body: { routes: unknown[] };
}

export const DeleteManyRoutesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  routes: Schema.Array(Schema.Unknown)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/routes" }),
).annotations({ identifier: "DeleteManyRoutesRequest" }) as unknown as Schema.Schema<DeleteManyRoutesRequest>;

export interface DeleteManyRoutesResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteManyRoutesResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteManyRoutesResponse" }) as unknown as Schema.Schema<DeleteManyRoutesResponse>;

export const deleteManyRoutes: (
  input: DeleteManyRoutesRequest
) => Effect.Effect<
  DeleteManyRoutesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteManyRoutesRequest,
  output: DeleteManyRoutesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MagicStaticRoutesRouteDetailsRequest {
  route_id: string;
  account_id: string;
}

export const MagicStaticRoutesRouteDetailsRequest = Schema.Struct({
  route_id: Schema.String.pipe(T.HttpPath("route_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/routes/{route_id}" }),
).annotations({ identifier: "MagicStaticRoutesRouteDetailsRequest" }) as unknown as Schema.Schema<MagicStaticRoutesRouteDetailsRequest>;

export interface MagicStaticRoutesRouteDetailsResponse {
  result: { route?: { created_on?: string; description?: string; id: string; modified_on?: string; nexthop: string; prefix: string; priority: number; scope?: { colo_names?: string[]; colo_regions?: string[] }; weight?: number } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MagicStaticRoutesRouteDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  route: Schema.optional(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.String,
  modified_on: Schema.optional(Schema.Date),
  nexthop: Schema.String,
  prefix: Schema.String,
  priority: Schema.Number,
  scope: Schema.optional(Schema.Struct({
  colo_names: Schema.optional(Schema.Array(Schema.String)),
  colo_regions: Schema.optional(Schema.Array(Schema.String))
})),
  weight: Schema.optional(Schema.Number)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MagicStaticRoutesRouteDetailsResponse" }) as unknown as Schema.Schema<MagicStaticRoutesRouteDetailsResponse>;

export const magicStaticRoutesRouteDetails: (
  input: MagicStaticRoutesRouteDetailsRequest
) => Effect.Effect<
  MagicStaticRoutesRouteDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MagicStaticRoutesRouteDetailsRequest,
  output: MagicStaticRoutesRouteDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateRouteRequest {
  route_id: string;
  account_id: string;
  body: unknown;
}

export const UpdateRouteRequest = Schema.Struct({
  route_id: Schema.String.pipe(T.HttpPath("route_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  nexthop: Schema.String,
  prefix: Schema.String,
  priority: Schema.Number,
  scope: Schema.optional(Schema.Struct({
  colo_names: Schema.optional(Schema.Array(Schema.String)),
  colo_regions: Schema.optional(Schema.Array(Schema.String))
})),
  weight: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/routes/{route_id}" }),
).annotations({ identifier: "UpdateRouteRequest" }) as unknown as Schema.Schema<UpdateRouteRequest>;

export interface UpdateRouteResponse {
  result: { modified?: boolean; modified_route?: { created_on?: string; description?: string; id: string; modified_on?: string; nexthop: string; prefix: string; priority: number; scope?: { colo_names?: string[]; colo_regions?: string[] }; weight?: number } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateRouteResponse = Schema.Struct({
  result: Schema.Struct({
  modified: Schema.optional(Schema.Boolean),
  modified_route: Schema.optional(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.String,
  modified_on: Schema.optional(Schema.Date),
  nexthop: Schema.String,
  prefix: Schema.String,
  priority: Schema.Number,
  scope: Schema.optional(Schema.Struct({
  colo_names: Schema.optional(Schema.Array(Schema.String)),
  colo_regions: Schema.optional(Schema.Array(Schema.String))
})),
  weight: Schema.optional(Schema.Number)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateRouteResponse" }) as unknown as Schema.Schema<UpdateRouteResponse>;

export const updateRoute: (
  input: UpdateRouteRequest
) => Effect.Effect<
  UpdateRouteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateRouteRequest,
  output: UpdateRouteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteRouteRequest {
  route_id: string;
  account_id: string;
}

export const DeleteRouteRequest = Schema.Struct({
  route_id: Schema.String.pipe(T.HttpPath("route_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/routes/{route_id}" }),
).annotations({ identifier: "DeleteRouteRequest" }) as unknown as Schema.Schema<DeleteRouteRequest>;

export interface DeleteRouteResponse {
  result: { deleted?: boolean; deleted_route?: { created_on?: string; description?: string; id: string; modified_on?: string; nexthop: string; prefix: string; priority: number; scope?: { colo_names?: string[]; colo_regions?: string[] }; weight?: number } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteRouteResponse = Schema.Struct({
  result: Schema.Struct({
  deleted: Schema.optional(Schema.Boolean),
  deleted_route: Schema.optional(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  id: Schema.String,
  modified_on: Schema.optional(Schema.Date),
  nexthop: Schema.String,
  prefix: Schema.String,
  priority: Schema.Number,
  scope: Schema.optional(Schema.Struct({
  colo_names: Schema.optional(Schema.Array(Schema.String)),
  colo_regions: Schema.optional(Schema.Array(Schema.String))
})),
  weight: Schema.optional(Schema.Number)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteRouteResponse" }) as unknown as Schema.Schema<DeleteRouteResponse>;

export const deleteRoute: (
  input: DeleteRouteRequest
) => Effect.Effect<
  DeleteRouteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteRouteRequest,
  output: DeleteRouteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListSitesRequest {
  account_id: string;
  connectorid?: string;
}

export const ListSitesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  connectorid: Schema.optional(Schema.String).pipe(T.HttpQuery("connectorid"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/sites" }),
).annotations({ identifier: "ListSitesRequest" }) as unknown as Schema.Schema<ListSitesRequest>;

export interface ListSitesResponse {
  result: { connector_id?: string; description?: string; ha_mode?: boolean; id?: string; location?: { lat?: string; lon?: string }; name?: string; secondary_connector_id?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListSitesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  ha_mode: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  location: Schema.optional(Schema.Struct({
  lat: Schema.optional(Schema.String),
  lon: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String),
  secondary_connector_id: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListSitesResponse" }) as unknown as Schema.Schema<ListSitesResponse>;

export const listSites: (
  input: ListSitesRequest
) => Effect.Effect<
  ListSitesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListSitesRequest,
  output: ListSitesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateSiteRequest {
  account_id: string;
  body: { connector_id?: string; description?: string; ha_mode?: boolean; location?: { lat?: string; lon?: string }; name: string; secondary_connector_id?: string };
}

export const CreateSiteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  ha_mode: Schema.optional(Schema.Boolean),
  location: Schema.optional(Schema.Struct({
  lat: Schema.optional(Schema.String),
  lon: Schema.optional(Schema.String)
})),
  name: Schema.String,
  secondary_connector_id: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/sites" }),
).annotations({ identifier: "CreateSiteRequest" }) as unknown as Schema.Schema<CreateSiteRequest>;

export interface CreateSiteResponse {
  result: { connector_id?: string; description?: string; ha_mode?: boolean; id?: string; location?: { lat?: string; lon?: string }; name?: string; secondary_connector_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateSiteResponse = Schema.Struct({
  result: Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  ha_mode: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  location: Schema.optional(Schema.Struct({
  lat: Schema.optional(Schema.String),
  lon: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String),
  secondary_connector_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateSiteResponse" }) as unknown as Schema.Schema<CreateSiteResponse>;

export const createSite: (
  input: CreateSiteRequest
) => Effect.Effect<
  CreateSiteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateSiteRequest,
  output: CreateSiteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MagicSitesSiteDetailsRequest {
  site_id: string;
  account_id: string;
  "x-magic-new-hc-target"?: boolean;
}

export const MagicSitesSiteDetailsRequest = Schema.Struct({
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  "x-magic-new-hc-target": Schema.optional(Schema.Boolean).pipe(T.HttpHeader("x-magic-new-hc-target"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/sites/{site_id}" }),
).annotations({ identifier: "MagicSitesSiteDetailsRequest" }) as unknown as Schema.Schema<MagicSitesSiteDetailsRequest>;

export interface MagicSitesSiteDetailsResponse {
  result: { connector_id?: string; description?: string; ha_mode?: boolean; id?: string; location?: { lat?: string; lon?: string }; name?: string; secondary_connector_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MagicSitesSiteDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  ha_mode: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  location: Schema.optional(Schema.Struct({
  lat: Schema.optional(Schema.String),
  lon: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String),
  secondary_connector_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MagicSitesSiteDetailsResponse" }) as unknown as Schema.Schema<MagicSitesSiteDetailsResponse>;

export const magicSitesSiteDetails: (
  input: MagicSitesSiteDetailsRequest
) => Effect.Effect<
  MagicSitesSiteDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MagicSitesSiteDetailsRequest,
  output: MagicSitesSiteDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateSiteRequest {
  site_id: string;
  account_id: string;
  body: { connector_id?: string; description?: string; location?: { lat?: string; lon?: string }; name?: string; secondary_connector_id?: string };
}

export const UpdateSiteRequest = Schema.Struct({
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  location: Schema.optional(Schema.Struct({
  lat: Schema.optional(Schema.String),
  lon: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String),
  secondary_connector_id: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/sites/{site_id}" }),
).annotations({ identifier: "UpdateSiteRequest" }) as unknown as Schema.Schema<UpdateSiteRequest>;

export interface UpdateSiteResponse {
  result: { connector_id?: string; description?: string; ha_mode?: boolean; id?: string; location?: { lat?: string; lon?: string }; name?: string; secondary_connector_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateSiteResponse = Schema.Struct({
  result: Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  ha_mode: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  location: Schema.optional(Schema.Struct({
  lat: Schema.optional(Schema.String),
  lon: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String),
  secondary_connector_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateSiteResponse" }) as unknown as Schema.Schema<UpdateSiteResponse>;

export const updateSite: (
  input: UpdateSiteRequest
) => Effect.Effect<
  UpdateSiteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateSiteRequest,
  output: UpdateSiteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteSiteRequest {
  site_id: string;
  account_id: string;
}

export const DeleteSiteRequest = Schema.Struct({
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/sites/{site_id}" }),
).annotations({ identifier: "DeleteSiteRequest" }) as unknown as Schema.Schema<DeleteSiteRequest>;

export interface DeleteSiteResponse {
  result: { connector_id?: string; description?: string; ha_mode?: boolean; id?: string; location?: { lat?: string; lon?: string }; name?: string; secondary_connector_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteSiteResponse = Schema.Struct({
  result: Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  ha_mode: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  location: Schema.optional(Schema.Struct({
  lat: Schema.optional(Schema.String),
  lon: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String),
  secondary_connector_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteSiteResponse" }) as unknown as Schema.Schema<DeleteSiteResponse>;

export const deleteSite: (
  input: DeleteSiteRequest
) => Effect.Effect<
  DeleteSiteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteSiteRequest,
  output: DeleteSiteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchSiteRequest {
  site_id: string;
  account_id: string;
  body: { connector_id?: string; description?: string; location?: { lat?: string; lon?: string }; name?: string; secondary_connector_id?: string };
}

export const PatchSiteRequest = Schema.Struct({
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  location: Schema.optional(Schema.Struct({
  lat: Schema.optional(Schema.String),
  lon: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String),
  secondary_connector_id: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/sites/{site_id}" }),
).annotations({ identifier: "PatchSiteRequest" }) as unknown as Schema.Schema<PatchSiteRequest>;

export interface PatchSiteResponse {
  result: { connector_id?: string; description?: string; ha_mode?: boolean; id?: string; location?: { lat?: string; lon?: string }; name?: string; secondary_connector_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchSiteResponse = Schema.Struct({
  result: Schema.Struct({
  connector_id: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  ha_mode: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  location: Schema.optional(Schema.Struct({
  lat: Schema.optional(Schema.String),
  lon: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String),
  secondary_connector_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchSiteResponse" }) as unknown as Schema.Schema<PatchSiteResponse>;

export const patchSite: (
  input: PatchSiteRequest
) => Effect.Effect<
  PatchSiteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchSiteRequest,
  output: PatchSiteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAclsRequest {
  account_id: string;
  site_id: string;
}

export const ListAclsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/sites/{site_id}/acls" }),
).annotations({ identifier: "ListAclsRequest" }) as unknown as Schema.Schema<ListAclsRequest>;

export interface ListAclsResponse {
  result: { description?: string; forward_locally?: boolean; id?: string; lan_1?: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; lan_2?: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; name?: string; protocols?: "tcp" | "udp" | "icmp"[]; unidirectional?: boolean }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAclsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  description: Schema.optional(Schema.String),
  forward_locally: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  lan_1: Schema.optional(Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
})),
  lan_2: Schema.optional(Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
})),
  name: Schema.optional(Schema.String),
  protocols: Schema.optional(Schema.Array(Schema.Literal("tcp", "udp", "icmp"))),
  unidirectional: Schema.optional(Schema.Boolean)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAclsResponse" }) as unknown as Schema.Schema<ListAclsResponse>;

export const listAcls: (
  input: ListAclsRequest
) => Effect.Effect<
  ListAclsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAclsRequest,
  output: ListAclsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateAclRequest {
  account_id: string;
  site_id: string;
  body: { description?: string; forward_locally?: boolean; lan_1: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; lan_2: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; name: string; protocols?: "tcp" | "udp" | "icmp"[]; unidirectional?: boolean };
}

export const CreateAclRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  forward_locally: Schema.optional(Schema.Boolean),
  lan_1: Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
}),
  lan_2: Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
}),
  name: Schema.String,
  protocols: Schema.optional(Schema.Array(Schema.Literal("tcp", "udp", "icmp"))),
  unidirectional: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/sites/{site_id}/acls" }),
).annotations({ identifier: "CreateAclRequest" }) as unknown as Schema.Schema<CreateAclRequest>;

export interface CreateAclResponse {
  result: { description?: string; forward_locally?: boolean; id?: string; lan_1?: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; lan_2?: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; name?: string; protocols?: "tcp" | "udp" | "icmp"[]; unidirectional?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateAclResponse = Schema.Struct({
  result: Schema.Struct({
  description: Schema.optional(Schema.String),
  forward_locally: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  lan_1: Schema.optional(Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
})),
  lan_2: Schema.optional(Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
})),
  name: Schema.optional(Schema.String),
  protocols: Schema.optional(Schema.Array(Schema.Literal("tcp", "udp", "icmp"))),
  unidirectional: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateAclResponse" }) as unknown as Schema.Schema<CreateAclResponse>;

export const createAcl: (
  input: CreateAclRequest
) => Effect.Effect<
  CreateAclResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAclRequest,
  output: CreateAclResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MagicSiteAclsAclDetailsRequest {
  site_id: string;
  account_id: string;
  acl_id: string;
}

export const MagicSiteAclsAclDetailsRequest = Schema.Struct({
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  acl_id: Schema.String.pipe(T.HttpPath("acl_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/sites/{site_id}/acls/{acl_id}" }),
).annotations({ identifier: "MagicSiteAclsAclDetailsRequest" }) as unknown as Schema.Schema<MagicSiteAclsAclDetailsRequest>;

export interface MagicSiteAclsAclDetailsResponse {
  result: { description?: string; forward_locally?: boolean; id?: string; lan_1?: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; lan_2?: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; name?: string; protocols?: "tcp" | "udp" | "icmp"[]; unidirectional?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MagicSiteAclsAclDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  description: Schema.optional(Schema.String),
  forward_locally: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  lan_1: Schema.optional(Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
})),
  lan_2: Schema.optional(Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
})),
  name: Schema.optional(Schema.String),
  protocols: Schema.optional(Schema.Array(Schema.Literal("tcp", "udp", "icmp"))),
  unidirectional: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MagicSiteAclsAclDetailsResponse" }) as unknown as Schema.Schema<MagicSiteAclsAclDetailsResponse>;

export const magicSiteAclsAclDetails: (
  input: MagicSiteAclsAclDetailsRequest
) => Effect.Effect<
  MagicSiteAclsAclDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MagicSiteAclsAclDetailsRequest,
  output: MagicSiteAclsAclDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAclRequest {
  site_id: string;
  account_id: string;
  acl_id: string;
  body: { description?: string; forward_locally?: boolean; lan_1?: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; lan_2?: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; name?: string; protocols?: "tcp" | "udp" | "icmp"[]; unidirectional?: boolean };
}

export const UpdateAclRequest = Schema.Struct({
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  acl_id: Schema.String.pipe(T.HttpPath("acl_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  forward_locally: Schema.optional(Schema.Boolean),
  lan_1: Schema.optional(Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
})),
  lan_2: Schema.optional(Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
})),
  name: Schema.optional(Schema.String),
  protocols: Schema.optional(Schema.Array(Schema.Literal("tcp", "udp", "icmp"))),
  unidirectional: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/sites/{site_id}/acls/{acl_id}" }),
).annotations({ identifier: "UpdateAclRequest" }) as unknown as Schema.Schema<UpdateAclRequest>;

export interface UpdateAclResponse {
  result: { description?: string; forward_locally?: boolean; id?: string; lan_1?: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; lan_2?: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; name?: string; protocols?: "tcp" | "udp" | "icmp"[]; unidirectional?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAclResponse = Schema.Struct({
  result: Schema.Struct({
  description: Schema.optional(Schema.String),
  forward_locally: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  lan_1: Schema.optional(Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
})),
  lan_2: Schema.optional(Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
})),
  name: Schema.optional(Schema.String),
  protocols: Schema.optional(Schema.Array(Schema.Literal("tcp", "udp", "icmp"))),
  unidirectional: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAclResponse" }) as unknown as Schema.Schema<UpdateAclResponse>;

export const updateAcl: (
  input: UpdateAclRequest
) => Effect.Effect<
  UpdateAclResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAclRequest,
  output: UpdateAclResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAclRequest {
  site_id: string;
  account_id: string;
  acl_id: string;
}

export const DeleteAclRequest = Schema.Struct({
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  acl_id: Schema.String.pipe(T.HttpPath("acl_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/sites/{site_id}/acls/{acl_id}" }),
).annotations({ identifier: "DeleteAclRequest" }) as unknown as Schema.Schema<DeleteAclRequest>;

export interface DeleteAclResponse {
  result: { description?: string; forward_locally?: boolean; id?: string; lan_1?: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; lan_2?: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; name?: string; protocols?: "tcp" | "udp" | "icmp"[]; unidirectional?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAclResponse = Schema.Struct({
  result: Schema.Struct({
  description: Schema.optional(Schema.String),
  forward_locally: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  lan_1: Schema.optional(Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
})),
  lan_2: Schema.optional(Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
})),
  name: Schema.optional(Schema.String),
  protocols: Schema.optional(Schema.Array(Schema.Literal("tcp", "udp", "icmp"))),
  unidirectional: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAclResponse" }) as unknown as Schema.Schema<DeleteAclResponse>;

export const deleteAcl: (
  input: DeleteAclRequest
) => Effect.Effect<
  DeleteAclResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAclRequest,
  output: DeleteAclResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchAclRequest {
  site_id: string;
  account_id: string;
  acl_id: string;
  body: { description?: string; forward_locally?: boolean; lan_1?: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; lan_2?: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; name?: string; protocols?: "tcp" | "udp" | "icmp"[]; unidirectional?: boolean };
}

export const PatchAclRequest = Schema.Struct({
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  acl_id: Schema.String.pipe(T.HttpPath("acl_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  forward_locally: Schema.optional(Schema.Boolean),
  lan_1: Schema.optional(Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
})),
  lan_2: Schema.optional(Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
})),
  name: Schema.optional(Schema.String),
  protocols: Schema.optional(Schema.Array(Schema.Literal("tcp", "udp", "icmp"))),
  unidirectional: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/sites/{site_id}/acls/{acl_id}" }),
).annotations({ identifier: "PatchAclRequest" }) as unknown as Schema.Schema<PatchAclRequest>;

export interface PatchAclResponse {
  result: { description?: string; forward_locally?: boolean; id?: string; lan_1?: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; lan_2?: { lan_id: string; lan_name?: string; port_ranges?: string[]; ports?: number[]; subnets?: unknown[] }; name?: string; protocols?: "tcp" | "udp" | "icmp"[]; unidirectional?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchAclResponse = Schema.Struct({
  result: Schema.Struct({
  description: Schema.optional(Schema.String),
  forward_locally: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  lan_1: Schema.optional(Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
})),
  lan_2: Schema.optional(Schema.Struct({
  lan_id: Schema.String,
  lan_name: Schema.optional(Schema.String),
  port_ranges: Schema.optional(Schema.Array(Schema.String)),
  ports: Schema.optional(Schema.Array(Schema.Number)),
  subnets: Schema.optional(Schema.Array(Schema.Union(Schema.String, Schema.String)))
})),
  name: Schema.optional(Schema.String),
  protocols: Schema.optional(Schema.Array(Schema.Literal("tcp", "udp", "icmp"))),
  unidirectional: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchAclResponse" }) as unknown as Schema.Schema<PatchAclResponse>;

export const patchAcl: (
  input: PatchAclRequest
) => Effect.Effect<
  PatchAclResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchAclRequest,
  output: PatchAclResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAppConfigsRequest {
  account_id: string;
  site_id: string;
}

export const ListAppConfigsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/sites/{site_id}/app_configs" }),
).annotations({ identifier: "ListAppConfigsRequest" }) as unknown as Schema.Schema<ListAppConfigsRequest>;

export interface ListAppConfigsResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAppConfigsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAppConfigsResponse" }) as unknown as Schema.Schema<ListAppConfigsResponse>;

export const listAppConfigs: (
  input: ListAppConfigsRequest
) => Effect.Effect<
  ListAppConfigsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAppConfigsRequest,
  output: ListAppConfigsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MagicSiteAppConfigsAddAppConfigRequest {
  account_id: string;
  site_id: string;
  body: Record<string, unknown>;
}

export const MagicSiteAppConfigsAddAppConfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/sites/{site_id}/app_configs" }),
).annotations({ identifier: "MagicSiteAppConfigsAddAppConfigRequest" }) as unknown as Schema.Schema<MagicSiteAppConfigsAddAppConfigRequest>;

export interface MagicSiteAppConfigsAddAppConfigResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MagicSiteAppConfigsAddAppConfigResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MagicSiteAppConfigsAddAppConfigResponse" }) as unknown as Schema.Schema<MagicSiteAppConfigsAddAppConfigResponse>;

export const magicSiteAppConfigsAddAppConfig: (
  input: MagicSiteAppConfigsAddAppConfigRequest
) => Effect.Effect<
  MagicSiteAppConfigsAddAppConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MagicSiteAppConfigsAddAppConfigRequest,
  output: MagicSiteAppConfigsAddAppConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAppConfigRequest {
  account_id: string;
  site_id: string;
  app_config_id: string;
  body: { account_app_id?: string; breakout?: boolean; managed_app_id?: string; preferred_wans?: string[]; priority?: number };
}

export const UpdateAppConfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  app_config_id: Schema.String.pipe(T.HttpPath("app_config_id")),
  body: Schema.Struct({
  account_app_id: Schema.optional(Schema.String),
  breakout: Schema.optional(Schema.Boolean),
  managed_app_id: Schema.optional(Schema.String),
  preferred_wans: Schema.optional(Schema.Array(Schema.String)),
  priority: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/sites/{site_id}/app_configs/{app_config_id}" }),
).annotations({ identifier: "UpdateAppConfigRequest" }) as unknown as Schema.Schema<UpdateAppConfigRequest>;

export interface UpdateAppConfigResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAppConfigResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAppConfigResponse" }) as unknown as Schema.Schema<UpdateAppConfigResponse>;

export const updateAppConfig: (
  input: UpdateAppConfigRequest
) => Effect.Effect<
  UpdateAppConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAppConfigRequest,
  output: UpdateAppConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAppConfigRequest {
  account_id: string;
  site_id: string;
  app_config_id: string;
}

export const DeleteAppConfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  app_config_id: Schema.String.pipe(T.HttpPath("app_config_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/sites/{site_id}/app_configs/{app_config_id}" }),
).annotations({ identifier: "DeleteAppConfigRequest" }) as unknown as Schema.Schema<DeleteAppConfigRequest>;

export interface DeleteAppConfigResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAppConfigResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAppConfigResponse" }) as unknown as Schema.Schema<DeleteAppConfigResponse>;

export const deleteAppConfig: (
  input: DeleteAppConfigRequest
) => Effect.Effect<
  DeleteAppConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAppConfigRequest,
  output: DeleteAppConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchAppConfigRequest {
  account_id: string;
  site_id: string;
  app_config_id: string;
  body: { account_app_id?: string; breakout?: boolean; managed_app_id?: string; preferred_wans?: string[]; priority?: number };
}

export const PatchAppConfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  app_config_id: Schema.String.pipe(T.HttpPath("app_config_id")),
  body: Schema.Struct({
  account_app_id: Schema.optional(Schema.String),
  breakout: Schema.optional(Schema.Boolean),
  managed_app_id: Schema.optional(Schema.String),
  preferred_wans: Schema.optional(Schema.Array(Schema.String)),
  priority: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/sites/{site_id}/app_configs/{app_config_id}" }),
).annotations({ identifier: "PatchAppConfigRequest" }) as unknown as Schema.Schema<PatchAppConfigRequest>;

export interface PatchAppConfigResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchAppConfigResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchAppConfigResponse" }) as unknown as Schema.Schema<PatchAppConfigResponse>;

export const patchAppConfig: (
  input: PatchAppConfigRequest
) => Effect.Effect<
  PatchAppConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchAppConfigRequest,
  output: PatchAppConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListLansRequest {
  account_id: string;
  site_id: string;
}

export const ListLansRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/sites/{site_id}/lans" }),
).annotations({ identifier: "ListLansRequest" }) as unknown as Schema.Schema<ListLansRequest>;

export interface ListLansResponse {
  result: { ha_link?: boolean; id?: string; name?: string; nat?: { static_prefix?: string }; physport?: number; routed_subnets?: { nat?: { static_prefix?: string }; next_hop: string; prefix: string }[]; site_id?: string; static_addressing?: { address: string; dhcp_relay?: { server_addresses?: string[] }; dhcp_server?: { dhcp_pool_end?: string; dhcp_pool_start?: string; dns_server?: string; dns_servers?: string[]; reservations?: Record<string, unknown> }; secondary_address?: string; virtual_address?: string }; vlan_tag?: number }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListLansResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  ha_link: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  physport: Schema.optional(Schema.Number),
  routed_subnets: Schema.optional(Schema.Array(Schema.Struct({
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  next_hop: Schema.String,
  prefix: Schema.String
}))),
  site_id: Schema.optional(Schema.String),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  dhcp_relay: Schema.optional(Schema.Struct({
  server_addresses: Schema.optional(Schema.Array(Schema.String))
})),
  dhcp_server: Schema.optional(Schema.Struct({
  dhcp_pool_end: Schema.optional(Schema.String),
  dhcp_pool_start: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.String),
  dns_servers: Schema.optional(Schema.Array(Schema.String)),
  reservations: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String }))
})),
  secondary_address: Schema.optional(Schema.String),
  virtual_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListLansResponse" }) as unknown as Schema.Schema<ListLansResponse>;

export const listLans: (
  input: ListLansRequest
) => Effect.Effect<
  ListLansResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListLansRequest,
  output: ListLansResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateLanRequest {
  account_id: string;
  site_id: string;
  body: { ha_link?: boolean; name?: string; nat?: { static_prefix?: string }; physport: number; routed_subnets?: { nat?: { static_prefix?: string }; next_hop: string; prefix: string }[]; static_addressing?: { address: string; dhcp_relay?: { server_addresses?: string[] }; dhcp_server?: { dhcp_pool_end?: string; dhcp_pool_start?: string; dns_server?: string; dns_servers?: string[]; reservations?: Record<string, unknown> }; secondary_address?: string; virtual_address?: string }; vlan_tag?: number };
}

export const CreateLanRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  body: Schema.Struct({
  ha_link: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  physport: Schema.Number,
  routed_subnets: Schema.optional(Schema.Array(Schema.Struct({
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  next_hop: Schema.String,
  prefix: Schema.String
}))),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  dhcp_relay: Schema.optional(Schema.Struct({
  server_addresses: Schema.optional(Schema.Array(Schema.String))
})),
  dhcp_server: Schema.optional(Schema.Struct({
  dhcp_pool_end: Schema.optional(Schema.String),
  dhcp_pool_start: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.String),
  dns_servers: Schema.optional(Schema.Array(Schema.String)),
  reservations: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String }))
})),
  secondary_address: Schema.optional(Schema.String),
  virtual_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/sites/{site_id}/lans" }),
).annotations({ identifier: "CreateLanRequest" }) as unknown as Schema.Schema<CreateLanRequest>;

export interface CreateLanResponse {
  result: { ha_link?: boolean; id?: string; name?: string; nat?: { static_prefix?: string }; physport?: number; routed_subnets?: { nat?: { static_prefix?: string }; next_hop: string; prefix: string }[]; site_id?: string; static_addressing?: { address: string; dhcp_relay?: { server_addresses?: string[] }; dhcp_server?: { dhcp_pool_end?: string; dhcp_pool_start?: string; dns_server?: string; dns_servers?: string[]; reservations?: Record<string, unknown> }; secondary_address?: string; virtual_address?: string }; vlan_tag?: number }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateLanResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  ha_link: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  physport: Schema.optional(Schema.Number),
  routed_subnets: Schema.optional(Schema.Array(Schema.Struct({
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  next_hop: Schema.String,
  prefix: Schema.String
}))),
  site_id: Schema.optional(Schema.String),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  dhcp_relay: Schema.optional(Schema.Struct({
  server_addresses: Schema.optional(Schema.Array(Schema.String))
})),
  dhcp_server: Schema.optional(Schema.Struct({
  dhcp_pool_end: Schema.optional(Schema.String),
  dhcp_pool_start: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.String),
  dns_servers: Schema.optional(Schema.Array(Schema.String)),
  reservations: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String }))
})),
  secondary_address: Schema.optional(Schema.String),
  virtual_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateLanResponse" }) as unknown as Schema.Schema<CreateLanResponse>;

export const createLan: (
  input: CreateLanRequest
) => Effect.Effect<
  CreateLanResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateLanRequest,
  output: CreateLanResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MagicSiteLansLanDetailsRequest {
  site_id: string;
  account_id: string;
  lan_id: string;
}

export const MagicSiteLansLanDetailsRequest = Schema.Struct({
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  lan_id: Schema.String.pipe(T.HttpPath("lan_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/sites/{site_id}/lans/{lan_id}" }),
).annotations({ identifier: "MagicSiteLansLanDetailsRequest" }) as unknown as Schema.Schema<MagicSiteLansLanDetailsRequest>;

export interface MagicSiteLansLanDetailsResponse {
  result: { ha_link?: boolean; id?: string; name?: string; nat?: { static_prefix?: string }; physport?: number; routed_subnets?: { nat?: { static_prefix?: string }; next_hop: string; prefix: string }[]; site_id?: string; static_addressing?: { address: string; dhcp_relay?: { server_addresses?: string[] }; dhcp_server?: { dhcp_pool_end?: string; dhcp_pool_start?: string; dns_server?: string; dns_servers?: string[]; reservations?: Record<string, unknown> }; secondary_address?: string; virtual_address?: string }; vlan_tag?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MagicSiteLansLanDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  ha_link: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  physport: Schema.optional(Schema.Number),
  routed_subnets: Schema.optional(Schema.Array(Schema.Struct({
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  next_hop: Schema.String,
  prefix: Schema.String
}))),
  site_id: Schema.optional(Schema.String),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  dhcp_relay: Schema.optional(Schema.Struct({
  server_addresses: Schema.optional(Schema.Array(Schema.String))
})),
  dhcp_server: Schema.optional(Schema.Struct({
  dhcp_pool_end: Schema.optional(Schema.String),
  dhcp_pool_start: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.String),
  dns_servers: Schema.optional(Schema.Array(Schema.String)),
  reservations: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String }))
})),
  secondary_address: Schema.optional(Schema.String),
  virtual_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MagicSiteLansLanDetailsResponse" }) as unknown as Schema.Schema<MagicSiteLansLanDetailsResponse>;

export const magicSiteLansLanDetails: (
  input: MagicSiteLansLanDetailsRequest
) => Effect.Effect<
  MagicSiteLansLanDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MagicSiteLansLanDetailsRequest,
  output: MagicSiteLansLanDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateLanRequest {
  site_id: string;
  account_id: string;
  lan_id: string;
  body: { name?: string; nat?: { static_prefix?: string }; physport?: number; routed_subnets?: { nat?: { static_prefix?: string }; next_hop: string; prefix: string }[]; static_addressing?: { address: string; dhcp_relay?: { server_addresses?: string[] }; dhcp_server?: { dhcp_pool_end?: string; dhcp_pool_start?: string; dns_server?: string; dns_servers?: string[]; reservations?: Record<string, unknown> }; secondary_address?: string; virtual_address?: string }; vlan_tag?: number };
}

export const UpdateLanRequest = Schema.Struct({
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  lan_id: Schema.String.pipe(T.HttpPath("lan_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String),
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  physport: Schema.optional(Schema.Number),
  routed_subnets: Schema.optional(Schema.Array(Schema.Struct({
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  next_hop: Schema.String,
  prefix: Schema.String
}))),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  dhcp_relay: Schema.optional(Schema.Struct({
  server_addresses: Schema.optional(Schema.Array(Schema.String))
})),
  dhcp_server: Schema.optional(Schema.Struct({
  dhcp_pool_end: Schema.optional(Schema.String),
  dhcp_pool_start: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.String),
  dns_servers: Schema.optional(Schema.Array(Schema.String)),
  reservations: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String }))
})),
  secondary_address: Schema.optional(Schema.String),
  virtual_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/sites/{site_id}/lans/{lan_id}" }),
).annotations({ identifier: "UpdateLanRequest" }) as unknown as Schema.Schema<UpdateLanRequest>;

export interface UpdateLanResponse {
  result: { ha_link?: boolean; id?: string; name?: string; nat?: { static_prefix?: string }; physport?: number; routed_subnets?: { nat?: { static_prefix?: string }; next_hop: string; prefix: string }[]; site_id?: string; static_addressing?: { address: string; dhcp_relay?: { server_addresses?: string[] }; dhcp_server?: { dhcp_pool_end?: string; dhcp_pool_start?: string; dns_server?: string; dns_servers?: string[]; reservations?: Record<string, unknown> }; secondary_address?: string; virtual_address?: string }; vlan_tag?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateLanResponse = Schema.Struct({
  result: Schema.Struct({
  ha_link: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  physport: Schema.optional(Schema.Number),
  routed_subnets: Schema.optional(Schema.Array(Schema.Struct({
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  next_hop: Schema.String,
  prefix: Schema.String
}))),
  site_id: Schema.optional(Schema.String),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  dhcp_relay: Schema.optional(Schema.Struct({
  server_addresses: Schema.optional(Schema.Array(Schema.String))
})),
  dhcp_server: Schema.optional(Schema.Struct({
  dhcp_pool_end: Schema.optional(Schema.String),
  dhcp_pool_start: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.String),
  dns_servers: Schema.optional(Schema.Array(Schema.String)),
  reservations: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String }))
})),
  secondary_address: Schema.optional(Schema.String),
  virtual_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateLanResponse" }) as unknown as Schema.Schema<UpdateLanResponse>;

export const updateLan: (
  input: UpdateLanRequest
) => Effect.Effect<
  UpdateLanResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateLanRequest,
  output: UpdateLanResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteLanRequest {
  site_id: string;
  account_id: string;
  lan_id: string;
}

export const DeleteLanRequest = Schema.Struct({
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  lan_id: Schema.String.pipe(T.HttpPath("lan_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/sites/{site_id}/lans/{lan_id}" }),
).annotations({ identifier: "DeleteLanRequest" }) as unknown as Schema.Schema<DeleteLanRequest>;

export interface DeleteLanResponse {
  result: { ha_link?: boolean; id?: string; name?: string; nat?: { static_prefix?: string }; physport?: number; routed_subnets?: { nat?: { static_prefix?: string }; next_hop: string; prefix: string }[]; site_id?: string; static_addressing?: { address: string; dhcp_relay?: { server_addresses?: string[] }; dhcp_server?: { dhcp_pool_end?: string; dhcp_pool_start?: string; dns_server?: string; dns_servers?: string[]; reservations?: Record<string, unknown> }; secondary_address?: string; virtual_address?: string }; vlan_tag?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteLanResponse = Schema.Struct({
  result: Schema.Struct({
  ha_link: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  physport: Schema.optional(Schema.Number),
  routed_subnets: Schema.optional(Schema.Array(Schema.Struct({
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  next_hop: Schema.String,
  prefix: Schema.String
}))),
  site_id: Schema.optional(Schema.String),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  dhcp_relay: Schema.optional(Schema.Struct({
  server_addresses: Schema.optional(Schema.Array(Schema.String))
})),
  dhcp_server: Schema.optional(Schema.Struct({
  dhcp_pool_end: Schema.optional(Schema.String),
  dhcp_pool_start: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.String),
  dns_servers: Schema.optional(Schema.Array(Schema.String)),
  reservations: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String }))
})),
  secondary_address: Schema.optional(Schema.String),
  virtual_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteLanResponse" }) as unknown as Schema.Schema<DeleteLanResponse>;

export const deleteLan: (
  input: DeleteLanRequest
) => Effect.Effect<
  DeleteLanResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteLanRequest,
  output: DeleteLanResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchLanRequest {
  site_id: string;
  account_id: string;
  lan_id: string;
  body: { name?: string; nat?: { static_prefix?: string }; physport?: number; routed_subnets?: { nat?: { static_prefix?: string }; next_hop: string; prefix: string }[]; static_addressing?: { address: string; dhcp_relay?: { server_addresses?: string[] }; dhcp_server?: { dhcp_pool_end?: string; dhcp_pool_start?: string; dns_server?: string; dns_servers?: string[]; reservations?: Record<string, unknown> }; secondary_address?: string; virtual_address?: string }; vlan_tag?: number };
}

export const PatchLanRequest = Schema.Struct({
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  lan_id: Schema.String.pipe(T.HttpPath("lan_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String),
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  physport: Schema.optional(Schema.Number),
  routed_subnets: Schema.optional(Schema.Array(Schema.Struct({
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  next_hop: Schema.String,
  prefix: Schema.String
}))),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  dhcp_relay: Schema.optional(Schema.Struct({
  server_addresses: Schema.optional(Schema.Array(Schema.String))
})),
  dhcp_server: Schema.optional(Schema.Struct({
  dhcp_pool_end: Schema.optional(Schema.String),
  dhcp_pool_start: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.String),
  dns_servers: Schema.optional(Schema.Array(Schema.String)),
  reservations: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String }))
})),
  secondary_address: Schema.optional(Schema.String),
  virtual_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/sites/{site_id}/lans/{lan_id}" }),
).annotations({ identifier: "PatchLanRequest" }) as unknown as Schema.Schema<PatchLanRequest>;

export interface PatchLanResponse {
  result: { ha_link?: boolean; id?: string; name?: string; nat?: { static_prefix?: string }; physport?: number; routed_subnets?: { nat?: { static_prefix?: string }; next_hop: string; prefix: string }[]; site_id?: string; static_addressing?: { address: string; dhcp_relay?: { server_addresses?: string[] }; dhcp_server?: { dhcp_pool_end?: string; dhcp_pool_start?: string; dns_server?: string; dns_servers?: string[]; reservations?: Record<string, unknown> }; secondary_address?: string; virtual_address?: string }; vlan_tag?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchLanResponse = Schema.Struct({
  result: Schema.Struct({
  ha_link: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  physport: Schema.optional(Schema.Number),
  routed_subnets: Schema.optional(Schema.Array(Schema.Struct({
  nat: Schema.optional(Schema.Struct({
  static_prefix: Schema.optional(Schema.String)
})),
  next_hop: Schema.String,
  prefix: Schema.String
}))),
  site_id: Schema.optional(Schema.String),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  dhcp_relay: Schema.optional(Schema.Struct({
  server_addresses: Schema.optional(Schema.Array(Schema.String))
})),
  dhcp_server: Schema.optional(Schema.Struct({
  dhcp_pool_end: Schema.optional(Schema.String),
  dhcp_pool_start: Schema.optional(Schema.String),
  dns_server: Schema.optional(Schema.String),
  dns_servers: Schema.optional(Schema.Array(Schema.String)),
  reservations: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String }))
})),
  secondary_address: Schema.optional(Schema.String),
  virtual_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchLanResponse" }) as unknown as Schema.Schema<PatchLanResponse>;

export const patchLan: (
  input: PatchLanRequest
) => Effect.Effect<
  PatchLanResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchLanRequest,
  output: PatchLanResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MagicSiteNetflowConfigDetailsRequest {
  account_id: string;
  site_id: string;
}

export const MagicSiteNetflowConfigDetailsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/sites/{site_id}/netflow_config" }),
).annotations({ identifier: "MagicSiteNetflowConfigDetailsRequest" }) as unknown as Schema.Schema<MagicSiteNetflowConfigDetailsRequest>;

export interface MagicSiteNetflowConfigDetailsResponse {
  result: { active_timeout?: number; collector_ip: string; collector_port?: number; inactive_timeout?: number; sampling_rate?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MagicSiteNetflowConfigDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  active_timeout: Schema.optional(Schema.Number),
  collector_ip: Schema.String,
  collector_port: Schema.optional(Schema.Number),
  inactive_timeout: Schema.optional(Schema.Number),
  sampling_rate: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MagicSiteNetflowConfigDetailsResponse" }) as unknown as Schema.Schema<MagicSiteNetflowConfigDetailsResponse>;

export const magicSiteNetflowConfigDetails: (
  input: MagicSiteNetflowConfigDetailsRequest
) => Effect.Effect<
  MagicSiteNetflowConfigDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MagicSiteNetflowConfigDetailsRequest,
  output: MagicSiteNetflowConfigDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateNetflowConfigRequest {
  account_id: string;
  site_id: string;
  body: { active_timeout?: number; collector_ip?: string; collector_port?: number; inactive_timeout?: number; sampling_rate?: number };
}

export const CreateNetflowConfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  body: Schema.Struct({
  active_timeout: Schema.optional(Schema.Number),
  collector_ip: Schema.optional(Schema.String),
  collector_port: Schema.optional(Schema.Number),
  inactive_timeout: Schema.optional(Schema.Number),
  sampling_rate: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/sites/{site_id}/netflow_config" }),
).annotations({ identifier: "CreateNetflowConfigRequest" }) as unknown as Schema.Schema<CreateNetflowConfigRequest>;

export interface CreateNetflowConfigResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateNetflowConfigResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateNetflowConfigResponse" }) as unknown as Schema.Schema<CreateNetflowConfigResponse>;

export const createNetflowConfig: (
  input: CreateNetflowConfigRequest
) => Effect.Effect<
  CreateNetflowConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateNetflowConfigRequest,
  output: CreateNetflowConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateNetflowConfigRequest {
  account_id: string;
  site_id: string;
  body: { active_timeout?: number; collector_ip?: string; collector_port?: number; inactive_timeout?: number; sampling_rate?: number };
}

export const UpdateNetflowConfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  body: Schema.Struct({
  active_timeout: Schema.optional(Schema.Number),
  collector_ip: Schema.optional(Schema.String),
  collector_port: Schema.optional(Schema.Number),
  inactive_timeout: Schema.optional(Schema.Number),
  sampling_rate: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/sites/{site_id}/netflow_config" }),
).annotations({ identifier: "UpdateNetflowConfigRequest" }) as unknown as Schema.Schema<UpdateNetflowConfigRequest>;

export interface UpdateNetflowConfigResponse {
  result: { active_timeout?: number; collector_ip: string; collector_port?: number; inactive_timeout?: number; sampling_rate?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateNetflowConfigResponse = Schema.Struct({
  result: Schema.Struct({
  active_timeout: Schema.optional(Schema.Number),
  collector_ip: Schema.String,
  collector_port: Schema.optional(Schema.Number),
  inactive_timeout: Schema.optional(Schema.Number),
  sampling_rate: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateNetflowConfigResponse" }) as unknown as Schema.Schema<UpdateNetflowConfigResponse>;

export const updateNetflowConfig: (
  input: UpdateNetflowConfigRequest
) => Effect.Effect<
  UpdateNetflowConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateNetflowConfigRequest,
  output: UpdateNetflowConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteNetflowConfigRequest {
  account_id: string;
  site_id: string;
}

export const DeleteNetflowConfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/sites/{site_id}/netflow_config" }),
).annotations({ identifier: "DeleteNetflowConfigRequest" }) as unknown as Schema.Schema<DeleteNetflowConfigRequest>;

export interface DeleteNetflowConfigResponse {
  result: { active_timeout?: number; collector_ip: string; collector_port?: number; inactive_timeout?: number; sampling_rate?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteNetflowConfigResponse = Schema.Struct({
  result: Schema.Struct({
  active_timeout: Schema.optional(Schema.Number),
  collector_ip: Schema.String,
  collector_port: Schema.optional(Schema.Number),
  inactive_timeout: Schema.optional(Schema.Number),
  sampling_rate: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteNetflowConfigResponse" }) as unknown as Schema.Schema<DeleteNetflowConfigResponse>;

export const deleteNetflowConfig: (
  input: DeleteNetflowConfigRequest
) => Effect.Effect<
  DeleteNetflowConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteNetflowConfigRequest,
  output: DeleteNetflowConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchNetflowConfigRequest {
  account_id: string;
  site_id: string;
  body: { active_timeout?: number; collector_ip?: string; collector_port?: number; inactive_timeout?: number; sampling_rate?: number };
}

export const PatchNetflowConfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  body: Schema.Struct({
  active_timeout: Schema.optional(Schema.Number),
  collector_ip: Schema.optional(Schema.String),
  collector_port: Schema.optional(Schema.Number),
  inactive_timeout: Schema.optional(Schema.Number),
  sampling_rate: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/sites/{site_id}/netflow_config" }),
).annotations({ identifier: "PatchNetflowConfigRequest" }) as unknown as Schema.Schema<PatchNetflowConfigRequest>;

export interface PatchNetflowConfigResponse {
  result: { active_timeout?: number; collector_ip: string; collector_port?: number; inactive_timeout?: number; sampling_rate?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchNetflowConfigResponse = Schema.Struct({
  result: Schema.Struct({
  active_timeout: Schema.optional(Schema.Number),
  collector_ip: Schema.String,
  collector_port: Schema.optional(Schema.Number),
  inactive_timeout: Schema.optional(Schema.Number),
  sampling_rate: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchNetflowConfigResponse" }) as unknown as Schema.Schema<PatchNetflowConfigResponse>;

export const patchNetflowConfig: (
  input: PatchNetflowConfigRequest
) => Effect.Effect<
  PatchNetflowConfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchNetflowConfigRequest,
  output: PatchNetflowConfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListWansRequest {
  account_id: string;
  site_id: string;
}

export const ListWansRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/sites/{site_id}/wans" }),
).annotations({ identifier: "ListWansRequest" }) as unknown as Schema.Schema<ListWansRequest>;

export interface ListWansResponse {
  result: { health_check_rate?: "low" | "mid" | "high"; id?: string; name?: string; physport?: number; priority?: number; site_id?: string; static_addressing?: { address: string; gateway_address: string; secondary_address?: string }; vlan_tag?: number }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListWansResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  health_check_rate: Schema.optional(Schema.Literal("low", "mid", "high")),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  physport: Schema.optional(Schema.Number),
  priority: Schema.optional(Schema.Number),
  site_id: Schema.optional(Schema.String),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  gateway_address: Schema.String,
  secondary_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListWansResponse" }) as unknown as Schema.Schema<ListWansResponse>;

export const listWans: (
  input: ListWansRequest
) => Effect.Effect<
  ListWansResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListWansRequest,
  output: ListWansResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateWanRequest {
  account_id: string;
  site_id: string;
  body: { name?: string; physport: number; priority?: number; static_addressing?: { address: string; gateway_address: string; secondary_address?: string }; vlan_tag?: number };
}

export const CreateWanRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String),
  physport: Schema.Number,
  priority: Schema.optional(Schema.Number),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  gateway_address: Schema.String,
  secondary_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/magic/sites/{site_id}/wans" }),
).annotations({ identifier: "CreateWanRequest" }) as unknown as Schema.Schema<CreateWanRequest>;

export interface CreateWanResponse {
  result: { health_check_rate?: "low" | "mid" | "high"; id?: string; name?: string; physport?: number; priority?: number; site_id?: string; static_addressing?: { address: string; gateway_address: string; secondary_address?: string }; vlan_tag?: number }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateWanResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  health_check_rate: Schema.optional(Schema.Literal("low", "mid", "high")),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  physport: Schema.optional(Schema.Number),
  priority: Schema.optional(Schema.Number),
  site_id: Schema.optional(Schema.String),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  gateway_address: Schema.String,
  secondary_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateWanResponse" }) as unknown as Schema.Schema<CreateWanResponse>;

export const createWan: (
  input: CreateWanRequest
) => Effect.Effect<
  CreateWanResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateWanRequest,
  output: CreateWanResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MagicSiteWansWanDetailsRequest {
  site_id: string;
  account_id: string;
  wan_id: string;
}

export const MagicSiteWansWanDetailsRequest = Schema.Struct({
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  wan_id: Schema.String.pipe(T.HttpPath("wan_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/magic/sites/{site_id}/wans/{wan_id}" }),
).annotations({ identifier: "MagicSiteWansWanDetailsRequest" }) as unknown as Schema.Schema<MagicSiteWansWanDetailsRequest>;

export interface MagicSiteWansWanDetailsResponse {
  result: { health_check_rate?: "low" | "mid" | "high"; id?: string; name?: string; physport?: number; priority?: number; site_id?: string; static_addressing?: { address: string; gateway_address: string; secondary_address?: string }; vlan_tag?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MagicSiteWansWanDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  health_check_rate: Schema.optional(Schema.Literal("low", "mid", "high")),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  physport: Schema.optional(Schema.Number),
  priority: Schema.optional(Schema.Number),
  site_id: Schema.optional(Schema.String),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  gateway_address: Schema.String,
  secondary_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MagicSiteWansWanDetailsResponse" }) as unknown as Schema.Schema<MagicSiteWansWanDetailsResponse>;

export const magicSiteWansWanDetails: (
  input: MagicSiteWansWanDetailsRequest
) => Effect.Effect<
  MagicSiteWansWanDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MagicSiteWansWanDetailsRequest,
  output: MagicSiteWansWanDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateWanRequest {
  site_id: string;
  account_id: string;
  wan_id: string;
  body: { name?: string; physport?: number; priority?: number; static_addressing?: { address: string; gateway_address: string; secondary_address?: string }; vlan_tag?: number };
}

export const UpdateWanRequest = Schema.Struct({
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  wan_id: Schema.String.pipe(T.HttpPath("wan_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String),
  physport: Schema.optional(Schema.Number),
  priority: Schema.optional(Schema.Number),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  gateway_address: Schema.String,
  secondary_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/magic/sites/{site_id}/wans/{wan_id}" }),
).annotations({ identifier: "UpdateWanRequest" }) as unknown as Schema.Schema<UpdateWanRequest>;

export interface UpdateWanResponse {
  result: { health_check_rate?: "low" | "mid" | "high"; id?: string; name?: string; physport?: number; priority?: number; site_id?: string; static_addressing?: { address: string; gateway_address: string; secondary_address?: string }; vlan_tag?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateWanResponse = Schema.Struct({
  result: Schema.Struct({
  health_check_rate: Schema.optional(Schema.Literal("low", "mid", "high")),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  physport: Schema.optional(Schema.Number),
  priority: Schema.optional(Schema.Number),
  site_id: Schema.optional(Schema.String),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  gateway_address: Schema.String,
  secondary_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateWanResponse" }) as unknown as Schema.Schema<UpdateWanResponse>;

export const updateWan: (
  input: UpdateWanRequest
) => Effect.Effect<
  UpdateWanResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateWanRequest,
  output: UpdateWanResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteWanRequest {
  site_id: string;
  account_id: string;
  wan_id: string;
}

export const DeleteWanRequest = Schema.Struct({
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  wan_id: Schema.String.pipe(T.HttpPath("wan_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/magic/sites/{site_id}/wans/{wan_id}" }),
).annotations({ identifier: "DeleteWanRequest" }) as unknown as Schema.Schema<DeleteWanRequest>;

export interface DeleteWanResponse {
  result: { health_check_rate?: "low" | "mid" | "high"; id?: string; name?: string; physport?: number; priority?: number; site_id?: string; static_addressing?: { address: string; gateway_address: string; secondary_address?: string }; vlan_tag?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteWanResponse = Schema.Struct({
  result: Schema.Struct({
  health_check_rate: Schema.optional(Schema.Literal("low", "mid", "high")),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  physport: Schema.optional(Schema.Number),
  priority: Schema.optional(Schema.Number),
  site_id: Schema.optional(Schema.String),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  gateway_address: Schema.String,
  secondary_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteWanResponse" }) as unknown as Schema.Schema<DeleteWanResponse>;

export const deleteWan: (
  input: DeleteWanRequest
) => Effect.Effect<
  DeleteWanResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteWanRequest,
  output: DeleteWanResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchWanRequest {
  site_id: string;
  account_id: string;
  wan_id: string;
  body: { name?: string; physport?: number; priority?: number; static_addressing?: { address: string; gateway_address: string; secondary_address?: string }; vlan_tag?: number };
}

export const PatchWanRequest = Schema.Struct({
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  wan_id: Schema.String.pipe(T.HttpPath("wan_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String),
  physport: Schema.optional(Schema.Number),
  priority: Schema.optional(Schema.Number),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  gateway_address: Schema.String,
  secondary_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/magic/sites/{site_id}/wans/{wan_id}" }),
).annotations({ identifier: "PatchWanRequest" }) as unknown as Schema.Schema<PatchWanRequest>;

export interface PatchWanResponse {
  result: { health_check_rate?: "low" | "mid" | "high"; id?: string; name?: string; physport?: number; priority?: number; site_id?: string; static_addressing?: { address: string; gateway_address: string; secondary_address?: string }; vlan_tag?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchWanResponse = Schema.Struct({
  result: Schema.Struct({
  health_check_rate: Schema.optional(Schema.Literal("low", "mid", "high")),
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  physport: Schema.optional(Schema.Number),
  priority: Schema.optional(Schema.Number),
  site_id: Schema.optional(Schema.String),
  static_addressing: Schema.optional(Schema.Struct({
  address: Schema.String,
  gateway_address: Schema.String,
  secondary_address: Schema.optional(Schema.String)
})),
  vlan_tag: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchWanResponse" }) as unknown as Schema.Schema<PatchWanResponse>;

export const patchWan: (
  input: PatchWanRequest
) => Effect.Effect<
  PatchWanResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchWanRequest,
  output: PatchWanResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListMembersRequest {
  account_id: unknown;
  order?: "user.first_name" | "user.last_name" | "user.email" | "status";
  status?: "accepted" | "pending" | "rejected";
  page?: number;
  per_page?: number;
  direction?: "asc" | "desc";
}

export const ListMembersRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  order: Schema.optional(Schema.Literal("user.first_name", "user.last_name", "user.email", "status")).pipe(T.HttpQuery("order")),
  status: Schema.optional(Schema.Literal("accepted", "pending", "rejected")).pipe(T.HttpQuery("status")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/members" }),
).annotations({ identifier: "ListMembersRequest" }) as unknown as Schema.Schema<ListMembersRequest>;

export interface ListMembersResponse {
  result: { email?: string; id?: string; policies?: unknown[]; roles?: { description: string; id: string; name: string; permissions: unknown }[]; status?: "accepted" | "pending"; user?: { email: string; first_name?: string; id?: string; last_name?: string; two_factor_authentication_enabled?: boolean } }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListMembersResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  email: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  policies: Schema.optional(Schema.Array(Schema.Unknown)),
  roles: Schema.optional(Schema.Array(Schema.Struct({
  description: Schema.String,
  id: Schema.String,
  name: Schema.String,
  permissions: Schema.Unknown
}))),
  status: Schema.optional(Schema.Literal("accepted", "pending")),
  user: Schema.optional(Schema.Struct({
  email: Schema.String,
  first_name: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  last_name: Schema.optional(Schema.String),
  two_factor_authentication_enabled: Schema.optional(Schema.Boolean)
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListMembersResponse" }) as unknown as Schema.Schema<ListMembersResponse>;

export const listMembers: (
  input: ListMembersRequest
) => Effect.Effect<
  ListMembersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListMembersRequest,
  output: ListMembersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountMembersAddMemberRequest {
  account_id: unknown;
  body: unknown;
}

export const AccountMembersAddMemberRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Union(Schema.Struct({
  email: Schema.String,
  roles: Schema.Array(Schema.String),
  status: Schema.optional(Schema.Literal("accepted", "pending"))
}), Schema.Struct({
  email: Schema.String,
  policies: Schema.Array(Schema.Unknown),
  status: Schema.optional(Schema.Literal("accepted", "pending"))
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/members" }),
).annotations({ identifier: "AccountMembersAddMemberRequest" }) as unknown as Schema.Schema<AccountMembersAddMemberRequest>;

export interface AccountMembersAddMemberResponse {
  result: { email?: string; id?: string; policies?: unknown[]; roles?: { description: string; id: string; name: string; permissions: unknown }[]; status?: "accepted" | "pending"; user?: { email: string; first_name?: string; id?: string; last_name?: string; two_factor_authentication_enabled?: boolean } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountMembersAddMemberResponse = Schema.Struct({
  result: Schema.Struct({
  email: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  policies: Schema.optional(Schema.Array(Schema.Unknown)),
  roles: Schema.optional(Schema.Array(Schema.Struct({
  description: Schema.String,
  id: Schema.String,
  name: Schema.String,
  permissions: Schema.Unknown
}))),
  status: Schema.optional(Schema.Literal("accepted", "pending")),
  user: Schema.optional(Schema.Struct({
  email: Schema.String,
  first_name: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  last_name: Schema.optional(Schema.String),
  two_factor_authentication_enabled: Schema.optional(Schema.Boolean)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountMembersAddMemberResponse" }) as unknown as Schema.Schema<AccountMembersAddMemberResponse>;

export const accountMembersAddMember: (
  input: AccountMembersAddMemberRequest
) => Effect.Effect<
  AccountMembersAddMemberResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountMembersAddMemberRequest,
  output: AccountMembersAddMemberResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountMembersMemberDetailsRequest {
  member_id: string;
  account_id: unknown;
}

export const AccountMembersMemberDetailsRequest = Schema.Struct({
  member_id: Schema.String.pipe(T.HttpPath("member_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/members/{member_id}" }),
).annotations({ identifier: "AccountMembersMemberDetailsRequest" }) as unknown as Schema.Schema<AccountMembersMemberDetailsRequest>;

export interface AccountMembersMemberDetailsResponse {
  result: { email?: string; id?: string; policies?: unknown[]; roles?: { description: string; id: string; name: string; permissions: unknown }[]; status?: "accepted" | "pending"; user?: { email: string; first_name?: string; id?: string; last_name?: string; two_factor_authentication_enabled?: boolean } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountMembersMemberDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  email: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  policies: Schema.optional(Schema.Array(Schema.Unknown)),
  roles: Schema.optional(Schema.Array(Schema.Struct({
  description: Schema.String,
  id: Schema.String,
  name: Schema.String,
  permissions: Schema.Unknown
}))),
  status: Schema.optional(Schema.Literal("accepted", "pending")),
  user: Schema.optional(Schema.Struct({
  email: Schema.String,
  first_name: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  last_name: Schema.optional(Schema.String),
  two_factor_authentication_enabled: Schema.optional(Schema.Boolean)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountMembersMemberDetailsResponse" }) as unknown as Schema.Schema<AccountMembersMemberDetailsResponse>;

export const accountMembersMemberDetails: (
  input: AccountMembersMemberDetailsRequest
) => Effect.Effect<
  AccountMembersMemberDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountMembersMemberDetailsRequest,
  output: AccountMembersMemberDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateMemberRequest {
  member_id: string;
  account_id: unknown;
  body: unknown;
}

export const UpdateMemberRequest = Schema.Struct({
  member_id: Schema.String.pipe(T.HttpPath("member_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Union(Schema.Struct({
  id: Schema.optional(Schema.String),
  roles: Schema.optional(Schema.Array(Schema.Struct({
  description: Schema.String,
  id: Schema.String,
  name: Schema.String,
  permissions: Schema.Unknown
}))),
  status: Schema.optional(Schema.Literal("accepted", "pending")),
  user: Schema.optional(Schema.Struct({
  email: Schema.String,
  first_name: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  last_name: Schema.optional(Schema.String),
  two_factor_authentication_enabled: Schema.optional(Schema.Boolean)
}))
}), Schema.Struct({
  policies: Schema.Array(Schema.Unknown)
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/members/{member_id}" }),
).annotations({ identifier: "UpdateMemberRequest" }) as unknown as Schema.Schema<UpdateMemberRequest>;

export interface UpdateMemberResponse {
  result: { email?: string; id?: string; policies?: unknown[]; roles?: { description: string; id: string; name: string; permissions: unknown }[]; status?: "accepted" | "pending"; user?: { email: string; first_name?: string; id?: string; last_name?: string; two_factor_authentication_enabled?: boolean } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateMemberResponse = Schema.Struct({
  result: Schema.Struct({
  email: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  policies: Schema.optional(Schema.Array(Schema.Unknown)),
  roles: Schema.optional(Schema.Array(Schema.Struct({
  description: Schema.String,
  id: Schema.String,
  name: Schema.String,
  permissions: Schema.Unknown
}))),
  status: Schema.optional(Schema.Literal("accepted", "pending")),
  user: Schema.optional(Schema.Struct({
  email: Schema.String,
  first_name: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  last_name: Schema.optional(Schema.String),
  two_factor_authentication_enabled: Schema.optional(Schema.Boolean)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateMemberResponse" }) as unknown as Schema.Schema<UpdateMemberResponse>;

export const updateMember: (
  input: UpdateMemberRequest
) => Effect.Effect<
  UpdateMemberResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateMemberRequest,
  output: UpdateMemberResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountMembersRemoveMemberRequest {
  member_id: string;
  account_id: unknown;
}

export const AccountMembersRemoveMemberRequest = Schema.Struct({
  member_id: Schema.String.pipe(T.HttpPath("member_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/members/{member_id}" }),
).annotations({ identifier: "AccountMembersRemoveMemberRequest" }) as unknown as Schema.Schema<AccountMembersRemoveMemberRequest>;

export interface AccountMembersRemoveMemberResponse {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountMembersRemoveMemberResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountMembersRemoveMemberResponse" }) as unknown as Schema.Schema<AccountMembersRemoveMemberResponse>;

export const accountMembersRemoveMember: (
  input: AccountMembersRemoveMemberRequest
) => Effect.Effect<
  AccountMembersRemoveMemberResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountMembersRemoveMemberRequest,
  output: AccountMembersRemoveMemberResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAccountConfigurationRequest {
  account_id: string;
}

export const ListAccountConfigurationRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/mnm/config" }),
).annotations({ identifier: "ListAccountConfigurationRequest" }) as unknown as Schema.Schema<ListAccountConfigurationRequest>;

export interface ListAccountConfigurationResponse {
  result: { default_sampling: number; name: string; router_ips: string[]; warp_devices: { id: string; name: string; router_ip: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAccountConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  default_sampling: Schema.Number,
  name: Schema.String,
  router_ips: Schema.Array(Schema.String),
  warp_devices: Schema.Array(Schema.Struct({
  id: Schema.String,
  name: Schema.String,
  router_ip: Schema.String
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAccountConfigurationResponse" }) as unknown as Schema.Schema<ListAccountConfigurationResponse>;

export const listAccountConfiguration: (
  input: ListAccountConfigurationRequest
) => Effect.Effect<
  ListAccountConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccountConfigurationRequest,
  output: ListAccountConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateAccountConfigurationRequest {
  account_id: string;
  body: { default_sampling: number; name: string; router_ips?: string[]; warp_devices?: { id: string; name: string; router_ip: string }[] };
}

export const CreateAccountConfigurationRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  default_sampling: Schema.Number,
  name: Schema.String,
  router_ips: Schema.optional(Schema.Array(Schema.String)),
  warp_devices: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.String,
  name: Schema.String,
  router_ip: Schema.String
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/mnm/config" }),
).annotations({ identifier: "CreateAccountConfigurationRequest" }) as unknown as Schema.Schema<CreateAccountConfigurationRequest>;

export interface CreateAccountConfigurationResponse {
  result: { default_sampling: number; name: string; router_ips: string[]; warp_devices: { id: string; name: string; router_ip: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateAccountConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  default_sampling: Schema.Number,
  name: Schema.String,
  router_ips: Schema.Array(Schema.String),
  warp_devices: Schema.Array(Schema.Struct({
  id: Schema.String,
  name: Schema.String,
  router_ip: Schema.String
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateAccountConfigurationResponse" }) as unknown as Schema.Schema<CreateAccountConfigurationResponse>;

export const createAccountConfiguration: (
  input: CreateAccountConfigurationRequest
) => Effect.Effect<
  CreateAccountConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccountConfigurationRequest,
  output: CreateAccountConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAnEntireAccountConfigurationRequest {
  account_id: string;
  body: { default_sampling: number; name: string; router_ips?: string[]; warp_devices?: { id: string; name: string; router_ip: string }[] };
}

export const UpdateAnEntireAccountConfigurationRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  default_sampling: Schema.Number,
  name: Schema.String,
  router_ips: Schema.optional(Schema.Array(Schema.String)),
  warp_devices: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.String,
  name: Schema.String,
  router_ip: Schema.String
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/mnm/config" }),
).annotations({ identifier: "UpdateAnEntireAccountConfigurationRequest" }) as unknown as Schema.Schema<UpdateAnEntireAccountConfigurationRequest>;

export interface UpdateAnEntireAccountConfigurationResponse {
  result: { default_sampling: number; name: string; router_ips: string[]; warp_devices: { id: string; name: string; router_ip: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAnEntireAccountConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  default_sampling: Schema.Number,
  name: Schema.String,
  router_ips: Schema.Array(Schema.String),
  warp_devices: Schema.Array(Schema.Struct({
  id: Schema.String,
  name: Schema.String,
  router_ip: Schema.String
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAnEntireAccountConfigurationResponse" }) as unknown as Schema.Schema<UpdateAnEntireAccountConfigurationResponse>;

export const updateAnEntireAccountConfiguration: (
  input: UpdateAnEntireAccountConfigurationRequest
) => Effect.Effect<
  UpdateAnEntireAccountConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAnEntireAccountConfigurationRequest,
  output: UpdateAnEntireAccountConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAccountConfigurationRequest {
  account_id: string;
}

export const DeleteAccountConfigurationRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/mnm/config" }),
).annotations({ identifier: "DeleteAccountConfigurationRequest" }) as unknown as Schema.Schema<DeleteAccountConfigurationRequest>;

export interface DeleteAccountConfigurationResponse {
  result: { default_sampling: number; name: string; router_ips: string[]; warp_devices: { id: string; name: string; router_ip: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAccountConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  default_sampling: Schema.Number,
  name: Schema.String,
  router_ips: Schema.Array(Schema.String),
  warp_devices: Schema.Array(Schema.Struct({
  id: Schema.String,
  name: Schema.String,
  router_ip: Schema.String
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAccountConfigurationResponse" }) as unknown as Schema.Schema<DeleteAccountConfigurationResponse>;

export const deleteAccountConfiguration: (
  input: DeleteAccountConfigurationRequest
) => Effect.Effect<
  DeleteAccountConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccountConfigurationRequest,
  output: DeleteAccountConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAccountConfigurationFieldsRequest {
  account_id: string;
  body: { default_sampling?: number; name?: string; router_ips?: string[]; warp_devices?: { id: string; name: string; router_ip: string }[] };
}

export const UpdateAccountConfigurationFieldsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  default_sampling: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  router_ips: Schema.optional(Schema.Array(Schema.String)),
  warp_devices: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.String,
  name: Schema.String,
  router_ip: Schema.String
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/mnm/config" }),
).annotations({ identifier: "UpdateAccountConfigurationFieldsRequest" }) as unknown as Schema.Schema<UpdateAccountConfigurationFieldsRequest>;

export interface UpdateAccountConfigurationFieldsResponse {
  result: { default_sampling: number; name: string; router_ips: string[]; warp_devices: { id: string; name: string; router_ip: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAccountConfigurationFieldsResponse = Schema.Struct({
  result: Schema.Struct({
  default_sampling: Schema.Number,
  name: Schema.String,
  router_ips: Schema.Array(Schema.String),
  warp_devices: Schema.Array(Schema.Struct({
  id: Schema.String,
  name: Schema.String,
  router_ip: Schema.String
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAccountConfigurationFieldsResponse" }) as unknown as Schema.Schema<UpdateAccountConfigurationFieldsResponse>;

export const updateAccountConfigurationFields: (
  input: UpdateAccountConfigurationFieldsRequest
) => Effect.Effect<
  UpdateAccountConfigurationFieldsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccountConfigurationFieldsRequest,
  output: UpdateAccountConfigurationFieldsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListRulesAndAccountConfigurationRequest {
  account_id: string;
}

export const ListRulesAndAccountConfigurationRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/mnm/config/full" }),
).annotations({ identifier: "ListRulesAndAccountConfigurationRequest" }) as unknown as Schema.Schema<ListRulesAndAccountConfigurationRequest>;

export interface ListRulesAndAccountConfigurationResponse {
  result: { default_sampling: number; name: string; router_ips: string[]; warp_devices: { id: string; name: string; router_ip: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListRulesAndAccountConfigurationResponse = Schema.Struct({
  result: Schema.Struct({
  default_sampling: Schema.Number,
  name: Schema.String,
  router_ips: Schema.Array(Schema.String),
  warp_devices: Schema.Array(Schema.Struct({
  id: Schema.String,
  name: Schema.String,
  router_ip: Schema.String
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListRulesAndAccountConfigurationResponse" }) as unknown as Schema.Schema<ListRulesAndAccountConfigurationResponse>;

export const listRulesAndAccountConfiguration: (
  input: ListRulesAndAccountConfigurationRequest
) => Effect.Effect<
  ListRulesAndAccountConfigurationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListRulesAndAccountConfigurationRequest,
  output: ListRulesAndAccountConfigurationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListRulesRequest {
  account_id: string;
}

export const ListRulesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/mnm/rules" }),
).annotations({ identifier: "ListRulesRequest" }) as unknown as Schema.Schema<ListRulesRequest>;

export interface ListRulesResponse {
  result: { automatic_advertisement: boolean; bandwidth_threshold?: number; duration?: "1m" | "5m" | "10m" | "15m" | "20m" | "30m" | "45m" | "60m"; id?: string; name: string; packet_threshold?: number; prefix_match?: "exact" | "subnet" | "supernet"; prefixes: string[]; type: "threshold" | "zscore" | "advanced_ddos"; zscore_sensitivity?: "low" | "medium" | "high"; zscore_target?: "bits" | "packets" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListRulesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  automatic_advertisement: Schema.Boolean,
  bandwidth_threshold: Schema.optional(Schema.Number),
  duration: Schema.optional(Schema.Literal("1m", "5m", "10m", "15m", "20m", "30m", "45m", "60m")),
  id: Schema.optional(Schema.String),
  name: Schema.String,
  packet_threshold: Schema.optional(Schema.Number),
  prefix_match: Schema.optional(Schema.Literal("exact", "subnet", "supernet")),
  prefixes: Schema.Array(Schema.String),
  type: Schema.Literal("threshold", "zscore", "advanced_ddos"),
  zscore_sensitivity: Schema.optional(Schema.Literal("low", "medium", "high")),
  zscore_target: Schema.optional(Schema.Literal("bits", "packets"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListRulesResponse" }) as unknown as Schema.Schema<ListRulesResponse>;

export const listRules: (
  input: ListRulesRequest
) => Effect.Effect<
  ListRulesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListRulesRequest,
  output: ListRulesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateRulesRequest {
  account_id: string;
  body: { automatic_advertisement?: boolean; bandwidth?: number; duration: "1m" | "5m" | "10m" | "15m" | "20m" | "30m" | "45m" | "60m"; name: string; packet_threshold?: number; prefixes?: string[] };
}

export const CreateRulesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  automatic_advertisement: Schema.optional(Schema.Boolean),
  bandwidth: Schema.optional(Schema.Number),
  duration: Schema.Literal("1m", "5m", "10m", "15m", "20m", "30m", "45m", "60m"),
  name: Schema.String,
  packet_threshold: Schema.optional(Schema.Number),
  prefixes: Schema.optional(Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/mnm/rules" }),
).annotations({ identifier: "CreateRulesRequest" }) as unknown as Schema.Schema<CreateRulesRequest>;

export interface CreateRulesResponse {
  result: { automatic_advertisement: boolean; bandwidth_threshold?: number; duration?: "1m" | "5m" | "10m" | "15m" | "20m" | "30m" | "45m" | "60m"; id?: string; name: string; packet_threshold?: number; prefix_match?: "exact" | "subnet" | "supernet"; prefixes: string[]; type: "threshold" | "zscore" | "advanced_ddos"; zscore_sensitivity?: "low" | "medium" | "high"; zscore_target?: "bits" | "packets" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateRulesResponse = Schema.Struct({
  result: Schema.Struct({
  automatic_advertisement: Schema.Boolean,
  bandwidth_threshold: Schema.optional(Schema.Number),
  duration: Schema.optional(Schema.Literal("1m", "5m", "10m", "15m", "20m", "30m", "45m", "60m")),
  id: Schema.optional(Schema.String),
  name: Schema.String,
  packet_threshold: Schema.optional(Schema.Number),
  prefix_match: Schema.optional(Schema.Literal("exact", "subnet", "supernet")),
  prefixes: Schema.Array(Schema.String),
  type: Schema.Literal("threshold", "zscore", "advanced_ddos"),
  zscore_sensitivity: Schema.optional(Schema.Literal("low", "medium", "high")),
  zscore_target: Schema.optional(Schema.Literal("bits", "packets"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateRulesResponse" }) as unknown as Schema.Schema<CreateRulesResponse>;

export const createRules: (
  input: CreateRulesRequest
) => Effect.Effect<
  CreateRulesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateRulesRequest,
  output: CreateRulesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateRulesRequest {
  account_id: string;
  body: { automatic_advertisement?: boolean; bandwidth?: number; duration: "1m" | "5m" | "10m" | "15m" | "20m" | "30m" | "45m" | "60m"; id?: string; name: string; packet_threshold?: number; prefixes?: string[] };
}

export const UpdateRulesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  automatic_advertisement: Schema.optional(Schema.Boolean),
  bandwidth: Schema.optional(Schema.Number),
  duration: Schema.Literal("1m", "5m", "10m", "15m", "20m", "30m", "45m", "60m"),
  id: Schema.optional(Schema.String),
  name: Schema.String,
  packet_threshold: Schema.optional(Schema.Number),
  prefixes: Schema.optional(Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/mnm/rules" }),
).annotations({ identifier: "UpdateRulesRequest" }) as unknown as Schema.Schema<UpdateRulesRequest>;

export interface UpdateRulesResponse {
  result: { automatic_advertisement: boolean; bandwidth_threshold?: number; duration?: "1m" | "5m" | "10m" | "15m" | "20m" | "30m" | "45m" | "60m"; id?: string; name: string; packet_threshold?: number; prefix_match?: "exact" | "subnet" | "supernet"; prefixes: string[]; type: "threshold" | "zscore" | "advanced_ddos"; zscore_sensitivity?: "low" | "medium" | "high"; zscore_target?: "bits" | "packets" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateRulesResponse = Schema.Struct({
  result: Schema.Struct({
  automatic_advertisement: Schema.Boolean,
  bandwidth_threshold: Schema.optional(Schema.Number),
  duration: Schema.optional(Schema.Literal("1m", "5m", "10m", "15m", "20m", "30m", "45m", "60m")),
  id: Schema.optional(Schema.String),
  name: Schema.String,
  packet_threshold: Schema.optional(Schema.Number),
  prefix_match: Schema.optional(Schema.Literal("exact", "subnet", "supernet")),
  prefixes: Schema.Array(Schema.String),
  type: Schema.Literal("threshold", "zscore", "advanced_ddos"),
  zscore_sensitivity: Schema.optional(Schema.Literal("low", "medium", "high")),
  zscore_target: Schema.optional(Schema.Literal("bits", "packets"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateRulesResponse" }) as unknown as Schema.Schema<UpdateRulesResponse>;

export const updateRules: (
  input: UpdateRulesRequest
) => Effect.Effect<
  UpdateRulesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateRulesRequest,
  output: UpdateRulesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetRule1Request {
  rule_id: string;
  account_id: string;
}

export const GetRule1Request = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/mnm/rules/{rule_id}" }),
).annotations({ identifier: "GetRule1Request" }) as unknown as Schema.Schema<GetRule1Request>;

export interface GetRule1Response {
  result: { automatic_advertisement: boolean; bandwidth_threshold?: number; duration?: "1m" | "5m" | "10m" | "15m" | "20m" | "30m" | "45m" | "60m"; id?: string; name: string; packet_threshold?: number; prefix_match?: "exact" | "subnet" | "supernet"; prefixes: string[]; type: "threshold" | "zscore" | "advanced_ddos"; zscore_sensitivity?: "low" | "medium" | "high"; zscore_target?: "bits" | "packets" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetRule1Response = Schema.Struct({
  result: Schema.Struct({
  automatic_advertisement: Schema.Boolean,
  bandwidth_threshold: Schema.optional(Schema.Number),
  duration: Schema.optional(Schema.Literal("1m", "5m", "10m", "15m", "20m", "30m", "45m", "60m")),
  id: Schema.optional(Schema.String),
  name: Schema.String,
  packet_threshold: Schema.optional(Schema.Number),
  prefix_match: Schema.optional(Schema.Literal("exact", "subnet", "supernet")),
  prefixes: Schema.Array(Schema.String),
  type: Schema.Literal("threshold", "zscore", "advanced_ddos"),
  zscore_sensitivity: Schema.optional(Schema.Literal("low", "medium", "high")),
  zscore_target: Schema.optional(Schema.Literal("bits", "packets"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetRule1Response" }) as unknown as Schema.Schema<GetRule1Response>;

export const getRule1: (
  input: GetRule1Request
) => Effect.Effect<
  GetRule1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRule1Request,
  output: GetRule1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteRule1Request {
  rule_id: string;
  account_id: string;
}

export const DeleteRule1Request = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/mnm/rules/{rule_id}" }),
).annotations({ identifier: "DeleteRule1Request" }) as unknown as Schema.Schema<DeleteRule1Request>;

export interface DeleteRule1Response {
  result: { automatic_advertisement: boolean; bandwidth_threshold?: number; duration?: "1m" | "5m" | "10m" | "15m" | "20m" | "30m" | "45m" | "60m"; id?: string; name: string; packet_threshold?: number; prefix_match?: "exact" | "subnet" | "supernet"; prefixes: string[]; type: "threshold" | "zscore" | "advanced_ddos"; zscore_sensitivity?: "low" | "medium" | "high"; zscore_target?: "bits" | "packets" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteRule1Response = Schema.Struct({
  result: Schema.Struct({
  automatic_advertisement: Schema.Boolean,
  bandwidth_threshold: Schema.optional(Schema.Number),
  duration: Schema.optional(Schema.Literal("1m", "5m", "10m", "15m", "20m", "30m", "45m", "60m")),
  id: Schema.optional(Schema.String),
  name: Schema.String,
  packet_threshold: Schema.optional(Schema.Number),
  prefix_match: Schema.optional(Schema.Literal("exact", "subnet", "supernet")),
  prefixes: Schema.Array(Schema.String),
  type: Schema.Literal("threshold", "zscore", "advanced_ddos"),
  zscore_sensitivity: Schema.optional(Schema.Literal("low", "medium", "high")),
  zscore_target: Schema.optional(Schema.Literal("bits", "packets"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteRule1Response" }) as unknown as Schema.Schema<DeleteRule1Response>;

export const deleteRule1: (
  input: DeleteRule1Request
) => Effect.Effect<
  DeleteRule1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteRule1Request,
  output: DeleteRule1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateRule1Request {
  rule_id: string;
  account_id: string;
  body: { automatic_advertisement?: boolean; bandwidth?: number; duration?: "1m" | "5m" | "10m" | "15m" | "20m" | "30m" | "45m" | "60m"; name?: string; packet_threshold?: number; prefixes?: string[] };
}

export const UpdateRule1Request = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  automatic_advertisement: Schema.optional(Schema.Boolean),
  bandwidth: Schema.optional(Schema.Number),
  duration: Schema.optional(Schema.Literal("1m", "5m", "10m", "15m", "20m", "30m", "45m", "60m")),
  name: Schema.optional(Schema.String),
  packet_threshold: Schema.optional(Schema.Number),
  prefixes: Schema.optional(Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/mnm/rules/{rule_id}" }),
).annotations({ identifier: "UpdateRule1Request" }) as unknown as Schema.Schema<UpdateRule1Request>;

export interface UpdateRule1Response {
  result: { automatic_advertisement: boolean; bandwidth_threshold?: number; duration?: "1m" | "5m" | "10m" | "15m" | "20m" | "30m" | "45m" | "60m"; id?: string; name: string; packet_threshold?: number; prefix_match?: "exact" | "subnet" | "supernet"; prefixes: string[]; type: "threshold" | "zscore" | "advanced_ddos"; zscore_sensitivity?: "low" | "medium" | "high"; zscore_target?: "bits" | "packets" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateRule1Response = Schema.Struct({
  result: Schema.Struct({
  automatic_advertisement: Schema.Boolean,
  bandwidth_threshold: Schema.optional(Schema.Number),
  duration: Schema.optional(Schema.Literal("1m", "5m", "10m", "15m", "20m", "30m", "45m", "60m")),
  id: Schema.optional(Schema.String),
  name: Schema.String,
  packet_threshold: Schema.optional(Schema.Number),
  prefix_match: Schema.optional(Schema.Literal("exact", "subnet", "supernet")),
  prefixes: Schema.Array(Schema.String),
  type: Schema.Literal("threshold", "zscore", "advanced_ddos"),
  zscore_sensitivity: Schema.optional(Schema.Literal("low", "medium", "high")),
  zscore_target: Schema.optional(Schema.Literal("bits", "packets"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateRule1Response" }) as unknown as Schema.Schema<UpdateRule1Response>;

export const updateRule1: (
  input: UpdateRule1Request
) => Effect.Effect<
  UpdateRule1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateRule1Request,
  output: UpdateRule1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAdvertisementForRuleRequest {
  rule_id: string;
  account_id: string;
}

export const UpdateAdvertisementForRuleRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/mnm/rules/{rule_id}/advertisement" }),
).annotations({ identifier: "UpdateAdvertisementForRuleRequest" }) as unknown as Schema.Schema<UpdateAdvertisementForRuleRequest>;

export interface UpdateAdvertisementForRuleResponse {
  result: { automatic_advertisement: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAdvertisementForRuleResponse = Schema.Struct({
  result: Schema.Struct({
  automatic_advertisement: Schema.Boolean
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAdvertisementForRuleResponse" }) as unknown as Schema.Schema<UpdateAdvertisementForRuleResponse>;

export const updateAdvertisementForRule: (
  input: UpdateAdvertisementForRuleRequest
) => Effect.Effect<
  UpdateAdvertisementForRuleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAdvertisementForRuleRequest,
  output: UpdateAdvertisementForRuleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MagicNetworkMonitoringVpcFlowsGenerateAuthenticationTokenRequest {
  account_id: string;
}

export const MagicNetworkMonitoringVpcFlowsGenerateAuthenticationTokenRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/mnm/vpc-flows/token" }),
).annotations({ identifier: "MagicNetworkMonitoringVpcFlowsGenerateAuthenticationTokenRequest" }) as unknown as Schema.Schema<MagicNetworkMonitoringVpcFlowsGenerateAuthenticationTokenRequest>;

export interface MagicNetworkMonitoringVpcFlowsGenerateAuthenticationTokenResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MagicNetworkMonitoringVpcFlowsGenerateAuthenticationTokenResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MagicNetworkMonitoringVpcFlowsGenerateAuthenticationTokenResponse" }) as unknown as Schema.Schema<MagicNetworkMonitoringVpcFlowsGenerateAuthenticationTokenResponse>;

export const magicNetworkMonitoringVpcFlowsGenerateAuthenticationToken: (
  input: MagicNetworkMonitoringVpcFlowsGenerateAuthenticationTokenRequest
) => Effect.Effect<
  MagicNetworkMonitoringVpcFlowsGenerateAuthenticationTokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MagicNetworkMonitoringVpcFlowsGenerateAuthenticationTokenRequest,
  output: MagicNetworkMonitoringVpcFlowsGenerateAuthenticationTokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountsMoveaccountsRequest {
  account_id: string;
  body: { destination_organization_id: string };
}

export const AccountsMoveaccountsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  destination_organization_id: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/move" }),
).annotations({ identifier: "AccountsMoveaccountsRequest" }) as unknown as Schema.Schema<AccountsMoveaccountsRequest>;

export interface AccountsMoveaccountsResponse {
  result: { account_id: string; destination_organization_id: string; source_organization_id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountsMoveaccountsResponse = Schema.Struct({
  result: Schema.Struct({
  account_id: Schema.String,
  destination_organization_id: Schema.String,
  source_organization_id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountsMoveaccountsResponse" }) as unknown as Schema.Schema<AccountsMoveaccountsResponse>;

export const accountsMoveaccounts: (
  input: AccountsMoveaccountsRequest
) => Effect.Effect<
  AccountsMoveaccountsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountsMoveaccountsRequest,
  output: AccountsMoveaccountsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListMTlsCertificatesRequest {
  account_id: string;
}

export const ListMTlsCertificatesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/mtls_certificates" }),
).annotations({ identifier: "ListMTlsCertificatesRequest" }) as unknown as Schema.Schema<ListMTlsCertificatesRequest>;

export interface ListMTlsCertificatesResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListMTlsCertificatesResponse = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListMTlsCertificatesResponse" }) as unknown as Schema.Schema<ListMTlsCertificatesResponse>;

export const listMTlsCertificates: (
  input: ListMTlsCertificatesRequest
) => Effect.Effect<
  ListMTlsCertificatesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListMTlsCertificatesRequest,
  output: ListMTlsCertificatesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MTlsCertificateManagementUploadMTlsCertificateRequest {
  account_id: string;
  body: { ca: boolean; certificates: string; name?: string; private_key?: string };
}

export const MTlsCertificateManagementUploadMTlsCertificateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  ca: Schema.Boolean,
  certificates: Schema.String,
  name: Schema.optional(Schema.String),
  private_key: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/mtls_certificates" }),
).annotations({ identifier: "MTlsCertificateManagementUploadMTlsCertificateRequest" }) as unknown as Schema.Schema<MTlsCertificateManagementUploadMTlsCertificateRequest>;

export interface MTlsCertificateManagementUploadMTlsCertificateResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MTlsCertificateManagementUploadMTlsCertificateResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MTlsCertificateManagementUploadMTlsCertificateResponse" }) as unknown as Schema.Schema<MTlsCertificateManagementUploadMTlsCertificateResponse>;

export const mTlsCertificateManagementUploadMTlsCertificate: (
  input: MTlsCertificateManagementUploadMTlsCertificateRequest
) => Effect.Effect<
  MTlsCertificateManagementUploadMTlsCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MTlsCertificateManagementUploadMTlsCertificateRequest,
  output: MTlsCertificateManagementUploadMTlsCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetMTlsCertificateRequest {
  mtls_certificate_id: string;
  account_id: string;
}

export const GetMTlsCertificateRequest = Schema.Struct({
  mtls_certificate_id: Schema.String.pipe(T.HttpPath("mtls_certificate_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/mtls_certificates/{mtls_certificate_id}" }),
).annotations({ identifier: "GetMTlsCertificateRequest" }) as unknown as Schema.Schema<GetMTlsCertificateRequest>;

export interface GetMTlsCertificateResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetMTlsCertificateResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetMTlsCertificateResponse" }) as unknown as Schema.Schema<GetMTlsCertificateResponse>;

export const getMTlsCertificate: (
  input: GetMTlsCertificateRequest
) => Effect.Effect<
  GetMTlsCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetMTlsCertificateRequest,
  output: GetMTlsCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteMTlsCertificateRequest {
  mtls_certificate_id: string;
  account_id: string;
}

export const DeleteMTlsCertificateRequest = Schema.Struct({
  mtls_certificate_id: Schema.String.pipe(T.HttpPath("mtls_certificate_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/mtls_certificates/{mtls_certificate_id}" }),
).annotations({ identifier: "DeleteMTlsCertificateRequest" }) as unknown as Schema.Schema<DeleteMTlsCertificateRequest>;

export interface DeleteMTlsCertificateResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteMTlsCertificateResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteMTlsCertificateResponse" }) as unknown as Schema.Schema<DeleteMTlsCertificateResponse>;

export const deleteMTlsCertificate: (
  input: DeleteMTlsCertificateRequest
) => Effect.Effect<
  DeleteMTlsCertificateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteMTlsCertificateRequest,
  output: DeleteMTlsCertificateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListMTlsCertificateAssociationsRequest {
  mtls_certificate_id: string;
  account_id: string;
}

export const ListMTlsCertificateAssociationsRequest = Schema.Struct({
  mtls_certificate_id: Schema.String.pipe(T.HttpPath("mtls_certificate_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/mtls_certificates/{mtls_certificate_id}/associations" }),
).annotations({ identifier: "ListMTlsCertificateAssociationsRequest" }) as unknown as Schema.Schema<ListMTlsCertificateAssociationsRequest>;

export interface ListMTlsCertificateAssociationsResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListMTlsCertificateAssociationsResponse = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListMTlsCertificateAssociationsResponse" }) as unknown as Schema.Schema<ListMTlsCertificateAssociationsResponse>;

export const listMTlsCertificateAssociations: (
  input: ListMTlsCertificateAssociationsRequest
) => Effect.Effect<
  ListMTlsCertificateAssociationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListMTlsCertificateAssociationsRequest,
  output: ListMTlsCertificateAssociationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountsListaccountorganizationsRequest {
  account_id: string;
}

export const AccountsListaccountorganizationsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/organizations" }),
).annotations({ identifier: "AccountsListaccountorganizationsRequest" }) as unknown as Schema.Schema<AccountsListaccountorganizationsRequest>;

export interface AccountsListaccountorganizationsResponse {
  result: { create_time: string; id: unknown; meta: { flags?: unknown; managed_by?: string }; name: string; parent?: { id: string; name: string }; profile?: { business_address: string; business_email: string; business_name: string; business_phone: string; external_metadata: string } }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountsListaccountorganizationsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  create_time: Schema.Date,
  id: Schema.String,
  meta: Schema.Struct({
  flags: Schema.optional(Schema.Struct({
  account_creation: Schema.String,
  account_deletion: Schema.String,
  account_migration: Schema.String,
  account_mobility: Schema.String,
  sub_org_creation: Schema.String
})),
  managed_by: Schema.optional(Schema.String)
}),
  name: Schema.String,
  parent: Schema.optional(Schema.Struct({
  id: Schema.String,
  name: Schema.String
})),
  profile: Schema.optional(Schema.Struct({
  business_address: Schema.String,
  business_email: Schema.String,
  business_name: Schema.String,
  business_phone: Schema.String,
  external_metadata: Schema.String
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountsListaccountorganizationsResponse" }) as unknown as Schema.Schema<AccountsListaccountorganizationsResponse>;

export const accountsListaccountorganizations: (
  input: AccountsListaccountorganizationsRequest
) => Effect.Effect<
  AccountsListaccountorganizationsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountsListaccountorganizationsRequest,
  output: AccountsListaccountorganizationsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PayPerCrawlcrawlergetstripeconfigRequest {
  account_id: string;
}

export const PayPerCrawlcrawlergetstripeconfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/pay-per-crawl/crawler/stripe" }),
).annotations({ identifier: "PayPerCrawlcrawlergetstripeconfigRequest" }) as unknown as Schema.Schema<PayPerCrawlcrawlergetstripeconfigRequest>;

export interface PayPerCrawlcrawlergetstripeconfigResponse {
  result: { connect_status?: string; stripe_account_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PayPerCrawlcrawlergetstripeconfigResponse = Schema.Struct({
  result: Schema.Struct({
  connect_status: Schema.optional(Schema.String),
  stripe_account_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PayPerCrawlcrawlergetstripeconfigResponse" }) as unknown as Schema.Schema<PayPerCrawlcrawlergetstripeconfigResponse>;

export const payPerCrawlcrawlergetstripeconfig: (
  input: PayPerCrawlcrawlergetstripeconfigRequest
) => Effect.Effect<
  PayPerCrawlcrawlergetstripeconfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PayPerCrawlcrawlergetstripeconfigRequest,
  output: PayPerCrawlcrawlergetstripeconfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PayPerCrawlcrawlercreatestripeconfigRequest {
  account_id: string;
}

export const PayPerCrawlcrawlercreatestripeconfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/pay-per-crawl/crawler/stripe" }),
).annotations({ identifier: "PayPerCrawlcrawlercreatestripeconfigRequest" }) as unknown as Schema.Schema<PayPerCrawlcrawlercreatestripeconfigRequest>;

export interface PayPerCrawlcrawlercreatestripeconfigResponse {
  result: { url?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PayPerCrawlcrawlercreatestripeconfigResponse = Schema.Struct({
  result: Schema.Struct({
  url: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PayPerCrawlcrawlercreatestripeconfigResponse" }) as unknown as Schema.Schema<PayPerCrawlcrawlercreatestripeconfigResponse>;

export const payPerCrawlcrawlercreatestripeconfig: (
  input: PayPerCrawlcrawlercreatestripeconfigRequest
) => Effect.Effect<
  PayPerCrawlcrawlercreatestripeconfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PayPerCrawlcrawlercreatestripeconfigRequest,
  output: PayPerCrawlcrawlercreatestripeconfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PayPerCrawlcrawlerdeletestripeconfigRequest {
  account_id: string;
}

export const PayPerCrawlcrawlerdeletestripeconfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/pay-per-crawl/crawler/stripe" }),
).annotations({ identifier: "PayPerCrawlcrawlerdeletestripeconfigRequest" }) as unknown as Schema.Schema<PayPerCrawlcrawlerdeletestripeconfigRequest>;

export interface PayPerCrawlcrawlerdeletestripeconfigResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PayPerCrawlcrawlerdeletestripeconfigResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PayPerCrawlcrawlerdeletestripeconfigResponse" }) as unknown as Schema.Schema<PayPerCrawlcrawlerdeletestripeconfigResponse>;

export const payPerCrawlcrawlerdeletestripeconfig: (
  input: PayPerCrawlcrawlerdeletestripeconfigRequest
) => Effect.Effect<
  PayPerCrawlcrawlerdeletestripeconfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PayPerCrawlcrawlerdeletestripeconfigRequest,
  output: PayPerCrawlcrawlerdeletestripeconfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PayPerCrawlpublishergetstripeconfigRequest {
  account_id: string;
}

export const PayPerCrawlpublishergetstripeconfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/pay-per-crawl/publisher/stripe" }),
).annotations({ identifier: "PayPerCrawlpublishergetstripeconfigRequest" }) as unknown as Schema.Schema<PayPerCrawlpublishergetstripeconfigRequest>;

export interface PayPerCrawlpublishergetstripeconfigResponse {
  result: { connect_status?: string; stripe_account_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PayPerCrawlpublishergetstripeconfigResponse = Schema.Struct({
  result: Schema.Struct({
  connect_status: Schema.optional(Schema.String),
  stripe_account_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PayPerCrawlpublishergetstripeconfigResponse" }) as unknown as Schema.Schema<PayPerCrawlpublishergetstripeconfigResponse>;

export const payPerCrawlpublishergetstripeconfig: (
  input: PayPerCrawlpublishergetstripeconfigRequest
) => Effect.Effect<
  PayPerCrawlpublishergetstripeconfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PayPerCrawlpublishergetstripeconfigRequest,
  output: PayPerCrawlpublishergetstripeconfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PayPerCrawlpublishercreatestripeconfigRequest {
  account_id: string;
}

export const PayPerCrawlpublishercreatestripeconfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/pay-per-crawl/publisher/stripe" }),
).annotations({ identifier: "PayPerCrawlpublishercreatestripeconfigRequest" }) as unknown as Schema.Schema<PayPerCrawlpublishercreatestripeconfigRequest>;

export interface PayPerCrawlpublishercreatestripeconfigResponse {
  result: { url?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PayPerCrawlpublishercreatestripeconfigResponse = Schema.Struct({
  result: Schema.Struct({
  url: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PayPerCrawlpublishercreatestripeconfigResponse" }) as unknown as Schema.Schema<PayPerCrawlpublishercreatestripeconfigResponse>;

export const payPerCrawlpublishercreatestripeconfig: (
  input: PayPerCrawlpublishercreatestripeconfigRequest
) => Effect.Effect<
  PayPerCrawlpublishercreatestripeconfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PayPerCrawlpublishercreatestripeconfigRequest,
  output: PayPerCrawlpublishercreatestripeconfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PayPerCrawlpublisherdeletestripeconfigRequest {
  account_id: string;
}

export const PayPerCrawlpublisherdeletestripeconfigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/pay-per-crawl/publisher/stripe" }),
).annotations({ identifier: "PayPerCrawlpublisherdeletestripeconfigRequest" }) as unknown as Schema.Schema<PayPerCrawlpublisherdeletestripeconfigRequest>;

export interface PayPerCrawlpublisherdeletestripeconfigResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PayPerCrawlpublisherdeletestripeconfigResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PayPerCrawlpublisherdeletestripeconfigResponse" }) as unknown as Schema.Schema<PayPerCrawlpublisherdeletestripeconfigResponse>;

export const payPerCrawlpublisherdeletestripeconfig: (
  input: PayPerCrawlpublisherdeletestripeconfigRequest
) => Effect.Effect<
  PayPerCrawlpublisherdeletestripeconfigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PayPerCrawlpublisherdeletestripeconfigRequest,
  output: PayPerCrawlpublisherdeletestripeconfigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PayPerCrawlsetzonescanbeenabledRequest {
  account_id: string;
  body: { zones?: { can_be_enabled?: boolean; id?: string }[] };
}

export const PayPerCrawlsetzonescanbeenabledRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  zones: Schema.optional(Schema.Array(Schema.Struct({
  can_be_enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String)
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/pay-per-crawl/zones_can_be_enabled" }),
).annotations({ identifier: "PayPerCrawlsetzonescanbeenabledRequest" }) as unknown as Schema.Schema<PayPerCrawlsetzonescanbeenabledRequest>;

export interface PayPerCrawlsetzonescanbeenabledResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PayPerCrawlsetzonescanbeenabledResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PayPerCrawlsetzonescanbeenabledResponse" }) as unknown as Schema.Schema<PayPerCrawlsetzonescanbeenabledResponse>;

export const payPerCrawlsetzonescanbeenabled: (
  input: PayPerCrawlsetzonescanbeenabledRequest
) => Effect.Effect<
  PayPerCrawlsetzonescanbeenabledResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PayPerCrawlsetzonescanbeenabledRequest,
  output: PayPerCrawlsetzonescanbeenabledResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PayPerCrawlqueryzonescanbeenabledRequest {
  account_id: string;
  body: { zones?: { can_be_enabled?: boolean; id?: string }[] };
}

export const PayPerCrawlqueryzonescanbeenabledRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  zones: Schema.optional(Schema.Array(Schema.Struct({
  can_be_enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String)
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/pay-per-crawl/zones_can_be_enabled/query" }),
).annotations({ identifier: "PayPerCrawlqueryzonescanbeenabledRequest" }) as unknown as Schema.Schema<PayPerCrawlqueryzonescanbeenabledRequest>;

export interface PayPerCrawlqueryzonescanbeenabledResponse {
  result: { zones?: { can_be_enabled?: boolean; id?: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PayPerCrawlqueryzonescanbeenabledResponse = Schema.Struct({
  result: Schema.Struct({
  zones: Schema.optional(Schema.Array(Schema.Struct({
  can_be_enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String)
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PayPerCrawlqueryzonescanbeenabledResponse" }) as unknown as Schema.Schema<PayPerCrawlqueryzonescanbeenabledResponse>;

export const payPerCrawlqueryzonescanbeenabled: (
  input: PayPerCrawlqueryzonescanbeenabledRequest
) => Effect.Effect<
  PayPerCrawlqueryzonescanbeenabledResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PayPerCrawlqueryzonescanbeenabledRequest,
  output: PayPerCrawlqueryzonescanbeenabledResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListPacketCaptureRequestsRequest {
  account_id: string;
}

export const ListPacketCaptureRequestsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/pcaps" }),
).annotations({ identifier: "ListPacketCaptureRequestsRequest" }) as unknown as Schema.Schema<ListPacketCaptureRequestsRequest>;

export interface ListPacketCaptureRequestsResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListPacketCaptureRequestsResponse = Schema.Struct({
  result: Schema.Array(Schema.Union(Schema.Struct({
  filter_v1: Schema.optional(Schema.Struct({
  destination_address: Schema.optional(Schema.String),
  destination_port: Schema.optional(Schema.Number),
  protocol: Schema.optional(Schema.Number),
  source_address: Schema.optional(Schema.String),
  source_port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  offset_time: Schema.optional(Schema.Date),
  status: Schema.optional(Schema.Literal("unknown", "success", "pending", "running", "conversion_pending", "conversion_running", "complete", "failed")),
  submitted: Schema.optional(Schema.String),
  system: Schema.optional(Schema.Literal("magic-transit")),
  time_limit: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("simple", "full"))
}), Schema.Struct({
  byte_limit: Schema.optional(Schema.Number),
  colo_name: Schema.optional(Schema.String),
  destination_conf: Schema.optional(Schema.String),
  error_message: Schema.optional(Schema.String),
  filter_v1: Schema.optional(Schema.Struct({
  destination_address: Schema.optional(Schema.String),
  destination_port: Schema.optional(Schema.Number),
  protocol: Schema.optional(Schema.Number),
  source_address: Schema.optional(Schema.String),
  source_port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  packets_captured: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("unknown", "success", "pending", "running", "conversion_pending", "conversion_running", "complete", "failed")),
  stop_requested: Schema.optional(Schema.Date),
  submitted: Schema.optional(Schema.String),
  system: Schema.optional(Schema.Literal("magic-transit")),
  time_limit: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("simple", "full"))
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListPacketCaptureRequestsResponse" }) as unknown as Schema.Schema<ListPacketCaptureRequestsResponse>;

export const listPacketCaptureRequests: (
  input: ListPacketCaptureRequestsRequest
) => Effect.Effect<
  ListPacketCaptureRequestsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListPacketCaptureRequestsRequest,
  output: ListPacketCaptureRequestsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatePcapRequestRequest {
  account_id: string;
  body: unknown;
}

export const CreatePcapRequestRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Union(Schema.Struct({
  filter_v1: Schema.optional(Schema.Struct({
  destination_address: Schema.optional(Schema.String),
  destination_port: Schema.optional(Schema.Number),
  protocol: Schema.optional(Schema.Number),
  source_address: Schema.optional(Schema.String),
  source_port: Schema.optional(Schema.Number)
})),
  offset_time: Schema.optional(Schema.Date),
  packet_limit: Schema.Number,
  system: Schema.Literal("magic-transit"),
  time_limit: Schema.Number,
  type: Schema.Literal("simple", "full")
}), Schema.Struct({
  byte_limit: Schema.optional(Schema.Number),
  colo_name: Schema.String,
  destination_conf: Schema.String,
  filter_v1: Schema.optional(Schema.Struct({
  destination_address: Schema.optional(Schema.String),
  destination_port: Schema.optional(Schema.Number),
  protocol: Schema.optional(Schema.Number),
  source_address: Schema.optional(Schema.String),
  source_port: Schema.optional(Schema.Number)
})),
  packet_limit: Schema.optional(Schema.Number),
  system: Schema.Literal("magic-transit"),
  time_limit: Schema.Number,
  type: Schema.Literal("simple", "full")
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/pcaps" }),
).annotations({ identifier: "CreatePcapRequestRequest" }) as unknown as Schema.Schema<CreatePcapRequestRequest>;

export interface CreatePcapRequestResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatePcapRequestResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  filter_v1: Schema.optional(Schema.Struct({
  destination_address: Schema.optional(Schema.String),
  destination_port: Schema.optional(Schema.Number),
  protocol: Schema.optional(Schema.Number),
  source_address: Schema.optional(Schema.String),
  source_port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  offset_time: Schema.optional(Schema.Date),
  status: Schema.optional(Schema.Literal("unknown", "success", "pending", "running", "conversion_pending", "conversion_running", "complete", "failed")),
  submitted: Schema.optional(Schema.String),
  system: Schema.optional(Schema.Literal("magic-transit")),
  time_limit: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("simple", "full"))
}), Schema.Struct({
  byte_limit: Schema.optional(Schema.Number),
  colo_name: Schema.optional(Schema.String),
  destination_conf: Schema.optional(Schema.String),
  error_message: Schema.optional(Schema.String),
  filter_v1: Schema.optional(Schema.Struct({
  destination_address: Schema.optional(Schema.String),
  destination_port: Schema.optional(Schema.Number),
  protocol: Schema.optional(Schema.Number),
  source_address: Schema.optional(Schema.String),
  source_port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  packets_captured: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("unknown", "success", "pending", "running", "conversion_pending", "conversion_running", "complete", "failed")),
  stop_requested: Schema.optional(Schema.Date),
  submitted: Schema.optional(Schema.String),
  system: Schema.optional(Schema.Literal("magic-transit")),
  time_limit: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("simple", "full"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatePcapRequestResponse" }) as unknown as Schema.Schema<CreatePcapRequestResponse>;

export const createPcapRequest: (
  input: CreatePcapRequestRequest
) => Effect.Effect<
  CreatePcapRequestResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatePcapRequestRequest,
  output: CreatePcapRequestResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListPcaPsBucketOwnershipRequest {
  account_id: string;
}

export const ListPcaPsBucketOwnershipRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/pcaps/ownership" }),
).annotations({ identifier: "ListPcaPsBucketOwnershipRequest" }) as unknown as Schema.Schema<ListPcaPsBucketOwnershipRequest>;

export interface ListPcaPsBucketOwnershipResponse {
  result: { destination_conf: string; filename: string; id: string; status: "pending" | "success" | "failed"; submitted: string; validated?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListPcaPsBucketOwnershipResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  destination_conf: Schema.String,
  filename: Schema.String,
  id: Schema.String,
  status: Schema.Literal("pending", "success", "failed"),
  submitted: Schema.String,
  validated: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListPcaPsBucketOwnershipResponse" }) as unknown as Schema.Schema<ListPcaPsBucketOwnershipResponse>;

export const listPcaPsBucketOwnership: (
  input: ListPcaPsBucketOwnershipRequest
) => Effect.Effect<
  ListPcaPsBucketOwnershipResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListPcaPsBucketOwnershipRequest,
  output: ListPcaPsBucketOwnershipResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MagicPcapCollectionAddBucketsForFullPacketCapturesRequest {
  account_id: string;
  body: { destination_conf: string };
}

export const MagicPcapCollectionAddBucketsForFullPacketCapturesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  destination_conf: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/pcaps/ownership" }),
).annotations({ identifier: "MagicPcapCollectionAddBucketsForFullPacketCapturesRequest" }) as unknown as Schema.Schema<MagicPcapCollectionAddBucketsForFullPacketCapturesRequest>;

export interface MagicPcapCollectionAddBucketsForFullPacketCapturesResponse {
  result: { destination_conf: string; filename: string; id: string; status: "pending" | "success" | "failed"; submitted: string; validated?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MagicPcapCollectionAddBucketsForFullPacketCapturesResponse = Schema.Struct({
  result: Schema.Struct({
  destination_conf: Schema.String,
  filename: Schema.String,
  id: Schema.String,
  status: Schema.Literal("pending", "success", "failed"),
  submitted: Schema.String,
  validated: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MagicPcapCollectionAddBucketsForFullPacketCapturesResponse" }) as unknown as Schema.Schema<MagicPcapCollectionAddBucketsForFullPacketCapturesResponse>;

export const magicPcapCollectionAddBucketsForFullPacketCaptures: (
  input: MagicPcapCollectionAddBucketsForFullPacketCapturesRequest
) => Effect.Effect<
  MagicPcapCollectionAddBucketsForFullPacketCapturesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MagicPcapCollectionAddBucketsForFullPacketCapturesRequest,
  output: MagicPcapCollectionAddBucketsForFullPacketCapturesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MagicPcapCollectionValidateBucketsForFullPacketCapturesRequest {
  account_id: string;
  body: { destination_conf: string; ownership_challenge: string };
}

export const MagicPcapCollectionValidateBucketsForFullPacketCapturesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  destination_conf: Schema.String,
  ownership_challenge: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/pcaps/ownership/validate" }),
).annotations({ identifier: "MagicPcapCollectionValidateBucketsForFullPacketCapturesRequest" }) as unknown as Schema.Schema<MagicPcapCollectionValidateBucketsForFullPacketCapturesRequest>;

export interface MagicPcapCollectionValidateBucketsForFullPacketCapturesResponse {
  result: { destination_conf: string; filename: string; id: string; status: "pending" | "success" | "failed"; submitted: string; validated?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MagicPcapCollectionValidateBucketsForFullPacketCapturesResponse = Schema.Struct({
  result: Schema.Struct({
  destination_conf: Schema.String,
  filename: Schema.String,
  id: Schema.String,
  status: Schema.Literal("pending", "success", "failed"),
  submitted: Schema.String,
  validated: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MagicPcapCollectionValidateBucketsForFullPacketCapturesResponse" }) as unknown as Schema.Schema<MagicPcapCollectionValidateBucketsForFullPacketCapturesResponse>;

export const magicPcapCollectionValidateBucketsForFullPacketCaptures: (
  input: MagicPcapCollectionValidateBucketsForFullPacketCapturesRequest
) => Effect.Effect<
  MagicPcapCollectionValidateBucketsForFullPacketCapturesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MagicPcapCollectionValidateBucketsForFullPacketCapturesRequest,
  output: MagicPcapCollectionValidateBucketsForFullPacketCapturesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteBucketsForFullPacketCapturesRequest {
  ownership_id: string;
  account_id: string;
}

export const DeleteBucketsForFullPacketCapturesRequest = Schema.Struct({
  ownership_id: Schema.String.pipe(T.HttpPath("ownership_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/pcaps/ownership/{ownership_id}" }),
).annotations({ identifier: "DeleteBucketsForFullPacketCapturesRequest" }) as unknown as Schema.Schema<DeleteBucketsForFullPacketCapturesRequest>;

export interface DeleteBucketsForFullPacketCapturesResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteBucketsForFullPacketCapturesResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteBucketsForFullPacketCapturesResponse" }) as unknown as Schema.Schema<DeleteBucketsForFullPacketCapturesResponse>;

export const deleteBucketsForFullPacketCaptures: (
  input: DeleteBucketsForFullPacketCapturesRequest
) => Effect.Effect<
  DeleteBucketsForFullPacketCapturesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteBucketsForFullPacketCapturesRequest,
  output: DeleteBucketsForFullPacketCapturesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetPcapRequestRequest {
  pcap_id: string;
  account_id: string;
}

export const GetPcapRequestRequest = Schema.Struct({
  pcap_id: Schema.String.pipe(T.HttpPath("pcap_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/pcaps/{pcap_id}" }),
).annotations({ identifier: "GetPcapRequestRequest" }) as unknown as Schema.Schema<GetPcapRequestRequest>;

export interface GetPcapRequestResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetPcapRequestResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  filter_v1: Schema.optional(Schema.Struct({
  destination_address: Schema.optional(Schema.String),
  destination_port: Schema.optional(Schema.Number),
  protocol: Schema.optional(Schema.Number),
  source_address: Schema.optional(Schema.String),
  source_port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  offset_time: Schema.optional(Schema.Date),
  status: Schema.optional(Schema.Literal("unknown", "success", "pending", "running", "conversion_pending", "conversion_running", "complete", "failed")),
  submitted: Schema.optional(Schema.String),
  system: Schema.optional(Schema.Literal("magic-transit")),
  time_limit: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("simple", "full"))
}), Schema.Struct({
  byte_limit: Schema.optional(Schema.Number),
  colo_name: Schema.optional(Schema.String),
  destination_conf: Schema.optional(Schema.String),
  error_message: Schema.optional(Schema.String),
  filter_v1: Schema.optional(Schema.Struct({
  destination_address: Schema.optional(Schema.String),
  destination_port: Schema.optional(Schema.Number),
  protocol: Schema.optional(Schema.Number),
  source_address: Schema.optional(Schema.String),
  source_port: Schema.optional(Schema.Number)
})),
  id: Schema.optional(Schema.String),
  packets_captured: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("unknown", "success", "pending", "running", "conversion_pending", "conversion_running", "complete", "failed")),
  stop_requested: Schema.optional(Schema.Date),
  submitted: Schema.optional(Schema.String),
  system: Schema.optional(Schema.Literal("magic-transit")),
  time_limit: Schema.optional(Schema.Number),
  type: Schema.optional(Schema.Literal("simple", "full"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetPcapRequestResponse" }) as unknown as Schema.Schema<GetPcapRequestResponse>;

export const getPcapRequest: (
  input: GetPcapRequestRequest
) => Effect.Effect<
  GetPcapRequestResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetPcapRequestRequest,
  output: GetPcapRequestResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MagicPcapCollectionDownloadSimplePcapRequest {
  pcap_id: string;
  account_id: string;
}

export const MagicPcapCollectionDownloadSimplePcapRequest = Schema.Struct({
  pcap_id: Schema.String.pipe(T.HttpPath("pcap_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/pcaps/{pcap_id}/download" }),
).annotations({ identifier: "MagicPcapCollectionDownloadSimplePcapRequest" }) as unknown as Schema.Schema<MagicPcapCollectionDownloadSimplePcapRequest>;

export interface MagicPcapCollectionDownloadSimplePcapResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MagicPcapCollectionDownloadSimplePcapResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MagicPcapCollectionDownloadSimplePcapResponse" }) as unknown as Schema.Schema<MagicPcapCollectionDownloadSimplePcapResponse>;

export const magicPcapCollectionDownloadSimplePcap: (
  input: MagicPcapCollectionDownloadSimplePcapRequest
) => Effect.Effect<
  MagicPcapCollectionDownloadSimplePcapResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MagicPcapCollectionDownloadSimplePcapRequest,
  output: MagicPcapCollectionDownloadSimplePcapResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MagicPcapCollectionStopFullPcapRequest {
  pcap_id: string;
  account_id: string;
}

export const MagicPcapCollectionStopFullPcapRequest = Schema.Struct({
  pcap_id: Schema.String.pipe(T.HttpPath("pcap_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/pcaps/{pcap_id}/stop" }),
).annotations({ identifier: "MagicPcapCollectionStopFullPcapRequest" }) as unknown as Schema.Schema<MagicPcapCollectionStopFullPcapRequest>;

export interface MagicPcapCollectionStopFullPcapResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MagicPcapCollectionStopFullPcapResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MagicPcapCollectionStopFullPcapResponse" }) as unknown as Schema.Schema<MagicPcapCollectionStopFullPcapResponse>;

export const magicPcapCollectionStopFullPcap: (
  input: MagicPcapCollectionStopFullPcapRequest
) => Effect.Effect<
  MagicPcapCollectionStopFullPcapResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MagicPcapCollectionStopFullPcapRequest,
  output: MagicPcapCollectionStopFullPcapResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Getv4accountsbyaccountIdpipelinesDeprecatedRequest {
  account_id: string;
  search?: string;
  page?: string;
  per_page?: string;
}

export const Getv4accountsbyaccountIdpipelinesDeprecatedRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
  page: Schema.optional(Schema.String).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.String).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/pipelines" }),
).annotations({ identifier: "Getv4accountsbyaccountIdpipelinesDeprecatedRequest" }) as unknown as Schema.Schema<Getv4accountsbyaccountIdpipelinesDeprecatedRequest>;

export interface Getv4accountsbyaccountIdpipelinesDeprecatedResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Getv4accountsbyaccountIdpipelinesDeprecatedResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Getv4accountsbyaccountIdpipelinesDeprecatedResponse" }) as unknown as Schema.Schema<Getv4accountsbyaccountIdpipelinesDeprecatedResponse>;

export const getv4accountsbyaccountIdpipelinesDeprecated: (
  input: Getv4accountsbyaccountIdpipelinesDeprecatedRequest
) => Effect.Effect<
  Getv4accountsbyaccountIdpipelinesDeprecatedResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Getv4accountsbyaccountIdpipelinesDeprecatedRequest,
  output: Getv4accountsbyaccountIdpipelinesDeprecatedResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Postv4accountsbyaccountIdpipelinesDeprecatedRequest {
  account_id: string;
  body: { destination: { batch: { max_bytes?: number; max_duration_s?: number; max_rows?: number }; compression: { type?: "none" | "gzip" | "deflate" }; credentials: { access_key_id: string; endpoint: string; secret_access_key: string }; format: "json"; path: { bucket: string; filename?: unknown; filepath?: string; prefix?: string }; type: "r2" }; name: string; source: unknown[] };
}

export const Postv4accountsbyaccountIdpipelinesDeprecatedRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  destination: Schema.Struct({
  batch: Schema.Struct({
  max_bytes: Schema.optional(Schema.Number),
  max_duration_s: Schema.optional(Schema.Number),
  max_rows: Schema.optional(Schema.Number)
}),
  compression: Schema.Struct({
  type: Schema.optional(Schema.Literal("none", "gzip", "deflate"))
}),
  credentials: Schema.Struct({
  access_key_id: Schema.String,
  endpoint: Schema.String,
  secret_access_key: Schema.String
}),
  format: Schema.Literal("json"),
  path: Schema.Struct({
  bucket: Schema.String,
  filename: Schema.optional(Schema.String),
  filepath: Schema.optional(Schema.String),
  prefix: Schema.optional(Schema.String)
}),
  type: Schema.Literal("r2")
}),
  name: Schema.String,
  source: Schema.Array(Schema.Union(Schema.Struct({
  authentication: Schema.optional(Schema.Boolean),
  cors: Schema.optional(Schema.Struct({
  origins: Schema.optional(Schema.Array(Schema.String))
})),
  format: Schema.Literal("json"),
  type: Schema.String
}), Schema.Struct({
  format: Schema.Literal("json"),
  type: Schema.String
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/pipelines" }),
).annotations({ identifier: "Postv4accountsbyaccountIdpipelinesDeprecatedRequest" }) as unknown as Schema.Schema<Postv4accountsbyaccountIdpipelinesDeprecatedRequest>;

export interface Postv4accountsbyaccountIdpipelinesDeprecatedResponse {
  result: { destination: { batch: { max_bytes: number; max_duration_s: number; max_rows: number }; compression: { type: "none" | "gzip" | "deflate" }; format: "json"; path: { bucket: string; filename?: unknown; filepath?: string; prefix?: string }; type: "r2" }; endpoint: string; id: string; name: string; source: unknown[]; version: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Postv4accountsbyaccountIdpipelinesDeprecatedResponse = Schema.Struct({
  result: Schema.Struct({
  destination: Schema.Struct({
  batch: Schema.Struct({
  max_bytes: Schema.Number,
  max_duration_s: Schema.Number,
  max_rows: Schema.Number
}),
  compression: Schema.Struct({
  type: Schema.Literal("none", "gzip", "deflate")
}),
  format: Schema.Literal("json"),
  path: Schema.Struct({
  bucket: Schema.String,
  filename: Schema.optional(Schema.String),
  filepath: Schema.optional(Schema.String),
  prefix: Schema.optional(Schema.String)
}),
  type: Schema.Literal("r2")
}),
  endpoint: Schema.String,
  id: Schema.String,
  name: Schema.String,
  source: Schema.Array(Schema.Union(Schema.Struct({
  authentication: Schema.optional(Schema.Boolean),
  cors: Schema.optional(Schema.Struct({
  origins: Schema.optional(Schema.Array(Schema.String))
})),
  format: Schema.Literal("json"),
  type: Schema.String
}), Schema.Struct({
  format: Schema.Literal("json"),
  type: Schema.String
}))),
  version: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Postv4accountsbyaccountIdpipelinesDeprecatedResponse" }) as unknown as Schema.Schema<Postv4accountsbyaccountIdpipelinesDeprecatedResponse>;

export const postv4accountsbyaccountIdpipelinesDeprecated: (
  input: Postv4accountsbyaccountIdpipelinesDeprecatedRequest
) => Effect.Effect<
  Postv4accountsbyaccountIdpipelinesDeprecatedResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Postv4accountsbyaccountIdpipelinesDeprecatedRequest,
  output: Postv4accountsbyaccountIdpipelinesDeprecatedResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Getv4accountsbyaccountIdpipelinesv1pipelinesRequest {
  account_id: string;
  page?: number;
  per_page?: number;
}

export const Getv4accountsbyaccountIdpipelinesv1pipelinesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/pipelines/v1/pipelines" }),
).annotations({ identifier: "Getv4accountsbyaccountIdpipelinesv1pipelinesRequest" }) as unknown as Schema.Schema<Getv4accountsbyaccountIdpipelinesv1pipelinesRequest>;

export interface Getv4accountsbyaccountIdpipelinesv1pipelinesResponse {
  result: { created_at: string; id: string; modified_at: string; name: string; sql: string; status: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Getv4accountsbyaccountIdpipelinesv1pipelinesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.String,
  id: Schema.String,
  modified_at: Schema.String,
  name: Schema.String,
  sql: Schema.String,
  status: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Getv4accountsbyaccountIdpipelinesv1pipelinesResponse" }) as unknown as Schema.Schema<Getv4accountsbyaccountIdpipelinesv1pipelinesResponse>;

export const getv4accountsbyaccountIdpipelinesv1pipelines: (
  input: Getv4accountsbyaccountIdpipelinesv1pipelinesRequest
) => Effect.Effect<
  Getv4accountsbyaccountIdpipelinesv1pipelinesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Getv4accountsbyaccountIdpipelinesv1pipelinesRequest,
  output: Getv4accountsbyaccountIdpipelinesv1pipelinesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Postv4accountsbyaccountIdpipelinesv1pipelinesRequest {
  account_id: string;
  body: { name: string; sql: string };
}

export const Postv4accountsbyaccountIdpipelinesv1pipelinesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  name: Schema.String,
  sql: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/pipelines/v1/pipelines" }),
).annotations({ identifier: "Postv4accountsbyaccountIdpipelinesv1pipelinesRequest" }) as unknown as Schema.Schema<Postv4accountsbyaccountIdpipelinesv1pipelinesRequest>;

export interface Postv4accountsbyaccountIdpipelinesv1pipelinesResponse {
  result: { created_at: string; id: string; modified_at: string; name: string; sql: string; status: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Postv4accountsbyaccountIdpipelinesv1pipelinesResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.String,
  id: Schema.String,
  modified_at: Schema.String,
  name: Schema.String,
  sql: Schema.String,
  status: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Postv4accountsbyaccountIdpipelinesv1pipelinesResponse" }) as unknown as Schema.Schema<Postv4accountsbyaccountIdpipelinesv1pipelinesResponse>;

export const postv4accountsbyaccountIdpipelinesv1pipelines: (
  input: Postv4accountsbyaccountIdpipelinesv1pipelinesRequest
) => Effect.Effect<
  Postv4accountsbyaccountIdpipelinesv1pipelinesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Postv4accountsbyaccountIdpipelinesv1pipelinesRequest,
  output: Postv4accountsbyaccountIdpipelinesv1pipelinesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Getv4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdRequest {
  account_id: string;
  pipeline_id: string;
}

export const Getv4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  pipeline_id: Schema.String.pipe(T.HttpPath("pipeline_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/pipelines/v1/pipelines/{pipeline_id}" }),
).annotations({ identifier: "Getv4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdRequest" }) as unknown as Schema.Schema<Getv4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdRequest>;

export interface Getv4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdResponse {
  result: { created_at: string; id: string; modified_at: string; name: string; sql: string; status: string; tables: { id: string; latest: number; name: string; type: "stream" | "sink"; version: number }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Getv4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.String,
  id: Schema.String,
  modified_at: Schema.String,
  name: Schema.String,
  sql: Schema.String,
  status: Schema.String,
  tables: Schema.Array(Schema.Struct({
  id: Schema.String,
  latest: Schema.Number,
  name: Schema.String,
  type: Schema.Literal("stream", "sink"),
  version: Schema.Number
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Getv4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdResponse" }) as unknown as Schema.Schema<Getv4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdResponse>;

export const getv4accountsbyaccountIdpipelinesv1pipelinesbypipelineId: (
  input: Getv4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdRequest
) => Effect.Effect<
  Getv4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Getv4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdRequest,
  output: Getv4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Deletev4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdRequest {
  account_id: string;
  pipeline_id: string;
}

export const Deletev4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  pipeline_id: Schema.String.pipe(T.HttpPath("pipeline_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/pipelines/v1/pipelines/{pipeline_id}" }),
).annotations({ identifier: "Deletev4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdRequest" }) as unknown as Schema.Schema<Deletev4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdRequest>;

export interface Deletev4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Deletev4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Deletev4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdResponse" }) as unknown as Schema.Schema<Deletev4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdResponse>;

export const deletev4accountsbyaccountIdpipelinesv1pipelinesbypipelineId: (
  input: Deletev4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdRequest
) => Effect.Effect<
  Deletev4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Deletev4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdRequest,
  output: Deletev4accountsbyaccountIdpipelinesv1pipelinesbypipelineIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Getv4accountsbyaccountIdpipelinesv1sinksRequest {
  account_id: string;
  pipeline_id?: string;
  page?: number;
  per_page?: number;
}

export const Getv4accountsbyaccountIdpipelinesv1sinksRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  pipeline_id: Schema.optional(Schema.String).pipe(T.HttpQuery("pipeline_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/pipelines/v1/sinks" }),
).annotations({ identifier: "Getv4accountsbyaccountIdpipelinesv1sinksRequest" }) as unknown as Schema.Schema<Getv4accountsbyaccountIdpipelinesv1sinksRequest>;

export interface Getv4accountsbyaccountIdpipelinesv1sinksResponse {
  result: { config?: unknown; created_at: string; format?: unknown; id: string; modified_at: string; name: string; schema?: { fields?: unknown[]; format?: unknown; inferred?: boolean }; type: "r2" | "r2_data_catalog" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Getv4accountsbyaccountIdpipelinesv1sinksResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  config: Schema.optional(Schema.Union(Schema.Struct({
  account_id: Schema.String,
  bucket: Schema.String,
  credentials: Schema.Struct({
  access_key_id: Schema.String,
  secret_access_key: Schema.String
}),
  file_naming: Schema.optional(Schema.Struct({
  prefix: Schema.optional(Schema.String),
  strategy: Schema.optional(Schema.Literal("serial", "uuid", "uuid_v7", "ulid")),
  suffix: Schema.optional(Schema.String)
})),
  jurisdiction: Schema.optional(Schema.String),
  partitioning: Schema.optional(Schema.Struct({
  time_pattern: Schema.optional(Schema.String)
})),
  path: Schema.optional(Schema.String),
  rolling_policy: Schema.optional(Schema.Struct({
  file_size_bytes: Schema.optional(Schema.Number),
  inactivity_seconds: Schema.optional(Schema.Number),
  interval_seconds: Schema.optional(Schema.Number)
}))
}), Schema.Struct({
  account_id: Schema.String,
  bucket: Schema.String,
  namespace: Schema.optional(Schema.String),
  rolling_policy: Schema.optional(Schema.Struct({
  file_size_bytes: Schema.optional(Schema.Number),
  inactivity_seconds: Schema.optional(Schema.Number),
  interval_seconds: Schema.optional(Schema.Number)
})),
  table_name: Schema.String,
  token: Schema.String
}))),
  created_at: Schema.Date,
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  schema: Schema.optional(Schema.Struct({
  fields: Schema.optional(Schema.Array(cloudflare_pipelines_SourceField)),
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  inferred: Schema.optional(Schema.Boolean)
})),
  type: Schema.Literal("r2", "r2_data_catalog")
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Getv4accountsbyaccountIdpipelinesv1sinksResponse" }) as unknown as Schema.Schema<Getv4accountsbyaccountIdpipelinesv1sinksResponse>;

export const getv4accountsbyaccountIdpipelinesv1sinks: (
  input: Getv4accountsbyaccountIdpipelinesv1sinksRequest
) => Effect.Effect<
  Getv4accountsbyaccountIdpipelinesv1sinksResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Getv4accountsbyaccountIdpipelinesv1sinksRequest,
  output: Getv4accountsbyaccountIdpipelinesv1sinksResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Postv4accountsbyaccountIdpipelinesv1sinksRequest {
  account_id: string;
  body: { config?: unknown; format?: unknown; name: string; schema?: { fields?: unknown[]; format?: unknown; inferred?: boolean }; type: "r2" | "r2_data_catalog" };
}

export const Postv4accountsbyaccountIdpipelinesv1sinksRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  config: Schema.optional(Schema.Union(Schema.Struct({
  account_id: Schema.String,
  bucket: Schema.String,
  credentials: Schema.Struct({
  access_key_id: Schema.String,
  secret_access_key: Schema.String
}),
  file_naming: Schema.optional(Schema.Struct({
  prefix: Schema.optional(Schema.String),
  strategy: Schema.optional(Schema.Literal("serial", "uuid", "uuid_v7", "ulid")),
  suffix: Schema.optional(Schema.String)
})),
  jurisdiction: Schema.optional(Schema.String),
  partitioning: Schema.optional(Schema.Struct({
  time_pattern: Schema.optional(Schema.String)
})),
  path: Schema.optional(Schema.String),
  rolling_policy: Schema.optional(Schema.Struct({
  file_size_bytes: Schema.optional(Schema.Number),
  inactivity_seconds: Schema.optional(Schema.Number),
  interval_seconds: Schema.optional(Schema.Number)
}))
}), Schema.Struct({
  account_id: Schema.String,
  bucket: Schema.String,
  namespace: Schema.optional(Schema.String),
  rolling_policy: Schema.optional(Schema.Struct({
  file_size_bytes: Schema.optional(Schema.Number),
  inactivity_seconds: Schema.optional(Schema.Number),
  interval_seconds: Schema.optional(Schema.Number)
})),
  table_name: Schema.String,
  token: Schema.String
}))),
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  name: Schema.String,
  schema: Schema.optional(Schema.Struct({
  fields: Schema.optional(Schema.Array(cloudflare_pipelines_SourceField)),
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  inferred: Schema.optional(Schema.Boolean)
})),
  type: Schema.Literal("r2", "r2_data_catalog")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/pipelines/v1/sinks" }),
).annotations({ identifier: "Postv4accountsbyaccountIdpipelinesv1sinksRequest" }) as unknown as Schema.Schema<Postv4accountsbyaccountIdpipelinesv1sinksRequest>;

export interface Postv4accountsbyaccountIdpipelinesv1sinksResponse {
  result: { config?: unknown; created_at: string; format?: unknown; id: string; modified_at: string; name: string; schema?: { fields?: unknown[]; format?: unknown; inferred?: boolean }; type: "r2" | "r2_data_catalog" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Postv4accountsbyaccountIdpipelinesv1sinksResponse = Schema.Struct({
  result: Schema.Struct({
  config: Schema.optional(Schema.Union(Schema.Struct({
  account_id: Schema.String,
  bucket: Schema.String,
  credentials: Schema.Struct({
  access_key_id: Schema.String,
  secret_access_key: Schema.String
}),
  file_naming: Schema.optional(Schema.Struct({
  prefix: Schema.optional(Schema.String),
  strategy: Schema.optional(Schema.Literal("serial", "uuid", "uuid_v7", "ulid")),
  suffix: Schema.optional(Schema.String)
})),
  jurisdiction: Schema.optional(Schema.String),
  partitioning: Schema.optional(Schema.Struct({
  time_pattern: Schema.optional(Schema.String)
})),
  path: Schema.optional(Schema.String),
  rolling_policy: Schema.optional(Schema.Struct({
  file_size_bytes: Schema.optional(Schema.Number),
  inactivity_seconds: Schema.optional(Schema.Number),
  interval_seconds: Schema.optional(Schema.Number)
}))
}), Schema.Struct({
  account_id: Schema.String,
  bucket: Schema.String,
  namespace: Schema.optional(Schema.String),
  rolling_policy: Schema.optional(Schema.Struct({
  file_size_bytes: Schema.optional(Schema.Number),
  inactivity_seconds: Schema.optional(Schema.Number),
  interval_seconds: Schema.optional(Schema.Number)
})),
  table_name: Schema.String,
  token: Schema.String
}))),
  created_at: Schema.Date,
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  schema: Schema.optional(Schema.Struct({
  fields: Schema.optional(Schema.Array(cloudflare_pipelines_SourceField)),
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  inferred: Schema.optional(Schema.Boolean)
})),
  type: Schema.Literal("r2", "r2_data_catalog")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Postv4accountsbyaccountIdpipelinesv1sinksResponse" }) as unknown as Schema.Schema<Postv4accountsbyaccountIdpipelinesv1sinksResponse>;

export const postv4accountsbyaccountIdpipelinesv1sinks: (
  input: Postv4accountsbyaccountIdpipelinesv1sinksRequest
) => Effect.Effect<
  Postv4accountsbyaccountIdpipelinesv1sinksResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Postv4accountsbyaccountIdpipelinesv1sinksRequest,
  output: Postv4accountsbyaccountIdpipelinesv1sinksResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Getv4accountsbyaccountIdpipelinesv1sinksbysinkIdRequest {
  account_id: string;
  sink_id: string;
}

export const Getv4accountsbyaccountIdpipelinesv1sinksbysinkIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  sink_id: Schema.String.pipe(T.HttpPath("sink_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/pipelines/v1/sinks/{sink_id}" }),
).annotations({ identifier: "Getv4accountsbyaccountIdpipelinesv1sinksbysinkIdRequest" }) as unknown as Schema.Schema<Getv4accountsbyaccountIdpipelinesv1sinksbysinkIdRequest>;

export interface Getv4accountsbyaccountIdpipelinesv1sinksbysinkIdResponse {
  result: { config?: unknown; created_at: string; format?: unknown; id: string; modified_at: string; name: string; schema?: { fields?: unknown[]; format?: unknown; inferred?: boolean }; type: "r2" | "r2_data_catalog" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Getv4accountsbyaccountIdpipelinesv1sinksbysinkIdResponse = Schema.Struct({
  result: Schema.Struct({
  config: Schema.optional(Schema.Union(Schema.Struct({
  account_id: Schema.String,
  bucket: Schema.String,
  credentials: Schema.Struct({
  access_key_id: Schema.String,
  secret_access_key: Schema.String
}),
  file_naming: Schema.optional(Schema.Struct({
  prefix: Schema.optional(Schema.String),
  strategy: Schema.optional(Schema.Literal("serial", "uuid", "uuid_v7", "ulid")),
  suffix: Schema.optional(Schema.String)
})),
  jurisdiction: Schema.optional(Schema.String),
  partitioning: Schema.optional(Schema.Struct({
  time_pattern: Schema.optional(Schema.String)
})),
  path: Schema.optional(Schema.String),
  rolling_policy: Schema.optional(Schema.Struct({
  file_size_bytes: Schema.optional(Schema.Number),
  inactivity_seconds: Schema.optional(Schema.Number),
  interval_seconds: Schema.optional(Schema.Number)
}))
}), Schema.Struct({
  account_id: Schema.String,
  bucket: Schema.String,
  namespace: Schema.optional(Schema.String),
  rolling_policy: Schema.optional(Schema.Struct({
  file_size_bytes: Schema.optional(Schema.Number),
  inactivity_seconds: Schema.optional(Schema.Number),
  interval_seconds: Schema.optional(Schema.Number)
})),
  table_name: Schema.String,
  token: Schema.String
}))),
  created_at: Schema.Date,
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  schema: Schema.optional(Schema.Struct({
  fields: Schema.optional(Schema.Array(cloudflare_pipelines_SourceField)),
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  inferred: Schema.optional(Schema.Boolean)
})),
  type: Schema.Literal("r2", "r2_data_catalog")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Getv4accountsbyaccountIdpipelinesv1sinksbysinkIdResponse" }) as unknown as Schema.Schema<Getv4accountsbyaccountIdpipelinesv1sinksbysinkIdResponse>;

export const getv4accountsbyaccountIdpipelinesv1sinksbysinkId: (
  input: Getv4accountsbyaccountIdpipelinesv1sinksbysinkIdRequest
) => Effect.Effect<
  Getv4accountsbyaccountIdpipelinesv1sinksbysinkIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Getv4accountsbyaccountIdpipelinesv1sinksbysinkIdRequest,
  output: Getv4accountsbyaccountIdpipelinesv1sinksbysinkIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Deletev4accountsbyaccountIdpipelinesv1sinksbysinkIdRequest {
  account_id: string;
  sink_id: string;
  force?: string;
}

export const Deletev4accountsbyaccountIdpipelinesv1sinksbysinkIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  sink_id: Schema.String.pipe(T.HttpPath("sink_id")),
  force: Schema.optional(Schema.String).pipe(T.HttpQuery("force"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/pipelines/v1/sinks/{sink_id}" }),
).annotations({ identifier: "Deletev4accountsbyaccountIdpipelinesv1sinksbysinkIdRequest" }) as unknown as Schema.Schema<Deletev4accountsbyaccountIdpipelinesv1sinksbysinkIdRequest>;

export interface Deletev4accountsbyaccountIdpipelinesv1sinksbysinkIdResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Deletev4accountsbyaccountIdpipelinesv1sinksbysinkIdResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Deletev4accountsbyaccountIdpipelinesv1sinksbysinkIdResponse" }) as unknown as Schema.Schema<Deletev4accountsbyaccountIdpipelinesv1sinksbysinkIdResponse>;

export const deletev4accountsbyaccountIdpipelinesv1sinksbysinkId: (
  input: Deletev4accountsbyaccountIdpipelinesv1sinksbysinkIdRequest
) => Effect.Effect<
  Deletev4accountsbyaccountIdpipelinesv1sinksbysinkIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Deletev4accountsbyaccountIdpipelinesv1sinksbysinkIdRequest,
  output: Deletev4accountsbyaccountIdpipelinesv1sinksbysinkIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Getv4accountsbyaccountIdpipelinesv1streamsRequest {
  account_id: string;
  pipeline_id?: string;
  page?: number;
  per_page?: number;
}

export const Getv4accountsbyaccountIdpipelinesv1streamsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  pipeline_id: Schema.optional(Schema.String).pipe(T.HttpQuery("pipeline_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/pipelines/v1/streams" }),
).annotations({ identifier: "Getv4accountsbyaccountIdpipelinesv1streamsRequest" }) as unknown as Schema.Schema<Getv4accountsbyaccountIdpipelinesv1streamsRequest>;

export interface Getv4accountsbyaccountIdpipelinesv1streamsResponse {
  result: { created_at: string; endpoint?: string; format?: unknown; http: { authentication: boolean; cors?: { origins?: string[] }; enabled: boolean }; id: string; modified_at: string; name: string; schema?: { fields?: unknown[]; format?: unknown; inferred?: boolean }; version: number; worker_binding: { enabled: boolean } }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Getv4accountsbyaccountIdpipelinesv1streamsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_at: Schema.Date,
  endpoint: Schema.optional(Schema.String),
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  http: Schema.Struct({
  authentication: Schema.Boolean,
  cors: Schema.optional(Schema.Struct({
  origins: Schema.optional(Schema.Array(Schema.String))
})),
  enabled: Schema.Boolean
}),
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  schema: Schema.optional(Schema.Struct({
  fields: Schema.optional(Schema.Array(cloudflare_pipelines_SourceField)),
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  inferred: Schema.optional(Schema.Boolean)
})),
  version: Schema.Number,
  worker_binding: Schema.Struct({
  enabled: Schema.Boolean
})
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Getv4accountsbyaccountIdpipelinesv1streamsResponse" }) as unknown as Schema.Schema<Getv4accountsbyaccountIdpipelinesv1streamsResponse>;

export const getv4accountsbyaccountIdpipelinesv1streams: (
  input: Getv4accountsbyaccountIdpipelinesv1streamsRequest
) => Effect.Effect<
  Getv4accountsbyaccountIdpipelinesv1streamsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Getv4accountsbyaccountIdpipelinesv1streamsRequest,
  output: Getv4accountsbyaccountIdpipelinesv1streamsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Postv4accountsbyaccountIdpipelinesv1streamsRequest {
  account_id: string;
  body: { format?: unknown; http?: { authentication: boolean; cors?: { origins?: string[] }; enabled: boolean }; name: string; schema?: { fields?: unknown[]; format?: unknown; inferred?: boolean }; worker_binding?: { enabled: boolean } };
}

export const Postv4accountsbyaccountIdpipelinesv1streamsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  http: Schema.optional(Schema.Struct({
  authentication: Schema.Boolean,
  cors: Schema.optional(Schema.Struct({
  origins: Schema.optional(Schema.Array(Schema.String))
})),
  enabled: Schema.Boolean
})),
  name: Schema.String,
  schema: Schema.optional(Schema.Struct({
  fields: Schema.optional(Schema.Array(cloudflare_pipelines_SourceField)),
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  inferred: Schema.optional(Schema.Boolean)
})),
  worker_binding: Schema.optional(Schema.Struct({
  enabled: Schema.Boolean
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/pipelines/v1/streams" }),
).annotations({ identifier: "Postv4accountsbyaccountIdpipelinesv1streamsRequest" }) as unknown as Schema.Schema<Postv4accountsbyaccountIdpipelinesv1streamsRequest>;

export interface Postv4accountsbyaccountIdpipelinesv1streamsResponse {
  result: { created_at: string; endpoint?: string; format?: unknown; http: { authentication: boolean; cors?: { origins?: string[] }; enabled: boolean }; id: string; modified_at: string; name: string; schema?: { fields?: unknown[]; format?: unknown; inferred?: boolean }; version: number; worker_binding: { enabled: boolean } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Postv4accountsbyaccountIdpipelinesv1streamsResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  endpoint: Schema.optional(Schema.String),
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  http: Schema.Struct({
  authentication: Schema.Boolean,
  cors: Schema.optional(Schema.Struct({
  origins: Schema.optional(Schema.Array(Schema.String))
})),
  enabled: Schema.Boolean
}),
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  schema: Schema.optional(Schema.Struct({
  fields: Schema.optional(Schema.Array(cloudflare_pipelines_SourceField)),
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  inferred: Schema.optional(Schema.Boolean)
})),
  version: Schema.Number,
  worker_binding: Schema.Struct({
  enabled: Schema.Boolean
})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Postv4accountsbyaccountIdpipelinesv1streamsResponse" }) as unknown as Schema.Schema<Postv4accountsbyaccountIdpipelinesv1streamsResponse>;

export const postv4accountsbyaccountIdpipelinesv1streams: (
  input: Postv4accountsbyaccountIdpipelinesv1streamsRequest
) => Effect.Effect<
  Postv4accountsbyaccountIdpipelinesv1streamsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Postv4accountsbyaccountIdpipelinesv1streamsRequest,
  output: Postv4accountsbyaccountIdpipelinesv1streamsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Getv4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest {
  account_id: string;
  stream_id: string;
}

export const Getv4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  stream_id: Schema.String.pipe(T.HttpPath("stream_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/pipelines/v1/streams/{stream_id}" }),
).annotations({ identifier: "Getv4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest" }) as unknown as Schema.Schema<Getv4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest>;

export interface Getv4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse {
  result: { created_at: string; endpoint?: string; format?: unknown; http: { authentication: boolean; cors?: { origins?: string[] }; enabled: boolean }; id: string; modified_at: string; name: string; schema?: { fields?: unknown[]; format?: unknown; inferred?: boolean }; version: number; worker_binding: { enabled: boolean } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Getv4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  endpoint: Schema.optional(Schema.String),
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  http: Schema.Struct({
  authentication: Schema.Boolean,
  cors: Schema.optional(Schema.Struct({
  origins: Schema.optional(Schema.Array(Schema.String))
})),
  enabled: Schema.Boolean
}),
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  schema: Schema.optional(Schema.Struct({
  fields: Schema.optional(Schema.Array(cloudflare_pipelines_SourceField)),
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  inferred: Schema.optional(Schema.Boolean)
})),
  version: Schema.Number,
  worker_binding: Schema.Struct({
  enabled: Schema.Boolean
})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Getv4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse" }) as unknown as Schema.Schema<Getv4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse>;

export const getv4accountsbyaccountIdpipelinesv1streamsbystreamId: (
  input: Getv4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest
) => Effect.Effect<
  Getv4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Getv4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest,
  output: Getv4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Deletev4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest {
  force?: string;
  account_id: string;
  stream_id: string;
}

export const Deletev4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest = Schema.Struct({
  force: Schema.optional(Schema.String).pipe(T.HttpQuery("force")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  stream_id: Schema.String.pipe(T.HttpPath("stream_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/pipelines/v1/streams/{stream_id}" }),
).annotations({ identifier: "Deletev4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest" }) as unknown as Schema.Schema<Deletev4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest>;

export interface Deletev4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Deletev4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Deletev4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse" }) as unknown as Schema.Schema<Deletev4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse>;

export const deletev4accountsbyaccountIdpipelinesv1streamsbystreamId: (
  input: Deletev4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest
) => Effect.Effect<
  Deletev4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Deletev4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest,
  output: Deletev4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Patchv4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest {
  account_id: string;
  stream_id: string;
  body: { http?: { authentication: boolean; cors?: { origins?: string[] }; enabled: boolean }; worker_binding?: { enabled: boolean } };
}

export const Patchv4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  stream_id: Schema.String.pipe(T.HttpPath("stream_id")),
  body: Schema.Struct({
  http: Schema.optional(Schema.Struct({
  authentication: Schema.Boolean,
  cors: Schema.optional(Schema.Struct({
  origins: Schema.optional(Schema.Array(Schema.String))
})),
  enabled: Schema.Boolean
})),
  worker_binding: Schema.optional(Schema.Struct({
  enabled: Schema.Boolean
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/pipelines/v1/streams/{stream_id}" }),
).annotations({ identifier: "Patchv4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest" }) as unknown as Schema.Schema<Patchv4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest>;

export interface Patchv4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse {
  result: { created_at: string; endpoint?: string; format?: unknown; http: { authentication: boolean; cors?: { origins?: string[] }; enabled: boolean }; id: string; modified_at: string; name: string; version: number; worker_binding: { enabled: boolean } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Patchv4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse = Schema.Struct({
  result: Schema.Struct({
  created_at: Schema.Date,
  endpoint: Schema.optional(Schema.String),
  format: Schema.optional(Schema.Union(Schema.Struct({
  type: Schema.Literal("json")
}), Schema.Struct({
  type: Schema.Literal("parquet")
}))),
  http: Schema.Struct({
  authentication: Schema.Boolean,
  cors: Schema.optional(Schema.Struct({
  origins: Schema.optional(Schema.Array(Schema.String))
})),
  enabled: Schema.Boolean
}),
  id: Schema.String,
  modified_at: Schema.Date,
  name: Schema.String,
  version: Schema.Number,
  worker_binding: Schema.Struct({
  enabled: Schema.Boolean
})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Patchv4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse" }) as unknown as Schema.Schema<Patchv4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse>;

export const patchv4accountsbyaccountIdpipelinesv1streamsbystreamId: (
  input: Patchv4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest
) => Effect.Effect<
  Patchv4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Patchv4accountsbyaccountIdpipelinesv1streamsbystreamIdRequest,
  output: Patchv4accountsbyaccountIdpipelinesv1streamsbystreamIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Postv4accountsbyaccountIdpipelinesv1validateSqlRequest {
  account_id: string;
  body: { sql: string };
}

export const Postv4accountsbyaccountIdpipelinesv1validateSqlRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  sql: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/pipelines/v1/validate_sql" }),
).annotations({ identifier: "Postv4accountsbyaccountIdpipelinesv1validateSqlRequest" }) as unknown as Schema.Schema<Postv4accountsbyaccountIdpipelinesv1validateSqlRequest>;

export interface Postv4accountsbyaccountIdpipelinesv1validateSqlResponse {
  result: { graph?: { edges: { dest_id: number; edge_type: string; key_type: string; src_id: number; value_type: string }[]; nodes: { description: string; node_id: number; operator: string; parallelism: number }[] }; tables: Record<string, unknown> };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Postv4accountsbyaccountIdpipelinesv1validateSqlResponse = Schema.Struct({
  result: Schema.Struct({
  graph: Schema.optional(Schema.Struct({
  edges: Schema.Array(Schema.Struct({
  dest_id: Schema.Number,
  edge_type: Schema.String,
  key_type: Schema.String,
  src_id: Schema.Number,
  value_type: Schema.String
})),
  nodes: Schema.Array(Schema.Struct({
  description: Schema.String,
  node_id: Schema.Number,
  operator: Schema.String,
  parallelism: Schema.Number
}))
})),
  tables: Schema.Record({ key: Schema.String, value: Schema.Struct({
  id: Schema.String,
  name: Schema.String,
  type: Schema.String,
  version: Schema.Number
}) })
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Postv4accountsbyaccountIdpipelinesv1validateSqlResponse" }) as unknown as Schema.Schema<Postv4accountsbyaccountIdpipelinesv1validateSqlResponse>;

export const postv4accountsbyaccountIdpipelinesv1validateSql: (
  input: Postv4accountsbyaccountIdpipelinesv1validateSqlRequest
) => Effect.Effect<
  Postv4accountsbyaccountIdpipelinesv1validateSqlResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Postv4accountsbyaccountIdpipelinesv1validateSqlRequest,
  output: Postv4accountsbyaccountIdpipelinesv1validateSqlResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Getv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest {
  account_id: string;
  pipeline_name: string;
}

export const Getv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  pipeline_name: Schema.String.pipe(T.HttpPath("pipeline_name"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/pipelines/{pipeline_name}" }),
).annotations({ identifier: "Getv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest" }) as unknown as Schema.Schema<Getv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest>;

export interface Getv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse {
  result: { destination: { batch: { max_bytes: number; max_duration_s: number; max_rows: number }; compression: { type: "none" | "gzip" | "deflate" }; format: "json"; path: { bucket: string; filename?: unknown; filepath?: string; prefix?: string }; type: "r2" }; endpoint: string; id: string; name: string; source: unknown[]; version: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Getv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse = Schema.Struct({
  result: Schema.Struct({
  destination: Schema.Struct({
  batch: Schema.Struct({
  max_bytes: Schema.Number,
  max_duration_s: Schema.Number,
  max_rows: Schema.Number
}),
  compression: Schema.Struct({
  type: Schema.Literal("none", "gzip", "deflate")
}),
  format: Schema.Literal("json"),
  path: Schema.Struct({
  bucket: Schema.String,
  filename: Schema.optional(Schema.String),
  filepath: Schema.optional(Schema.String),
  prefix: Schema.optional(Schema.String)
}),
  type: Schema.Literal("r2")
}),
  endpoint: Schema.String,
  id: Schema.String,
  name: Schema.String,
  source: Schema.Array(Schema.Union(Schema.Struct({
  authentication: Schema.optional(Schema.Boolean),
  cors: Schema.optional(Schema.Struct({
  origins: Schema.optional(Schema.Array(Schema.String))
})),
  format: Schema.Literal("json"),
  type: Schema.String
}), Schema.Struct({
  format: Schema.Literal("json"),
  type: Schema.String
}))),
  version: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Getv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse" }) as unknown as Schema.Schema<Getv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse>;

export const getv4accountsbyaccountIdpipelinesbypipelineNameDeprecated: (
  input: Getv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest
) => Effect.Effect<
  Getv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Getv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest,
  output: Getv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Putv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest {
  account_id: string;
  pipeline_name: string;
  body: { destination: { batch: { max_bytes?: number; max_duration_s?: number; max_rows?: number }; compression: { type?: "none" | "gzip" | "deflate" }; credentials?: { access_key_id: string; endpoint: string; secret_access_key: string }; format: "json"; path: { bucket: string; filename?: unknown; filepath?: string; prefix?: string }; type: "r2" }; name: string; source: unknown[] };
}

export const Putv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  pipeline_name: Schema.String.pipe(T.HttpPath("pipeline_name")),
  body: Schema.Struct({
  destination: Schema.Struct({
  batch: Schema.Struct({
  max_bytes: Schema.optional(Schema.Number),
  max_duration_s: Schema.optional(Schema.Number),
  max_rows: Schema.optional(Schema.Number)
}),
  compression: Schema.Struct({
  type: Schema.optional(Schema.Literal("none", "gzip", "deflate"))
}),
  credentials: Schema.optional(Schema.Struct({
  access_key_id: Schema.String,
  endpoint: Schema.String,
  secret_access_key: Schema.String
})),
  format: Schema.Literal("json"),
  path: Schema.Struct({
  bucket: Schema.String,
  filename: Schema.optional(Schema.String),
  filepath: Schema.optional(Schema.String),
  prefix: Schema.optional(Schema.String)
}),
  type: Schema.Literal("r2")
}),
  name: Schema.String,
  source: Schema.Array(Schema.Union(Schema.Struct({
  authentication: Schema.optional(Schema.Boolean),
  cors: Schema.optional(Schema.Struct({
  origins: Schema.optional(Schema.Array(Schema.String))
})),
  format: Schema.Literal("json"),
  type: Schema.String
}), Schema.Struct({
  format: Schema.Literal("json"),
  type: Schema.String
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/pipelines/{pipeline_name}" }),
).annotations({ identifier: "Putv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest" }) as unknown as Schema.Schema<Putv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest>;

export interface Putv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse {
  result: { destination: { batch: { max_bytes: number; max_duration_s: number; max_rows: number }; compression: { type: "none" | "gzip" | "deflate" }; format: "json"; path: { bucket: string; filename?: unknown; filepath?: string; prefix?: string }; type: "r2" }; endpoint: string; id: string; name: string; source: unknown[]; version: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Putv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse = Schema.Struct({
  result: Schema.Struct({
  destination: Schema.Struct({
  batch: Schema.Struct({
  max_bytes: Schema.Number,
  max_duration_s: Schema.Number,
  max_rows: Schema.Number
}),
  compression: Schema.Struct({
  type: Schema.Literal("none", "gzip", "deflate")
}),
  format: Schema.Literal("json"),
  path: Schema.Struct({
  bucket: Schema.String,
  filename: Schema.optional(Schema.String),
  filepath: Schema.optional(Schema.String),
  prefix: Schema.optional(Schema.String)
}),
  type: Schema.Literal("r2")
}),
  endpoint: Schema.String,
  id: Schema.String,
  name: Schema.String,
  source: Schema.Array(Schema.Union(Schema.Struct({
  authentication: Schema.optional(Schema.Boolean),
  cors: Schema.optional(Schema.Struct({
  origins: Schema.optional(Schema.Array(Schema.String))
})),
  format: Schema.Literal("json"),
  type: Schema.String
}), Schema.Struct({
  format: Schema.Literal("json"),
  type: Schema.String
}))),
  version: Schema.Number
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Putv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse" }) as unknown as Schema.Schema<Putv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse>;

export const putv4accountsbyaccountIdpipelinesbypipelineNameDeprecated: (
  input: Putv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest
) => Effect.Effect<
  Putv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Putv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest,
  output: Putv4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Deletev4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest {
  account_id: string;
  pipeline_name: string;
}

export const Deletev4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  pipeline_name: Schema.String.pipe(T.HttpPath("pipeline_name"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/pipelines/{pipeline_name}" }),
).annotations({ identifier: "Deletev4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest" }) as unknown as Schema.Schema<Deletev4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest>;

export interface Deletev4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Deletev4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Deletev4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse" }) as unknown as Schema.Schema<Deletev4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse>;

export const deletev4accountsbyaccountIdpipelinesbypipelineNameDeprecated: (
  input: Deletev4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest
) => Effect.Effect<
  Deletev4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Deletev4accountsbyaccountIdpipelinesbypipelineNameDeprecatedRequest,
  output: Deletev4accountsbyaccountIdpipelinesbypipelineNameDeprecatedResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountsGetaccountprofileRequest {
  account_id: string;
}

export const AccountsGetaccountprofileRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/profile" }),
).annotations({ identifier: "AccountsGetaccountprofileRequest" }) as unknown as Schema.Schema<AccountsGetaccountprofileRequest>;

export interface AccountsGetaccountprofileResponse {
  result: { business_address: string; business_email: string; business_name: string; business_phone: string; external_metadata: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountsGetaccountprofileResponse = Schema.Struct({
  result: Schema.Struct({
  business_address: Schema.String,
  business_email: Schema.String,
  business_name: Schema.String,
  business_phone: Schema.String,
  external_metadata: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountsGetaccountprofileResponse" }) as unknown as Schema.Schema<AccountsGetaccountprofileResponse>;

export const accountsGetaccountprofile: (
  input: AccountsGetaccountprofileRequest
) => Effect.Effect<
  AccountsGetaccountprofileResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountsGetaccountprofileRequest,
  output: AccountsGetaccountprofileResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountsModifyaccountprofileRequest {
  account_id: string;
  body: { business_address: string; business_email: string; business_name: string; business_phone: string; external_metadata: string };
}

export const AccountsModifyaccountprofileRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  business_address: Schema.String,
  business_email: Schema.String,
  business_name: Schema.String,
  business_phone: Schema.String,
  external_metadata: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/profile" }),
).annotations({ identifier: "AccountsModifyaccountprofileRequest" }) as unknown as Schema.Schema<AccountsModifyaccountprofileRequest>;

export interface AccountsModifyaccountprofileResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountsModifyaccountprofileResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountsModifyaccountprofileResponse" }) as unknown as Schema.Schema<AccountsModifyaccountprofileResponse>;

export const accountsModifyaccountprofile: (
  input: AccountsModifyaccountprofileRequest
) => Effect.Effect<
  AccountsModifyaccountprofileResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountsModifyaccountprofileRequest,
  output: AccountsModifyaccountprofileResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAppsRequest {
  account_id: string;
}

export const GetAppsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/apps" }),
).annotations({ identifier: "GetAppsRequest" }) as unknown as Schema.Schema<GetAppsRequest>;

export interface GetAppsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAppsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAppsResponse" }) as unknown as Schema.Schema<GetAppsResponse>;

export const getApps: (
  input: GetAppsRequest
) => Effect.Effect<
  GetAppsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAppsRequest,
  output: GetAppsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateAppRequest {
  body: { name: string };
}

export const CreateAppRequest = Schema.Struct({
  body: Schema.Struct({
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/apps" }),
).annotations({ identifier: "CreateAppRequest" }) as unknown as Schema.Schema<CreateAppRequest>;

export interface CreateAppResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateAppResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateAppResponse" }) as unknown as Schema.Schema<CreateAppResponse>;

export const createApp: (
  input: CreateAppRequest
) => Effect.Effect<
  CreateAppResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAppRequest,
  output: CreateAppResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetOrgAnalyticsRequest {
  account_id: string;
  app_id: string;
}

export const GetOrgAnalyticsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/analytics/daywise" }),
).annotations({ identifier: "GetOrgAnalyticsRequest" }) as unknown as Schema.Schema<GetOrgAnalyticsRequest>;

export interface GetOrgAnalyticsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetOrgAnalyticsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetOrgAnalyticsResponse" }) as unknown as Schema.Schema<GetOrgAnalyticsResponse>;

export const getOrgAnalytics: (
  input: GetOrgAnalyticsRequest
) => Effect.Effect<
  GetOrgAnalyticsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetOrgAnalyticsRequest,
  output: GetOrgAnalyticsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetLivestreamAnalyticsCompleteRequest {
  account_id: string;
  app_id: string;
  start_time?: string;
  end_time?: string;
}

export const GetLivestreamAnalyticsCompleteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  start_time: Schema.optional(Schema.Date).pipe(T.HttpQuery("start_time")),
  end_time: Schema.optional(Schema.Date).pipe(T.HttpQuery("end_time"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/analytics/livestreams/overall" }),
).annotations({ identifier: "GetLivestreamAnalyticsCompleteRequest" }) as unknown as Schema.Schema<GetLivestreamAnalyticsCompleteRequest>;

export interface GetLivestreamAnalyticsCompleteResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetLivestreamAnalyticsCompleteResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetLivestreamAnalyticsCompleteResponse" }) as unknown as Schema.Schema<GetLivestreamAnalyticsCompleteResponse>;

export const getLivestreamAnalyticsComplete: (
  input: GetLivestreamAnalyticsCompleteRequest
) => Effect.Effect<
  GetLivestreamAnalyticsCompleteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetLivestreamAnalyticsCompleteRequest,
  output: GetLivestreamAnalyticsCompleteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface FetchAllLivestreamsRequest {
  exclude_meetings?: boolean;
  per_page?: number;
  page_no?: number;
  status?: "LIVE" | "IDLE" | "ERRORED" | "INVOKED";
  start_time?: string;
  end_time?: string;
  sort_order?: "ASC" | "DSC";
}

export const FetchAllLivestreamsRequest = Schema.Struct({
  exclude_meetings: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("exclude_meetings")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  page_no: Schema.optional(Schema.Number).pipe(T.HttpQuery("page_no")),
  status: Schema.optional(Schema.Literal("LIVE", "IDLE", "ERRORED", "INVOKED")).pipe(T.HttpQuery("status")),
  start_time: Schema.optional(Schema.Date).pipe(T.HttpQuery("start_time")),
  end_time: Schema.optional(Schema.Date).pipe(T.HttpQuery("end_time")),
  sort_order: Schema.optional(Schema.Literal("ASC", "DSC")).pipe(T.HttpQuery("sort_order"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/livestreams" }),
).annotations({ identifier: "FetchAllLivestreamsRequest" }) as unknown as Schema.Schema<FetchAllLivestreamsRequest>;

export interface FetchAllLivestreamsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const FetchAllLivestreamsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "FetchAllLivestreamsResponse" }) as unknown as Schema.Schema<FetchAllLivestreamsResponse>;

export const fetchAllLivestreams: (
  input: FetchAllLivestreamsRequest
) => Effect.Effect<
  FetchAllLivestreamsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: FetchAllLivestreamsRequest,
  output: FetchAllLivestreamsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostAccountsAccountIdRealtimeKitAppIdLivestreamsRequest {
  body: { name?: string };
}

export const PostAccountsAccountIdRealtimeKitAppIdLivestreamsRequest = Schema.Struct({
  body: Schema.Struct({
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/{app_id}/livestreams" }),
).annotations({ identifier: "PostAccountsAccountIdRealtimeKitAppIdLivestreamsRequest" }) as unknown as Schema.Schema<PostAccountsAccountIdRealtimeKitAppIdLivestreamsRequest>;

export interface PostAccountsAccountIdRealtimeKitAppIdLivestreamsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostAccountsAccountIdRealtimeKitAppIdLivestreamsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostAccountsAccountIdRealtimeKitAppIdLivestreamsResponse" }) as unknown as Schema.Schema<PostAccountsAccountIdRealtimeKitAppIdLivestreamsResponse>;

export const postAccountsAccountIdRealtimeKitAppIdLivestreams: (
  input: PostAccountsAccountIdRealtimeKitAppIdLivestreamsRequest
) => Effect.Effect<
  PostAccountsAccountIdRealtimeKitAppIdLivestreamsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostAccountsAccountIdRealtimeKitAppIdLivestreamsRequest,
  output: PostAccountsAccountIdRealtimeKitAppIdLivestreamsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetV2LivestreamsLivestreamSessionIdRequest {
  account_id: string;
  app_id: string;
  "livestream-session-id": string;
}

export const GetV2LivestreamsLivestreamSessionIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  "livestream-session-id": Schema.String.pipe(T.HttpPath("livestream-session-id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/livestreams/sessions/{livestream-session-id}" }),
).annotations({ identifier: "GetV2LivestreamsLivestreamSessionIdRequest" }) as unknown as Schema.Schema<GetV2LivestreamsLivestreamSessionIdRequest>;

export interface GetV2LivestreamsLivestreamSessionIdResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetV2LivestreamsLivestreamSessionIdResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetV2LivestreamsLivestreamSessionIdResponse" }) as unknown as Schema.Schema<GetV2LivestreamsLivestreamSessionIdResponse>;

export const getV2LivestreamsLivestreamSessionId: (
  input: GetV2LivestreamsLivestreamSessionIdRequest
) => Effect.Effect<
  GetV2LivestreamsLivestreamSessionIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetV2LivestreamsLivestreamSessionIdRequest,
  output: GetV2LivestreamsLivestreamSessionIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetV2LivestreamSessionLivestreamIdRequest {
  account_id: string;
  app_id: string;
  page_no?: number;
  per_page?: number;
  livestream_id: string;
}

export const GetV2LivestreamSessionLivestreamIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  page_no: Schema.optional(Schema.Number).pipe(T.HttpQuery("page_no")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  livestream_id: Schema.String.pipe(T.HttpPath("livestream_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/livestreams/{livestream_id}" }),
).annotations({ identifier: "GetV2LivestreamSessionLivestreamIdRequest" }) as unknown as Schema.Schema<GetV2LivestreamSessionLivestreamIdRequest>;

export interface GetV2LivestreamSessionLivestreamIdResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetV2LivestreamSessionLivestreamIdResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetV2LivestreamSessionLivestreamIdResponse" }) as unknown as Schema.Schema<GetV2LivestreamSessionLivestreamIdResponse>;

export const getV2LivestreamSessionLivestreamId: (
  input: GetV2LivestreamSessionLivestreamIdRequest
) => Effect.Effect<
  GetV2LivestreamSessionLivestreamIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetV2LivestreamSessionLivestreamIdRequest,
  output: GetV2LivestreamSessionLivestreamIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetV2ActiveLivestreamSessionDetailsRequest {
  account_id: string;
  app_id: string;
  livestream_id: string;
}

export const GetV2ActiveLivestreamSessionDetailsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  livestream_id: Schema.String.pipe(T.HttpPath("livestream_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/livestreams/{livestream_id}/active-livestream-session" }),
).annotations({ identifier: "GetV2ActiveLivestreamSessionDetailsRequest" }) as unknown as Schema.Schema<GetV2ActiveLivestreamSessionDetailsRequest>;

export interface GetV2ActiveLivestreamSessionDetailsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetV2ActiveLivestreamSessionDetailsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetV2ActiveLivestreamSessionDetailsResponse" }) as unknown as Schema.Schema<GetV2ActiveLivestreamSessionDetailsResponse>;

export const getV2ActiveLivestreamSessionDetails: (
  input: GetV2ActiveLivestreamSessionDetailsRequest
) => Effect.Effect<
  GetV2ActiveLivestreamSessionDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetV2ActiveLivestreamSessionDetailsRequest,
  output: GetV2ActiveLivestreamSessionDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAllMeetingsRequest {
  account_id: string;
  app_id: string;
}

export const GetAllMeetingsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings" }),
).annotations({ identifier: "GetAllMeetingsRequest" }) as unknown as Schema.Schema<GetAllMeetingsRequest>;

export interface GetAllMeetingsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAllMeetingsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAllMeetingsResponse" }) as unknown as Schema.Schema<GetAllMeetingsResponse>;

export const getAllMeetings: (
  input: GetAllMeetingsRequest
) => Effect.Effect<
  GetAllMeetingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAllMeetingsRequest,
  output: GetAllMeetingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateMeetingRequest {
  account_id: string;
  app_id: string;
  body: { ai_config?: { summarization?: { summary_type?: "general" | "team_meeting" | "sales_call" | "client_check_in" | "interview" | "daily_standup" | "one_on_one_meeting" | "lecture" | "code_review"; text_format?: "plain_text" | "markdown"; word_limit?: number }; transcription?: { keywords?: string[]; language?: "en-US" | "en-IN" | "de" | "hi" | "sv" | "ru" | "pl" | "el" | "fr" | "nl"; profanity_filter?: boolean } }; live_stream_on_start?: boolean; persist_chat?: boolean; record_on_start?: boolean; recording_config?: { audio_config?: { channel?: "mono" | "stereo"; codec?: "MP3" | "AAC"; export_file?: boolean }; file_name_prefix?: string; live_streaming_config?: { rtmp_url?: string }; max_seconds?: number; realtimekit_bucket_config?: { enabled: boolean }; storage_config?: { access_key?: string; auth_method?: "KEY" | "PASSWORD"; bucket?: string; host?: string; password?: string; path?: string; port?: number; private_key?: string; region?: string; secret?: string; type: "aws" | "azure" | "digitalocean" | "gcs" | "sftp"; username?: string }; video_config?: { codec?: "H264" | "VP8"; export_file?: boolean; height?: number; watermark?: { position?: "left top" | "right top" | "left bottom" | "right bottom"; size?: { height?: number; width?: number }; url?: string }; width?: number } }; session_keep_alive_time_in_secs?: number; summarize_on_end?: boolean; title?: string };
}

export const CreateMeetingRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  body: Schema.Struct({
  ai_config: Schema.optional(Schema.Struct({
  summarization: Schema.optional(Schema.Struct({
  summary_type: Schema.optional(Schema.Literal("general", "team_meeting", "sales_call", "client_check_in", "interview", "daily_standup", "one_on_one_meeting", "lecture", "code_review")),
  text_format: Schema.optional(Schema.Literal("plain_text", "markdown")),
  word_limit: Schema.optional(Schema.Number)
})),
  transcription: Schema.optional(Schema.Struct({
  keywords: Schema.optional(Schema.Array(Schema.String)),
  language: Schema.optional(Schema.Literal("en-US", "en-IN", "de", "hi", "sv", "ru", "pl", "el", "fr", "nl")),
  profanity_filter: Schema.optional(Schema.Boolean)
}))
})),
  live_stream_on_start: Schema.optional(Schema.Boolean),
  persist_chat: Schema.optional(Schema.Boolean),
  record_on_start: Schema.optional(Schema.Boolean),
  recording_config: Schema.optional(Schema.Struct({
  audio_config: Schema.optional(Schema.Struct({
  channel: Schema.optional(Schema.Literal("mono", "stereo")),
  codec: Schema.optional(Schema.Literal("MP3", "AAC")),
  export_file: Schema.optional(Schema.Boolean)
})),
  file_name_prefix: Schema.optional(Schema.String),
  live_streaming_config: Schema.optional(Schema.Struct({
  rtmp_url: Schema.optional(Schema.String)
})),
  max_seconds: Schema.optional(Schema.Number),
  realtimekit_bucket_config: Schema.optional(Schema.Struct({
  enabled: Schema.Boolean
})),
  storage_config: Schema.optional(Schema.Struct({
  access_key: Schema.optional(Schema.String),
  auth_method: Schema.optional(Schema.Literal("KEY", "PASSWORD")),
  bucket: Schema.optional(Schema.String),
  host: Schema.optional(Schema.String),
  password: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  private_key: Schema.optional(Schema.String),
  region: Schema.optional(Schema.String),
  secret: Schema.optional(Schema.String),
  type: Schema.Literal("aws", "azure", "digitalocean", "gcs", "sftp"),
  username: Schema.optional(Schema.String)
})),
  video_config: Schema.optional(Schema.Struct({
  codec: Schema.optional(Schema.Literal("H264", "VP8")),
  export_file: Schema.optional(Schema.Boolean),
  height: Schema.optional(Schema.Number),
  watermark: Schema.optional(Schema.Struct({
  position: Schema.optional(Schema.Literal("left top", "right top", "left bottom", "right bottom")),
  size: Schema.optional(Schema.Struct({
  height: Schema.optional(Schema.Number),
  width: Schema.optional(Schema.Number)
})),
  url: Schema.optional(Schema.String)
})),
  width: Schema.optional(Schema.Number)
}))
})),
  session_keep_alive_time_in_secs: Schema.optional(Schema.Number),
  summarize_on_end: Schema.optional(Schema.Boolean),
  title: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings" }),
).annotations({ identifier: "CreateMeetingRequest" }) as unknown as Schema.Schema<CreateMeetingRequest>;

export interface CreateMeetingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateMeetingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateMeetingResponse" }) as unknown as Schema.Schema<CreateMeetingResponse>;

export const createMeeting: (
  input: CreateMeetingRequest
) => Effect.Effect<
  CreateMeetingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateMeetingRequest,
  output: CreateMeetingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetMeetingRequest {
  name?: string;
  meeting_id: string;
}

export const GetMeetingRequest = Schema.Struct({
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  meeting_id: Schema.UUID.pipe(T.HttpPath("meeting_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}" }),
).annotations({ identifier: "GetMeetingRequest" }) as unknown as Schema.Schema<GetMeetingRequest>;

export interface GetMeetingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetMeetingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetMeetingResponse" }) as unknown as Schema.Schema<GetMeetingResponse>;

export const getMeeting: (
  input: GetMeetingRequest
) => Effect.Effect<
  GetMeetingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetMeetingRequest,
  output: GetMeetingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ReplaceMeetingRequest {
  meeting_id: string;
  body: { ai_config?: { summarization?: { summary_type?: "general" | "team_meeting" | "sales_call" | "client_check_in" | "interview" | "daily_standup" | "one_on_one_meeting" | "lecture" | "code_review"; text_format?: "plain_text" | "markdown"; word_limit?: number }; transcription?: { keywords?: string[]; language?: "en-US" | "en-IN" | "de" | "hi" | "sv" | "ru" | "pl" | "el" | "fr" | "nl"; profanity_filter?: boolean } }; live_stream_on_start?: boolean; persist_chat?: boolean; record_on_start?: boolean; recording_config?: { audio_config?: { channel?: "mono" | "stereo"; codec?: "MP3" | "AAC"; export_file?: boolean }; file_name_prefix?: string; live_streaming_config?: { rtmp_url?: string }; max_seconds?: number; realtimekit_bucket_config?: { enabled: boolean }; storage_config?: { access_key?: string; auth_method?: "KEY" | "PASSWORD"; bucket?: string; host?: string; password?: string; path?: string; port?: number; private_key?: string; region?: string; secret?: string; type: "aws" | "azure" | "digitalocean" | "gcs" | "sftp"; username?: string }; video_config?: { codec?: "H264" | "VP8"; export_file?: boolean; height?: number; watermark?: { position?: "left top" | "right top" | "left bottom" | "right bottom"; size?: { height?: number; width?: number }; url?: string }; width?: number } }; session_keep_alive_time_in_secs?: number; summarize_on_end?: boolean; title?: string };
}

export const ReplaceMeetingRequest = Schema.Struct({
  meeting_id: Schema.UUID.pipe(T.HttpPath("meeting_id")),
  body: Schema.Struct({
  ai_config: Schema.optional(Schema.Struct({
  summarization: Schema.optional(Schema.Struct({
  summary_type: Schema.optional(Schema.Literal("general", "team_meeting", "sales_call", "client_check_in", "interview", "daily_standup", "one_on_one_meeting", "lecture", "code_review")),
  text_format: Schema.optional(Schema.Literal("plain_text", "markdown")),
  word_limit: Schema.optional(Schema.Number)
})),
  transcription: Schema.optional(Schema.Struct({
  keywords: Schema.optional(Schema.Array(Schema.String)),
  language: Schema.optional(Schema.Literal("en-US", "en-IN", "de", "hi", "sv", "ru", "pl", "el", "fr", "nl")),
  profanity_filter: Schema.optional(Schema.Boolean)
}))
})),
  live_stream_on_start: Schema.optional(Schema.Boolean),
  persist_chat: Schema.optional(Schema.Boolean),
  record_on_start: Schema.optional(Schema.Boolean),
  recording_config: Schema.optional(Schema.Struct({
  audio_config: Schema.optional(Schema.Struct({
  channel: Schema.optional(Schema.Literal("mono", "stereo")),
  codec: Schema.optional(Schema.Literal("MP3", "AAC")),
  export_file: Schema.optional(Schema.Boolean)
})),
  file_name_prefix: Schema.optional(Schema.String),
  live_streaming_config: Schema.optional(Schema.Struct({
  rtmp_url: Schema.optional(Schema.String)
})),
  max_seconds: Schema.optional(Schema.Number),
  realtimekit_bucket_config: Schema.optional(Schema.Struct({
  enabled: Schema.Boolean
})),
  storage_config: Schema.optional(Schema.Struct({
  access_key: Schema.optional(Schema.String),
  auth_method: Schema.optional(Schema.Literal("KEY", "PASSWORD")),
  bucket: Schema.optional(Schema.String),
  host: Schema.optional(Schema.String),
  password: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  private_key: Schema.optional(Schema.String),
  region: Schema.optional(Schema.String),
  secret: Schema.optional(Schema.String),
  type: Schema.Literal("aws", "azure", "digitalocean", "gcs", "sftp"),
  username: Schema.optional(Schema.String)
})),
  video_config: Schema.optional(Schema.Struct({
  codec: Schema.optional(Schema.Literal("H264", "VP8")),
  export_file: Schema.optional(Schema.Boolean),
  height: Schema.optional(Schema.Number),
  watermark: Schema.optional(Schema.Struct({
  position: Schema.optional(Schema.Literal("left top", "right top", "left bottom", "right bottom")),
  size: Schema.optional(Schema.Struct({
  height: Schema.optional(Schema.Number),
  width: Schema.optional(Schema.Number)
})),
  url: Schema.optional(Schema.String)
})),
  width: Schema.optional(Schema.Number)
}))
})),
  session_keep_alive_time_in_secs: Schema.optional(Schema.Number),
  summarize_on_end: Schema.optional(Schema.Boolean),
  title: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}" }),
).annotations({ identifier: "ReplaceMeetingRequest" }) as unknown as Schema.Schema<ReplaceMeetingRequest>;

export interface ReplaceMeetingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ReplaceMeetingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ReplaceMeetingResponse" }) as unknown as Schema.Schema<ReplaceMeetingResponse>;

export const replaceMeeting: (
  input: ReplaceMeetingRequest
) => Effect.Effect<
  ReplaceMeetingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ReplaceMeetingRequest,
  output: ReplaceMeetingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateMeetingRequest {
  meeting_id: string;
  body: { ai_config?: { summarization?: { summary_type?: "general" | "team_meeting" | "sales_call" | "client_check_in" | "interview" | "daily_standup" | "one_on_one_meeting" | "lecture" | "code_review"; text_format?: "plain_text" | "markdown"; word_limit?: number }; transcription?: { keywords?: string[]; language?: "en-US" | "en-IN" | "de" | "hi" | "sv" | "ru" | "pl" | "el" | "fr" | "nl"; profanity_filter?: boolean } }; live_stream_on_start?: boolean; persist_chat?: boolean; record_on_start?: boolean; session_keep_alive_time_in_secs?: number; status?: "ACTIVE" | "INACTIVE"; summarize_on_end?: boolean; title?: string };
}

export const UpdateMeetingRequest = Schema.Struct({
  meeting_id: Schema.UUID.pipe(T.HttpPath("meeting_id")),
  body: Schema.Struct({
  ai_config: Schema.optional(Schema.Struct({
  summarization: Schema.optional(Schema.Struct({
  summary_type: Schema.optional(Schema.Literal("general", "team_meeting", "sales_call", "client_check_in", "interview", "daily_standup", "one_on_one_meeting", "lecture", "code_review")),
  text_format: Schema.optional(Schema.Literal("plain_text", "markdown")),
  word_limit: Schema.optional(Schema.Number)
})),
  transcription: Schema.optional(Schema.Struct({
  keywords: Schema.optional(Schema.Array(Schema.String)),
  language: Schema.optional(Schema.Literal("en-US", "en-IN", "de", "hi", "sv", "ru", "pl", "el", "fr", "nl")),
  profanity_filter: Schema.optional(Schema.Boolean)
}))
})),
  live_stream_on_start: Schema.optional(Schema.Boolean),
  persist_chat: Schema.optional(Schema.Boolean),
  record_on_start: Schema.optional(Schema.Boolean),
  session_keep_alive_time_in_secs: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("ACTIVE", "INACTIVE")),
  summarize_on_end: Schema.optional(Schema.Boolean),
  title: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}" }),
).annotations({ identifier: "UpdateMeetingRequest" }) as unknown as Schema.Schema<UpdateMeetingRequest>;

export interface UpdateMeetingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateMeetingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateMeetingResponse" }) as unknown as Schema.Schema<UpdateMeetingResponse>;

export const updateMeeting: (
  input: UpdateMeetingRequest
) => Effect.Effect<
  UpdateMeetingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateMeetingRequest,
  output: UpdateMeetingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetV2MeetingsMeetingidActiveLivestreamRequest {
  meeting_id: string;
}

export const GetV2MeetingsMeetingidActiveLivestreamRequest = Schema.Struct({
  meeting_id: Schema.UUID.pipe(T.HttpPath("meeting_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}/active-livestream" }),
).annotations({ identifier: "GetV2MeetingsMeetingidActiveLivestreamRequest" }) as unknown as Schema.Schema<GetV2MeetingsMeetingidActiveLivestreamRequest>;

export interface GetV2MeetingsMeetingidActiveLivestreamResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetV2MeetingsMeetingidActiveLivestreamResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetV2MeetingsMeetingidActiveLivestreamResponse" }) as unknown as Schema.Schema<GetV2MeetingsMeetingidActiveLivestreamResponse>;

export const getV2MeetingsMeetingidActiveLivestream: (
  input: GetV2MeetingsMeetingidActiveLivestreamRequest
) => Effect.Effect<
  GetV2MeetingsMeetingidActiveLivestreamResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetV2MeetingsMeetingidActiveLivestreamRequest,
  output: GetV2MeetingsMeetingidActiveLivestreamResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface StopLivestreamingRequest {
  meeting_id: string;
}

export const StopLivestreamingRequest = Schema.Struct({
  meeting_id: Schema.UUID.pipe(T.HttpPath("meeting_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}/active-livestream/stop" }),
).annotations({ identifier: "StopLivestreamingRequest" }) as unknown as Schema.Schema<StopLivestreamingRequest>;

export interface StopLivestreamingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const StopLivestreamingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "StopLivestreamingResponse" }) as unknown as Schema.Schema<StopLivestreamingResponse>;

export const stopLivestreaming: (
  input: StopLivestreamingRequest
) => Effect.Effect<
  StopLivestreamingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: StopLivestreamingRequest,
  output: StopLivestreamingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetactivesessionRequest {
}

export const GetactivesessionRequest = Schema.Struct({

}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}/active-session" }),
).annotations({ identifier: "GetactivesessionRequest" }) as unknown as Schema.Schema<GetactivesessionRequest>;

export interface GetactivesessionResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetactivesessionResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetactivesessionResponse" }) as unknown as Schema.Schema<GetactivesessionResponse>;

export const getactivesession: (
  input: GetactivesessionRequest
) => Effect.Effect<
  GetactivesessionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetactivesessionRequest,
  output: GetactivesessionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface KickpartcipantsRequest {
  account_id: string;
  app_id: string;
  body: { custom_participant_ids: string[]; participant_ids: string[] };
}

export const KickpartcipantsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  body: Schema.Struct({
  custom_participant_ids: Schema.Array(Schema.String),
  participant_ids: Schema.Array(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}/active-session/kick" }),
).annotations({ identifier: "KickpartcipantsRequest" }) as unknown as Schema.Schema<KickpartcipantsRequest>;

export interface KickpartcipantsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const KickpartcipantsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "KickpartcipantsResponse" }) as unknown as Schema.Schema<KickpartcipantsResponse>;

export const kickpartcipants: (
  input: KickpartcipantsRequest
) => Effect.Effect<
  KickpartcipantsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: KickpartcipantsRequest,
  output: KickpartcipantsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface KickallparticipantsRequest {
  account_id: string;
  app_id: string;
}

export const KickallparticipantsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}/active-session/kick-all" }),
).annotations({ identifier: "KickallparticipantsRequest" }) as unknown as Schema.Schema<KickallparticipantsRequest>;

export interface KickallparticipantsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const KickallparticipantsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "KickallparticipantsResponse" }) as unknown as Schema.Schema<KickallparticipantsResponse>;

export const kickallparticipants: (
  input: KickallparticipantsRequest
) => Effect.Effect<
  KickallparticipantsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: KickallparticipantsRequest,
  output: KickallparticipantsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MuteparticipantsRequest {
  account_id: string;
  app_id: string;
  body: { custom_participant_ids: string[]; participant_ids: string[] };
}

export const MuteparticipantsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  body: Schema.Struct({
  custom_participant_ids: Schema.Array(Schema.String),
  participant_ids: Schema.Array(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}/active-session/mute" }),
).annotations({ identifier: "MuteparticipantsRequest" }) as unknown as Schema.Schema<MuteparticipantsRequest>;

export interface MuteparticipantsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MuteparticipantsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MuteparticipantsResponse" }) as unknown as Schema.Schema<MuteparticipantsResponse>;

export const muteparticipants: (
  input: MuteparticipantsRequest
) => Effect.Effect<
  MuteparticipantsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MuteparticipantsRequest,
  output: MuteparticipantsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface MuteallparticipantsRequest {
  account_id: string;
  app_id: string;
  body: { allow_unmute: boolean };
}

export const MuteallparticipantsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  body: Schema.Struct({
  allow_unmute: Schema.Boolean
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}/active-session/mute-all" }),
).annotations({ identifier: "MuteallparticipantsRequest" }) as unknown as Schema.Schema<MuteallparticipantsRequest>;

export interface MuteallparticipantsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const MuteallparticipantsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "MuteallparticipantsResponse" }) as unknown as Schema.Schema<MuteallparticipantsResponse>;

export const muteallparticipants: (
  input: MuteallparticipantsRequest
) => Effect.Effect<
  MuteallparticipantsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: MuteallparticipantsRequest,
  output: MuteallparticipantsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatepollRequest {
  account_id: string;
  app_id: string;
  body: { anonymous?: boolean; hide_votes?: boolean; options: string[]; question: string };
}

export const CreatepollRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  body: Schema.Struct({
  anonymous: Schema.optional(Schema.Boolean),
  hide_votes: Schema.optional(Schema.Boolean),
  options: Schema.Array(Schema.String),
  question: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}/active-session/poll" }),
).annotations({ identifier: "CreatepollRequest" }) as unknown as Schema.Schema<CreatepollRequest>;

export interface CreatepollResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatepollResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatepollResponse" }) as unknown as Schema.Schema<CreatepollResponse>;

export const createpoll: (
  input: CreatepollRequest
) => Effect.Effect<
  CreatepollResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatepollRequest,
  output: CreatepollResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface LivestreamSessionDetailsRequest {
  page_no?: number;
  per_page?: number;
  meeting_id: string;
}

export const LivestreamSessionDetailsRequest = Schema.Struct({
  page_no: Schema.optional(Schema.Number).pipe(T.HttpQuery("page_no")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  meeting_id: Schema.UUID.pipe(T.HttpPath("meeting_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}/livestream" }),
).annotations({ identifier: "LivestreamSessionDetailsRequest" }) as unknown as Schema.Schema<LivestreamSessionDetailsRequest>;

export interface LivestreamSessionDetailsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const LivestreamSessionDetailsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "LivestreamSessionDetailsResponse" }) as unknown as Schema.Schema<LivestreamSessionDetailsResponse>;

export const livestreamSessionDetails: (
  input: LivestreamSessionDetailsRequest
) => Effect.Effect<
  LivestreamSessionDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: LivestreamSessionDetailsRequest,
  output: LivestreamSessionDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface StartLivestreamingRequest {
  meeting_id: string;
  body: { name?: string; video_config?: { height?: number; width?: number } };
}

export const StartLivestreamingRequest = Schema.Struct({
  meeting_id: Schema.UUID.pipe(T.HttpPath("meeting_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String),
  video_config: Schema.optional(Schema.Struct({
  height: Schema.optional(Schema.Number),
  width: Schema.optional(Schema.Number)
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}/livestreams" }),
).annotations({ identifier: "StartLivestreamingRequest" }) as unknown as Schema.Schema<StartLivestreamingRequest>;

export interface StartLivestreamingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const StartLivestreamingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "StartLivestreamingResponse" }) as unknown as Schema.Schema<StartLivestreamingResponse>;

export const startLivestreaming: (
  input: StartLivestreamingRequest
) => Effect.Effect<
  StartLivestreamingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: StartLivestreamingRequest,
  output: StartLivestreamingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetMeetingParticipantsRequest {
  account_id: string;
  app_id: string;
  meeting_id: string;
}

export const GetMeetingParticipantsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  meeting_id: Schema.UUID.pipe(T.HttpPath("meeting_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}/participants" }),
).annotations({ identifier: "GetMeetingParticipantsRequest" }) as unknown as Schema.Schema<GetMeetingParticipantsRequest>;

export interface GetMeetingParticipantsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetMeetingParticipantsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetMeetingParticipantsResponse" }) as unknown as Schema.Schema<GetMeetingParticipantsResponse>;

export const getMeetingParticipants: (
  input: GetMeetingParticipantsRequest
) => Effect.Effect<
  GetMeetingParticipantsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetMeetingParticipantsRequest,
  output: GetMeetingParticipantsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AddParticipantRequest {
  account_id: string;
  app_id: string;
  meeting_id: string;
  body: { custom_participant_id: string; name?: string; picture?: string; preset_name: string };
}

export const AddParticipantRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  meeting_id: Schema.UUID.pipe(T.HttpPath("meeting_id")),
  body: Schema.Struct({
  custom_participant_id: Schema.String,
  name: Schema.optional(Schema.String),
  picture: Schema.optional(Schema.String),
  preset_name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}/participants" }),
).annotations({ identifier: "AddParticipantRequest" }) as unknown as Schema.Schema<AddParticipantRequest>;

export interface AddParticipantResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AddParticipantResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AddParticipantResponse" }) as unknown as Schema.Schema<AddParticipantResponse>;

export const addParticipant: (
  input: AddParticipantRequest
) => Effect.Effect<
  AddParticipantResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AddParticipantRequest,
  output: AddParticipantResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetMeetingParticipantRequest {
  meeting_id: string;
  participant_id: string;
}

export const GetMeetingParticipantRequest = Schema.Struct({
  meeting_id: Schema.UUID.pipe(T.HttpPath("meeting_id")),
  participant_id: Schema.String.pipe(T.HttpPath("participant_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}/participants/{participant_id}" }),
).annotations({ identifier: "GetMeetingParticipantRequest" }) as unknown as Schema.Schema<GetMeetingParticipantRequest>;

export interface GetMeetingParticipantResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetMeetingParticipantResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetMeetingParticipantResponse" }) as unknown as Schema.Schema<GetMeetingParticipantResponse>;

export const getMeetingParticipant: (
  input: GetMeetingParticipantRequest
) => Effect.Effect<
  GetMeetingParticipantResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetMeetingParticipantRequest,
  output: GetMeetingParticipantResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteMeetingParticipantRequest {
  meeting_id: string;
  participant_id: string;
}

export const DeleteMeetingParticipantRequest = Schema.Struct({
  meeting_id: Schema.UUID.pipe(T.HttpPath("meeting_id")),
  participant_id: Schema.String.pipe(T.HttpPath("participant_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}/participants/{participant_id}" }),
).annotations({ identifier: "DeleteMeetingParticipantRequest" }) as unknown as Schema.Schema<DeleteMeetingParticipantRequest>;

export interface DeleteMeetingParticipantResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteMeetingParticipantResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteMeetingParticipantResponse" }) as unknown as Schema.Schema<DeleteMeetingParticipantResponse>;

export const deleteMeetingParticipant: (
  input: DeleteMeetingParticipantRequest
) => Effect.Effect<
  DeleteMeetingParticipantResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteMeetingParticipantRequest,
  output: DeleteMeetingParticipantResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface EditParticipantRequest {
  meeting_id: string;
  participant_id: string;
  body: { name?: string; picture?: string; preset_name?: string };
}

export const EditParticipantRequest = Schema.Struct({
  meeting_id: Schema.UUID.pipe(T.HttpPath("meeting_id")),
  participant_id: Schema.String.pipe(T.HttpPath("participant_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String),
  picture: Schema.optional(Schema.String),
  preset_name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}/participants/{participant_id}" }),
).annotations({ identifier: "EditParticipantRequest" }) as unknown as Schema.Schema<EditParticipantRequest>;

export interface EditParticipantResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const EditParticipantResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "EditParticipantResponse" }) as unknown as Schema.Schema<EditParticipantResponse>;

export const editParticipant: (
  input: EditParticipantRequest
) => Effect.Effect<
  EditParticipantResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: EditParticipantRequest,
  output: EditParticipantResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface RegenerateTokenRequest {
  account_id: string;
  app_id: string;
  meeting_id: string;
  participant_id: string;
}

export const RegenerateTokenRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  meeting_id: Schema.UUID.pipe(T.HttpPath("meeting_id")),
  participant_id: Schema.String.pipe(T.HttpPath("participant_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/{app_id}/meetings/{meeting_id}/participants/{participant_id}/token" }),
).annotations({ identifier: "RegenerateTokenRequest" }) as unknown as Schema.Schema<RegenerateTokenRequest>;

export interface RegenerateTokenResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const RegenerateTokenResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "RegenerateTokenResponse" }) as unknown as Schema.Schema<RegenerateTokenResponse>;

export const regenerateToken: (
  input: RegenerateTokenRequest
) => Effect.Effect<
  RegenerateTokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: RegenerateTokenRequest,
  output: RegenerateTokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetPresetsRequest {
  account_id: string;
  app_id: string;
}

export const GetPresetsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/presets" }),
).annotations({ identifier: "GetPresetsRequest" }) as unknown as Schema.Schema<GetPresetsRequest>;

export interface GetPresetsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetPresetsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetPresetsResponse" }) as unknown as Schema.Schema<GetPresetsResponse>;

export const getPresets: (
  input: GetPresetsRequest
) => Effect.Effect<
  GetPresetsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetPresetsRequest,
  output: GetPresetsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostPresetsRequest {
  account_id: string;
  app_id: string;
  body: { config: { max_screenshare_count: number; max_video_streams: { desktop: number; mobile: number }; media: { audio?: { enable_high_bitrate?: boolean; enable_stereo?: boolean }; screenshare: { frame_rate: number; quality: "hd" | "vga" | "qvga" }; video: { frame_rate: number; quality: "hd" | "vga" | "qvga" } }; view_type: "GROUP_CALL" | "WEBINAR" | "AUDIO_ROOM" }; name: string; permissions?: { accept_waiting_requests: boolean; can_accept_production_requests: boolean; can_change_participant_permissions: boolean; can_edit_display_name: boolean; can_livestream: boolean; can_record: boolean; can_spotlight: boolean; chat: { private: { can_receive: boolean; can_send: boolean; files: boolean; text: boolean }; public: { can_send: boolean; files: boolean; text: boolean } }; connected_meetings: { can_alter_connected_meetings: boolean; can_switch_connected_meetings: boolean; can_switch_to_parent_meeting: boolean }; disable_participant_audio: boolean; disable_participant_screensharing: boolean; disable_participant_video: boolean; hidden_participant: boolean; is_recorder?: boolean; kick_participant: boolean; media: { audio: { can_produce: "ALLOWED" | "NOT_ALLOWED" | "CAN_REQUEST" }; screenshare: { can_produce: "ALLOWED" | "NOT_ALLOWED" | "CAN_REQUEST" }; video: { can_produce: "ALLOWED" | "NOT_ALLOWED" | "CAN_REQUEST" } }; pin_participant: boolean; plugins: { can_close: boolean; can_edit_config: boolean; can_start: boolean; config: unknown }; polls: { can_create: boolean; can_view: boolean; can_vote: boolean }; recorder_type: "RECORDER" | "LIVESTREAMER" | "NONE"; show_participant_list: boolean; waiting_room_type: "SKIP" | "ON_PRIVILEGED_USER_ENTRY" | "SKIP_ON_ACCEPT" }; ui: { config_diff?: Record<string, unknown>; design_tokens: { border_radius: "rounded"; border_width: "thin"; colors: { background: { "600": string; "700": string; "800": string; "900": string; "1000": string }; brand: { "300": string; "400": string; "500": string; "600": string; "700": string }; danger: string; success: string; text: string; text_on_brand: string; video_bg: string; warning: string }; logo: string; spacing_base: number; theme: "dark" } } };
}

export const PostPresetsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  body: Schema.Struct({
  config: Schema.Struct({
  max_screenshare_count: Schema.Number,
  max_video_streams: Schema.Struct({
  desktop: Schema.Number,
  mobile: Schema.Number
}),
  media: Schema.Struct({
  audio: Schema.optional(Schema.Struct({
  enable_high_bitrate: Schema.optional(Schema.Boolean),
  enable_stereo: Schema.optional(Schema.Boolean)
})),
  screenshare: Schema.Struct({
  frame_rate: Schema.Number,
  quality: Schema.Literal("hd", "vga", "qvga")
}),
  video: Schema.Struct({
  frame_rate: Schema.Number,
  quality: Schema.Literal("hd", "vga", "qvga")
})
}),
  view_type: Schema.Literal("GROUP_CALL", "WEBINAR", "AUDIO_ROOM")
}),
  name: Schema.String,
  permissions: Schema.optional(Schema.Struct({
  accept_waiting_requests: Schema.Boolean,
  can_accept_production_requests: Schema.Boolean,
  can_change_participant_permissions: Schema.Boolean,
  can_edit_display_name: Schema.Boolean,
  can_livestream: Schema.Boolean,
  can_record: Schema.Boolean,
  can_spotlight: Schema.Boolean,
  chat: Schema.Struct({
  private: Schema.Struct({
  can_receive: Schema.Boolean,
  can_send: Schema.Boolean,
  files: Schema.Boolean,
  text: Schema.Boolean
}),
  public: Schema.Struct({
  can_send: Schema.Boolean,
  files: Schema.Boolean,
  text: Schema.Boolean
})
}),
  connected_meetings: Schema.Struct({
  can_alter_connected_meetings: Schema.Boolean,
  can_switch_connected_meetings: Schema.Boolean,
  can_switch_to_parent_meeting: Schema.Boolean
}),
  disable_participant_audio: Schema.Boolean,
  disable_participant_screensharing: Schema.Boolean,
  disable_participant_video: Schema.Boolean,
  hidden_participant: Schema.Boolean,
  is_recorder: Schema.optional(Schema.Boolean),
  kick_participant: Schema.Boolean,
  media: Schema.Struct({
  audio: Schema.Struct({
  can_produce: Schema.Literal("ALLOWED", "NOT_ALLOWED", "CAN_REQUEST")
}),
  screenshare: Schema.Struct({
  can_produce: Schema.Literal("ALLOWED", "NOT_ALLOWED", "CAN_REQUEST")
}),
  video: Schema.Struct({
  can_produce: Schema.Literal("ALLOWED", "NOT_ALLOWED", "CAN_REQUEST")
})
}),
  pin_participant: Schema.Boolean,
  plugins: Schema.Struct({
  can_close: Schema.Boolean,
  can_edit_config: Schema.Boolean,
  can_start: Schema.Boolean,
  config: Schema.Union(Schema.UUID, Schema.Struct({
  access_control: Schema.Literal("FULL_ACCESS", "VIEW_ONLY"),
  handles_view_only: Schema.Boolean
}))
}),
  polls: Schema.Struct({
  can_create: Schema.Boolean,
  can_view: Schema.Boolean,
  can_vote: Schema.Boolean
}),
  recorder_type: Schema.Literal("RECORDER", "LIVESTREAMER", "NONE"),
  show_participant_list: Schema.Boolean,
  waiting_room_type: Schema.Literal("SKIP", "ON_PRIVILEGED_USER_ENTRY", "SKIP_ON_ACCEPT")
})),
  ui: Schema.Struct({
  config_diff: Schema.optional(Schema.Struct({})),
  design_tokens: Schema.Struct({
  border_radius: Schema.Literal("rounded"),
  border_width: Schema.Literal("thin"),
  colors: Schema.Struct({
  background: Schema.Struct({
  "600": Schema.String,
  "700": Schema.String,
  "800": Schema.String,
  "900": Schema.String,
  "1000": Schema.String
}),
  brand: Schema.Struct({
  "300": Schema.String,
  "400": Schema.String,
  "500": Schema.String,
  "600": Schema.String,
  "700": Schema.String
}),
  danger: Schema.String,
  success: Schema.String,
  text: Schema.String,
  text_on_brand: Schema.String,
  video_bg: Schema.String,
  warning: Schema.String
}),
  logo: Schema.String,
  spacing_base: Schema.Number,
  theme: Schema.Literal("dark")
})
})
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/{app_id}/presets" }),
).annotations({ identifier: "PostPresetsRequest" }) as unknown as Schema.Schema<PostPresetsRequest>;

export interface PostPresetsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostPresetsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostPresetsResponse" }) as unknown as Schema.Schema<PostPresetsResponse>;

export const postPresets: (
  input: PostPresetsRequest
) => Effect.Effect<
  PostPresetsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostPresetsRequest,
  output: PostPresetsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetPresetsPresetIdRequest {
  account_id: string;
  app_id: string;
  preset_id: string;
}

export const GetPresetsPresetIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  preset_id: Schema.String.pipe(T.HttpPath("preset_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/presets/{preset_id}" }),
).annotations({ identifier: "GetPresetsPresetIdRequest" }) as unknown as Schema.Schema<GetPresetsPresetIdRequest>;

export interface GetPresetsPresetIdResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetPresetsPresetIdResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetPresetsPresetIdResponse" }) as unknown as Schema.Schema<GetPresetsPresetIdResponse>;

export const getPresetsPresetId: (
  input: GetPresetsPresetIdRequest
) => Effect.Effect<
  GetPresetsPresetIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetPresetsPresetIdRequest,
  output: GetPresetsPresetIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletePresetsPresetIdRequest {
  account_id: string;
  app_id: string;
  preset_id: string;
}

export const DeletePresetsPresetIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  preset_id: Schema.String.pipe(T.HttpPath("preset_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/realtime/kit/{app_id}/presets/{preset_id}" }),
).annotations({ identifier: "DeletePresetsPresetIdRequest" }) as unknown as Schema.Schema<DeletePresetsPresetIdRequest>;

export interface DeletePresetsPresetIdResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletePresetsPresetIdResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletePresetsPresetIdResponse" }) as unknown as Schema.Schema<DeletePresetsPresetIdResponse>;

export const deletePresetsPresetId: (
  input: DeletePresetsPresetIdRequest
) => Effect.Effect<
  DeletePresetsPresetIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletePresetsPresetIdRequest,
  output: DeletePresetsPresetIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchPresetsPresetIdRequest {
  account_id: string;
  app_id: string;
  preset_id: string;
  body: { config?: { max_screenshare_count?: number; max_video_streams?: { desktop?: number; mobile?: number }; media?: { screenshare?: { frame_rate?: number; quality?: "hd" | "vga" | "qvga" }; video?: { frame_rate?: number; quality?: "hd" | "vga" | "qvga" } }; view_type?: "GROUP_CALL" | "WEBINAR" | "AUDIO_ROOM" }; name?: string; permissions?: { accept_waiting_requests?: boolean; can_accept_production_requests?: boolean; can_change_participant_permissions?: boolean; can_edit_display_name?: boolean; can_livestream?: boolean; can_record?: boolean; can_spotlight?: boolean; chat?: { private?: { can_receive?: boolean; can_send?: boolean; files?: boolean; text?: boolean }; public?: { can_send?: boolean; files?: boolean; text?: boolean } }; connected_meetings?: { can_alter_connected_meetings?: boolean; can_switch_connected_meetings?: boolean; can_switch_to_parent_meeting?: boolean }; disable_participant_audio?: boolean; disable_participant_screensharing?: boolean; disable_participant_video?: boolean; hidden_participant?: boolean; is_recorder?: boolean; kick_participant?: boolean; media?: { audio?: { can_produce?: "ALLOWED" | "NOT_ALLOWED" | "CAN_REQUEST" }; screenshare?: { can_produce?: "ALLOWED" | "NOT_ALLOWED" | "CAN_REQUEST" }; video?: { can_produce?: "ALLOWED" | "NOT_ALLOWED" | "CAN_REQUEST" } }; pin_participant?: boolean; plugins?: { can_close?: boolean; can_edit_config?: boolean; can_start?: boolean; config?: unknown }; polls?: { can_create?: boolean; can_view?: boolean; can_vote?: boolean }; recorder_type?: "RECORDER" | "LIVESTREAMER" | "NONE"; show_participant_list?: boolean; waiting_room_type?: "SKIP" | "ON_PRIVILEGED_USER_ENTRY" | "SKIP_ON_ACCEPT" }; ui?: { config_diff?: Record<string, unknown>; design_tokens?: { border_radius?: "rounded"; border_width?: "thin"; colors?: { background?: { "600"?: string; "700"?: string; "800"?: string; "900"?: string; "1000"?: string }; brand?: { "300"?: string; "400"?: string; "500"?: string; "600"?: string; "700"?: string }; danger?: string; success?: string; text?: string; text_on_brand?: string; video_bg?: string; warning?: string }; logo?: string; spacing_base?: number; theme?: "dark" } } };
}

export const PatchPresetsPresetIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  preset_id: Schema.String.pipe(T.HttpPath("preset_id")),
  body: Schema.Struct({
  config: Schema.optional(Schema.Struct({
  max_screenshare_count: Schema.optional(Schema.Number),
  max_video_streams: Schema.optional(Schema.Struct({
  desktop: Schema.optional(Schema.Number),
  mobile: Schema.optional(Schema.Number)
})),
  media: Schema.optional(Schema.Struct({
  screenshare: Schema.optional(Schema.Struct({
  frame_rate: Schema.optional(Schema.Number),
  quality: Schema.optional(Schema.Literal("hd", "vga", "qvga"))
})),
  video: Schema.optional(Schema.Struct({
  frame_rate: Schema.optional(Schema.Number),
  quality: Schema.optional(Schema.Literal("hd", "vga", "qvga"))
}))
})),
  view_type: Schema.optional(Schema.Literal("GROUP_CALL", "WEBINAR", "AUDIO_ROOM"))
})),
  name: Schema.optional(Schema.String),
  permissions: Schema.optional(Schema.Struct({
  accept_waiting_requests: Schema.optional(Schema.Boolean),
  can_accept_production_requests: Schema.optional(Schema.Boolean),
  can_change_participant_permissions: Schema.optional(Schema.Boolean),
  can_edit_display_name: Schema.optional(Schema.Boolean),
  can_livestream: Schema.optional(Schema.Boolean),
  can_record: Schema.optional(Schema.Boolean),
  can_spotlight: Schema.optional(Schema.Boolean),
  chat: Schema.optional(Schema.Struct({
  private: Schema.optional(Schema.Struct({
  can_receive: Schema.optional(Schema.Boolean),
  can_send: Schema.optional(Schema.Boolean),
  files: Schema.optional(Schema.Boolean),
  text: Schema.optional(Schema.Boolean)
})),
  public: Schema.optional(Schema.Struct({
  can_send: Schema.optional(Schema.Boolean),
  files: Schema.optional(Schema.Boolean),
  text: Schema.optional(Schema.Boolean)
}))
})),
  connected_meetings: Schema.optional(Schema.Struct({
  can_alter_connected_meetings: Schema.optional(Schema.Boolean),
  can_switch_connected_meetings: Schema.optional(Schema.Boolean),
  can_switch_to_parent_meeting: Schema.optional(Schema.Boolean)
})),
  disable_participant_audio: Schema.optional(Schema.Boolean),
  disable_participant_screensharing: Schema.optional(Schema.Boolean),
  disable_participant_video: Schema.optional(Schema.Boolean),
  hidden_participant: Schema.optional(Schema.Boolean),
  is_recorder: Schema.optional(Schema.Boolean),
  kick_participant: Schema.optional(Schema.Boolean),
  media: Schema.optional(Schema.Struct({
  audio: Schema.optional(Schema.Struct({
  can_produce: Schema.optional(Schema.Literal("ALLOWED", "NOT_ALLOWED", "CAN_REQUEST"))
})),
  screenshare: Schema.optional(Schema.Struct({
  can_produce: Schema.optional(Schema.Literal("ALLOWED", "NOT_ALLOWED", "CAN_REQUEST"))
})),
  video: Schema.optional(Schema.Struct({
  can_produce: Schema.optional(Schema.Literal("ALLOWED", "NOT_ALLOWED", "CAN_REQUEST"))
}))
})),
  pin_participant: Schema.optional(Schema.Boolean),
  plugins: Schema.optional(Schema.Struct({
  can_close: Schema.optional(Schema.Boolean),
  can_edit_config: Schema.optional(Schema.Boolean),
  can_start: Schema.optional(Schema.Boolean),
  config: Schema.optional(Schema.Union(Schema.UUID, Schema.Struct({
  access_control: Schema.optional(Schema.Literal("FULL_ACCESS", "VIEW_ONLY")),
  handles_view_only: Schema.optional(Schema.Boolean)
})))
})),
  polls: Schema.optional(Schema.Struct({
  can_create: Schema.optional(Schema.Boolean),
  can_view: Schema.optional(Schema.Boolean),
  can_vote: Schema.optional(Schema.Boolean)
})),
  recorder_type: Schema.optional(Schema.Literal("RECORDER", "LIVESTREAMER", "NONE")),
  show_participant_list: Schema.optional(Schema.Boolean),
  waiting_room_type: Schema.optional(Schema.Literal("SKIP", "ON_PRIVILEGED_USER_ENTRY", "SKIP_ON_ACCEPT"))
})),
  ui: Schema.optional(Schema.Struct({
  config_diff: Schema.optional(Schema.Struct({})),
  design_tokens: Schema.optional(Schema.Struct({
  border_radius: Schema.optional(Schema.Literal("rounded")),
  border_width: Schema.optional(Schema.Literal("thin")),
  colors: Schema.optional(Schema.Struct({
  background: Schema.optional(Schema.Struct({
  "600": Schema.optional(Schema.String),
  "700": Schema.optional(Schema.String),
  "800": Schema.optional(Schema.String),
  "900": Schema.optional(Schema.String),
  "1000": Schema.optional(Schema.String)
})),
  brand: Schema.optional(Schema.Struct({
  "300": Schema.optional(Schema.String),
  "400": Schema.optional(Schema.String),
  "500": Schema.optional(Schema.String),
  "600": Schema.optional(Schema.String),
  "700": Schema.optional(Schema.String)
})),
  danger: Schema.optional(Schema.String),
  success: Schema.optional(Schema.String),
  text: Schema.optional(Schema.String),
  text_on_brand: Schema.optional(Schema.String),
  video_bg: Schema.optional(Schema.String),
  warning: Schema.optional(Schema.String)
})),
  logo: Schema.optional(Schema.String),
  spacing_base: Schema.optional(Schema.Number),
  theme: Schema.optional(Schema.Literal("dark"))
}))
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/realtime/kit/{app_id}/presets/{preset_id}" }),
).annotations({ identifier: "PatchPresetsPresetIdRequest" }) as unknown as Schema.Schema<PatchPresetsPresetIdRequest>;

export interface PatchPresetsPresetIdResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchPresetsPresetIdResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchPresetsPresetIdResponse" }) as unknown as Schema.Schema<PatchPresetsPresetIdResponse>;

export const patchPresetsPresetId: (
  input: PatchPresetsPresetIdRequest
) => Effect.Effect<
  PatchPresetsPresetIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchPresetsPresetIdRequest,
  output: PatchPresetsPresetIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAllRecordingsRequest {
  account_id: string;
  app_id: string;
  meeting_id?: string;
  expired?: boolean;
}

export const GetAllRecordingsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  meeting_id: Schema.optional(Schema.UUID).pipe(T.HttpQuery("meeting_id")),
  expired: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("expired"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/recordings" }),
).annotations({ identifier: "GetAllRecordingsRequest" }) as unknown as Schema.Schema<GetAllRecordingsRequest>;

export interface GetAllRecordingsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAllRecordingsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAllRecordingsResponse" }) as unknown as Schema.Schema<GetAllRecordingsResponse>;

export const getAllRecordings: (
  input: GetAllRecordingsRequest
) => Effect.Effect<
  GetAllRecordingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAllRecordingsRequest,
  output: GetAllRecordingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface StartRecordingRequest {
  account_id: string;
  app_id: string;
  body: { allow_multiple_recordings?: boolean; audio_config?: { channel?: "mono" | "stereo"; codec?: "MP3" | "AAC"; export_file?: boolean }; file_name_prefix?: string; interactive_config?: { type?: "ID3" }; max_seconds?: number; meeting_id?: string; realtimekit_bucket_config?: { enabled: boolean }; rtmp_out_config?: { rtmp_url?: string }; storage_config?: { access_key?: string; auth_method?: "KEY" | "PASSWORD"; bucket?: string; host?: string; password?: string; path?: string; port?: number; private_key?: string; region?: string; secret?: string; type: "aws" | "azure" | "digitalocean" | "gcs" | "sftp"; username?: string }; url?: string; video_config?: { codec?: "H264" | "VP8"; export_file?: boolean; height?: number; watermark?: { position?: "left top" | "right top" | "left bottom" | "right bottom"; size?: { height?: number; width?: number }; url?: string }; width?: number } };
}

export const StartRecordingRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  body: Schema.Struct({
  allow_multiple_recordings: Schema.optional(Schema.Boolean),
  audio_config: Schema.optional(Schema.Struct({
  channel: Schema.optional(Schema.Literal("mono", "stereo")),
  codec: Schema.optional(Schema.Literal("MP3", "AAC")),
  export_file: Schema.optional(Schema.Boolean)
})),
  file_name_prefix: Schema.optional(Schema.String),
  interactive_config: Schema.optional(Schema.Struct({
  type: Schema.optional(Schema.Literal("ID3"))
})),
  max_seconds: Schema.optional(Schema.Number),
  meeting_id: Schema.optional(Schema.UUID),
  realtimekit_bucket_config: Schema.optional(Schema.Struct({
  enabled: Schema.Boolean
})),
  rtmp_out_config: Schema.optional(Schema.Struct({
  rtmp_url: Schema.optional(Schema.String)
})),
  storage_config: Schema.optional(Schema.Struct({
  access_key: Schema.optional(Schema.String),
  auth_method: Schema.optional(Schema.Literal("KEY", "PASSWORD")),
  bucket: Schema.optional(Schema.String),
  host: Schema.optional(Schema.String),
  password: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  private_key: Schema.optional(Schema.String),
  region: Schema.optional(Schema.String),
  secret: Schema.optional(Schema.String),
  type: Schema.Literal("aws", "azure", "digitalocean", "gcs", "sftp"),
  username: Schema.optional(Schema.String)
})),
  url: Schema.optional(Schema.String),
  video_config: Schema.optional(Schema.Struct({
  codec: Schema.optional(Schema.Literal("H264", "VP8")),
  export_file: Schema.optional(Schema.Boolean),
  height: Schema.optional(Schema.Number),
  watermark: Schema.optional(Schema.Struct({
  position: Schema.optional(Schema.Literal("left top", "right top", "left bottom", "right bottom")),
  size: Schema.optional(Schema.Struct({
  height: Schema.optional(Schema.Number),
  width: Schema.optional(Schema.Number)
})),
  url: Schema.optional(Schema.String)
})),
  width: Schema.optional(Schema.Number)
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/{app_id}/recordings" }),
).annotations({ identifier: "StartRecordingRequest" }) as unknown as Schema.Schema<StartRecordingRequest>;

export interface StartRecordingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const StartRecordingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "StartRecordingResponse" }) as unknown as Schema.Schema<StartRecordingResponse>;

export const startRecording: (
  input: StartRecordingRequest
) => Effect.Effect<
  StartRecordingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: StartRecordingRequest,
  output: StartRecordingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetActiveRecordingRequest {
  account_id: string;
  app_id: string;
  meeting_id: string;
}

export const GetActiveRecordingRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  meeting_id: Schema.String.pipe(T.HttpPath("meeting_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/recordings/active-recording/{meeting_id}" }),
).annotations({ identifier: "GetActiveRecordingRequest" }) as unknown as Schema.Schema<GetActiveRecordingRequest>;

export interface GetActiveRecordingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetActiveRecordingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetActiveRecordingResponse" }) as unknown as Schema.Schema<GetActiveRecordingResponse>;

export const getActiveRecording: (
  input: GetActiveRecordingRequest
) => Effect.Effect<
  GetActiveRecordingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetActiveRecordingRequest,
  output: GetActiveRecordingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface StarttrackrecordingforameetingRequest {
  account_id: string;
  app_id: string;
  body: { layers: Record<string, unknown>; max_seconds?: number; meeting_id: string };
}

export const StarttrackrecordingforameetingRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  body: Schema.Struct({
  layers: Schema.Record({ key: Schema.String, value: Schema.Struct({
  file_name_prefix: Schema.optional(Schema.String),
  outputs: Schema.optional(Schema.Array(Schema.Struct({
  storage_config: Schema.optional(Schema.Struct({
  access_key: Schema.optional(Schema.String),
  auth_method: Schema.optional(Schema.Literal("KEY", "PASSWORD")),
  bucket: Schema.optional(Schema.String),
  host: Schema.optional(Schema.String),
  password: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  port: Schema.optional(Schema.Number),
  private_key: Schema.optional(Schema.String),
  region: Schema.optional(Schema.String),
  secret: Schema.optional(Schema.String),
  type: Schema.Literal("aws", "azure", "digitalocean", "gcs", "sftp"),
  username: Schema.optional(Schema.String)
})),
  type: Schema.optional(Schema.Literal("REALTIMEKIT_BUCKET", "STORAGE_CONFIG"))
})))
}) }),
  max_seconds: Schema.optional(Schema.Number),
  meeting_id: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/{app_id}/recordings/track" }),
).annotations({ identifier: "StarttrackrecordingforameetingRequest" }) as unknown as Schema.Schema<StarttrackrecordingforameetingRequest>;

export interface StarttrackrecordingforameetingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const StarttrackrecordingforameetingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "StarttrackrecordingforameetingResponse" }) as unknown as Schema.Schema<StarttrackrecordingforameetingResponse>;

export const starttrackrecordingforameeting: (
  input: StarttrackrecordingforameetingRequest
) => Effect.Effect<
  StarttrackrecordingforameetingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: StarttrackrecordingforameetingRequest,
  output: StarttrackrecordingforameetingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetOneRecordingRequest {
  account_id: string;
  app_id: string;
  recording_id: string;
}

export const GetOneRecordingRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  recording_id: Schema.String.pipe(T.HttpPath("recording_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/recordings/{recording_id}" }),
).annotations({ identifier: "GetOneRecordingRequest" }) as unknown as Schema.Schema<GetOneRecordingRequest>;

export interface GetOneRecordingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetOneRecordingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetOneRecordingResponse" }) as unknown as Schema.Schema<GetOneRecordingResponse>;

export const getOneRecording: (
  input: GetOneRecordingRequest
) => Effect.Effect<
  GetOneRecordingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetOneRecordingRequest,
  output: GetOneRecordingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PauseResumeStopRecordingRequest {
  account_id: string;
  app_id: string;
  recording_id: string;
  body: { action: "stop" | "pause" | "resume" };
}

export const PauseResumeStopRecordingRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  recording_id: Schema.String.pipe(T.HttpPath("recording_id")),
  body: Schema.Struct({
  action: Schema.Literal("stop", "pause", "resume")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/realtime/kit/{app_id}/recordings/{recording_id}" }),
).annotations({ identifier: "PauseResumeStopRecordingRequest" }) as unknown as Schema.Schema<PauseResumeStopRecordingRequest>;

export interface PauseResumeStopRecordingResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PauseResumeStopRecordingResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PauseResumeStopRecordingResponse" }) as unknown as Schema.Schema<PauseResumeStopRecordingResponse>;

export const pauseResumeStopRecording: (
  input: PauseResumeStopRecordingRequest
) => Effect.Effect<
  PauseResumeStopRecordingResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PauseResumeStopRecordingRequest,
  output: PauseResumeStopRecordingResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetsessionsRequest {
  account_id: string;
  app_id: string;
  search?: string;
  associated_id?: string;
}

export const GetsessionsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
  associated_id: Schema.optional(Schema.String).pipe(T.HttpQuery("associated_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/sessions" }),
).annotations({ identifier: "GetsessionsRequest" }) as unknown as Schema.Schema<GetsessionsRequest>;

export interface GetsessionsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetsessionsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetsessionsResponse" }) as unknown as Schema.Schema<GetsessionsResponse>;

export const getsessions: (
  input: GetsessionsRequest
) => Effect.Effect<
  GetsessionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetsessionsRequest,
  output: GetsessionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetparticipantdatafrompeeridRequest {
  account_id: string;
  app_id: string;
  filters?: "device_info" | "ip_information" | "precall_network_information" | "events" | "quality_stats";
  peer_id: string;
}

export const GetparticipantdatafrompeeridRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  filters: Schema.optional(Schema.Literal("device_info", "ip_information", "precall_network_information", "events", "quality_stats")).pipe(T.HttpQuery("filters")),
  peer_id: Schema.String.pipe(T.HttpPath("peer_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/sessions/peer-report/{peer_id}" }),
).annotations({ identifier: "GetparticipantdatafrompeeridRequest" }) as unknown as Schema.Schema<GetparticipantdatafrompeeridRequest>;

export interface GetparticipantdatafrompeeridResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetparticipantdatafrompeeridResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetparticipantdatafrompeeridResponse" }) as unknown as Schema.Schema<GetparticipantdatafrompeeridResponse>;

export const getparticipantdatafrompeerid: (
  input: GetparticipantdatafrompeeridRequest
) => Effect.Effect<
  GetparticipantdatafrompeeridResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetparticipantdatafrompeeridRequest,
  output: GetparticipantdatafrompeeridResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetsessiondetailsRequest {
  account_id: string;
  app_id: string;
  include_breakout_rooms?: boolean;
  session_id: string;
}

export const GetsessiondetailsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  include_breakout_rooms: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("include_breakout_rooms")),
  session_id: Schema.String.pipe(T.HttpPath("session_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/sessions/{session_id}" }),
).annotations({ identifier: "GetsessiondetailsRequest" }) as unknown as Schema.Schema<GetsessiondetailsRequest>;

export interface GetsessiondetailsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetsessiondetailsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetsessiondetailsResponse" }) as unknown as Schema.Schema<GetsessiondetailsResponse>;

export const getsessiondetails: (
  input: GetsessiondetailsRequest
) => Effect.Effect<
  GetsessiondetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetsessiondetailsRequest,
  output: GetsessiondetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetsessionchatRequest {
  account_id: string;
  app_id: string;
  session_id: string;
}

export const GetsessionchatRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  session_id: Schema.String.pipe(T.HttpPath("session_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/sessions/{session_id}/chat" }),
).annotations({ identifier: "GetsessionchatRequest" }) as unknown as Schema.Schema<GetsessionchatRequest>;

export interface GetsessionchatResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetsessionchatResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetsessionchatResponse" }) as unknown as Schema.Schema<GetsessionchatResponse>;

export const getsessionchat: (
  input: GetsessionchatRequest
) => Effect.Effect<
  GetsessionchatResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetsessionchatRequest,
  output: GetsessionchatResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetV2LivestreamsessionSessionMeetingidActiveLivestreamRequest {
  account_id: string;
  app_id: string;
  per_page?: number;
  page_no?: number;
  session_id: string;
}

export const GetV2LivestreamsessionSessionMeetingidActiveLivestreamRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  page_no: Schema.optional(Schema.Number).pipe(T.HttpQuery("page_no")),
  session_id: Schema.String.pipe(T.HttpPath("session_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/sessions/{session_id}/livestream-sessions" }),
).annotations({ identifier: "GetV2LivestreamsessionSessionMeetingidActiveLivestreamRequest" }) as unknown as Schema.Schema<GetV2LivestreamsessionSessionMeetingidActiveLivestreamRequest>;

export interface GetV2LivestreamsessionSessionMeetingidActiveLivestreamResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetV2LivestreamsessionSessionMeetingidActiveLivestreamResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetV2LivestreamsessionSessionMeetingidActiveLivestreamResponse" }) as unknown as Schema.Schema<GetV2LivestreamsessionSessionMeetingidActiveLivestreamResponse>;

export const getV2LivestreamsessionSessionMeetingidActiveLivestream: (
  input: GetV2LivestreamsessionSessionMeetingidActiveLivestreamRequest
) => Effect.Effect<
  GetV2LivestreamsessionSessionMeetingidActiveLivestreamResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetV2LivestreamsessionSessionMeetingidActiveLivestreamRequest,
  output: GetV2LivestreamsessionSessionMeetingidActiveLivestreamResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetsessionparticipantsRequest {
  account_id: string;
  app_id: string;
  include_peer_events?: boolean;
  view?: "raw" | "consolidated";
  session_id: string;
}

export const GetsessionparticipantsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  include_peer_events: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("include_peer_events")),
  view: Schema.optional(Schema.Literal("raw", "consolidated")).pipe(T.HttpQuery("view")),
  session_id: Schema.String.pipe(T.HttpPath("session_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/sessions/{session_id}/participants" }),
).annotations({ identifier: "GetsessionparticipantsRequest" }) as unknown as Schema.Schema<GetsessionparticipantsRequest>;

export interface GetsessionparticipantsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetsessionparticipantsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetsessionparticipantsResponse" }) as unknown as Schema.Schema<GetsessionparticipantsResponse>;

export const getsessionparticipants: (
  input: GetsessionparticipantsRequest
) => Effect.Effect<
  GetsessionparticipantsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetsessionparticipantsRequest,
  output: GetsessionparticipantsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetparticipantdetailsRequest {
  account_id: string;
  app_id: string;
  filters?: "device_info" | "ip_information" | "precall_network_information" | "events" | "quality_stats";
  include_peer_events?: boolean;
  participant_id: string;
  session_id: string;
}

export const GetparticipantdetailsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  filters: Schema.optional(Schema.Literal("device_info", "ip_information", "precall_network_information", "events", "quality_stats")).pipe(T.HttpQuery("filters")),
  include_peer_events: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("include_peer_events")),
  participant_id: Schema.String.pipe(T.HttpPath("participant_id")),
  session_id: Schema.String.pipe(T.HttpPath("session_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/sessions/{session_id}/participants/{participant_id}" }),
).annotations({ identifier: "GetparticipantdetailsRequest" }) as unknown as Schema.Schema<GetparticipantdetailsRequest>;

export interface GetparticipantdetailsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetparticipantdetailsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetparticipantdetailsResponse" }) as unknown as Schema.Schema<GetparticipantdetailsResponse>;

export const getparticipantdetails: (
  input: GetparticipantdetailsRequest
) => Effect.Effect<
  GetparticipantdetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetparticipantdetailsRequest,
  output: GetparticipantdetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetsessionsummaryRequest {
  account_id: string;
  app_id: string;
  session_id: string;
}

export const GetsessionsummaryRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  session_id: Schema.String.pipe(T.HttpPath("session_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/sessions/{session_id}/summary" }),
).annotations({ identifier: "GetsessionsummaryRequest" }) as unknown as Schema.Schema<GetsessionsummaryRequest>;

export interface GetsessionsummaryResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetsessionsummaryResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetsessionsummaryResponse" }) as unknown as Schema.Schema<GetsessionsummaryResponse>;

export const getsessionsummary: (
  input: GetsessionsummaryRequest
) => Effect.Effect<
  GetsessionsummaryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetsessionsummaryRequest,
  output: GetsessionsummaryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PostSessionsSessionIdSummaryRequest {
  account_id: string;
  app_id: string;
  session_id: string;
}

export const PostSessionsSessionIdSummaryRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  session_id: Schema.String.pipe(T.HttpPath("session_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/{app_id}/sessions/{session_id}/summary" }),
).annotations({ identifier: "PostSessionsSessionIdSummaryRequest" }) as unknown as Schema.Schema<PostSessionsSessionIdSummaryRequest>;

export interface PostSessionsSessionIdSummaryResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PostSessionsSessionIdSummaryResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PostSessionsSessionIdSummaryResponse" }) as unknown as Schema.Schema<PostSessionsSessionIdSummaryResponse>;

export const postSessionsSessionIdSummary: (
  input: PostSessionsSessionIdSummaryRequest
) => Effect.Effect<
  PostSessionsSessionIdSummaryResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PostSessionsSessionIdSummaryRequest,
  output: PostSessionsSessionIdSummaryResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetsessiontranscriptRequest {
  account_id: string;
  app_id: string;
  session_id: string;
}

export const GetsessiontranscriptRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  session_id: Schema.String.pipe(T.HttpPath("session_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/sessions/{session_id}/transcript" }),
).annotations({ identifier: "GetsessiontranscriptRequest" }) as unknown as Schema.Schema<GetsessiontranscriptRequest>;

export interface GetsessiontranscriptResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetsessiontranscriptResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetsessiontranscriptResponse" }) as unknown as Schema.Schema<GetsessiontranscriptResponse>;

export const getsessiontranscript: (
  input: GetsessiontranscriptRequest
) => Effect.Effect<
  GetsessiontranscriptResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetsessiontranscriptRequest,
  output: GetsessiontranscriptResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetallwebhooksRequest {
  account_id: string;
  app_id: string;
}

export const GetallwebhooksRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/webhooks" }),
).annotations({ identifier: "GetallwebhooksRequest" }) as unknown as Schema.Schema<GetallwebhooksRequest>;

export interface GetallwebhooksResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetallwebhooksResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetallwebhooksResponse" }) as unknown as Schema.Schema<GetallwebhooksResponse>;

export const getallwebhooks: (
  input: GetallwebhooksRequest
) => Effect.Effect<
  GetallwebhooksResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetallwebhooksRequest,
  output: GetallwebhooksResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AddwebhookRequest {
  account_id: string;
  app_id: string;
  body: { enabled?: boolean; events: "meeting.started" | "meeting.ended" | "meeting.participantJoined" | "meeting.participantLeft" | "meeting.chatSynced" | "recording.statusUpdate" | "livestreaming.statusUpdate" | "meeting.transcript" | "meeting.summary"[]; name: string; url: string };
}

export const AddwebhookRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  body: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  events: Schema.Array(Schema.Literal("meeting.started", "meeting.ended", "meeting.participantJoined", "meeting.participantLeft", "meeting.chatSynced", "recording.statusUpdate", "livestreaming.statusUpdate", "meeting.transcript", "meeting.summary")),
  name: Schema.String,
  url: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/realtime/kit/{app_id}/webhooks" }),
).annotations({ identifier: "AddwebhookRequest" }) as unknown as Schema.Schema<AddwebhookRequest>;

export interface AddwebhookResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AddwebhookResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AddwebhookResponse" }) as unknown as Schema.Schema<AddwebhookResponse>;

export const addwebhook: (
  input: AddwebhookRequest
) => Effect.Effect<
  AddwebhookResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AddwebhookRequest,
  output: AddwebhookResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetwebhookRequest {
  account_id: string;
  app_id: string;
  webhook_id: string;
}

export const GetwebhookRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  webhook_id: Schema.String.pipe(T.HttpPath("webhook_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/realtime/kit/{app_id}/webhooks/{webhook_id}" }),
).annotations({ identifier: "GetwebhookRequest" }) as unknown as Schema.Schema<GetwebhookRequest>;

export interface GetwebhookResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetwebhookResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetwebhookResponse" }) as unknown as Schema.Schema<GetwebhookResponse>;

export const getwebhook: (
  input: GetwebhookRequest
) => Effect.Effect<
  GetwebhookResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetwebhookRequest,
  output: GetwebhookResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ReplacewebhookRequest {
  account_id: string;
  app_id: string;
  webhook_id: string;
  body: { enabled?: boolean; events: "meeting.started" | "meeting.ended" | "meeting.participantJoined" | "meeting.participantLeft" | "meeting.chatSynced" | "recording.statusUpdate" | "livestreaming.statusUpdate" | "meeting.transcript" | "meeting.summary"[]; name: string; url: string };
}

export const ReplacewebhookRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  webhook_id: Schema.String.pipe(T.HttpPath("webhook_id")),
  body: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  events: Schema.Array(Schema.Literal("meeting.started", "meeting.ended", "meeting.participantJoined", "meeting.participantLeft", "meeting.chatSynced", "recording.statusUpdate", "livestreaming.statusUpdate", "meeting.transcript", "meeting.summary")),
  name: Schema.String,
  url: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/realtime/kit/{app_id}/webhooks/{webhook_id}" }),
).annotations({ identifier: "ReplacewebhookRequest" }) as unknown as Schema.Schema<ReplacewebhookRequest>;

export interface ReplacewebhookResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ReplacewebhookResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ReplacewebhookResponse" }) as unknown as Schema.Schema<ReplacewebhookResponse>;

export const replacewebhook: (
  input: ReplacewebhookRequest
) => Effect.Effect<
  ReplacewebhookResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ReplacewebhookRequest,
  output: ReplacewebhookResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletewebhookRequest {
  account_id: string;
  app_id: string;
  webhook_id: string;
}

export const DeletewebhookRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  webhook_id: Schema.String.pipe(T.HttpPath("webhook_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/realtime/kit/{app_id}/webhooks/{webhook_id}" }),
).annotations({ identifier: "DeletewebhookRequest" }) as unknown as Schema.Schema<DeletewebhookRequest>;

export interface DeletewebhookResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletewebhookResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletewebhookResponse" }) as unknown as Schema.Schema<DeletewebhookResponse>;

export const deletewebhook: (
  input: DeletewebhookRequest
) => Effect.Effect<
  DeletewebhookResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletewebhookRequest,
  output: DeletewebhookResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface EditwebhookRequest {
  account_id: string;
  app_id: string;
  webhook_id: string;
  body: { enabled?: boolean; events?: "meeting.started" | "meeting.ended" | "meeting.participantJoined" | "meeting.participantLeft" | "recording.statusUpdate" | "livestreaming.statusUpdate" | "meeting.chatSynced" | "meeting.transcript" | "meeting.summary"[]; name?: string; url?: string };
}

export const EditwebhookRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  app_id: Schema.String.pipe(T.HttpPath("app_id")),
  webhook_id: Schema.String.pipe(T.HttpPath("webhook_id")),
  body: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  events: Schema.optional(Schema.Array(Schema.Literal("meeting.started", "meeting.ended", "meeting.participantJoined", "meeting.participantLeft", "recording.statusUpdate", "livestreaming.statusUpdate", "meeting.chatSynced", "meeting.transcript", "meeting.summary"))),
  name: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/realtime/kit/{app_id}/webhooks/{webhook_id}" }),
).annotations({ identifier: "EditwebhookRequest" }) as unknown as Schema.Schema<EditwebhookRequest>;

export interface EditwebhookResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const EditwebhookResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "EditwebhookResponse" }) as unknown as Schema.Schema<EditwebhookResponse>;

export const editwebhook: (
  input: EditwebhookRequest
) => Effect.Effect<
  EditwebhookResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: EditwebhookRequest,
  output: EditwebhookResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListDomains1Request {
  account_id: string;
}

export const ListDomains1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/registrar/domains" }),
).annotations({ identifier: "ListDomains1Request" }) as unknown as Schema.Schema<ListDomains1Request>;

export interface ListDomains1Response {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListDomains1Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListDomains1Response" }) as unknown as Schema.Schema<ListDomains1Response>;

export const listDomains1: (
  input: ListDomains1Request
) => Effect.Effect<
  ListDomains1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDomains1Request,
  output: ListDomains1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetDomain1Request {
  domain_name: string;
  account_id: string;
}

export const GetDomain1Request = Schema.Struct({
  domain_name: Schema.String.pipe(T.HttpPath("domain_name")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/registrar/domains/{domain_name}" }),
).annotations({ identifier: "GetDomain1Request" }) as unknown as Schema.Schema<GetDomain1Request>;

export interface GetDomain1Response {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetDomain1Response = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetDomain1Response" }) as unknown as Schema.Schema<GetDomain1Response>;

export const getDomain1: (
  input: GetDomain1Request
) => Effect.Effect<
  GetDomain1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDomain1Request,
  output: GetDomain1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateDomain1Request {
  domain_name: string;
  account_id: string;
  body: unknown;
}

export const UpdateDomain1Request = Schema.Struct({
  domain_name: Schema.String.pipe(T.HttpPath("domain_name")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  auto_renew: Schema.optional(Schema.Boolean),
  locked: Schema.optional(Schema.Boolean),
  privacy: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/registrar/domains/{domain_name}" }),
).annotations({ identifier: "UpdateDomain1Request" }) as unknown as Schema.Schema<UpdateDomain1Request>;

export interface UpdateDomain1Response {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateDomain1Response = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateDomain1Response" }) as unknown as Schema.Schema<UpdateDomain1Response>;

export const updateDomain1: (
  input: UpdateDomain1Request
) => Effect.Effect<
  UpdateDomain1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDomain1Request,
  output: UpdateDomain1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountRequestTracerRequestTraceRequest {
  account_id: string;
  body: { body?: { base64?: string; json?: Record<string, unknown>; plain_text?: string }; context?: { bot_score?: number; geoloc?: { city?: string; continent?: string; is_eu_country?: boolean; iso_code?: string; latitude?: number; longitude?: number; postal_code?: string; region_code?: string; subdivision_2_iso_code?: string; timezone?: string }; skip_challenge?: boolean; threat_score?: number }; cookies?: Record<string, unknown>; headers?: Record<string, unknown>; method: string; protocol?: string; skip_response?: boolean; url: string };
}

export const AccountRequestTracerRequestTraceRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  body: Schema.optional(Schema.Struct({
  base64: Schema.optional(Schema.String),
  json: Schema.optional(Schema.Struct({})),
  plain_text: Schema.optional(Schema.String)
})),
  context: Schema.optional(Schema.Struct({
  bot_score: Schema.optional(Schema.Number),
  geoloc: Schema.optional(Schema.Struct({
  city: Schema.optional(Schema.String),
  continent: Schema.optional(Schema.String),
  is_eu_country: Schema.optional(Schema.Boolean),
  iso_code: Schema.optional(Schema.String),
  latitude: Schema.optional(Schema.Number),
  longitude: Schema.optional(Schema.Number),
  postal_code: Schema.optional(Schema.String),
  region_code: Schema.optional(Schema.String),
  subdivision_2_iso_code: Schema.optional(Schema.String),
  timezone: Schema.optional(Schema.String)
})),
  skip_challenge: Schema.optional(Schema.Boolean),
  threat_score: Schema.optional(Schema.Number)
})),
  cookies: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  headers: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  method: Schema.String,
  protocol: Schema.optional(Schema.String),
  skip_response: Schema.optional(Schema.Boolean),
  url: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/request-tracer/trace" }),
).annotations({ identifier: "AccountRequestTracerRequestTraceRequest" }) as unknown as Schema.Schema<AccountRequestTracerRequestTraceRequest>;

export interface AccountRequestTracerRequestTraceResponse {
  result: { status_code?: number; trace?: { action?: string; action_parameters?: Record<string, unknown>; description?: string; expression?: string; kind?: string; matched?: boolean; name?: string; step_name?: string; trace?: unknown; type?: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountRequestTracerRequestTraceResponse = Schema.Struct({
  result: Schema.Struct({
  status_code: Schema.optional(Schema.Number),
  trace: Schema.optional(Schema.Array(Schema.Struct({
  action: Schema.optional(Schema.String),
  action_parameters: Schema.optional(Schema.Struct({})),
  description: Schema.optional(Schema.String),
  expression: Schema.optional(Schema.String),
  kind: Schema.optional(Schema.String),
  matched: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  step_name: Schema.optional(Schema.String),
  trace: Schema.optional(Schema.Unknown),
  type: Schema.optional(Schema.String)
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountRequestTracerRequestTraceResponse" }) as unknown as Schema.Schema<AccountRequestTracerRequestTraceResponse>;

export const accountRequestTracerRequestTrace: (
  input: AccountRequestTracerRequestTraceRequest
) => Effect.Effect<
  AccountRequestTracerRequestTraceResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountRequestTracerRequestTraceRequest,
  output: AccountRequestTracerRequestTraceResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListRolesRequest {
  account_id: unknown;
  page?: number;
  per_page?: number;
}

export const ListRolesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/roles" }),
).annotations({ identifier: "ListRolesRequest" }) as unknown as Schema.Schema<ListRolesRequest>;

export interface ListRolesResponse {
  result: { description: string; id: string; name: string; permissions: unknown }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListRolesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  description: Schema.String,
  id: Schema.String,
  name: Schema.String,
  permissions: Schema.Unknown
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListRolesResponse" }) as unknown as Schema.Schema<ListRolesResponse>;

export const listRoles: (
  input: ListRolesRequest
) => Effect.Effect<
  ListRolesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListRolesRequest,
  output: ListRolesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountRolesRoleDetailsRequest {
  role_id: string;
  account_id: unknown;
}

export const AccountRolesRoleDetailsRequest = Schema.Struct({
  role_id: Schema.String.pipe(T.HttpPath("role_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/roles/{role_id}" }),
).annotations({ identifier: "AccountRolesRoleDetailsRequest" }) as unknown as Schema.Schema<AccountRolesRoleDetailsRequest>;

export interface AccountRolesRoleDetailsResponse {
  result: { description: string; id: string; name: string; permissions: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountRolesRoleDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  description: Schema.String,
  id: Schema.String,
  name: Schema.String,
  permissions: Schema.Unknown
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountRolesRoleDetailsResponse" }) as unknown as Schema.Schema<AccountRolesRoleDetailsResponse>;

export const accountRolesRoleDetails: (
  input: AccountRolesRoleDetailsRequest
) => Effect.Effect<
  AccountRolesRoleDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountRolesRoleDetailsRequest,
  output: AccountRolesRoleDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetListsRequest {
  account_id: string;
}

export const GetListsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/rules/lists" }),
).annotations({ identifier: "GetListsRequest" }) as unknown as Schema.Schema<GetListsRequest>;

export interface GetListsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetListsResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({}), Schema.Array(Schema.Struct({}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetListsResponse" }) as unknown as Schema.Schema<GetListsResponse>;

export const getLists: (
  input: GetListsRequest
) => Effect.Effect<
  GetListsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetListsRequest,
  output: GetListsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List35Request {
  account_id: string;
  body: { description?: string; kind: "ip" | "redirect" | "hostname" | "asn"; name: string };
}

export const List35Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String),
  kind: Schema.Literal("ip", "redirect", "hostname", "asn"),
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/rules/lists" }),
).annotations({ identifier: "List35Request" }) as unknown as Schema.Schema<List35Request>;

export interface List35Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List35Response = Schema.Struct({
  result: Schema.Union(Schema.Struct({}), Schema.Array(Schema.Struct({}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List35Response" }) as unknown as Schema.Schema<List35Response>;

export const list35: (
  input: List35Request
) => Effect.Effect<
  List35Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List35Request,
  output: List35Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetBulkOperationStatusRequest {
  operation_id: string;
  account_id: string;
}

export const GetBulkOperationStatusRequest = Schema.Struct({
  operation_id: Schema.String.pipe(T.HttpPath("operation_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/rules/lists/bulk_operations/{operation_id}" }),
).annotations({ identifier: "GetBulkOperationStatusRequest" }) as unknown as Schema.Schema<GetBulkOperationStatusRequest>;

export interface GetBulkOperationStatusResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetBulkOperationStatusResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({}), Schema.Array(Schema.Struct({}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetBulkOperationStatusResponse" }) as unknown as Schema.Schema<GetBulkOperationStatusResponse>;

export const getBulkOperationStatus: (
  input: GetBulkOperationStatusRequest
) => Effect.Effect<
  GetBulkOperationStatusResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetBulkOperationStatusRequest,
  output: GetBulkOperationStatusResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List36Request {
  list_id: string;
  account_id: string;
}

export const List36Request = Schema.Struct({
  list_id: Schema.String.pipe(T.HttpPath("list_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/rules/lists/{list_id}" }),
).annotations({ identifier: "List36Request" }) as unknown as Schema.Schema<List36Request>;

export interface List36Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List36Response = Schema.Struct({
  result: Schema.Union(Schema.Struct({}), Schema.Array(Schema.Struct({}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List36Response" }) as unknown as Schema.Schema<List36Response>;

export const list36: (
  input: List36Request
) => Effect.Effect<
  List36Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List36Request,
  output: List36Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List37Request {
  list_id: string;
  account_id: string;
  body: { description?: string };
}

export const List37Request = Schema.Struct({
  list_id: Schema.String.pipe(T.HttpPath("list_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  description: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/rules/lists/{list_id}" }),
).annotations({ identifier: "List37Request" }) as unknown as Schema.Schema<List37Request>;

export interface List37Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List37Response = Schema.Struct({
  result: Schema.Union(Schema.Struct({}), Schema.Array(Schema.Struct({}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List37Response" }) as unknown as Schema.Schema<List37Response>;

export const list37: (
  input: List37Request
) => Effect.Effect<
  List37Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List37Request,
  output: List37Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List38Request {
  list_id: string;
  account_id: string;
}

export const List38Request = Schema.Struct({
  list_id: Schema.String.pipe(T.HttpPath("list_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/rules/lists/{list_id}" }),
).annotations({ identifier: "List38Request" }) as unknown as Schema.Schema<List38Request>;

export interface List38Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List38Response = Schema.Struct({
  result: Schema.Union(Schema.Struct({}), Schema.Array(Schema.Struct({}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List38Response" }) as unknown as Schema.Schema<List38Response>;

export const list38: (
  input: List38Request
) => Effect.Effect<
  List38Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List38Request,
  output: List38Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListItems2Request {
  list_id: string;
  account_id: string;
  cursor?: string;
  per_page?: number;
  search?: string;
}

export const ListItems2Request = Schema.Struct({
  list_id: Schema.String.pipe(T.HttpPath("list_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  cursor: Schema.optional(Schema.String).pipe(T.HttpQuery("cursor")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/rules/lists/{list_id}/items" }),
).annotations({ identifier: "ListItems2Request" }) as unknown as Schema.Schema<ListItems2Request>;

export interface ListItems2Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListItems2Response = Schema.Struct({
  result: Schema.Union(Schema.Struct({}), Schema.Array(Schema.Struct({}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListItems2Response" }) as unknown as Schema.Schema<ListItems2Response>;

export const listItems2: (
  input: ListItems2Request
) => Effect.Effect<
  ListItems2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListItems2Request,
  output: ListItems2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListItems3Request {
  list_id: string;
  account_id: string;
  body: unknown[];
}

export const ListItems3Request = Schema.Struct({
  list_id: Schema.String.pipe(T.HttpPath("list_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Union(Schema.Struct({
  ip: Schema.String
}), Schema.Struct({
  redirect: Schema.Unknown
}), Schema.Struct({
  hostname: Schema.Unknown
}), Schema.Struct({
  asn: Schema.Number
}))).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/rules/lists/{list_id}/items" }),
).annotations({ identifier: "ListItems3Request" }) as unknown as Schema.Schema<ListItems3Request>;

export interface ListItems3Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListItems3Response = Schema.Struct({
  result: Schema.Union(Schema.Struct({}), Schema.Array(Schema.Struct({}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListItems3Response" }) as unknown as Schema.Schema<ListItems3Response>;

export const listItems3: (
  input: ListItems3Request
) => Effect.Effect<
  ListItems3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListItems3Request,
  output: ListItems3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListItems4Request {
  list_id: string;
  account_id: string;
  body: unknown[];
}

export const ListItems4Request = Schema.Struct({
  list_id: Schema.String.pipe(T.HttpPath("list_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Union(Schema.Struct({
  ip: Schema.String
}), Schema.Struct({
  redirect: Schema.Unknown
}), Schema.Struct({
  hostname: Schema.Unknown
}), Schema.Struct({
  asn: Schema.Number
}))).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/rules/lists/{list_id}/items" }),
).annotations({ identifier: "ListItems4Request" }) as unknown as Schema.Schema<ListItems4Request>;

export interface ListItems4Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListItems4Response = Schema.Struct({
  result: Schema.Union(Schema.Struct({}), Schema.Array(Schema.Struct({}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListItems4Response" }) as unknown as Schema.Schema<ListItems4Response>;

export const listItems4: (
  input: ListItems4Request
) => Effect.Effect<
  ListItems4Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListItems4Request,
  output: ListItems4Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListItems5Request {
  list_id: string;
  account_id: string;
  body: { items?: { id: string }[] };
}

export const ListItems5Request = Schema.Struct({
  list_id: Schema.String.pipe(T.HttpPath("list_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  items: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.String
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/rules/lists/{list_id}/items" }),
).annotations({ identifier: "ListItems5Request" }) as unknown as Schema.Schema<ListItems5Request>;

export interface ListItems5Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListItems5Response = Schema.Struct({
  result: Schema.Union(Schema.Struct({}), Schema.Array(Schema.Struct({}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListItems5Response" }) as unknown as Schema.Schema<ListItems5Response>;

export const listItems5: (
  input: ListItems5Request
) => Effect.Effect<
  ListItems5Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListItems5Request,
  output: ListItems5Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListItemRequest {
  item_id: string;
  list_id: string;
  account_id: string;
}

export const ListItemRequest = Schema.Struct({
  item_id: Schema.String.pipe(T.HttpPath("item_id")),
  list_id: Schema.String.pipe(T.HttpPath("list_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/rules/lists/{list_id}/items/{item_id}" }),
).annotations({ identifier: "ListItemRequest" }) as unknown as Schema.Schema<ListItemRequest>;

export interface ListItemResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListItemResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({}), Schema.Array(Schema.Struct({}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListItemResponse" }) as unknown as Schema.Schema<ListItemResponse>;

export const listItem: (
  input: ListItemRequest
) => Effect.Effect<
  ListItemResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListItemRequest,
  output: ListItemResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListaccountrulesetsRequest {
  account_id: string;
  cursor?: string;
  per_page?: number;
}

export const ListaccountrulesetsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  cursor: Schema.optional(Schema.String).pipe(T.HttpQuery("cursor")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/rulesets" }),
).annotations({ identifier: "ListaccountrulesetsRequest" }) as unknown as Schema.Schema<ListaccountrulesetsRequest>;

export interface ListaccountrulesetsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListaccountrulesetsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListaccountrulesetsResponse" }) as unknown as Schema.Schema<ListaccountrulesetsResponse>;

export const listaccountrulesets: (
  input: ListaccountrulesetsRequest
) => Effect.Effect<
  ListaccountrulesetsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListaccountrulesetsRequest,
  output: ListaccountrulesetsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateaccountrulesetRequest {
  account_id: string;
  body: unknown;
}

export const CreateaccountrulesetRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/rulesets" }),
).annotations({ identifier: "CreateaccountrulesetRequest" }) as unknown as Schema.Schema<CreateaccountrulesetRequest>;

export interface CreateaccountrulesetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateaccountrulesetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateaccountrulesetResponse" }) as unknown as Schema.Schema<CreateaccountrulesetResponse>;

export const createaccountruleset: (
  input: CreateaccountrulesetRequest
) => Effect.Effect<
  CreateaccountrulesetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateaccountrulesetRequest,
  output: CreateaccountrulesetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetaccountentrypointrulesetRequest {
  ruleset_phase: "ddos_l4" | "ddos_l7" | "http_config_settings" | "http_custom_errors" | "http_log_custom_fields" | "http_ratelimit" | "http_request_cache_settings" | "http_request_dynamic_redirect" | "http_request_firewall_custom" | "http_request_firewall_managed" | "http_request_late_transform" | "http_request_origin" | "http_request_redirect" | "http_request_sanitize" | "http_request_sbfm" | "http_request_transform" | "http_response_compression" | "http_response_firewall_managed" | "http_response_headers_transform" | "magic_transit" | "magic_transit_ids_managed" | "magic_transit_managed" | "magic_transit_ratelimit";
  account_id: string;
}

export const GetaccountentrypointrulesetRequest = Schema.Struct({
  ruleset_phase: Schema.Literal("ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed", "magic_transit_ratelimit").pipe(T.HttpPath("ruleset_phase")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/rulesets/phases/{ruleset_phase}/entrypoint" }),
).annotations({ identifier: "GetaccountentrypointrulesetRequest" }) as unknown as Schema.Schema<GetaccountentrypointrulesetRequest>;

export interface GetaccountentrypointrulesetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetaccountentrypointrulesetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetaccountentrypointrulesetResponse" }) as unknown as Schema.Schema<GetaccountentrypointrulesetResponse>;

export const getaccountentrypointruleset: (
  input: GetaccountentrypointrulesetRequest
) => Effect.Effect<
  GetaccountentrypointrulesetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetaccountentrypointrulesetRequest,
  output: GetaccountentrypointrulesetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateaccountentrypointrulesetRequest {
  ruleset_phase: "ddos_l4" | "ddos_l7" | "http_config_settings" | "http_custom_errors" | "http_log_custom_fields" | "http_ratelimit" | "http_request_cache_settings" | "http_request_dynamic_redirect" | "http_request_firewall_custom" | "http_request_firewall_managed" | "http_request_late_transform" | "http_request_origin" | "http_request_redirect" | "http_request_sanitize" | "http_request_sbfm" | "http_request_transform" | "http_response_compression" | "http_response_firewall_managed" | "http_response_headers_transform" | "magic_transit" | "magic_transit_ids_managed" | "magic_transit_managed" | "magic_transit_ratelimit";
  account_id: string;
  body: unknown;
}

export const UpdateaccountentrypointrulesetRequest = Schema.Struct({
  ruleset_phase: Schema.Literal("ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed", "magic_transit_ratelimit").pipe(T.HttpPath("ruleset_phase")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/rulesets/phases/{ruleset_phase}/entrypoint" }),
).annotations({ identifier: "UpdateaccountentrypointrulesetRequest" }) as unknown as Schema.Schema<UpdateaccountentrypointrulesetRequest>;

export interface UpdateaccountentrypointrulesetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateaccountentrypointrulesetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateaccountentrypointrulesetResponse" }) as unknown as Schema.Schema<UpdateaccountentrypointrulesetResponse>;

export const updateaccountentrypointruleset: (
  input: UpdateaccountentrypointrulesetRequest
) => Effect.Effect<
  UpdateaccountentrypointrulesetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateaccountentrypointrulesetRequest,
  output: UpdateaccountentrypointrulesetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListaccountentrypointrulesetversionsRequest {
  ruleset_phase: "ddos_l4" | "ddos_l7" | "http_config_settings" | "http_custom_errors" | "http_log_custom_fields" | "http_ratelimit" | "http_request_cache_settings" | "http_request_dynamic_redirect" | "http_request_firewall_custom" | "http_request_firewall_managed" | "http_request_late_transform" | "http_request_origin" | "http_request_redirect" | "http_request_sanitize" | "http_request_sbfm" | "http_request_transform" | "http_response_compression" | "http_response_firewall_managed" | "http_response_headers_transform" | "magic_transit" | "magic_transit_ids_managed" | "magic_transit_managed" | "magic_transit_ratelimit";
  account_id: string;
}

export const ListaccountentrypointrulesetversionsRequest = Schema.Struct({
  ruleset_phase: Schema.Literal("ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed", "magic_transit_ratelimit").pipe(T.HttpPath("ruleset_phase")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/rulesets/phases/{ruleset_phase}/entrypoint/versions" }),
).annotations({ identifier: "ListaccountentrypointrulesetversionsRequest" }) as unknown as Schema.Schema<ListaccountentrypointrulesetversionsRequest>;

export interface ListaccountentrypointrulesetversionsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListaccountentrypointrulesetversionsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListaccountentrypointrulesetversionsResponse" }) as unknown as Schema.Schema<ListaccountentrypointrulesetversionsResponse>;

export const listaccountentrypointrulesetversions: (
  input: ListaccountentrypointrulesetversionsRequest
) => Effect.Effect<
  ListaccountentrypointrulesetversionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListaccountentrypointrulesetversionsRequest,
  output: ListaccountentrypointrulesetversionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetaccountentrypointrulesetversionRequest {
  ruleset_version: string;
  ruleset_phase: "ddos_l4" | "ddos_l7" | "http_config_settings" | "http_custom_errors" | "http_log_custom_fields" | "http_ratelimit" | "http_request_cache_settings" | "http_request_dynamic_redirect" | "http_request_firewall_custom" | "http_request_firewall_managed" | "http_request_late_transform" | "http_request_origin" | "http_request_redirect" | "http_request_sanitize" | "http_request_sbfm" | "http_request_transform" | "http_response_compression" | "http_response_firewall_managed" | "http_response_headers_transform" | "magic_transit" | "magic_transit_ids_managed" | "magic_transit_managed" | "magic_transit_ratelimit";
  account_id: string;
}

export const GetaccountentrypointrulesetversionRequest = Schema.Struct({
  ruleset_version: Schema.String.pipe(T.HttpPath("ruleset_version")),
  ruleset_phase: Schema.Literal("ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed", "magic_transit_ratelimit").pipe(T.HttpPath("ruleset_phase")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/rulesets/phases/{ruleset_phase}/entrypoint/versions/{ruleset_version}" }),
).annotations({ identifier: "GetaccountentrypointrulesetversionRequest" }) as unknown as Schema.Schema<GetaccountentrypointrulesetversionRequest>;

export interface GetaccountentrypointrulesetversionResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetaccountentrypointrulesetversionResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetaccountentrypointrulesetversionResponse" }) as unknown as Schema.Schema<GetaccountentrypointrulesetversionResponse>;

export const getaccountentrypointrulesetversion: (
  input: GetaccountentrypointrulesetversionRequest
) => Effect.Effect<
  GetaccountentrypointrulesetversionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetaccountentrypointrulesetversionRequest,
  output: GetaccountentrypointrulesetversionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetaccountrulesetRequest {
  ruleset_id: string;
  account_id: string;
}

export const GetaccountrulesetRequest = Schema.Struct({
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/rulesets/{ruleset_id}" }),
).annotations({ identifier: "GetaccountrulesetRequest" }) as unknown as Schema.Schema<GetaccountrulesetRequest>;

export interface GetaccountrulesetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetaccountrulesetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetaccountrulesetResponse" }) as unknown as Schema.Schema<GetaccountrulesetResponse>;

export const getaccountruleset: (
  input: GetaccountrulesetRequest
) => Effect.Effect<
  GetaccountrulesetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetaccountrulesetRequest,
  output: GetaccountrulesetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateaccountrulesetRequest {
  ruleset_id: string;
  account_id: string;
  body: unknown;
}

export const UpdateaccountrulesetRequest = Schema.Struct({
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/rulesets/{ruleset_id}" }),
).annotations({ identifier: "UpdateaccountrulesetRequest" }) as unknown as Schema.Schema<UpdateaccountrulesetRequest>;

export interface UpdateaccountrulesetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateaccountrulesetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateaccountrulesetResponse" }) as unknown as Schema.Schema<UpdateaccountrulesetResponse>;

export const updateaccountruleset: (
  input: UpdateaccountrulesetRequest
) => Effect.Effect<
  UpdateaccountrulesetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateaccountrulesetRequest,
  output: UpdateaccountrulesetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteaccountrulesetRequest {
  ruleset_id: string;
  account_id: string;
}

export const DeleteaccountrulesetRequest = Schema.Struct({
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/rulesets/{ruleset_id}" }),
).annotations({ identifier: "DeleteaccountrulesetRequest" }) as unknown as Schema.Schema<DeleteaccountrulesetRequest>;

export interface DeleteaccountrulesetResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteaccountrulesetResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteaccountrulesetResponse" }) as unknown as Schema.Schema<DeleteaccountrulesetResponse>;

export const deleteaccountruleset: (
  input: DeleteaccountrulesetRequest
) => Effect.Effect<
  DeleteaccountrulesetResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteaccountrulesetRequest,
  output: DeleteaccountrulesetResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateaccountrulesetruleRequest {
  ruleset_id: string;
  account_id: string;
  body: unknown;
}

export const CreateaccountrulesetruleRequest = Schema.Struct({
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/rulesets/{ruleset_id}/rules" }),
).annotations({ identifier: "CreateaccountrulesetruleRequest" }) as unknown as Schema.Schema<CreateaccountrulesetruleRequest>;

export interface CreateaccountrulesetruleResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateaccountrulesetruleResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateaccountrulesetruleResponse" }) as unknown as Schema.Schema<CreateaccountrulesetruleResponse>;

export const createaccountrulesetrule: (
  input: CreateaccountrulesetruleRequest
) => Effect.Effect<
  CreateaccountrulesetruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateaccountrulesetruleRequest,
  output: CreateaccountrulesetruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteaccountrulesetruleRequest {
  rule_id: string;
  ruleset_id: string;
  account_id: string;
}

export const DeleteaccountrulesetruleRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/rulesets/{ruleset_id}/rules/{rule_id}" }),
).annotations({ identifier: "DeleteaccountrulesetruleRequest" }) as unknown as Schema.Schema<DeleteaccountrulesetruleRequest>;

export interface DeleteaccountrulesetruleResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteaccountrulesetruleResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteaccountrulesetruleResponse" }) as unknown as Schema.Schema<DeleteaccountrulesetruleResponse>;

export const deleteaccountrulesetrule: (
  input: DeleteaccountrulesetruleRequest
) => Effect.Effect<
  DeleteaccountrulesetruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteaccountrulesetruleRequest,
  output: DeleteaccountrulesetruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateaccountrulesetruleRequest {
  rule_id: string;
  ruleset_id: string;
  account_id: string;
  body: unknown;
}

export const UpdateaccountrulesetruleRequest = Schema.Struct({
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/rulesets/{ruleset_id}/rules/{rule_id}" }),
).annotations({ identifier: "UpdateaccountrulesetruleRequest" }) as unknown as Schema.Schema<UpdateaccountrulesetruleRequest>;

export interface UpdateaccountrulesetruleResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateaccountrulesetruleResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateaccountrulesetruleResponse" }) as unknown as Schema.Schema<UpdateaccountrulesetruleResponse>;

export const updateaccountrulesetrule: (
  input: UpdateaccountrulesetruleRequest
) => Effect.Effect<
  UpdateaccountrulesetruleResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateaccountrulesetruleRequest,
  output: UpdateaccountrulesetruleResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListaccountrulesetversionsRequest {
  ruleset_id: string;
  account_id: string;
}

export const ListaccountrulesetversionsRequest = Schema.Struct({
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/rulesets/{ruleset_id}/versions" }),
).annotations({ identifier: "ListaccountrulesetversionsRequest" }) as unknown as Schema.Schema<ListaccountrulesetversionsRequest>;

export interface ListaccountrulesetversionsResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListaccountrulesetversionsResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListaccountrulesetversionsResponse" }) as unknown as Schema.Schema<ListaccountrulesetversionsResponse>;

export const listaccountrulesetversions: (
  input: ListaccountrulesetversionsRequest
) => Effect.Effect<
  ListaccountrulesetversionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListaccountrulesetversionsRequest,
  output: ListaccountrulesetversionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetaccountrulesetversionRequest {
  ruleset_version: string;
  ruleset_id: string;
  account_id: string;
}

export const GetaccountrulesetversionRequest = Schema.Struct({
  ruleset_version: Schema.String.pipe(T.HttpPath("ruleset_version")),
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/rulesets/{ruleset_id}/versions/{ruleset_version}" }),
).annotations({ identifier: "GetaccountrulesetversionRequest" }) as unknown as Schema.Schema<GetaccountrulesetversionRequest>;

export interface GetaccountrulesetversionResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetaccountrulesetversionResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetaccountrulesetversionResponse" }) as unknown as Schema.Schema<GetaccountrulesetversionResponse>;

export const getaccountrulesetversion: (
  input: GetaccountrulesetversionRequest
) => Effect.Effect<
  GetaccountrulesetversionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetaccountrulesetversionRequest,
  output: GetaccountrulesetversionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteaccountrulesetversionRequest {
  ruleset_version: string;
  ruleset_id: string;
  account_id: string;
}

export const DeleteaccountrulesetversionRequest = Schema.Struct({
  ruleset_version: Schema.String.pipe(T.HttpPath("ruleset_version")),
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/rulesets/{ruleset_id}/versions/{ruleset_version}" }),
).annotations({ identifier: "DeleteaccountrulesetversionRequest" }) as unknown as Schema.Schema<DeleteaccountrulesetversionRequest>;

export interface DeleteaccountrulesetversionResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteaccountrulesetversionResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteaccountrulesetversionResponse" }) as unknown as Schema.Schema<DeleteaccountrulesetversionResponse>;

export const deleteaccountrulesetversion: (
  input: DeleteaccountrulesetversionRequest
) => Effect.Effect<
  DeleteaccountrulesetversionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteaccountrulesetversionRequest,
  output: DeleteaccountrulesetversionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListaccountrulesetversionrulesbytagRequest {
  rule_tag: string;
  ruleset_version: string;
  ruleset_id: string;
  account_id: string;
}

export const ListaccountrulesetversionrulesbytagRequest = Schema.Struct({
  rule_tag: Schema.String.pipe(T.HttpPath("rule_tag")),
  ruleset_version: Schema.String.pipe(T.HttpPath("ruleset_version")),
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/rulesets/{ruleset_id}/versions/{ruleset_version}/by_tag/{rule_tag}" }),
).annotations({ identifier: "ListaccountrulesetversionrulesbytagRequest" }) as unknown as Schema.Schema<ListaccountrulesetversionrulesbytagRequest>;

export interface ListaccountrulesetversionrulesbytagResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListaccountrulesetversionrulesbytagResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListaccountrulesetversionrulesbytagResponse" }) as unknown as Schema.Schema<ListaccountrulesetversionrulesbytagResponse>;

export const listaccountrulesetversionrulesbytag: (
  input: ListaccountrulesetversionrulesbytagRequest
) => Effect.Effect<
  ListaccountrulesetversionrulesbytagResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListaccountrulesetversionrulesbytagRequest,
  output: ListaccountrulesetversionrulesbytagResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateSite1Request {
  account_id: string;
  body: { auto_install?: boolean; host?: string; zone_tag?: string };
}

export const CreateSite1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  auto_install: Schema.optional(Schema.Boolean),
  host: Schema.optional(Schema.String),
  zone_tag: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/rum/site_info" }),
).annotations({ identifier: "CreateSite1Request" }) as unknown as Schema.Schema<CreateSite1Request>;

export interface CreateSite1Response {
  result: { auto_install?: boolean; created?: string; rules?: { created?: string; host?: string; id?: string; inclusive?: boolean; is_paused?: boolean; paths?: string[]; priority?: number }[]; ruleset?: { enabled?: boolean; id?: string; zone_name?: string; zone_tag?: string }; site_tag?: string; site_token?: string; snippet?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateSite1Response = Schema.Struct({
  result: Schema.Struct({
  auto_install: Schema.optional(Schema.Boolean),
  created: Schema.optional(Schema.Date),
  rules: Schema.optional(Schema.Array(Schema.Struct({
  created: Schema.optional(Schema.Date),
  host: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  inclusive: Schema.optional(Schema.Boolean),
  is_paused: Schema.optional(Schema.Boolean),
  paths: Schema.optional(Schema.Array(Schema.String)),
  priority: Schema.optional(Schema.Number)
}))),
  ruleset: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  zone_name: Schema.optional(Schema.String),
  zone_tag: Schema.optional(Schema.String)
})),
  site_tag: Schema.optional(Schema.String),
  site_token: Schema.optional(Schema.String),
  snippet: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateSite1Response" }) as unknown as Schema.Schema<CreateSite1Response>;

export const createSite1: (
  input: CreateSite1Request
) => Effect.Effect<
  CreateSite1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateSite1Request,
  output: CreateSite1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListSites1Request {
  account_id: string;
  per_page?: number;
  page?: number;
  order_by?: "host" | "created";
}

export const ListSites1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  order_by: Schema.optional(Schema.Literal("host", "created")).pipe(T.HttpQuery("order_by"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/rum/site_info/list" }),
).annotations({ identifier: "ListSites1Request" }) as unknown as Schema.Schema<ListSites1Request>;

export interface ListSites1Response {
  result: { auto_install?: boolean; created?: string; rules?: { created?: string; host?: string; id?: string; inclusive?: boolean; is_paused?: boolean; paths?: string[]; priority?: number }[]; ruleset?: { enabled?: boolean; id?: string; zone_name?: string; zone_tag?: string }; site_tag?: string; site_token?: string; snippet?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListSites1Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  auto_install: Schema.optional(Schema.Boolean),
  created: Schema.optional(Schema.Date),
  rules: Schema.optional(Schema.Array(Schema.Struct({
  created: Schema.optional(Schema.Date),
  host: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  inclusive: Schema.optional(Schema.Boolean),
  is_paused: Schema.optional(Schema.Boolean),
  paths: Schema.optional(Schema.Array(Schema.String)),
  priority: Schema.optional(Schema.Number)
}))),
  ruleset: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  zone_name: Schema.optional(Schema.String),
  zone_tag: Schema.optional(Schema.String)
})),
  site_tag: Schema.optional(Schema.String),
  site_token: Schema.optional(Schema.String),
  snippet: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListSites1Response" }) as unknown as Schema.Schema<ListSites1Response>;

export const listSites1: (
  input: ListSites1Request
) => Effect.Effect<
  ListSites1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListSites1Request,
  output: ListSites1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSiteRequest {
  account_id: string;
  site_id: string;
}

export const GetSiteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/rum/site_info/{site_id}" }),
).annotations({ identifier: "GetSiteRequest" }) as unknown as Schema.Schema<GetSiteRequest>;

export interface GetSiteResponse {
  result: { auto_install?: boolean; created?: string; rules?: { created?: string; host?: string; id?: string; inclusive?: boolean; is_paused?: boolean; paths?: string[]; priority?: number }[]; ruleset?: { enabled?: boolean; id?: string; zone_name?: string; zone_tag?: string }; site_tag?: string; site_token?: string; snippet?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSiteResponse = Schema.Struct({
  result: Schema.Struct({
  auto_install: Schema.optional(Schema.Boolean),
  created: Schema.optional(Schema.Date),
  rules: Schema.optional(Schema.Array(Schema.Struct({
  created: Schema.optional(Schema.Date),
  host: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  inclusive: Schema.optional(Schema.Boolean),
  is_paused: Schema.optional(Schema.Boolean),
  paths: Schema.optional(Schema.Array(Schema.String)),
  priority: Schema.optional(Schema.Number)
}))),
  ruleset: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  zone_name: Schema.optional(Schema.String),
  zone_tag: Schema.optional(Schema.String)
})),
  site_tag: Schema.optional(Schema.String),
  site_token: Schema.optional(Schema.String),
  snippet: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSiteResponse" }) as unknown as Schema.Schema<GetSiteResponse>;

export const getSite: (
  input: GetSiteRequest
) => Effect.Effect<
  GetSiteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSiteRequest,
  output: GetSiteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateSite1Request {
  account_id: string;
  site_id: string;
  body: { auto_install?: boolean; enabled?: boolean; host?: string; lite?: boolean; zone_tag?: string };
}

export const UpdateSite1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id")),
  body: Schema.Struct({
  auto_install: Schema.optional(Schema.Boolean),
  enabled: Schema.optional(Schema.Boolean),
  host: Schema.optional(Schema.String),
  lite: Schema.optional(Schema.Boolean),
  zone_tag: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/rum/site_info/{site_id}" }),
).annotations({ identifier: "UpdateSite1Request" }) as unknown as Schema.Schema<UpdateSite1Request>;

export interface UpdateSite1Response {
  result: { auto_install?: boolean; created?: string; rules?: { created?: string; host?: string; id?: string; inclusive?: boolean; is_paused?: boolean; paths?: string[]; priority?: number }[]; ruleset?: { enabled?: boolean; id?: string; zone_name?: string; zone_tag?: string }; site_tag?: string; site_token?: string; snippet?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateSite1Response = Schema.Struct({
  result: Schema.Struct({
  auto_install: Schema.optional(Schema.Boolean),
  created: Schema.optional(Schema.Date),
  rules: Schema.optional(Schema.Array(Schema.Struct({
  created: Schema.optional(Schema.Date),
  host: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  inclusive: Schema.optional(Schema.Boolean),
  is_paused: Schema.optional(Schema.Boolean),
  paths: Schema.optional(Schema.Array(Schema.String)),
  priority: Schema.optional(Schema.Number)
}))),
  ruleset: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  zone_name: Schema.optional(Schema.String),
  zone_tag: Schema.optional(Schema.String)
})),
  site_tag: Schema.optional(Schema.String),
  site_token: Schema.optional(Schema.String),
  snippet: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateSite1Response" }) as unknown as Schema.Schema<UpdateSite1Response>;

export const updateSite1: (
  input: UpdateSite1Request
) => Effect.Effect<
  UpdateSite1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateSite1Request,
  output: UpdateSite1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteSite1Request {
  account_id: string;
  site_id: string;
}

export const DeleteSite1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  site_id: Schema.String.pipe(T.HttpPath("site_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/rum/site_info/{site_id}" }),
).annotations({ identifier: "DeleteSite1Request" }) as unknown as Schema.Schema<DeleteSite1Request>;

export interface DeleteSite1Response {
  result: { site_tag?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteSite1Response = Schema.Struct({
  result: Schema.Struct({
  site_tag: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteSite1Response" }) as unknown as Schema.Schema<DeleteSite1Response>;

export const deleteSite1: (
  input: DeleteSite1Request
) => Effect.Effect<
  DeleteSite1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteSite1Request,
  output: DeleteSite1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateRule1Request {
  account_id: string;
  ruleset_id: string;
  body: { host?: string; inclusive?: boolean; is_paused?: boolean; paths?: string[] };
}

export const CreateRule1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  body: Schema.Struct({
  host: Schema.optional(Schema.String),
  inclusive: Schema.optional(Schema.Boolean),
  is_paused: Schema.optional(Schema.Boolean),
  paths: Schema.optional(Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/rum/v2/{ruleset_id}/rule" }),
).annotations({ identifier: "CreateRule1Request" }) as unknown as Schema.Schema<CreateRule1Request>;

export interface CreateRule1Response {
  result: { created?: string; host?: string; id?: string; inclusive?: boolean; is_paused?: boolean; paths?: string[]; priority?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateRule1Response = Schema.Struct({
  result: Schema.Struct({
  created: Schema.optional(Schema.Date),
  host: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  inclusive: Schema.optional(Schema.Boolean),
  is_paused: Schema.optional(Schema.Boolean),
  paths: Schema.optional(Schema.Array(Schema.String)),
  priority: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateRule1Response" }) as unknown as Schema.Schema<CreateRule1Response>;

export const createRule1: (
  input: CreateRule1Request
) => Effect.Effect<
  CreateRule1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateRule1Request,
  output: CreateRule1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateRule2Request {
  account_id: string;
  ruleset_id: string;
  rule_id: string;
  body: { host?: string; inclusive?: boolean; is_paused?: boolean; paths?: string[] };
}

export const UpdateRule2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  rule_id: Schema.String.pipe(T.HttpPath("rule_id")),
  body: Schema.Struct({
  host: Schema.optional(Schema.String),
  inclusive: Schema.optional(Schema.Boolean),
  is_paused: Schema.optional(Schema.Boolean),
  paths: Schema.optional(Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/rum/v2/{ruleset_id}/rule/{rule_id}" }),
).annotations({ identifier: "UpdateRule2Request" }) as unknown as Schema.Schema<UpdateRule2Request>;

export interface UpdateRule2Response {
  result: { created?: string; host?: string; id?: string; inclusive?: boolean; is_paused?: boolean; paths?: string[]; priority?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateRule2Response = Schema.Struct({
  result: Schema.Struct({
  created: Schema.optional(Schema.Date),
  host: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  inclusive: Schema.optional(Schema.Boolean),
  is_paused: Schema.optional(Schema.Boolean),
  paths: Schema.optional(Schema.Array(Schema.String)),
  priority: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateRule2Response" }) as unknown as Schema.Schema<UpdateRule2Response>;

export const updateRule2: (
  input: UpdateRule2Request
) => Effect.Effect<
  UpdateRule2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateRule2Request,
  output: UpdateRule2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteRule2Request {
  account_id: string;
  ruleset_id: string;
  rule_id: string;
}

export const DeleteRule2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  rule_id: Schema.String.pipe(T.HttpPath("rule_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/rum/v2/{ruleset_id}/rule/{rule_id}" }),
).annotations({ identifier: "DeleteRule2Request" }) as unknown as Schema.Schema<DeleteRule2Request>;

export interface DeleteRule2Response {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteRule2Response = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteRule2Response" }) as unknown as Schema.Schema<DeleteRule2Response>;

export const deleteRule2: (
  input: DeleteRule2Request
) => Effect.Effect<
  DeleteRule2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteRule2Request,
  output: DeleteRule2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListRules1Request {
  account_id: string;
  ruleset_id: string;
}

export const ListRules1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/rum/v2/{ruleset_id}/rules" }),
).annotations({ identifier: "ListRules1Request" }) as unknown as Schema.Schema<ListRules1Request>;

export interface ListRules1Response {
  result: { rules?: { created?: string; host?: string; id?: string; inclusive?: boolean; is_paused?: boolean; paths?: string[]; priority?: number }[]; ruleset?: { enabled?: boolean; id?: string; zone_name?: string; zone_tag?: string } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListRules1Response = Schema.Struct({
  result: Schema.Struct({
  rules: Schema.optional(Schema.Array(Schema.Struct({
  created: Schema.optional(Schema.Date),
  host: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  inclusive: Schema.optional(Schema.Boolean),
  is_paused: Schema.optional(Schema.Boolean),
  paths: Schema.optional(Schema.Array(Schema.String)),
  priority: Schema.optional(Schema.Number)
}))),
  ruleset: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  zone_name: Schema.optional(Schema.String),
  zone_tag: Schema.optional(Schema.String)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListRules1Response" }) as unknown as Schema.Schema<ListRules1Response>;

export const listRules1: (
  input: ListRules1Request
) => Effect.Effect<
  ListRules1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListRules1Request,
  output: ListRules1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface WebAnalyticsModifyRulesRequest {
  account_id: string;
  ruleset_id: string;
  body: { delete_rules?: string[]; rules?: { host?: string; id?: string; inclusive?: boolean; is_paused?: boolean; paths?: string[] }[] };
}

export const WebAnalyticsModifyRulesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  ruleset_id: Schema.String.pipe(T.HttpPath("ruleset_id")),
  body: Schema.Struct({
  delete_rules: Schema.optional(Schema.Array(Schema.String)),
  rules: Schema.optional(Schema.Array(Schema.Struct({
  host: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  inclusive: Schema.optional(Schema.Boolean),
  is_paused: Schema.optional(Schema.Boolean),
  paths: Schema.optional(Schema.Array(Schema.String))
})))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/rum/v2/{ruleset_id}/rules" }),
).annotations({ identifier: "WebAnalyticsModifyRulesRequest" }) as unknown as Schema.Schema<WebAnalyticsModifyRulesRequest>;

export interface WebAnalyticsModifyRulesResponse {
  result: { rules?: { created?: string; host?: string; id?: string; inclusive?: boolean; is_paused?: boolean; paths?: string[]; priority?: number }[]; ruleset?: { enabled?: boolean; id?: string; zone_name?: string; zone_tag?: string } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const WebAnalyticsModifyRulesResponse = Schema.Struct({
  result: Schema.Struct({
  rules: Schema.optional(Schema.Array(Schema.Struct({
  created: Schema.optional(Schema.Date),
  host: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  inclusive: Schema.optional(Schema.Boolean),
  is_paused: Schema.optional(Schema.Boolean),
  paths: Schema.optional(Schema.Array(Schema.String)),
  priority: Schema.optional(Schema.Number)
}))),
  ruleset: Schema.optional(Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  zone_name: Schema.optional(Schema.String),
  zone_tag: Schema.optional(Schema.String)
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "WebAnalyticsModifyRulesResponse" }) as unknown as Schema.Schema<WebAnalyticsModifyRulesResponse>;

export const webAnalyticsModifyRules: (
  input: WebAnalyticsModifyRulesRequest
) => Effect.Effect<
  WebAnalyticsModifyRulesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: WebAnalyticsModifyRulesRequest,
  output: WebAnalyticsModifyRulesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAcLsRequest {
  account_id: string;
}

export const ListAcLsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/secondary_dns/acls" }),
).annotations({ identifier: "ListAcLsRequest" }) as unknown as Schema.Schema<ListAcLsRequest>;

export interface ListAcLsResponse {
  result: { id: string; ip_range: string; name: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAcLsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  id: Schema.String,
  ip_range: Schema.String,
  name: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAcLsResponse" }) as unknown as Schema.Schema<ListAcLsResponse>;

export const listAcLs: (
  input: ListAcLsRequest
) => Effect.Effect<
  ListAcLsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAcLsRequest,
  output: ListAcLsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateAcl1Request {
  account_id: string;
  body: { ip_range: string; name: string };
}

export const CreateAcl1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  ip_range: Schema.String,
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/secondary_dns/acls" }),
).annotations({ identifier: "CreateAcl1Request" }) as unknown as Schema.Schema<CreateAcl1Request>;

export interface CreateAcl1Response {
  result: { id: string; ip_range: string; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateAcl1Response = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String,
  ip_range: Schema.String,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateAcl1Response" }) as unknown as Schema.Schema<CreateAcl1Response>;

export const createAcl1: (
  input: CreateAcl1Request
) => Effect.Effect<
  CreateAcl1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAcl1Request,
  output: CreateAcl1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SecondaryDnsAclAclDetailsRequest {
  acl_id: string;
  account_id: string;
}

export const SecondaryDnsAclAclDetailsRequest = Schema.Struct({
  acl_id: Schema.String.pipe(T.HttpPath("acl_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/secondary_dns/acls/{acl_id}" }),
).annotations({ identifier: "SecondaryDnsAclAclDetailsRequest" }) as unknown as Schema.Schema<SecondaryDnsAclAclDetailsRequest>;

export interface SecondaryDnsAclAclDetailsResponse {
  result: { id: string; ip_range: string; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SecondaryDnsAclAclDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String,
  ip_range: Schema.String,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SecondaryDnsAclAclDetailsResponse" }) as unknown as Schema.Schema<SecondaryDnsAclAclDetailsResponse>;

export const secondaryDnsAclAclDetails: (
  input: SecondaryDnsAclAclDetailsRequest
) => Effect.Effect<
  SecondaryDnsAclAclDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SecondaryDnsAclAclDetailsRequest,
  output: SecondaryDnsAclAclDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAcl1Request {
  acl_id: string;
  account_id: string;
  body: { id: string; ip_range: string; name: string };
}

export const UpdateAcl1Request = Schema.Struct({
  acl_id: Schema.String.pipe(T.HttpPath("acl_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  id: Schema.String,
  ip_range: Schema.String,
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/secondary_dns/acls/{acl_id}" }),
).annotations({ identifier: "UpdateAcl1Request" }) as unknown as Schema.Schema<UpdateAcl1Request>;

export interface UpdateAcl1Response {
  result: { id: string; ip_range: string; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAcl1Response = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String,
  ip_range: Schema.String,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAcl1Response" }) as unknown as Schema.Schema<UpdateAcl1Response>;

export const updateAcl1: (
  input: UpdateAcl1Request
) => Effect.Effect<
  UpdateAcl1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAcl1Request,
  output: UpdateAcl1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAcl1Request {
  acl_id: string;
  account_id: string;
}

export const DeleteAcl1Request = Schema.Struct({
  acl_id: Schema.String.pipe(T.HttpPath("acl_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/secondary_dns/acls/{acl_id}" }),
).annotations({ identifier: "DeleteAcl1Request" }) as unknown as Schema.Schema<DeleteAcl1Request>;

export interface DeleteAcl1Response {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAcl1Response = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAcl1Response" }) as unknown as Schema.Schema<DeleteAcl1Response>;

export const deleteAcl1: (
  input: DeleteAcl1Request
) => Effect.Effect<
  DeleteAcl1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAcl1Request,
  output: DeleteAcl1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListPeersRequest {
  account_id: string;
}

export const ListPeersRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/secondary_dns/peers" }),
).annotations({ identifier: "ListPeersRequest" }) as unknown as Schema.Schema<ListPeersRequest>;

export interface ListPeersResponse {
  result: { id: string; ip?: string; ixfr_enable?: boolean; name: string; port?: number; tsig_id?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListPeersResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  id: Schema.String,
  ip: Schema.optional(Schema.String),
  ixfr_enable: Schema.optional(Schema.Boolean),
  name: Schema.String,
  port: Schema.optional(Schema.Number),
  tsig_id: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListPeersResponse" }) as unknown as Schema.Schema<ListPeersResponse>;

export const listPeers: (
  input: ListPeersRequest
) => Effect.Effect<
  ListPeersResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListPeersRequest,
  output: ListPeersResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreatePeerRequest {
  account_id: string;
  body: { name: string };
}

export const CreatePeerRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/secondary_dns/peers" }),
).annotations({ identifier: "CreatePeerRequest" }) as unknown as Schema.Schema<CreatePeerRequest>;

export interface CreatePeerResponse {
  result: { id: string; ip?: string; ixfr_enable?: boolean; name: string; port?: number; tsig_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreatePeerResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String,
  ip: Schema.optional(Schema.String),
  ixfr_enable: Schema.optional(Schema.Boolean),
  name: Schema.String,
  port: Schema.optional(Schema.Number),
  tsig_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreatePeerResponse" }) as unknown as Schema.Schema<CreatePeerResponse>;

export const createPeer: (
  input: CreatePeerRequest
) => Effect.Effect<
  CreatePeerResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreatePeerRequest,
  output: CreatePeerResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SecondaryDnsPeerPeerDetailsRequest {
  peer_id: string;
  account_id: string;
}

export const SecondaryDnsPeerPeerDetailsRequest = Schema.Struct({
  peer_id: Schema.String.pipe(T.HttpPath("peer_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/secondary_dns/peers/{peer_id}" }),
).annotations({ identifier: "SecondaryDnsPeerPeerDetailsRequest" }) as unknown as Schema.Schema<SecondaryDnsPeerPeerDetailsRequest>;

export interface SecondaryDnsPeerPeerDetailsResponse {
  result: { id: string; ip?: string; ixfr_enable?: boolean; name: string; port?: number; tsig_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SecondaryDnsPeerPeerDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String,
  ip: Schema.optional(Schema.String),
  ixfr_enable: Schema.optional(Schema.Boolean),
  name: Schema.String,
  port: Schema.optional(Schema.Number),
  tsig_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SecondaryDnsPeerPeerDetailsResponse" }) as unknown as Schema.Schema<SecondaryDnsPeerPeerDetailsResponse>;

export const secondaryDnsPeerPeerDetails: (
  input: SecondaryDnsPeerPeerDetailsRequest
) => Effect.Effect<
  SecondaryDnsPeerPeerDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SecondaryDnsPeerPeerDetailsRequest,
  output: SecondaryDnsPeerPeerDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdatePeerRequest {
  peer_id: string;
  account_id: string;
  body: { id: string; ip?: string; ixfr_enable?: boolean; name: string; port?: number; tsig_id?: string };
}

export const UpdatePeerRequest = Schema.Struct({
  peer_id: Schema.String.pipe(T.HttpPath("peer_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  id: Schema.String,
  ip: Schema.optional(Schema.String),
  ixfr_enable: Schema.optional(Schema.Boolean),
  name: Schema.String,
  port: Schema.optional(Schema.Number),
  tsig_id: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/secondary_dns/peers/{peer_id}" }),
).annotations({ identifier: "UpdatePeerRequest" }) as unknown as Schema.Schema<UpdatePeerRequest>;

export interface UpdatePeerResponse {
  result: { id: string; ip?: string; ixfr_enable?: boolean; name: string; port?: number; tsig_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdatePeerResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String,
  ip: Schema.optional(Schema.String),
  ixfr_enable: Schema.optional(Schema.Boolean),
  name: Schema.String,
  port: Schema.optional(Schema.Number),
  tsig_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdatePeerResponse" }) as unknown as Schema.Schema<UpdatePeerResponse>;

export const updatePeer: (
  input: UpdatePeerRequest
) => Effect.Effect<
  UpdatePeerResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdatePeerRequest,
  output: UpdatePeerResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeletePeerRequest {
  peer_id: string;
  account_id: string;
}

export const DeletePeerRequest = Schema.Struct({
  peer_id: Schema.String.pipe(T.HttpPath("peer_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/secondary_dns/peers/{peer_id}" }),
).annotations({ identifier: "DeletePeerRequest" }) as unknown as Schema.Schema<DeletePeerRequest>;

export interface DeletePeerResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeletePeerResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeletePeerResponse" }) as unknown as Schema.Schema<DeletePeerResponse>;

export const deletePeer: (
  input: DeletePeerRequest
) => Effect.Effect<
  DeletePeerResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeletePeerRequest,
  output: DeletePeerResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListTsiGsRequest {
  account_id: string;
}

export const ListTsiGsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/secondary_dns/tsigs" }),
).annotations({ identifier: "ListTsiGsRequest" }) as unknown as Schema.Schema<ListTsiGsRequest>;

export interface ListTsiGsResponse {
  result: { algo: string; id: string; name: string; secret: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListTsiGsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  algo: Schema.String,
  id: Schema.String,
  name: Schema.String,
  secret: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListTsiGsResponse" }) as unknown as Schema.Schema<ListTsiGsResponse>;

export const listTsiGs: (
  input: ListTsiGsRequest
) => Effect.Effect<
  ListTsiGsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListTsiGsRequest,
  output: ListTsiGsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateTsigRequest {
  account_id: string;
  body: { algo: string; id: string; name: string; secret: string };
}

export const CreateTsigRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  algo: Schema.String,
  id: Schema.String,
  name: Schema.String,
  secret: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/secondary_dns/tsigs" }),
).annotations({ identifier: "CreateTsigRequest" }) as unknown as Schema.Schema<CreateTsigRequest>;

export interface CreateTsigResponse {
  result: { algo: string; id: string; name: string; secret: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateTsigResponse = Schema.Struct({
  result: Schema.Struct({
  algo: Schema.String,
  id: Schema.String,
  name: Schema.String,
  secret: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateTsigResponse" }) as unknown as Schema.Schema<CreateTsigResponse>;

export const createTsig: (
  input: CreateTsigRequest
) => Effect.Effect<
  CreateTsigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateTsigRequest,
  output: CreateTsigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SecondaryDnsTsigTsigDetailsRequest {
  tsig_id: string;
  account_id: string;
}

export const SecondaryDnsTsigTsigDetailsRequest = Schema.Struct({
  tsig_id: Schema.String.pipe(T.HttpPath("tsig_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/secondary_dns/tsigs/{tsig_id}" }),
).annotations({ identifier: "SecondaryDnsTsigTsigDetailsRequest" }) as unknown as Schema.Schema<SecondaryDnsTsigTsigDetailsRequest>;

export interface SecondaryDnsTsigTsigDetailsResponse {
  result: { algo: string; id: string; name: string; secret: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SecondaryDnsTsigTsigDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  algo: Schema.String,
  id: Schema.String,
  name: Schema.String,
  secret: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SecondaryDnsTsigTsigDetailsResponse" }) as unknown as Schema.Schema<SecondaryDnsTsigTsigDetailsResponse>;

export const secondaryDnsTsigTsigDetails: (
  input: SecondaryDnsTsigTsigDetailsRequest
) => Effect.Effect<
  SecondaryDnsTsigTsigDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SecondaryDnsTsigTsigDetailsRequest,
  output: SecondaryDnsTsigTsigDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateTsigRequest {
  tsig_id: string;
  account_id: string;
  body: { algo: string; id: string; name: string; secret: string };
}

export const UpdateTsigRequest = Schema.Struct({
  tsig_id: Schema.String.pipe(T.HttpPath("tsig_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  algo: Schema.String,
  id: Schema.String,
  name: Schema.String,
  secret: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/secondary_dns/tsigs/{tsig_id}" }),
).annotations({ identifier: "UpdateTsigRequest" }) as unknown as Schema.Schema<UpdateTsigRequest>;

export interface UpdateTsigResponse {
  result: { algo: string; id: string; name: string; secret: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateTsigResponse = Schema.Struct({
  result: Schema.Struct({
  algo: Schema.String,
  id: Schema.String,
  name: Schema.String,
  secret: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateTsigResponse" }) as unknown as Schema.Schema<UpdateTsigResponse>;

export const updateTsig: (
  input: UpdateTsigRequest
) => Effect.Effect<
  UpdateTsigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateTsigRequest,
  output: UpdateTsigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteTsigRequest {
  tsig_id: string;
  account_id: string;
}

export const DeleteTsigRequest = Schema.Struct({
  tsig_id: Schema.String.pipe(T.HttpPath("tsig_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/secondary_dns/tsigs/{tsig_id}" }),
).annotations({ identifier: "DeleteTsigRequest" }) as unknown as Schema.Schema<DeleteTsigRequest>;

export interface DeleteTsigResponse {
  result: { id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteTsigResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteTsigResponse" }) as unknown as Schema.Schema<DeleteTsigResponse>;

export const deleteTsig: (
  input: DeleteTsigRequest
) => Effect.Effect<
  DeleteTsigResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteTsigRequest,
  output: DeleteTsigResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SecretsStoreQuotaRequest {
  account_id: string;
}

export const SecretsStoreQuotaRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/secrets_store/quota" }),
).annotations({ identifier: "SecretsStoreQuotaRequest" }) as unknown as Schema.Schema<SecretsStoreQuotaRequest>;

export interface SecretsStoreQuotaResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SecretsStoreQuotaResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SecretsStoreQuotaResponse" }) as unknown as Schema.Schema<SecretsStoreQuotaResponse>;

export const secretsStoreQuota: (
  input: SecretsStoreQuotaRequest
) => Effect.Effect<
  SecretsStoreQuotaResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SecretsStoreQuotaRequest,
  output: SecretsStoreQuotaResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List39Request {
  account_id: string;
}

export const List39Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/secrets_store/stores" }),
).annotations({ identifier: "List39Request" }) as unknown as Schema.Schema<List39Request>;

export interface List39Response {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List39Response = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List39Response" }) as unknown as Schema.Schema<List39Response>;

export const list39: (
  input: List39Request
) => Effect.Effect<
  List39Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List39Request,
  output: List39Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create13Request {
  account_id: string;
  body: unknown[];
}

export const Create13Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Unknown).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/secrets_store/stores" }),
).annotations({ identifier: "Create13Request" }) as unknown as Schema.Schema<Create13Request>;

export interface Create13Response {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create13Response = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create13Response" }) as unknown as Schema.Schema<Create13Response>;

export const create13: (
  input: Create13Request
) => Effect.Effect<
  Create13Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create13Request,
  output: Create13Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteByIdRequest {
  account_id: string;
  store_id: string;
}

export const DeleteByIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  store_id: Schema.String.pipe(T.HttpPath("store_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/secrets_store/stores/{store_id}" }),
).annotations({ identifier: "DeleteByIdRequest" }) as unknown as Schema.Schema<DeleteByIdRequest>;

export interface DeleteByIdResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteByIdResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteByIdResponse" }) as unknown as Schema.Schema<DeleteByIdResponse>;

export const deleteById: (
  input: DeleteByIdRequest
) => Effect.Effect<
  DeleteByIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteByIdRequest,
  output: DeleteByIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List40Request {
  account_id: string;
  store_id: string;
}

export const List40Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  store_id: Schema.String.pipe(T.HttpPath("store_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/secrets_store/stores/{store_id}/secrets" }),
).annotations({ identifier: "List40Request" }) as unknown as Schema.Schema<List40Request>;

export interface List40Response {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List40Response = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List40Response" }) as unknown as Schema.Schema<List40Response>;

export const list40: (
  input: List40Request
) => Effect.Effect<
  List40Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List40Request,
  output: List40Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create14Request {
  account_id: string;
  store_id: string;
  body: unknown[];
}

export const Create14Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  store_id: Schema.String.pipe(T.HttpPath("store_id")),
  body: Schema.Array(Schema.Unknown).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/secrets_store/stores/{store_id}/secrets" }),
).annotations({ identifier: "Create14Request" }) as unknown as Schema.Schema<Create14Request>;

export interface Create14Response {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create14Response = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create14Response" }) as unknown as Schema.Schema<Create14Response>;

export const create14: (
  input: Create14Request
) => Effect.Effect<
  Create14Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create14Request,
  output: Create14Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteBulkRequest {
  account_id: string;
  store_id: string;
  body: unknown[];
}

export const DeleteBulkRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  store_id: Schema.String.pipe(T.HttpPath("store_id")),
  body: Schema.Array(Schema.Unknown).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/secrets_store/stores/{store_id}/secrets" }),
).annotations({ identifier: "DeleteBulkRequest" }) as unknown as Schema.Schema<DeleteBulkRequest>;

export interface DeleteBulkResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteBulkResponse = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteBulkResponse" }) as unknown as Schema.Schema<DeleteBulkResponse>;

export const deleteBulk: (
  input: DeleteBulkRequest
) => Effect.Effect<
  DeleteBulkResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteBulkRequest,
  output: DeleteBulkResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetByIdRequest {
  account_id: string;
  store_id: string;
  secret_id: string;
}

export const GetByIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  store_id: Schema.String.pipe(T.HttpPath("store_id")),
  secret_id: Schema.String.pipe(T.HttpPath("secret_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/secrets_store/stores/{store_id}/secrets/{secret_id}" }),
).annotations({ identifier: "GetByIdRequest" }) as unknown as Schema.Schema<GetByIdRequest>;

export interface GetByIdResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetByIdResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetByIdResponse" }) as unknown as Schema.Schema<GetByIdResponse>;

export const getById: (
  input: GetByIdRequest
) => Effect.Effect<
  GetByIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetByIdRequest,
  output: GetByIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteById1Request {
  account_id: string;
  store_id: string;
  secret_id: string;
}

export const DeleteById1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  store_id: Schema.String.pipe(T.HttpPath("store_id")),
  secret_id: Schema.String.pipe(T.HttpPath("secret_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/secrets_store/stores/{store_id}/secrets/{secret_id}" }),
).annotations({ identifier: "DeleteById1Request" }) as unknown as Schema.Schema<DeleteById1Request>;

export interface DeleteById1Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteById1Response = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteById1Response" }) as unknown as Schema.Schema<DeleteById1Response>;

export const deleteById1: (
  input: DeleteById1Request
) => Effect.Effect<
  DeleteById1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteById1Request,
  output: DeleteById1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchByIdRequest {
  account_id: string;
  store_id: string;
  secret_id: string;
  body: unknown;
}

export const PatchByIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  store_id: Schema.String.pipe(T.HttpPath("store_id")),
  secret_id: Schema.String.pipe(T.HttpPath("secret_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/secrets_store/stores/{store_id}/secrets/{secret_id}" }),
).annotations({ identifier: "PatchByIdRequest" }) as unknown as Schema.Schema<PatchByIdRequest>;

export interface PatchByIdResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchByIdResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchByIdResponse" }) as unknown as Schema.Schema<PatchByIdResponse>;

export const patchById: (
  input: PatchByIdRequest
) => Effect.Effect<
  PatchByIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchByIdRequest,
  output: PatchByIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SecretsStoreDuplicateByIdRequest {
  account_id: string;
  store_id: string;
  secret_id: string;
  body: unknown;
}

export const SecretsStoreDuplicateByIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  store_id: Schema.String.pipe(T.HttpPath("store_id")),
  secret_id: Schema.String.pipe(T.HttpPath("secret_id")),
  body: Schema.Unknown.pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/secrets_store/stores/{store_id}/secrets/{secret_id}/duplicate" }),
).annotations({ identifier: "SecretsStoreDuplicateByIdRequest" }) as unknown as Schema.Schema<SecretsStoreDuplicateByIdRequest>;

export interface SecretsStoreDuplicateByIdResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SecretsStoreDuplicateByIdResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SecretsStoreDuplicateByIdResponse" }) as unknown as Schema.Schema<SecretsStoreDuplicateByIdResponse>;

export const secretsStoreDuplicateById: (
  input: SecretsStoreDuplicateByIdRequest
) => Effect.Effect<
  SecretsStoreDuplicateByIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SecretsStoreDuplicateByIdRequest,
  output: SecretsStoreDuplicateByIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSecurityCenterInsightsRequest {
  account_id: string;
  dismissed?: boolean;
  issue_class?: string[];
  issue_type?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  product?: string[];
  severity?: "low" | "moderate" | "critical"[];
  subject?: string[];
  "issue_class~neq"?: string[];
  "issue_type~neq"?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  "product~neq"?: string[];
  "severity~neq"?: "low" | "moderate" | "critical"[];
  "subject~neq"?: string[];
  page?: unknown;
  per_page?: unknown;
}

export const GetSecurityCenterInsightsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dismissed: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("dismissed")),
  issue_class: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class")),
  issue_type: Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type")),
  product: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product")),
  severity: Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity")),
  subject: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject")),
  "issue_class~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class~neq")),
  "issue_type~neq": Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type~neq")),
  "product~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product~neq")),
  "severity~neq": Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity~neq")),
  "subject~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject~neq")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/security-center/insights" }),
).annotations({ identifier: "GetSecurityCenterInsightsRequest" }) as unknown as Schema.Schema<GetSecurityCenterInsightsRequest>;

export interface GetSecurityCenterInsightsResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSecurityCenterInsightsResponse = Schema.Struct({
  result: Schema.Union(Schema.Struct({
  count: Schema.optional(Schema.Number),
  issues: Schema.optional(Schema.Array(Schema.Struct({
  dismissed: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  issue_class: Schema.optional(Schema.String),
  issue_type: Schema.optional(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion")),
  payload: Schema.optional(Schema.Struct({
  detection_method: Schema.optional(Schema.String),
  zone_tag: Schema.optional(Schema.String)
})),
  resolve_link: Schema.optional(Schema.String),
  resolve_text: Schema.optional(Schema.String),
  severity: Schema.optional(Schema.Literal("Low", "Moderate", "Critical")),
  since: Schema.optional(Schema.Date),
  subject: Schema.optional(Schema.String),
  timestamp: Schema.optional(Schema.Date)
}))),
  page: Schema.optional(Schema.Number),
  per_page: Schema.optional(Schema.Number)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSecurityCenterInsightsResponse" }) as unknown as Schema.Schema<GetSecurityCenterInsightsResponse>;

export const getSecurityCenterInsights: (
  input: GetSecurityCenterInsightsRequest
) => Effect.Effect<
  GetSecurityCenterInsightsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSecurityCenterInsightsRequest,
  output: GetSecurityCenterInsightsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSecurityCenterInsightCountsByClassRequest {
  account_id: string;
  dismissed?: boolean;
  issue_class?: string[];
  issue_type?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  product?: string[];
  severity?: "low" | "moderate" | "critical"[];
  subject?: string[];
  "issue_class~neq"?: string[];
  "issue_type~neq"?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  "product~neq"?: string[];
  "severity~neq"?: "low" | "moderate" | "critical"[];
  "subject~neq"?: string[];
}

export const GetSecurityCenterInsightCountsByClassRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dismissed: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("dismissed")),
  issue_class: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class")),
  issue_type: Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type")),
  product: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product")),
  severity: Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity")),
  subject: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject")),
  "issue_class~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class~neq")),
  "issue_type~neq": Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type~neq")),
  "product~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product~neq")),
  "severity~neq": Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity~neq")),
  "subject~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject~neq"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/security-center/insights/class" }),
).annotations({ identifier: "GetSecurityCenterInsightCountsByClassRequest" }) as unknown as Schema.Schema<GetSecurityCenterInsightCountsByClassRequest>;

export interface GetSecurityCenterInsightCountsByClassResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSecurityCenterInsightCountsByClassResponse = Schema.Struct({
  result: Schema.Union(Schema.Array(Schema.Struct({
  count: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.String)
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSecurityCenterInsightCountsByClassResponse" }) as unknown as Schema.Schema<GetSecurityCenterInsightCountsByClassResponse>;

export const getSecurityCenterInsightCountsByClass: (
  input: GetSecurityCenterInsightCountsByClassRequest
) => Effect.Effect<
  GetSecurityCenterInsightCountsByClassResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSecurityCenterInsightCountsByClassRequest,
  output: GetSecurityCenterInsightCountsByClassResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSecurityCenterInsightCountsBySeverityRequest {
  account_id: string;
  dismissed?: boolean;
  issue_class?: string[];
  issue_type?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  product?: string[];
  severity?: "low" | "moderate" | "critical"[];
  subject?: string[];
  "issue_class~neq"?: string[];
  "issue_type~neq"?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  "product~neq"?: string[];
  "severity~neq"?: "low" | "moderate" | "critical"[];
  "subject~neq"?: string[];
}

export const GetSecurityCenterInsightCountsBySeverityRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dismissed: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("dismissed")),
  issue_class: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class")),
  issue_type: Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type")),
  product: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product")),
  severity: Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity")),
  subject: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject")),
  "issue_class~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class~neq")),
  "issue_type~neq": Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type~neq")),
  "product~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product~neq")),
  "severity~neq": Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity~neq")),
  "subject~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject~neq"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/security-center/insights/severity" }),
).annotations({ identifier: "GetSecurityCenterInsightCountsBySeverityRequest" }) as unknown as Schema.Schema<GetSecurityCenterInsightCountsBySeverityRequest>;

export interface GetSecurityCenterInsightCountsBySeverityResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSecurityCenterInsightCountsBySeverityResponse = Schema.Struct({
  result: Schema.Union(Schema.Array(Schema.Struct({
  count: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.String)
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSecurityCenterInsightCountsBySeverityResponse" }) as unknown as Schema.Schema<GetSecurityCenterInsightCountsBySeverityResponse>;

export const getSecurityCenterInsightCountsBySeverity: (
  input: GetSecurityCenterInsightCountsBySeverityRequest
) => Effect.Effect<
  GetSecurityCenterInsightCountsBySeverityResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSecurityCenterInsightCountsBySeverityRequest,
  output: GetSecurityCenterInsightCountsBySeverityResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSecurityCenterInsightCountsByTypeRequest {
  account_id: string;
  dismissed?: boolean;
  issue_class?: string[];
  issue_type?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  product?: string[];
  severity?: "low" | "moderate" | "critical"[];
  subject?: string[];
  "issue_class~neq"?: string[];
  "issue_type~neq"?: "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication" | "configuration_suggestion"[];
  "product~neq"?: string[];
  "severity~neq"?: "low" | "moderate" | "critical"[];
  "subject~neq"?: string[];
}

export const GetSecurityCenterInsightCountsByTypeRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  dismissed: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("dismissed")),
  issue_class: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class")),
  issue_type: Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type")),
  product: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product")),
  severity: Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity")),
  subject: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject")),
  "issue_class~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("issue_class~neq")),
  "issue_type~neq": Schema.optional(Schema.Array(Schema.Literal("compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication", "configuration_suggestion"))).pipe(T.HttpQuery("issue_type~neq")),
  "product~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("product~neq")),
  "severity~neq": Schema.optional(Schema.Array(Schema.Literal("low", "moderate", "critical"))).pipe(T.HttpQuery("severity~neq")),
  "subject~neq": Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("subject~neq"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/security-center/insights/type" }),
).annotations({ identifier: "GetSecurityCenterInsightCountsByTypeRequest" }) as unknown as Schema.Schema<GetSecurityCenterInsightCountsByTypeRequest>;

export interface GetSecurityCenterInsightCountsByTypeResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSecurityCenterInsightCountsByTypeResponse = Schema.Struct({
  result: Schema.Union(Schema.Array(Schema.Struct({
  count: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.String)
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSecurityCenterInsightCountsByTypeResponse" }) as unknown as Schema.Schema<GetSecurityCenterInsightCountsByTypeResponse>;

export const getSecurityCenterInsightCountsByType: (
  input: GetSecurityCenterInsightCountsByTypeRequest
) => Effect.Effect<
  GetSecurityCenterInsightCountsByTypeResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSecurityCenterInsightCountsByTypeRequest,
  output: GetSecurityCenterInsightCountsByTypeResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ArchiveSecurityCenterInsightRequest {
  account_id: string;
  issue_id: string;
  body: { dismiss?: boolean };
}

export const ArchiveSecurityCenterInsightRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  issue_id: Schema.String.pipe(T.HttpPath("issue_id")),
  body: Schema.Struct({
  dismiss: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/security-center/insights/{issue_id}/dismiss" }),
).annotations({ identifier: "ArchiveSecurityCenterInsightRequest" }) as unknown as Schema.Schema<ArchiveSecurityCenterInsightRequest>;

export interface ArchiveSecurityCenterInsightResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ArchiveSecurityCenterInsightResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ArchiveSecurityCenterInsightResponse" }) as unknown as Schema.Schema<ArchiveSecurityCenterInsightResponse>;

export const archiveSecurityCenterInsight: (
  input: ArchiveSecurityCenterInsightRequest
) => Effect.Effect<
  ArchiveSecurityCenterInsightResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ArchiveSecurityCenterInsightRequest,
  output: ArchiveSecurityCenterInsightResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List41Request {
  account_id: string;
}

export const List41Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/shares" }),
).annotations({ identifier: "List41Request" }) as unknown as Schema.Schema<List41Request>;

export interface List41Response {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List41Response = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List41Response" }) as unknown as Schema.Schema<List41Response>;

export const list41: (
  input: List41Request
) => Effect.Effect<
  List41Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List41Request,
  output: List41Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create15Request {
  account_id: string;
  body: { name: string; recipients: { account_id?: string; organization_id?: string }[]; resources: { meta: Record<string, unknown>; resource_account_id: string; resource_id: string; resource_type: "custom-ruleset" | "widget" | "gateway-policy" | "gateway-destination-ip" | "gateway-block-page-settings" | "gateway-extended-email-matching" }[] };
}

export const Create15Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  name: Schema.String,
  recipients: Schema.Array(Schema.Struct({
  account_id: Schema.optional(Schema.String),
  organization_id: Schema.optional(Schema.String)
})),
  resources: Schema.Array(Schema.Struct({
  meta: Schema.Struct({}),
  resource_account_id: Schema.String,
  resource_id: Schema.String,
  resource_type: Schema.Literal("custom-ruleset", "widget", "gateway-policy", "gateway-destination-ip", "gateway-block-page-settings", "gateway-extended-email-matching")
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/shares" }),
).annotations({ identifier: "Create15Request" }) as unknown as Schema.Schema<Create15Request>;

export interface Create15Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create15Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create15Response" }) as unknown as Schema.Schema<Create15Response>;

export const create15: (
  input: Create15Request
) => Effect.Effect<
  Create15Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create15Request,
  output: Create15Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetById1Request {
  account_id: string;
  share_id: string;
}

export const GetById1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  share_id: Schema.String.pipe(T.HttpPath("share_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/shares/{share_id}" }),
).annotations({ identifier: "GetById1Request" }) as unknown as Schema.Schema<GetById1Request>;

export interface GetById1Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetById1Response = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetById1Response" }) as unknown as Schema.Schema<GetById1Response>;

export const getById1: (
  input: GetById1Request
) => Effect.Effect<
  GetById1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetById1Request,
  output: GetById1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update17Request {
  account_id: string;
  share_id: string;
  body: { name: string };
}

export const Update17Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  share_id: Schema.String.pipe(T.HttpPath("share_id")),
  body: Schema.Struct({
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/shares/{share_id}" }),
).annotations({ identifier: "Update17Request" }) as unknown as Schema.Schema<Update17Request>;

export interface Update17Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update17Response = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update17Response" }) as unknown as Schema.Schema<Update17Response>;

export const update17: (
  input: Update17Request
) => Effect.Effect<
  Update17Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update17Request,
  output: Update17Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_18Request {
  account_id: string;
  share_id: string;
}

export const Delete_18Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  share_id: Schema.String.pipe(T.HttpPath("share_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/shares/{share_id}" }),
).annotations({ identifier: "Delete_18Request" }) as unknown as Schema.Schema<Delete_18Request>;

export interface Delete_18Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_18Response = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_18Response" }) as unknown as Schema.Schema<Delete_18Response>;

export const delete_18: (
  input: Delete_18Request
) => Effect.Effect<
  Delete_18Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_18Request,
  output: Delete_18Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List42Request {
  account_id: string;
  share_id: string;
}

export const List42Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  share_id: Schema.String.pipe(T.HttpPath("share_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/shares/{share_id}/recipients" }),
).annotations({ identifier: "List42Request" }) as unknown as Schema.Schema<List42Request>;

export interface List42Response {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List42Response = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List42Response" }) as unknown as Schema.Schema<List42Response>;

export const list42: (
  input: List42Request
) => Effect.Effect<
  List42Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List42Request,
  output: List42Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create16Request {
  account_id: string;
  share_id: string;
  body: { account_id?: string; organization_id?: string };
}

export const Create16Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  share_id: Schema.String.pipe(T.HttpPath("share_id")),
  body: Schema.Struct({
  account_id: Schema.optional(Schema.String),
  organization_id: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/shares/{share_id}/recipients" }),
).annotations({ identifier: "Create16Request" }) as unknown as Schema.Schema<Create16Request>;

export interface Create16Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create16Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create16Response" }) as unknown as Schema.Schema<Create16Response>;

export const create16: (
  input: Create16Request
) => Effect.Effect<
  Create16Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create16Request,
  output: Create16Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update18Request {
  account_id: string;
  share_id: string;
  body: { account_id?: string; organization_id?: string }[];
}

export const Update18Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  share_id: Schema.String.pipe(T.HttpPath("share_id")),
  body: Schema.Array(Schema.Struct({
  account_id: Schema.optional(Schema.String),
  organization_id: Schema.optional(Schema.String)
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/shares/{share_id}/recipients" }),
).annotations({ identifier: "Update18Request" }) as unknown as Schema.Schema<Update18Request>;

export interface Update18Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update18Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update18Response" }) as unknown as Schema.Schema<Update18Response>;

export const update18: (
  input: Update18Request
) => Effect.Effect<
  Update18Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update18Request,
  output: Update18Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetById2Request {
  account_id: string;
  share_id: string;
  recipient_id: string;
}

export const GetById2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  share_id: Schema.String.pipe(T.HttpPath("share_id")),
  recipient_id: Schema.String.pipe(T.HttpPath("recipient_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/shares/{share_id}/recipients/{recipient_id}" }),
).annotations({ identifier: "GetById2Request" }) as unknown as Schema.Schema<GetById2Request>;

export interface GetById2Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetById2Response = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetById2Response" }) as unknown as Schema.Schema<GetById2Response>;

export const getById2: (
  input: GetById2Request
) => Effect.Effect<
  GetById2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetById2Request,
  output: GetById2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_19Request {
  account_id: string;
  share_id: string;
  recipient_id: string;
}

export const Delete_19Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  share_id: Schema.String.pipe(T.HttpPath("share_id")),
  recipient_id: Schema.String.pipe(T.HttpPath("recipient_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/shares/{share_id}/recipients/{recipient_id}" }),
).annotations({ identifier: "Delete_19Request" }) as unknown as Schema.Schema<Delete_19Request>;

export interface Delete_19Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_19Response = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_19Response" }) as unknown as Schema.Schema<Delete_19Response>;

export const delete_19: (
  input: Delete_19Request
) => Effect.Effect<
  Delete_19Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_19Request,
  output: Delete_19Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List43Request {
  account_id: string;
  share_id: string;
}

export const List43Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  share_id: Schema.String.pipe(T.HttpPath("share_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/shares/{share_id}/resources" }),
).annotations({ identifier: "List43Request" }) as unknown as Schema.Schema<List43Request>;

export interface List43Response {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List43Response = Schema.Struct({
  result: Schema.Array(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List43Response" }) as unknown as Schema.Schema<List43Response>;

export const list43: (
  input: List43Request
) => Effect.Effect<
  List43Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List43Request,
  output: List43Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create17Request {
  account_id: string;
  share_id: string;
  body: { meta: Record<string, unknown>; resource_account_id: string; resource_id: string; resource_type: "custom-ruleset" | "widget" | "gateway-policy" | "gateway-destination-ip" | "gateway-block-page-settings" | "gateway-extended-email-matching" };
}

export const Create17Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  share_id: Schema.String.pipe(T.HttpPath("share_id")),
  body: Schema.Struct({
  meta: Schema.Struct({}),
  resource_account_id: Schema.String,
  resource_id: Schema.String,
  resource_type: Schema.Literal("custom-ruleset", "widget", "gateway-policy", "gateway-destination-ip", "gateway-block-page-settings", "gateway-extended-email-matching")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/shares/{share_id}/resources" }),
).annotations({ identifier: "Create17Request" }) as unknown as Schema.Schema<Create17Request>;

export interface Create17Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create17Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create17Response" }) as unknown as Schema.Schema<Create17Response>;

export const create17: (
  input: Create17Request
) => Effect.Effect<
  Create17Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create17Request,
  output: Create17Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetById3Request {
  account_id: string;
  share_id: string;
  resource_id: string;
}

export const GetById3Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  share_id: Schema.String.pipe(T.HttpPath("share_id")),
  resource_id: Schema.String.pipe(T.HttpPath("resource_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/shares/{share_id}/resources/{resource_id}" }),
).annotations({ identifier: "GetById3Request" }) as unknown as Schema.Schema<GetById3Request>;

export interface GetById3Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetById3Response = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetById3Response" }) as unknown as Schema.Schema<GetById3Response>;

export const getById3: (
  input: GetById3Request
) => Effect.Effect<
  GetById3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetById3Request,
  output: GetById3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update19Request {
  account_id: string;
  share_id: string;
  resource_id: string;
  body: { meta: Record<string, unknown> };
}

export const Update19Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  share_id: Schema.String.pipe(T.HttpPath("share_id")),
  resource_id: Schema.String.pipe(T.HttpPath("resource_id")),
  body: Schema.Struct({
  meta: Schema.Struct({})
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/shares/{share_id}/resources/{resource_id}" }),
).annotations({ identifier: "Update19Request" }) as unknown as Schema.Schema<Update19Request>;

export interface Update19Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update19Response = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update19Response" }) as unknown as Schema.Schema<Update19Response>;

export const update19: (
  input: Update19Request
) => Effect.Effect<
  Update19Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update19Request,
  output: Update19Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_20Request {
  account_id: string;
  share_id: string;
  resource_id: string;
}

export const Delete_20Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  share_id: Schema.String.pipe(T.HttpPath("share_id")),
  resource_id: Schema.String.pipe(T.HttpPath("resource_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/shares/{share_id}/resources/{resource_id}" }),
).annotations({ identifier: "Delete_20Request" }) as unknown as Schema.Schema<Delete_20Request>;

export interface Delete_20Response {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_20Response = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_20Response" }) as unknown as Schema.Schema<Delete_20Response>;

export const delete_20: (
  input: Delete_20Request
) => Effect.Effect<
  Delete_20Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_20Request,
  output: Delete_20Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListJobs2Request {
  account_id: string;
  limit?: number;
  offset?: number;
}

export const ListJobs2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/slurper/jobs" }),
).annotations({ identifier: "ListJobs2Request" }) as unknown as Schema.Schema<ListJobs2Request>;

export interface ListJobs2Response {
  result: { createdAt?: string; finishedAt?: string; id?: string; overwrite?: boolean; source?: unknown; status?: "running" | "paused" | "aborted" | "completed"; target?: { bucket?: string; jurisdiction?: "default" | "eu" | "fedramp"; vendor?: "r2" } }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListJobs2Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  createdAt: Schema.optional(Schema.String),
  finishedAt: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  overwrite: Schema.optional(Schema.Boolean),
  source: Schema.optional(Schema.Union(Schema.Struct({
  bucket: Schema.optional(Schema.String),
  endpoint: Schema.optional(Schema.String),
  keys: Schema.optional(Schema.Array(Schema.String)),
  pathPrefix: Schema.optional(Schema.String),
  vendor: Schema.optional(Schema.Literal("s3"))
}), Schema.Struct({
  bucket: Schema.optional(Schema.String),
  keys: Schema.optional(Schema.Array(Schema.String)),
  pathPrefix: Schema.optional(Schema.String),
  vendor: Schema.optional(Schema.Literal("gcs"))
}), Schema.Struct({
  bucket: Schema.optional(Schema.String),
  jurisdiction: Schema.optional(Schema.Literal("default", "eu", "fedramp")),
  keys: Schema.optional(Schema.Array(Schema.String)),
  pathPrefix: Schema.optional(Schema.String),
  vendor: Schema.optional(Schema.Literal("r2"))
}))),
  status: Schema.optional(Schema.Literal("running", "paused", "aborted", "completed")),
  target: Schema.optional(Schema.Struct({
  bucket: Schema.optional(Schema.String),
  jurisdiction: Schema.optional(Schema.Literal("default", "eu", "fedramp")),
  vendor: Schema.optional(Schema.Literal("r2"))
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListJobs2Response" }) as unknown as Schema.Schema<ListJobs2Response>;

export const listJobs2: (
  input: ListJobs2Request
) => Effect.Effect<
  ListJobs2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListJobs2Request,
  output: ListJobs2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateJob1Request {
  account_id: string;
  body: { overwrite?: boolean; source?: Record<string, unknown>; target?: { bucket: string; jurisdiction?: "default" | "eu" | "fedramp"; secret: { accessKeyId: string; secretAccessKey: string }; vendor: "r2" } };
}

export const CreateJob1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  overwrite: Schema.optional(Schema.Boolean),
  source: Schema.optional(Schema.Struct({})),
  target: Schema.optional(Schema.Struct({
  bucket: Schema.String,
  jurisdiction: Schema.optional(Schema.Literal("default", "eu", "fedramp")),
  secret: Schema.Struct({
  accessKeyId: Schema.String,
  secretAccessKey: Schema.String
}),
  vendor: Schema.Literal("r2")
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/slurper/jobs" }),
).annotations({ identifier: "CreateJob1Request" }) as unknown as Schema.Schema<CreateJob1Request>;

export interface CreateJob1Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateJob1Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateJob1Response" }) as unknown as Schema.Schema<CreateJob1Response>;

export const createJob1: (
  input: CreateJob1Request
) => Effect.Effect<
  CreateJob1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateJob1Request,
  output: CreateJob1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SlurperAbortAllJobsRequest {
  account_id: string;
}

export const SlurperAbortAllJobsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/slurper/jobs/abortAll" }),
).annotations({ identifier: "SlurperAbortAllJobsRequest" }) as unknown as Schema.Schema<SlurperAbortAllJobsRequest>;

export interface SlurperAbortAllJobsResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SlurperAbortAllJobsResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SlurperAbortAllJobsResponse" }) as unknown as Schema.Schema<SlurperAbortAllJobsResponse>;

export const slurperAbortAllJobs: (
  input: SlurperAbortAllJobsRequest
) => Effect.Effect<
  SlurperAbortAllJobsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SlurperAbortAllJobsRequest,
  output: SlurperAbortAllJobsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetJob2Request {
  account_id: string;
  job_id: string;
}

export const GetJob2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  job_id: Schema.String.pipe(T.HttpPath("job_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/slurper/jobs/{job_id}" }),
).annotations({ identifier: "GetJob2Request" }) as unknown as Schema.Schema<GetJob2Request>;

export interface GetJob2Response {
  result: { createdAt?: string; finishedAt?: string; id?: string; overwrite?: boolean; source?: unknown; status?: "running" | "paused" | "aborted" | "completed"; target?: { bucket?: string; jurisdiction?: "default" | "eu" | "fedramp"; vendor?: "r2" } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetJob2Response = Schema.Struct({
  result: Schema.Struct({
  createdAt: Schema.optional(Schema.String),
  finishedAt: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  overwrite: Schema.optional(Schema.Boolean),
  source: Schema.optional(Schema.Union(Schema.Struct({
  bucket: Schema.optional(Schema.String),
  endpoint: Schema.optional(Schema.String),
  keys: Schema.optional(Schema.Array(Schema.String)),
  pathPrefix: Schema.optional(Schema.String),
  vendor: Schema.optional(Schema.Literal("s3"))
}), Schema.Struct({
  bucket: Schema.optional(Schema.String),
  keys: Schema.optional(Schema.Array(Schema.String)),
  pathPrefix: Schema.optional(Schema.String),
  vendor: Schema.optional(Schema.Literal("gcs"))
}), Schema.Struct({
  bucket: Schema.optional(Schema.String),
  jurisdiction: Schema.optional(Schema.Literal("default", "eu", "fedramp")),
  keys: Schema.optional(Schema.Array(Schema.String)),
  pathPrefix: Schema.optional(Schema.String),
  vendor: Schema.optional(Schema.Literal("r2"))
}))),
  status: Schema.optional(Schema.Literal("running", "paused", "aborted", "completed")),
  target: Schema.optional(Schema.Struct({
  bucket: Schema.optional(Schema.String),
  jurisdiction: Schema.optional(Schema.Literal("default", "eu", "fedramp")),
  vendor: Schema.optional(Schema.Literal("r2"))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetJob2Response" }) as unknown as Schema.Schema<GetJob2Response>;

export const getJob2: (
  input: GetJob2Request
) => Effect.Effect<
  GetJob2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetJob2Request,
  output: GetJob2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SlurperAbortJobRequest {
  account_id: string;
  job_id: string;
}

export const SlurperAbortJobRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  job_id: Schema.String.pipe(T.HttpPath("job_id"))
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/slurper/jobs/{job_id}/abort" }),
).annotations({ identifier: "SlurperAbortJobRequest" }) as unknown as Schema.Schema<SlurperAbortJobRequest>;

export interface SlurperAbortJobResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SlurperAbortJobResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SlurperAbortJobResponse" }) as unknown as Schema.Schema<SlurperAbortJobResponse>;

export const slurperAbortJob: (
  input: SlurperAbortJobRequest
) => Effect.Effect<
  SlurperAbortJobResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SlurperAbortJobRequest,
  output: SlurperAbortJobResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetJobLogsRequest {
  account_id: string;
  job_id: string;
  limit?: number;
  offset?: number;
}

export const GetJobLogsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  job_id: Schema.String.pipe(T.HttpPath("job_id")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  offset: Schema.optional(Schema.Number).pipe(T.HttpQuery("offset"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/slurper/jobs/{job_id}/logs" }),
).annotations({ identifier: "GetJobLogsRequest" }) as unknown as Schema.Schema<GetJobLogsRequest>;

export interface GetJobLogsResponse {
  result: { createdAt?: string; job?: string; logType?: "migrationStart" | "migrationComplete" | "migrationAbort" | "migrationError" | "migrationPause" | "migrationResume" | "migrationErrorFailedContinuation" | "importErrorRetryExhaustion" | "importSkippedStorageClass" | "importSkippedOversized" | "importSkippedEmptyObject" | "importSkippedUnsupportedContentType" | "importSkippedExcludedContentType" | "importSkippedInvalidMedia" | "importSkippedRequiresRetrieval"; message?: string; objectKey?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetJobLogsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  createdAt: Schema.optional(Schema.String),
  job: Schema.optional(Schema.String),
  logType: Schema.optional(Schema.Literal("migrationStart", "migrationComplete", "migrationAbort", "migrationError", "migrationPause", "migrationResume", "migrationErrorFailedContinuation", "importErrorRetryExhaustion", "importSkippedStorageClass", "importSkippedOversized", "importSkippedEmptyObject", "importSkippedUnsupportedContentType", "importSkippedExcludedContentType", "importSkippedInvalidMedia", "importSkippedRequiresRetrieval")),
  message: Schema.optional(Schema.String),
  objectKey: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetJobLogsResponse" }) as unknown as Schema.Schema<GetJobLogsResponse>;

export const getJobLogs: (
  input: GetJobLogsRequest
) => Effect.Effect<
  GetJobLogsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetJobLogsRequest,
  output: GetJobLogsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SlurperPauseJobRequest {
  account_id: string;
  job_id: string;
}

export const SlurperPauseJobRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  job_id: Schema.String.pipe(T.HttpPath("job_id"))
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/slurper/jobs/{job_id}/pause" }),
).annotations({ identifier: "SlurperPauseJobRequest" }) as unknown as Schema.Schema<SlurperPauseJobRequest>;

export interface SlurperPauseJobResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SlurperPauseJobResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SlurperPauseJobResponse" }) as unknown as Schema.Schema<SlurperPauseJobResponse>;

export const slurperPauseJob: (
  input: SlurperPauseJobRequest
) => Effect.Effect<
  SlurperPauseJobResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SlurperPauseJobRequest,
  output: SlurperPauseJobResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetJobProgressRequest {
  account_id: string;
  job_id: string;
}

export const GetJobProgressRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  job_id: Schema.String.pipe(T.HttpPath("job_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/slurper/jobs/{job_id}/progress" }),
).annotations({ identifier: "GetJobProgressRequest" }) as unknown as Schema.Schema<GetJobProgressRequest>;

export interface GetJobProgressResponse {
  result: { createdAt?: string; failedObjects?: number; id?: string; objects?: number; skippedObjects?: number; status?: "running" | "paused" | "aborted" | "completed"; transferredObjects?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetJobProgressResponse = Schema.Struct({
  result: Schema.Struct({
  createdAt: Schema.optional(Schema.String),
  failedObjects: Schema.optional(Schema.Number),
  id: Schema.optional(Schema.String),
  objects: Schema.optional(Schema.Number),
  skippedObjects: Schema.optional(Schema.Number),
  status: Schema.optional(Schema.Literal("running", "paused", "aborted", "completed")),
  transferredObjects: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetJobProgressResponse" }) as unknown as Schema.Schema<GetJobProgressResponse>;

export const getJobProgress: (
  input: GetJobProgressRequest
) => Effect.Effect<
  GetJobProgressResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetJobProgressRequest,
  output: GetJobProgressResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SlurperResumeJobRequest {
  account_id: string;
  job_id: string;
}

export const SlurperResumeJobRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  job_id: Schema.String.pipe(T.HttpPath("job_id"))
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/slurper/jobs/{job_id}/resume" }),
).annotations({ identifier: "SlurperResumeJobRequest" }) as unknown as Schema.Schema<SlurperResumeJobRequest>;

export interface SlurperResumeJobResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SlurperResumeJobResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SlurperResumeJobResponse" }) as unknown as Schema.Schema<SlurperResumeJobResponse>;

export const slurperResumeJob: (
  input: SlurperResumeJobRequest
) => Effect.Effect<
  SlurperResumeJobResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SlurperResumeJobRequest,
  output: SlurperResumeJobResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SlurperCheckSourceConnectivityRequest {
  account_id: string;
  body: Record<string, unknown>;
}

export const SlurperCheckSourceConnectivityRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/slurper/source/connectivity-precheck" }),
).annotations({ identifier: "SlurperCheckSourceConnectivityRequest" }) as unknown as Schema.Schema<SlurperCheckSourceConnectivityRequest>;

export interface SlurperCheckSourceConnectivityResponse {
  result: { connectivityStatus?: "success" | "error" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SlurperCheckSourceConnectivityResponse = Schema.Struct({
  result: Schema.Struct({
  connectivityStatus: Schema.optional(Schema.Literal("success", "error"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SlurperCheckSourceConnectivityResponse" }) as unknown as Schema.Schema<SlurperCheckSourceConnectivityResponse>;

export const slurperCheckSourceConnectivity: (
  input: SlurperCheckSourceConnectivityRequest
) => Effect.Effect<
  SlurperCheckSourceConnectivityResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SlurperCheckSourceConnectivityRequest,
  output: SlurperCheckSourceConnectivityResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface SlurperCheckTargetConnectivityRequest {
  account_id: string;
  body: { bucket: string; jurisdiction?: "default" | "eu" | "fedramp"; secret: { accessKeyId: string; secretAccessKey: string }; vendor: "r2" };
}

export const SlurperCheckTargetConnectivityRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  bucket: Schema.String,
  jurisdiction: Schema.optional(Schema.Literal("default", "eu", "fedramp")),
  secret: Schema.Struct({
  accessKeyId: Schema.String,
  secretAccessKey: Schema.String
}),
  vendor: Schema.Literal("r2")
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/slurper/target/connectivity-precheck" }),
).annotations({ identifier: "SlurperCheckTargetConnectivityRequest" }) as unknown as Schema.Schema<SlurperCheckTargetConnectivityRequest>;

export interface SlurperCheckTargetConnectivityResponse {
  result: { connectivityStatus?: "success" | "error" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const SlurperCheckTargetConnectivityResponse = Schema.Struct({
  result: Schema.Struct({
  connectivityStatus: Schema.optional(Schema.Literal("success", "error"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "SlurperCheckTargetConnectivityResponse" }) as unknown as Schema.Schema<SlurperCheckTargetConnectivityResponse>;

export const slurperCheckTargetConnectivity: (
  input: SlurperCheckTargetConnectivityRequest
) => Effect.Effect<
  SlurperCheckTargetConnectivityResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SlurperCheckTargetConnectivityRequest,
  output: SlurperCheckTargetConnectivityResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAllSsoConnectorsRequest {
  account_id: unknown;
}

export const GetAllSsoConnectorsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/sso_connectors" }),
).annotations({ identifier: "GetAllSsoConnectorsRequest" }) as unknown as Schema.Schema<GetAllSsoConnectorsRequest>;

export interface GetAllSsoConnectorsResponse {
  result: { created_on?: string; email_domain?: string; enabled?: boolean; id?: unknown; updated_on?: string; use_fedramp_language?: boolean; verification?: { code?: string; status?: "awaiting" | "pending" | "failed" | "verified" } }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAllSsoConnectorsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  email_domain: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  updated_on: Schema.optional(Schema.Date),
  use_fedramp_language: Schema.optional(Schema.Boolean),
  verification: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("awaiting", "pending", "failed", "verified"))
}))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAllSsoConnectorsResponse" }) as unknown as Schema.Schema<GetAllSsoConnectorsResponse>;

export const getAllSsoConnectors: (
  input: GetAllSsoConnectorsRequest
) => Effect.Effect<
  GetAllSsoConnectorsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAllSsoConnectorsRequest,
  output: GetAllSsoConnectorsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface InitNewSsoConnectorRequest {
  account_id: unknown;
  body: { begin_verification?: boolean; email_domain: string; use_fedramp_language?: boolean };
}

export const InitNewSsoConnectorRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  begin_verification: Schema.optional(Schema.Boolean),
  email_domain: Schema.String,
  use_fedramp_language: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/sso_connectors" }),
).annotations({ identifier: "InitNewSsoConnectorRequest" }) as unknown as Schema.Schema<InitNewSsoConnectorRequest>;

export interface InitNewSsoConnectorResponse {
  result: { created_on?: string; email_domain?: string; enabled?: boolean; id?: unknown; updated_on?: string; use_fedramp_language?: boolean; verification?: { code?: string; status?: "awaiting" | "pending" | "failed" | "verified" } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const InitNewSsoConnectorResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  email_domain: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  updated_on: Schema.optional(Schema.Date),
  use_fedramp_language: Schema.optional(Schema.Boolean),
  verification: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("awaiting", "pending", "failed", "verified"))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "InitNewSsoConnectorResponse" }) as unknown as Schema.Schema<InitNewSsoConnectorResponse>;

export const initNewSsoConnector: (
  input: InitNewSsoConnectorRequest
) => Effect.Effect<
  InitNewSsoConnectorResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: InitNewSsoConnectorRequest,
  output: InitNewSsoConnectorResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetSsoConnectorRequest {
  account_id: unknown;
  sso_connector_id: unknown;
}

export const GetSsoConnectorRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  sso_connector_id: Schema.String.pipe(T.HttpPath("sso_connector_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/sso_connectors/{sso_connector_id}" }),
).annotations({ identifier: "GetSsoConnectorRequest" }) as unknown as Schema.Schema<GetSsoConnectorRequest>;

export interface GetSsoConnectorResponse {
  result: { created_on?: string; email_domain?: string; enabled?: boolean; id?: unknown; updated_on?: string; use_fedramp_language?: boolean; verification?: { code?: string; status?: "awaiting" | "pending" | "failed" | "verified" } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetSsoConnectorResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  email_domain: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  updated_on: Schema.optional(Schema.Date),
  use_fedramp_language: Schema.optional(Schema.Boolean),
  verification: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("awaiting", "pending", "failed", "verified"))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetSsoConnectorResponse" }) as unknown as Schema.Schema<GetSsoConnectorResponse>;

export const getSsoConnector: (
  input: GetSsoConnectorRequest
) => Effect.Effect<
  GetSsoConnectorResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetSsoConnectorRequest,
  output: GetSsoConnectorResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteSsoConnectorRequest {
  account_id: unknown;
  sso_connector_id: unknown;
}

export const DeleteSsoConnectorRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  sso_connector_id: Schema.String.pipe(T.HttpPath("sso_connector_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/sso_connectors/{sso_connector_id}" }),
).annotations({ identifier: "DeleteSsoConnectorRequest" }) as unknown as Schema.Schema<DeleteSsoConnectorRequest>;

export interface DeleteSsoConnectorResponse {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteSsoConnectorResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteSsoConnectorResponse" }) as unknown as Schema.Schema<DeleteSsoConnectorResponse>;

export const deleteSsoConnector: (
  input: DeleteSsoConnectorRequest
) => Effect.Effect<
  DeleteSsoConnectorResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteSsoConnectorRequest,
  output: DeleteSsoConnectorResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateSsoConnectorStateRequest {
  account_id: unknown;
  sso_connector_id: unknown;
  body: { enabled?: boolean; use_fedramp_language?: boolean };
}

export const UpdateSsoConnectorStateRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  sso_connector_id: Schema.String.pipe(T.HttpPath("sso_connector_id")),
  body: Schema.Struct({
  enabled: Schema.optional(Schema.Boolean),
  use_fedramp_language: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/sso_connectors/{sso_connector_id}" }),
).annotations({ identifier: "UpdateSsoConnectorStateRequest" }) as unknown as Schema.Schema<UpdateSsoConnectorStateRequest>;

export interface UpdateSsoConnectorStateResponse {
  result: { created_on?: string; email_domain?: string; enabled?: boolean; id?: unknown; updated_on?: string; use_fedramp_language?: boolean; verification?: { code?: string; status?: "awaiting" | "pending" | "failed" | "verified" } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateSsoConnectorStateResponse = Schema.Struct({
  result: Schema.Struct({
  created_on: Schema.optional(Schema.Date),
  email_domain: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  updated_on: Schema.optional(Schema.Date),
  use_fedramp_language: Schema.optional(Schema.Boolean),
  verification: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("awaiting", "pending", "failed", "verified"))
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateSsoConnectorStateResponse" }) as unknown as Schema.Schema<UpdateSsoConnectorStateResponse>;

export const updateSsoConnectorState: (
  input: UpdateSsoConnectorStateRequest
) => Effect.Effect<
  UpdateSsoConnectorStateResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateSsoConnectorStateRequest,
  output: UpdateSsoConnectorStateResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface BeginSsoConnectorVerificationRequest {
  account_id: unknown;
  sso_connector_id: unknown;
}

export const BeginSsoConnectorVerificationRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  sso_connector_id: Schema.String.pipe(T.HttpPath("sso_connector_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/sso_connectors/{sso_connector_id}/begin_verification" }),
).annotations({ identifier: "BeginSsoConnectorVerificationRequest" }) as unknown as Schema.Schema<BeginSsoConnectorVerificationRequest>;

export interface BeginSsoConnectorVerificationResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const BeginSsoConnectorVerificationResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "BeginSsoConnectorVerificationResponse" }) as unknown as Schema.Schema<BeginSsoConnectorVerificationResponse>;

export const beginSsoConnectorVerification: (
  input: BeginSsoConnectorVerificationRequest
) => Effect.Effect<
  BeginSsoConnectorVerificationResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: BeginSsoConnectorVerificationRequest,
  output: BeginSsoConnectorVerificationResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListSubscriptionsRequest {
  account_id: string;
}

export const ListSubscriptionsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/subscriptions" }),
).annotations({ identifier: "ListSubscriptionsRequest" }) as unknown as Schema.Schema<ListSubscriptionsRequest>;

export interface ListSubscriptionsResponse {
  result: Record<string, unknown>[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListSubscriptionsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListSubscriptionsResponse" }) as unknown as Schema.Schema<ListSubscriptionsResponse>;

export const listSubscriptions: (
  input: ListSubscriptionsRequest
) => Effect.Effect<
  ListSubscriptionsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListSubscriptionsRequest,
  output: ListSubscriptionsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateSubscriptionRequest {
  account_id: string;
  body: { app?: unknown; component_values?: { default?: number; name?: string; price?: number; value?: number }[]; currency?: string; current_period_end?: string; current_period_start?: string; frequency?: "weekly" | "monthly" | "quarterly" | "yearly"; id?: string; price?: number; rate_plan?: { currency?: string; externally_managed?: boolean; id?: string; is_contract?: boolean; public_name?: string; scope?: string; sets?: string[] }; state?: "Trial" | "Provisioned" | "Paid" | "AwaitingPayment" | "Cancelled" | "Failed" | "Expired"; zone?: { id?: string; name?: string } };
}

export const CreateSubscriptionRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  app: Schema.optional(Schema.Unknown),
  component_values: Schema.optional(Schema.Array(Schema.Struct({
  default: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  price: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.Number)
}))),
  currency: Schema.optional(Schema.String),
  current_period_end: Schema.optional(Schema.Date),
  current_period_start: Schema.optional(Schema.Date),
  frequency: Schema.optional(Schema.Literal("weekly", "monthly", "quarterly", "yearly")),
  id: Schema.optional(Schema.String),
  price: Schema.optional(Schema.Number),
  rate_plan: Schema.optional(Schema.Struct({
  currency: Schema.optional(Schema.String),
  externally_managed: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  is_contract: Schema.optional(Schema.Boolean),
  public_name: Schema.optional(Schema.String),
  scope: Schema.optional(Schema.String),
  sets: Schema.optional(Schema.Array(Schema.String))
})),
  state: Schema.optional(Schema.Literal("Trial", "Provisioned", "Paid", "AwaitingPayment", "Cancelled", "Failed", "Expired")),
  zone: Schema.optional(Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/subscriptions" }),
).annotations({ identifier: "CreateSubscriptionRequest" }) as unknown as Schema.Schema<CreateSubscriptionRequest>;

export interface CreateSubscriptionResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateSubscriptionResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateSubscriptionResponse" }) as unknown as Schema.Schema<CreateSubscriptionResponse>;

export const createSubscription: (
  input: CreateSubscriptionRequest
) => Effect.Effect<
  CreateSubscriptionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateSubscriptionRequest,
  output: CreateSubscriptionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateSubscriptionRequest {
  subscription_identifier: string;
  account_id: string;
  body: { app?: unknown; component_values?: { default?: number; name?: string; price?: number; value?: number }[]; currency?: string; current_period_end?: string; current_period_start?: string; frequency?: "weekly" | "monthly" | "quarterly" | "yearly"; id?: string; price?: number; rate_plan?: { currency?: string; externally_managed?: boolean; id?: string; is_contract?: boolean; public_name?: string; scope?: string; sets?: string[] }; state?: "Trial" | "Provisioned" | "Paid" | "AwaitingPayment" | "Cancelled" | "Failed" | "Expired"; zone?: { id?: string; name?: string } };
}

export const UpdateSubscriptionRequest = Schema.Struct({
  subscription_identifier: Schema.String.pipe(T.HttpPath("subscription_identifier")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  app: Schema.optional(Schema.Unknown),
  component_values: Schema.optional(Schema.Array(Schema.Struct({
  default: Schema.optional(Schema.Number),
  name: Schema.optional(Schema.String),
  price: Schema.optional(Schema.Number),
  value: Schema.optional(Schema.Number)
}))),
  currency: Schema.optional(Schema.String),
  current_period_end: Schema.optional(Schema.Date),
  current_period_start: Schema.optional(Schema.Date),
  frequency: Schema.optional(Schema.Literal("weekly", "monthly", "quarterly", "yearly")),
  id: Schema.optional(Schema.String),
  price: Schema.optional(Schema.Number),
  rate_plan: Schema.optional(Schema.Struct({
  currency: Schema.optional(Schema.String),
  externally_managed: Schema.optional(Schema.Boolean),
  id: Schema.optional(Schema.String),
  is_contract: Schema.optional(Schema.Boolean),
  public_name: Schema.optional(Schema.String),
  scope: Schema.optional(Schema.String),
  sets: Schema.optional(Schema.Array(Schema.String))
})),
  state: Schema.optional(Schema.Literal("Trial", "Provisioned", "Paid", "AwaitingPayment", "Cancelled", "Failed", "Expired")),
  zone: Schema.optional(Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String)
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/subscriptions/{subscription_identifier}" }),
).annotations({ identifier: "UpdateSubscriptionRequest" }) as unknown as Schema.Schema<UpdateSubscriptionRequest>;

export interface UpdateSubscriptionResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateSubscriptionResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateSubscriptionResponse" }) as unknown as Schema.Schema<UpdateSubscriptionResponse>;

export const updateSubscription: (
  input: UpdateSubscriptionRequest
) => Effect.Effect<
  UpdateSubscriptionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateSubscriptionRequest,
  output: UpdateSubscriptionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteSubscriptionRequest {
  subscription_identifier: string;
  account_id: string;
}

export const DeleteSubscriptionRequest = Schema.Struct({
  subscription_identifier: Schema.String.pipe(T.HttpPath("subscription_identifier")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/subscriptions/{subscription_identifier}" }),
).annotations({ identifier: "DeleteSubscriptionRequest" }) as unknown as Schema.Schema<DeleteSubscriptionRequest>;

export interface DeleteSubscriptionResponse {
  result: { subscription_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteSubscriptionResponse = Schema.Struct({
  result: Schema.Struct({
  subscription_id: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteSubscriptionResponse" }) as unknown as Schema.Schema<DeleteSubscriptionResponse>;

export const deleteSubscription: (
  input: DeleteSubscriptionRequest
) => Effect.Effect<
  DeleteSubscriptionResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteSubscriptionRequest,
  output: DeleteSubscriptionResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListTunnelRoutesRequest {
  account_id: string;
  comment?: string;
  is_deleted?: boolean;
  network_subset?: unknown;
  network_superset?: unknown;
  existed_at?: string;
  tunnel_id?: string;
  route_id?: string;
  tun_types?: "cfd_tunnel" | "warp_connector" | "warp" | "magic" | "ip_sec" | "gre" | "cni"[];
  virtual_network_id?: string;
  per_page?: number;
  page?: number;
}

export const ListTunnelRoutesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  comment: Schema.optional(Schema.String).pipe(T.HttpQuery("comment")),
  is_deleted: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_deleted")),
  network_subset: Schema.optional(Schema.String).pipe(T.HttpQuery("network_subset")),
  network_superset: Schema.optional(Schema.String).pipe(T.HttpQuery("network_superset")),
  existed_at: Schema.optional(Schema.String).pipe(T.HttpQuery("existed_at")),
  tunnel_id: Schema.optional(Schema.UUID).pipe(T.HttpQuery("tunnel_id")),
  route_id: Schema.optional(Schema.String).pipe(T.HttpQuery("route_id")),
  tun_types: Schema.optional(Schema.Array(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni"))).pipe(T.HttpQuery("tun_types")),
  virtual_network_id: Schema.optional(Schema.UUID).pipe(T.HttpQuery("virtual_network_id")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/teamnet/routes" }),
).annotations({ identifier: "ListTunnelRoutesRequest" }) as unknown as Schema.Schema<ListTunnelRoutesRequest>;

export interface ListTunnelRoutesResponse {
  result: { comment?: string; created_at?: string; deleted_at?: string; id?: string; network?: string; tun_type?: "cfd_tunnel" | "warp_connector" | "warp" | "magic" | "ip_sec" | "gre" | "cni"; tunnel_id?: string; tunnel_name?: string; virtual_network_id?: string; virtual_network_name?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListTunnelRoutesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  tun_type: Schema.optional(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni")),
  tunnel_id: Schema.optional(Schema.UUID),
  tunnel_name: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID),
  virtual_network_name: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListTunnelRoutesResponse" }) as unknown as Schema.Schema<ListTunnelRoutesResponse>;

export const listTunnelRoutes: (
  input: ListTunnelRoutesRequest
) => Effect.Effect<
  ListTunnelRoutesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListTunnelRoutesRequest,
  output: ListTunnelRoutesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateATunnelRouteRequest {
  account_id: string;
  body: { comment?: string; network: string; tunnel_id: string; virtual_network_id?: string };
}

export const CreateATunnelRouteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  comment: Schema.optional(Schema.String),
  network: Schema.String,
  tunnel_id: Schema.UUID,
  virtual_network_id: Schema.optional(Schema.UUID)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/teamnet/routes" }),
).annotations({ identifier: "CreateATunnelRouteRequest" }) as unknown as Schema.Schema<CreateATunnelRouteRequest>;

export interface CreateATunnelRouteResponse {
  result: { comment?: string; created_at?: string; deleted_at?: string; id?: string; network?: string; tunnel_id?: string; virtual_network_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateATunnelRouteResponse = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  tunnel_id: Schema.optional(Schema.UUID),
  virtual_network_id: Schema.optional(Schema.UUID)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateATunnelRouteResponse" }) as unknown as Schema.Schema<CreateATunnelRouteResponse>;

export const createATunnelRoute: (
  input: CreateATunnelRouteRequest
) => Effect.Effect<
  CreateATunnelRouteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateATunnelRouteRequest,
  output: CreateATunnelRouteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetTunnelRouteByIpRequest {
  ip: string;
  account_id: string;
  virtual_network_id?: string;
  default_virtual_network_fallback?: boolean;
}

export const GetTunnelRouteByIpRequest = Schema.Struct({
  ip: Schema.String.pipe(T.HttpPath("ip")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  virtual_network_id: Schema.optional(Schema.UUID).pipe(T.HttpQuery("virtual_network_id")),
  default_virtual_network_fallback: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("default_virtual_network_fallback"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/teamnet/routes/ip/{ip}" }),
).annotations({ identifier: "GetTunnelRouteByIpRequest" }) as unknown as Schema.Schema<GetTunnelRouteByIpRequest>;

export interface GetTunnelRouteByIpResponse {
  result: { comment?: string; created_at?: string; deleted_at?: string; id?: string; network?: string; tun_type?: "cfd_tunnel" | "warp_connector" | "warp" | "magic" | "ip_sec" | "gre" | "cni"; tunnel_id?: string; tunnel_name?: string; virtual_network_id?: string; virtual_network_name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetTunnelRouteByIpResponse = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  tun_type: Schema.optional(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni")),
  tunnel_id: Schema.optional(Schema.UUID),
  tunnel_name: Schema.optional(Schema.String),
  virtual_network_id: Schema.optional(Schema.UUID),
  virtual_network_name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetTunnelRouteByIpResponse" }) as unknown as Schema.Schema<GetTunnelRouteByIpResponse>;

export const getTunnelRouteByIp: (
  input: GetTunnelRouteByIpRequest
) => Effect.Effect<
  GetTunnelRouteByIpResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTunnelRouteByIpRequest,
  output: GetTunnelRouteByIpResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateATunnelRouteWithCidrRequest {
  ip_network_encoded: string;
  account_id: string;
  body: { comment?: string; tunnel_id: string; virtual_network_id?: string };
}

export const CreateATunnelRouteWithCidrRequest = Schema.Struct({
  ip_network_encoded: Schema.String.pipe(T.HttpPath("ip_network_encoded")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  comment: Schema.optional(Schema.String),
  tunnel_id: Schema.UUID,
  virtual_network_id: Schema.optional(Schema.UUID)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/teamnet/routes/network/{ip_network_encoded}" }),
).annotations({ identifier: "CreateATunnelRouteWithCidrRequest" }) as unknown as Schema.Schema<CreateATunnelRouteWithCidrRequest>;

export interface CreateATunnelRouteWithCidrResponse {
  result: { comment?: string; created_at?: string; deleted_at?: string; id?: string; network?: string; tunnel_id?: string; virtual_network_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateATunnelRouteWithCidrResponse = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  tunnel_id: Schema.optional(Schema.UUID),
  virtual_network_id: Schema.optional(Schema.UUID)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateATunnelRouteWithCidrResponse" }) as unknown as Schema.Schema<CreateATunnelRouteWithCidrResponse>;

export const createATunnelRouteWithCidr: (
  input: CreateATunnelRouteWithCidrRequest
) => Effect.Effect<
  CreateATunnelRouteWithCidrResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateATunnelRouteWithCidrRequest,
  output: CreateATunnelRouteWithCidrResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteATunnelRouteWithCidrRequest {
  ip_network_encoded: string;
  account_id: string;
  virtual_network_id?: string;
  tun_type?: "cfd_tunnel" | "warp_connector" | "warp" | "magic" | "ip_sec" | "gre" | "cni";
  tunnel_id?: string;
}

export const DeleteATunnelRouteWithCidrRequest = Schema.Struct({
  ip_network_encoded: Schema.String.pipe(T.HttpPath("ip_network_encoded")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  virtual_network_id: Schema.optional(Schema.UUID).pipe(T.HttpQuery("virtual_network_id")),
  tun_type: Schema.optional(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni")).pipe(T.HttpQuery("tun_type")),
  tunnel_id: Schema.optional(Schema.UUID).pipe(T.HttpQuery("tunnel_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/teamnet/routes/network/{ip_network_encoded}" }),
).annotations({ identifier: "DeleteATunnelRouteWithCidrRequest" }) as unknown as Schema.Schema<DeleteATunnelRouteWithCidrRequest>;

export interface DeleteATunnelRouteWithCidrResponse {
  result: { comment?: string; created_at?: string; deleted_at?: string; id?: string; network?: string; tunnel_id?: string; virtual_network_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteATunnelRouteWithCidrResponse = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  tunnel_id: Schema.optional(Schema.UUID),
  virtual_network_id: Schema.optional(Schema.UUID)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteATunnelRouteWithCidrResponse" }) as unknown as Schema.Schema<DeleteATunnelRouteWithCidrResponse>;

export const deleteATunnelRouteWithCidr: (
  input: DeleteATunnelRouteWithCidrRequest
) => Effect.Effect<
  DeleteATunnelRouteWithCidrResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteATunnelRouteWithCidrRequest,
  output: DeleteATunnelRouteWithCidrResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateATunnelRouteWithCidrRequest {
  ip_network_encoded: string;
  account_id: string;
}

export const UpdateATunnelRouteWithCidrRequest = Schema.Struct({
  ip_network_encoded: Schema.String.pipe(T.HttpPath("ip_network_encoded")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/teamnet/routes/network/{ip_network_encoded}" }),
).annotations({ identifier: "UpdateATunnelRouteWithCidrRequest" }) as unknown as Schema.Schema<UpdateATunnelRouteWithCidrRequest>;

export interface UpdateATunnelRouteWithCidrResponse {
  result: { comment?: string; created_at?: string; deleted_at?: string; id?: string; network?: string; tunnel_id?: string; virtual_network_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateATunnelRouteWithCidrResponse = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  tunnel_id: Schema.optional(Schema.UUID),
  virtual_network_id: Schema.optional(Schema.UUID)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateATunnelRouteWithCidrResponse" }) as unknown as Schema.Schema<UpdateATunnelRouteWithCidrResponse>;

export const updateATunnelRouteWithCidr: (
  input: UpdateATunnelRouteWithCidrRequest
) => Effect.Effect<
  UpdateATunnelRouteWithCidrResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateATunnelRouteWithCidrRequest,
  output: UpdateATunnelRouteWithCidrResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetTunnelRouteRequest {
  account_id: string;
  route_id: string;
}

export const GetTunnelRouteRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  route_id: Schema.String.pipe(T.HttpPath("route_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/teamnet/routes/{route_id}" }),
).annotations({ identifier: "GetTunnelRouteRequest" }) as unknown as Schema.Schema<GetTunnelRouteRequest>;

export interface GetTunnelRouteResponse {
  result: { comment?: string; created_at?: string; deleted_at?: string; id?: string; network?: string; tunnel_id?: string; virtual_network_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetTunnelRouteResponse = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  tunnel_id: Schema.optional(Schema.UUID),
  virtual_network_id: Schema.optional(Schema.UUID)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetTunnelRouteResponse" }) as unknown as Schema.Schema<GetTunnelRouteResponse>;

export const getTunnelRoute: (
  input: GetTunnelRouteRequest
) => Effect.Effect<
  GetTunnelRouteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTunnelRouteRequest,
  output: GetTunnelRouteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteATunnelRouteRequest {
  route_id: string;
  account_id: string;
}

export const DeleteATunnelRouteRequest = Schema.Struct({
  route_id: Schema.String.pipe(T.HttpPath("route_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/teamnet/routes/{route_id}" }),
).annotations({ identifier: "DeleteATunnelRouteRequest" }) as unknown as Schema.Schema<DeleteATunnelRouteRequest>;

export interface DeleteATunnelRouteResponse {
  result: { comment?: string; created_at?: string; deleted_at?: string; id?: string; network?: string; tunnel_id?: string; virtual_network_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteATunnelRouteResponse = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  tunnel_id: Schema.optional(Schema.UUID),
  virtual_network_id: Schema.optional(Schema.UUID)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteATunnelRouteResponse" }) as unknown as Schema.Schema<DeleteATunnelRouteResponse>;

export const deleteATunnelRoute: (
  input: DeleteATunnelRouteRequest
) => Effect.Effect<
  DeleteATunnelRouteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteATunnelRouteRequest,
  output: DeleteATunnelRouteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateATunnelRouteRequest {
  route_id: string;
  account_id: string;
  body: { comment?: string; network?: string; tunnel_id?: string; virtual_network_id?: string };
}

export const UpdateATunnelRouteRequest = Schema.Struct({
  route_id: Schema.String.pipe(T.HttpPath("route_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  comment: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  tunnel_id: Schema.optional(Schema.UUID),
  virtual_network_id: Schema.optional(Schema.UUID)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/teamnet/routes/{route_id}" }),
).annotations({ identifier: "UpdateATunnelRouteRequest" }) as unknown as Schema.Schema<UpdateATunnelRouteRequest>;

export interface UpdateATunnelRouteResponse {
  result: { comment?: string; created_at?: string; deleted_at?: string; id?: string; network?: string; tunnel_id?: string; virtual_network_id?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateATunnelRouteResponse = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  tunnel_id: Schema.optional(Schema.UUID),
  virtual_network_id: Schema.optional(Schema.UUID)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateATunnelRouteResponse" }) as unknown as Schema.Schema<UpdateATunnelRouteResponse>;

export const updateATunnelRoute: (
  input: UpdateATunnelRouteRequest
) => Effect.Effect<
  UpdateATunnelRouteResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateATunnelRouteRequest,
  output: UpdateATunnelRouteResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListVirtualNetworksRequest {
  account_id: string;
  id?: string;
  name?: string;
  is_default?: boolean;
  is_default_network?: boolean;
  is_deleted?: boolean;
}

export const ListVirtualNetworksRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.optional(Schema.UUID).pipe(T.HttpQuery("id")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  is_default: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_default")),
  is_default_network: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_default_network")),
  is_deleted: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_deleted"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/teamnet/virtual_networks" }),
).annotations({ identifier: "ListVirtualNetworksRequest" }) as unknown as Schema.Schema<ListVirtualNetworksRequest>;

export interface ListVirtualNetworksResponse {
  result: { comment: string; created_at: string; deleted_at?: string; id: string; is_default_network: boolean; name: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListVirtualNetworksResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  comment: Schema.String,
  created_at: Schema.Date,
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.UUID,
  is_default_network: Schema.Boolean,
  name: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListVirtualNetworksResponse" }) as unknown as Schema.Schema<ListVirtualNetworksResponse>;

export const listVirtualNetworks: (
  input: ListVirtualNetworksRequest
) => Effect.Effect<
  ListVirtualNetworksResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListVirtualNetworksRequest,
  output: ListVirtualNetworksResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateAVirtualNetworkRequest {
  account_id: string;
  body: { comment?: string; is_default?: boolean; is_default_network?: boolean; name: string };
}

export const CreateAVirtualNetworkRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  comment: Schema.optional(Schema.String),
  is_default: Schema.optional(Schema.Boolean),
  is_default_network: Schema.optional(Schema.Boolean),
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/teamnet/virtual_networks" }),
).annotations({ identifier: "CreateAVirtualNetworkRequest" }) as unknown as Schema.Schema<CreateAVirtualNetworkRequest>;

export interface CreateAVirtualNetworkResponse {
  result: { comment: string; created_at: string; deleted_at?: string; id: string; is_default_network: boolean; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateAVirtualNetworkResponse = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.String,
  created_at: Schema.Date,
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.UUID,
  is_default_network: Schema.Boolean,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateAVirtualNetworkResponse" }) as unknown as Schema.Schema<CreateAVirtualNetworkResponse>;

export const createAVirtualNetwork: (
  input: CreateAVirtualNetworkRequest
) => Effect.Effect<
  CreateAVirtualNetworkResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAVirtualNetworkRequest,
  output: CreateAVirtualNetworkResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_12Request {
  account_id: string;
  virtual_network_id: string;
  body: { comment?: string; is_default_network?: boolean; name?: string };
}

export const Get_12Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  virtual_network_id: Schema.UUID.pipe(T.HttpPath("virtual_network_id")),
  body: Schema.Struct({
  comment: Schema.optional(Schema.String),
  is_default_network: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/teamnet/virtual_networks/{virtual_network_id}" }),
).annotations({ identifier: "Get_12Request" }) as unknown as Schema.Schema<Get_12Request>;

export interface Get_12Response {
  result: { comment: string; created_at: string; deleted_at?: string; id: string; is_default_network: boolean; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_12Response = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.String,
  created_at: Schema.Date,
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.UUID,
  is_default_network: Schema.Boolean,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_12Response" }) as unknown as Schema.Schema<Get_12Response>;

export const get_12: (
  input: Get_12Request
) => Effect.Effect<
  Get_12Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_12Request,
  output: Get_12Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_21Request {
  virtual_network_id: string;
  account_id: string;
}

export const Delete_21Request = Schema.Struct({
  virtual_network_id: Schema.UUID.pipe(T.HttpPath("virtual_network_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/teamnet/virtual_networks/{virtual_network_id}" }),
).annotations({ identifier: "Delete_21Request" }) as unknown as Schema.Schema<Delete_21Request>;

export interface Delete_21Response {
  result: { comment: string; created_at: string; deleted_at?: string; id: string; is_default_network: boolean; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_21Response = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.String,
  created_at: Schema.Date,
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.UUID,
  is_default_network: Schema.Boolean,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_21Response" }) as unknown as Schema.Schema<Delete_21Response>;

export const delete_21: (
  input: Delete_21Request
) => Effect.Effect<
  Delete_21Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_21Request,
  output: Delete_21Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update20Request {
  account_id: string;
  virtual_network_id: string;
  body: { comment?: string; is_default_network?: boolean; name?: string };
}

export const Update20Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  virtual_network_id: Schema.UUID.pipe(T.HttpPath("virtual_network_id")),
  body: Schema.Struct({
  comment: Schema.optional(Schema.String),
  is_default_network: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/teamnet/virtual_networks/{virtual_network_id}" }),
).annotations({ identifier: "Update20Request" }) as unknown as Schema.Schema<Update20Request>;

export interface Update20Response {
  result: { comment: string; created_at: string; deleted_at?: string; id: string; is_default_network: boolean; name: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update20Response = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.String,
  created_at: Schema.Date,
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.UUID,
  is_default_network: Schema.Boolean,
  name: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update20Response" }) as unknown as Schema.Schema<Update20Response>;

export const update20: (
  input: Update20Request
) => Effect.Effect<
  Update20Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update20Request,
  output: Update20Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListTokens1Request {
  account_id: unknown;
  page?: number;
  per_page?: number;
  direction?: "asc" | "desc";
}

export const ListTokens1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  direction: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("direction"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/tokens" }),
).annotations({ identifier: "ListTokens1Request" }) as unknown as Schema.Schema<ListTokens1Request>;

export interface ListTokens1Response {
  result: { condition?: { request_ip?: { in?: string[]; not_in?: string[] } }; expires_on?: string; id?: string; issued_on?: string; last_used_on?: string; modified_on?: string; name?: string; not_before?: string; policies?: { effect: "allow" | "deny"; id: string; permission_groups: { id: string; meta?: { key?: string; value?: string }; name?: string }[]; resources: unknown }[]; status?: "active" | "disabled" | "expired" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListTokens1Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  condition: Schema.optional(Schema.Struct({
  request_ip: Schema.optional(Schema.Struct({
  in: Schema.optional(Schema.Array(Schema.String)),
  not_in: Schema.optional(Schema.Array(Schema.String))
}))
})),
  expires_on: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  issued_on: Schema.optional(Schema.Date),
  last_used_on: Schema.optional(Schema.Date),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  not_before: Schema.optional(Schema.Date),
  policies: Schema.optional(Schema.Array(Schema.Struct({
  effect: Schema.Literal("allow", "deny"),
  id: Schema.String,
  permission_groups: Schema.Array(Schema.Struct({
  id: Schema.String,
  meta: Schema.optional(Schema.Struct({
  key: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String)
})),
  resources: Schema.Union(Schema.Record({ key: Schema.String, value: Schema.String }), Schema.Record({ key: Schema.String, value: Schema.Record({ key: Schema.String, value: Schema.String }) }))
}))),
  status: Schema.optional(Schema.Literal("active", "disabled", "expired"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListTokens1Response" }) as unknown as Schema.Schema<ListTokens1Response>;

export const listTokens1: (
  input: ListTokens1Request
) => Effect.Effect<
  ListTokens1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListTokens1Request,
  output: ListTokens1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateTokenRequest {
  account_id: unknown;
  body: { condition?: { request_ip?: { in?: string[]; not_in?: string[] } }; expires_on?: string; name: string; not_before?: string; policies: { effect: "allow" | "deny"; id: string; permission_groups: { id: string; meta?: { key?: string; value?: string }; name?: string }[]; resources: unknown }[] };
}

export const CreateTokenRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  condition: Schema.optional(Schema.Struct({
  request_ip: Schema.optional(Schema.Struct({
  in: Schema.optional(Schema.Array(Schema.String)),
  not_in: Schema.optional(Schema.Array(Schema.String))
}))
})),
  expires_on: Schema.optional(Schema.Date),
  name: Schema.String,
  not_before: Schema.optional(Schema.Date),
  policies: Schema.Array(Schema.Struct({
  effect: Schema.Literal("allow", "deny"),
  id: Schema.String,
  permission_groups: Schema.Array(Schema.Struct({
  id: Schema.String,
  meta: Schema.optional(Schema.Struct({
  key: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String)
})),
  resources: Schema.Union(Schema.Record({ key: Schema.String, value: Schema.String }), Schema.Record({ key: Schema.String, value: Schema.Record({ key: Schema.String, value: Schema.String }) }))
}))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/tokens" }),
).annotations({ identifier: "CreateTokenRequest" }) as unknown as Schema.Schema<CreateTokenRequest>;

export interface CreateTokenResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateTokenResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateTokenResponse" }) as unknown as Schema.Schema<CreateTokenResponse>;

export const createToken: (
  input: CreateTokenRequest
) => Effect.Effect<
  CreateTokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateTokenRequest,
  output: CreateTokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListPermissionGroupsRequest {
  account_id: unknown;
  name?: string;
  scope?: string;
}

export const ListPermissionGroupsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  scope: Schema.optional(Schema.String).pipe(T.HttpQuery("scope"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/tokens/permission_groups" }),
).annotations({ identifier: "ListPermissionGroupsRequest" }) as unknown as Schema.Schema<ListPermissionGroupsRequest>;

export interface ListPermissionGroupsResponse {
  result: { id?: string; name?: string; scopes?: "com.cloudflare.api.account" | "com.cloudflare.api.account.zone" | "com.cloudflare.api.user" | "com.cloudflare.edge.r2.bucket"[] }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListPermissionGroupsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  scopes: Schema.optional(Schema.Array(Schema.Literal("com.cloudflare.api.account", "com.cloudflare.api.account.zone", "com.cloudflare.api.user", "com.cloudflare.edge.r2.bucket")))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListPermissionGroupsResponse" }) as unknown as Schema.Schema<ListPermissionGroupsResponse>;

export const listPermissionGroups: (
  input: ListPermissionGroupsRequest
) => Effect.Effect<
  ListPermissionGroupsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListPermissionGroupsRequest,
  output: ListPermissionGroupsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountApiTokensVerifyTokenRequest {
  account_id: unknown;
}

export const AccountApiTokensVerifyTokenRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/tokens/verify" }),
).annotations({ identifier: "AccountApiTokensVerifyTokenRequest" }) as unknown as Schema.Schema<AccountApiTokensVerifyTokenRequest>;

export interface AccountApiTokensVerifyTokenResponse {
  result: unknown;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountApiTokensVerifyTokenResponse = Schema.Struct({
  result: Schema.Unknown,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountApiTokensVerifyTokenResponse" }) as unknown as Schema.Schema<AccountApiTokensVerifyTokenResponse>;

export const accountApiTokensVerifyToken: (
  input: AccountApiTokensVerifyTokenRequest
) => Effect.Effect<
  AccountApiTokensVerifyTokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountApiTokensVerifyTokenRequest,
  output: AccountApiTokensVerifyTokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountApiTokensTokenDetailsRequest {
  account_id: unknown;
  token_id: string;
}

export const AccountApiTokensTokenDetailsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  token_id: Schema.String.pipe(T.HttpPath("token_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/tokens/{token_id}" }),
).annotations({ identifier: "AccountApiTokensTokenDetailsRequest" }) as unknown as Schema.Schema<AccountApiTokensTokenDetailsRequest>;

export interface AccountApiTokensTokenDetailsResponse {
  result: { condition?: { request_ip?: { in?: string[]; not_in?: string[] } }; expires_on?: string; id?: string; issued_on?: string; last_used_on?: string; modified_on?: string; name?: string; not_before?: string; policies?: { effect: "allow" | "deny"; id: string; permission_groups: { id: string; meta?: { key?: string; value?: string }; name?: string }[]; resources: unknown }[]; status?: "active" | "disabled" | "expired" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountApiTokensTokenDetailsResponse = Schema.Struct({
  result: Schema.Struct({
  condition: Schema.optional(Schema.Struct({
  request_ip: Schema.optional(Schema.Struct({
  in: Schema.optional(Schema.Array(Schema.String)),
  not_in: Schema.optional(Schema.Array(Schema.String))
}))
})),
  expires_on: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  issued_on: Schema.optional(Schema.Date),
  last_used_on: Schema.optional(Schema.Date),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  not_before: Schema.optional(Schema.Date),
  policies: Schema.optional(Schema.Array(Schema.Struct({
  effect: Schema.Literal("allow", "deny"),
  id: Schema.String,
  permission_groups: Schema.Array(Schema.Struct({
  id: Schema.String,
  meta: Schema.optional(Schema.Struct({
  key: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String)
})),
  resources: Schema.Union(Schema.Record({ key: Schema.String, value: Schema.String }), Schema.Record({ key: Schema.String, value: Schema.Record({ key: Schema.String, value: Schema.String }) }))
}))),
  status: Schema.optional(Schema.Literal("active", "disabled", "expired"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountApiTokensTokenDetailsResponse" }) as unknown as Schema.Schema<AccountApiTokensTokenDetailsResponse>;

export const accountApiTokensTokenDetails: (
  input: AccountApiTokensTokenDetailsRequest
) => Effect.Effect<
  AccountApiTokensTokenDetailsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountApiTokensTokenDetailsRequest,
  output: AccountApiTokensTokenDetailsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateTokenRequest {
  account_id: unknown;
  token_id: string;
  body: unknown;
}

export const UpdateTokenRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  token_id: Schema.String.pipe(T.HttpPath("token_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/tokens/{token_id}" }),
).annotations({ identifier: "UpdateTokenRequest" }) as unknown as Schema.Schema<UpdateTokenRequest>;

export interface UpdateTokenResponse {
  result: { condition?: { request_ip?: { in?: string[]; not_in?: string[] } }; expires_on?: string; id?: string; issued_on?: string; last_used_on?: string; modified_on?: string; name?: string; not_before?: string; policies?: { effect: "allow" | "deny"; id: string; permission_groups: { id: string; meta?: { key?: string; value?: string }; name?: string }[]; resources: unknown }[]; status?: "active" | "disabled" | "expired" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateTokenResponse = Schema.Struct({
  result: Schema.Struct({
  condition: Schema.optional(Schema.Struct({
  request_ip: Schema.optional(Schema.Struct({
  in: Schema.optional(Schema.Array(Schema.String)),
  not_in: Schema.optional(Schema.Array(Schema.String))
}))
})),
  expires_on: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.String),
  issued_on: Schema.optional(Schema.Date),
  last_used_on: Schema.optional(Schema.Date),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  not_before: Schema.optional(Schema.Date),
  policies: Schema.optional(Schema.Array(Schema.Struct({
  effect: Schema.Literal("allow", "deny"),
  id: Schema.String,
  permission_groups: Schema.Array(Schema.Struct({
  id: Schema.String,
  meta: Schema.optional(Schema.Struct({
  key: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
})),
  name: Schema.optional(Schema.String)
})),
  resources: Schema.Union(Schema.Record({ key: Schema.String, value: Schema.String }), Schema.Record({ key: Schema.String, value: Schema.Record({ key: Schema.String, value: Schema.String }) }))
}))),
  status: Schema.optional(Schema.Literal("active", "disabled", "expired"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateTokenResponse" }) as unknown as Schema.Schema<UpdateTokenResponse>;

export const updateToken: (
  input: UpdateTokenRequest
) => Effect.Effect<
  UpdateTokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateTokenRequest,
  output: UpdateTokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteTokenRequest {
  account_id: unknown;
  token_id: string;
}

export const DeleteTokenRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  token_id: Schema.String.pipe(T.HttpPath("token_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/tokens/{token_id}" }),
).annotations({ identifier: "DeleteTokenRequest" }) as unknown as Schema.Schema<DeleteTokenRequest>;

export interface DeleteTokenResponse {
  result: { id: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteTokenResponse = Schema.Struct({
  result: Schema.Struct({
  id: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteTokenResponse" }) as unknown as Schema.Schema<DeleteTokenResponse>;

export const deleteToken: (
  input: DeleteTokenRequest
) => Effect.Effect<
  DeleteTokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteTokenRequest,
  output: DeleteTokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface AccountApiTokensRollTokenRequest {
  account_id: unknown;
  token_id: string;
  body: Record<string, unknown>;
}

export const AccountApiTokensRollTokenRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  token_id: Schema.String.pipe(T.HttpPath("token_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/tokens/{token_id}/value" }),
).annotations({ identifier: "AccountApiTokensRollTokenRequest" }) as unknown as Schema.Schema<AccountApiTokensRollTokenRequest>;

export interface AccountApiTokensRollTokenResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const AccountApiTokensRollTokenResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "AccountApiTokensRollTokenResponse" }) as unknown as Schema.Schema<AccountApiTokensRollTokenResponse>;

export const accountApiTokensRollToken: (
  input: AccountApiTokensRollTokenRequest
) => Effect.Effect<
  AccountApiTokensRollTokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: AccountApiTokensRollTokenRequest,
  output: AccountApiTokensRollTokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListAllTunnelsRequest {
  account_id: string;
  name?: string;
  is_deleted?: boolean;
  existed_at?: string;
  uuid?: string;
  was_active_at?: string;
  was_inactive_at?: string;
  include_prefix?: string;
  exclude_prefix?: string;
  tun_types?: "cfd_tunnel" | "warp_connector" | "warp" | "magic" | "ip_sec" | "gre" | "cni"[];
  status?: "inactive" | "degraded" | "healthy" | "down";
  per_page?: number;
  page?: number;
}

export const ListAllTunnelsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  is_deleted: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_deleted")),
  existed_at: Schema.optional(Schema.String).pipe(T.HttpQuery("existed_at")),
  uuid: Schema.optional(Schema.UUID).pipe(T.HttpQuery("uuid")),
  was_active_at: Schema.optional(Schema.Date).pipe(T.HttpQuery("was_active_at")),
  was_inactive_at: Schema.optional(Schema.Date).pipe(T.HttpQuery("was_inactive_at")),
  include_prefix: Schema.optional(Schema.String).pipe(T.HttpQuery("include_prefix")),
  exclude_prefix: Schema.optional(Schema.String).pipe(T.HttpQuery("exclude_prefix")),
  tun_types: Schema.optional(Schema.Array(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni"))).pipe(T.HttpQuery("tun_types")),
  status: Schema.optional(Schema.Literal("inactive", "degraded", "healthy", "down")).pipe(T.HttpQuery("status")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/tunnels" }),
).annotations({ identifier: "ListAllTunnelsRequest" }) as unknown as Schema.Schema<ListAllTunnelsRequest>;

export interface ListAllTunnelsResponse {
  result: unknown[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListAllTunnelsResponse = Schema.Struct({
  result: Schema.Array(Schema.Union(Schema.Struct({
  account_tag: Schema.optional(Schema.String),
  config_src: Schema.optional(Schema.Literal("local", "cloudflare")),
  connections: Schema.optional(Schema.Array(Schema.Unknown)),
  conns_active_at: Schema.optional(Schema.Date),
  conns_inactive_at: Schema.optional(Schema.Date),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.UUID),
  metadata: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  remote_config: Schema.optional(Schema.Boolean),
  status: Schema.optional(Schema.Literal("inactive", "degraded", "healthy", "down")),
  tun_type: Schema.optional(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni"))
}), Schema.Struct({
  account_tag: Schema.optional(Schema.String),
  connections: Schema.optional(Schema.Array(Schema.Unknown)),
  conns_active_at: Schema.optional(Schema.Date),
  conns_inactive_at: Schema.optional(Schema.Date),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.UUID),
  metadata: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("inactive", "degraded", "healthy", "down")),
  tun_type: Schema.optional(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni"))
}))),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListAllTunnelsResponse" }) as unknown as Schema.Schema<ListAllTunnelsResponse>;

export const listAllTunnels: (
  input: ListAllTunnelsRequest
) => Effect.Effect<
  ListAllTunnelsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAllTunnelsRequest,
  output: ListAllTunnelsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetResponseTextRequest {
  response_id: string;
  account_id: string;
}

export const GetResponseTextRequest = Schema.Struct({
  response_id: Schema.String.pipe(T.HttpPath("response_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/urlscanner/response/{response_id}" }),
).annotations({ identifier: "GetResponseTextRequest" }) as unknown as Schema.Schema<GetResponseTextRequest>;

export interface GetResponseTextResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetResponseTextResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetResponseTextResponse" }) as unknown as Schema.Schema<GetResponseTextResponse>;

export const getResponseText: (
  input: GetResponseTextRequest
) => Effect.Effect<
  GetResponseTextResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetResponseTextRequest,
  output: GetResponseTextResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UrlscannerSearchScansRequest {
  account_id: string;
  scan_id?: string;
  limit?: number;
  next_cursor?: string;
  date_start?: string;
  date_end?: string;
  url?: string;
  hostname?: string;
  path?: string;
  ip?: string;
  hash?: string;
  page_url?: string;
  page_hostname?: string;
  page_path?: string;
  page_asn?: string;
  page_ip?: string;
  account_scans?: boolean;
  is_malicious?: boolean;
}

export const UrlscannerSearchScansRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  scan_id: Schema.optional(Schema.UUID).pipe(T.HttpQuery("scan_id")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  next_cursor: Schema.optional(Schema.String).pipe(T.HttpQuery("next_cursor")),
  date_start: Schema.optional(Schema.Date).pipe(T.HttpQuery("date_start")),
  date_end: Schema.optional(Schema.Date).pipe(T.HttpQuery("date_end")),
  url: Schema.optional(Schema.String).pipe(T.HttpQuery("url")),
  hostname: Schema.optional(Schema.String).pipe(T.HttpQuery("hostname")),
  path: Schema.optional(Schema.String).pipe(T.HttpQuery("path")),
  ip: Schema.optional(Schema.String).pipe(T.HttpQuery("ip")),
  hash: Schema.optional(Schema.String).pipe(T.HttpQuery("hash")),
  page_url: Schema.optional(Schema.String).pipe(T.HttpQuery("page_url")),
  page_hostname: Schema.optional(Schema.String).pipe(T.HttpQuery("page_hostname")),
  page_path: Schema.optional(Schema.String).pipe(T.HttpQuery("page_path")),
  page_asn: Schema.optional(Schema.String).pipe(T.HttpQuery("page_asn")),
  page_ip: Schema.optional(Schema.String).pipe(T.HttpQuery("page_ip")),
  account_scans: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("account_scans")),
  is_malicious: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_malicious"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/urlscanner/scan" }),
).annotations({ identifier: "UrlscannerSearchScansRequest" }) as unknown as Schema.Schema<UrlscannerSearchScansRequest>;

export interface UrlscannerSearchScansResponse {
  result: { tasks: { country: string; success: boolean; time: string; url: string; uuid: string; visibility: "public" | "unlisted" }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UrlscannerSearchScansResponse = Schema.Struct({
  result: Schema.Struct({
  tasks: Schema.Array(Schema.Struct({
  country: Schema.String,
  success: Schema.Boolean,
  time: Schema.Date,
  url: Schema.String,
  uuid: Schema.UUID,
  visibility: Schema.Literal("public", "unlisted")
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UrlscannerSearchScansResponse" }) as unknown as Schema.Schema<UrlscannerSearchScansResponse>;

export const urlscannerSearchScans: (
  input: UrlscannerSearchScansRequest
) => Effect.Effect<
  UrlscannerSearchScansResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UrlscannerSearchScansRequest,
  output: UrlscannerSearchScansResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateScanRequest {
  account_id: string;
  body: { country?: "AF" | "AL" | "DZ" | "AD" | "AO" | "AG" | "AR" | "AM" | "AU" | "AT" | "AZ" | "BH" | "BD" | "BB" | "BY" | "BE" | "BZ" | "BJ" | "BM" | "BT" | "BO" | "BA" | "BW" | "BR" | "BN" | "BG" | "BF" | "BI" | "KH" | "CM" | "CA" | "CV" | "KY" | "CF" | "TD" | "CL" | "CN" | "CO" | "KM" | "CG" | "CR" | "CI" | "HR" | "CU" | "CY" | "CZ" | "CD" | "DK" | "DJ" | "DM" | "DO" | "EC" | "EG" | "SV" | "GQ" | "ER" | "EE" | "SZ" | "ET" | "FJ" | "FI" | "FR" | "GA" | "GE" | "DE" | "GH" | "GR" | "GL" | "GD" | "GT" | "GN" | "GW" | "GY" | "HT" | "HN" | "HU" | "IS" | "IN" | "ID" | "IR" | "IQ" | "IE" | "IL" | "IT" | "JM" | "JP" | "JO" | "KZ" | "KE" | "KI" | "KW" | "KG" | "LA" | "LV" | "LB" | "LS" | "LR" | "LY" | "LI" | "LT" | "LU" | "MO" | "MG" | "MW" | "MY" | "MV" | "ML" | "MR" | "MU" | "MX" | "FM" | "MD" | "MC" | "MN" | "MS" | "MA" | "MZ" | "MM" | "NA" | "NR" | "NP" | "NL" | "NZ" | "NI" | "NE" | "NG" | "KP" | "MK" | "NO" | "OM" | "PK" | "PS" | "PA" | "PG" | "PY" | "PE" | "PH" | "PL" | "PT" | "QA" | "RO" | "RU" | "RW" | "SH" | "KN" | "LC" | "VC" | "WS" | "SM" | "ST" | "SA" | "SN" | "RS" | "SC" | "SL" | "SK" | "SI" | "SB" | "SO" | "ZA" | "KR" | "SS" | "ES" | "LK" | "SD" | "SR" | "SE" | "CH" | "SY" | "TW" | "TJ" | "TZ" | "TH" | "BS" | "GM" | "TL" | "TG" | "TO" | "TT" | "TN" | "TR" | "TM" | "UG" | "UA" | "AE" | "GB" | "US" | "UY" | "UZ" | "VU" | "VE" | "VN" | "YE" | "ZM" | "ZW"; customHeaders?: Record<string, unknown>; screenshotsResolutions?: "desktop" | "mobile" | "tablet"[]; url: string; visibility?: "Public" | "Unlisted" };
}

export const CreateScanRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  country: Schema.optional(Schema.Literal("AF", "AL", "DZ", "AD", "AO", "AG", "AR", "AM", "AU", "AT", "AZ", "BH", "BD", "BB", "BY", "BE", "BZ", "BJ", "BM", "BT", "BO", "BA", "BW", "BR", "BN", "BG", "BF", "BI", "KH", "CM", "CA", "CV", "KY", "CF", "TD", "CL", "CN", "CO", "KM", "CG", "CR", "CI", "HR", "CU", "CY", "CZ", "CD", "DK", "DJ", "DM", "DO", "EC", "EG", "SV", "GQ", "ER", "EE", "SZ", "ET", "FJ", "FI", "FR", "GA", "GE", "DE", "GH", "GR", "GL", "GD", "GT", "GN", "GW", "GY", "HT", "HN", "HU", "IS", "IN", "ID", "IR", "IQ", "IE", "IL", "IT", "JM", "JP", "JO", "KZ", "KE", "KI", "KW", "KG", "LA", "LV", "LB", "LS", "LR", "LY", "LI", "LT", "LU", "MO", "MG", "MW", "MY", "MV", "ML", "MR", "MU", "MX", "FM", "MD", "MC", "MN", "MS", "MA", "MZ", "MM", "NA", "NR", "NP", "NL", "NZ", "NI", "NE", "NG", "KP", "MK", "NO", "OM", "PK", "PS", "PA", "PG", "PY", "PE", "PH", "PL", "PT", "QA", "RO", "RU", "RW", "SH", "KN", "LC", "VC", "WS", "SM", "ST", "SA", "SN", "RS", "SC", "SL", "SK", "SI", "SB", "SO", "ZA", "KR", "SS", "ES", "LK", "SD", "SR", "SE", "CH", "SY", "TW", "TJ", "TZ", "TH", "BS", "GM", "TL", "TG", "TO", "TT", "TN", "TR", "TM", "UG", "UA", "AE", "GB", "US", "UY", "UZ", "VU", "VE", "VN", "YE", "ZM", "ZW")),
  customHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  screenshotsResolutions: Schema.optional(Schema.Array(Schema.Literal("desktop", "mobile", "tablet"))),
  url: Schema.String,
  visibility: Schema.optional(Schema.Literal("Public", "Unlisted"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/urlscanner/scan" }),
).annotations({ identifier: "CreateScanRequest" }) as unknown as Schema.Schema<CreateScanRequest>;

export interface CreateScanResponse {
  result: { time: string; url: string; uuid: string; visibility: "public" | "unlisted" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateScanResponse = Schema.Struct({
  result: Schema.Struct({
  time: Schema.Date,
  url: Schema.String,
  uuid: Schema.UUID,
  visibility: Schema.Literal("public", "unlisted")
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateScanResponse" }) as unknown as Schema.Schema<CreateScanResponse>;

export const createScan: (
  input: CreateScanRequest
) => Effect.Effect<
  CreateScanResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateScanRequest,
  output: CreateScanResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetScanRequest {
  scan_id: string;
  account_id: string;
  full?: boolean;
}

export const GetScanRequest = Schema.Struct({
  scan_id: Schema.UUID.pipe(T.HttpPath("scan_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  full: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("full"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/urlscanner/scan/{scan_id}" }),
).annotations({ identifier: "GetScanRequest" }) as unknown as Schema.Schema<GetScanRequest>;

export interface GetScanResponse {
  result: { scan: { asns?: { asn?: { asn: string; description: string; location_alpha2: string; name: string; org_name: string } }; certificates: { issuer: string; subjectName: string; validFrom: number; validTo: number }[]; domains?: { "example.com"?: { categories: { content?: { id: number; name: string; super_category_id?: number }[]; inherited: { content?: { id: number; name: string; super_category_id?: number }[]; from?: string; risks?: { id: number; name: string; super_category_id?: number }[] }; risks?: { id: number; name: string; super_category_id?: number }[] }; dns: { address: string; dnssec_valid: boolean; name: string; type: string }[]; name: string; rank: { bucket: string; name: string; rank?: number }; type: string } }; geo: { continents: string[]; locations: string[] }; ips?: { ip?: { asn: string; asnDescription: string; asnLocationAlpha2: string; asnName: string; asnOrgName: string; continent: string; geonameId: string; ip: string; ipVersion: string; latitude: string; locationAlpha2: string; locationName: string; longitude: string; subdivision1Name: string; subdivision2Name: string } }; links?: { link?: { href: string; text: string } }; meta: { processors: { categories: { content: { id: number; name: string; super_category_id?: number }[]; risks: { id: number; name: string; super_category_id: number }[] }; phishing: string[]; rank: { bucket: string; name: string; rank?: number }; tech: { categories: { groups: number[]; id: number; name: string; priority: number; slug: string }[]; confidence: number; description?: string; evidence: { impliedBy: string[]; patterns: { confidence: number; excludes: string[]; implies: string[]; match: string; name: string; regex: string; type: string; value: string; version: string }[] }; icon: string; name: string; slug: string; website: string }[] } }; page: { asn: string; asnLocationAlpha2: string; asnname: string; console: { category: string; text: string; type: string; url?: string }[]; cookies: { domain: string; expires: number; httpOnly: boolean; name: string; path: string; priority?: string; sameParty: boolean; secure: boolean; session: boolean; size: number; sourcePort: number; sourceScheme: string; value: string }[]; country: string; countryLocationAlpha2: string; domain: string; headers: { name: string; value: string }[]; ip: string; js: { variables: { name: string; type: string }[] }; securityViolations: { category: string; text: string; url: string }[]; status: number; subdivision1Name: string; subdivision2name: string; url: string }; performance: { connectEnd: number; connectStart: number; decodedBodySize: number; domComplete: number; domContentLoadedEventEnd: number; domContentLoadedEventStart: number; domInteractive: number; domainLookupEnd: number; domainLookupStart: number; duration: number; encodedBodySize: number; entryType: string; fetchStart: number; initiatorType: string; loadEventEnd: number; loadEventStart: number; name: string; nextHopProtocol: string; redirectCount: number; redirectEnd: number; redirectStart: number; requestStart: number; responseEnd: number; responseStart: number; secureConnectionStart: number; startTime: number; transferSize: number; type: string; unloadEventEnd: number; unloadEventStart: number; workerStart: number }[]; task: { clientLocation: string; clientType: "Site" | "Automatic" | "Api"; effectiveUrl: string; errors: { message: string }[]; scannedFrom: { colo: string }; status: "Queued" | "InProgress" | "InPostProcessing" | "Finished"; success: boolean; time: string; timeEnd: string; url: string; uuid: string; visibility: "Public" | "Unlisted" }; verdicts: { overall: { categories: { id: number; name: string; super_category_id: number }[]; malicious: boolean; phishing: string[] } } } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetScanResponse = Schema.Struct({
  result: Schema.Struct({
  scan: Schema.Struct({
  asns: Schema.optional(Schema.Struct({
  asn: Schema.optional(Schema.Struct({
  asn: Schema.String,
  description: Schema.String,
  location_alpha2: Schema.String,
  name: Schema.String,
  org_name: Schema.String
}))
})),
  certificates: Schema.Array(Schema.Struct({
  issuer: Schema.String,
  subjectName: Schema.String,
  validFrom: Schema.Number,
  validTo: Schema.Number
})),
  domains: Schema.optional(Schema.Struct({
  "example.com": Schema.optional(Schema.Struct({
  categories: Schema.Struct({
  content: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.Number,
  name: Schema.String,
  super_category_id: Schema.optional(Schema.Number)
}))),
  inherited: Schema.Struct({
  content: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.Number,
  name: Schema.String,
  super_category_id: Schema.optional(Schema.Number)
}))),
  from: Schema.optional(Schema.String),
  risks: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.Number,
  name: Schema.String,
  super_category_id: Schema.optional(Schema.Number)
})))
}),
  risks: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.Number,
  name: Schema.String,
  super_category_id: Schema.optional(Schema.Number)
})))
}),
  dns: Schema.Array(Schema.Struct({
  address: Schema.String,
  dnssec_valid: Schema.Boolean,
  name: Schema.String,
  type: Schema.String
})),
  name: Schema.String,
  rank: Schema.Struct({
  bucket: Schema.String,
  name: Schema.String,
  rank: Schema.optional(Schema.Number)
}),
  type: Schema.String
}))
})),
  geo: Schema.Struct({
  continents: Schema.Array(Schema.String),
  locations: Schema.Array(Schema.String)
}),
  ips: Schema.optional(Schema.Struct({
  ip: Schema.optional(Schema.Struct({
  asn: Schema.String,
  asnDescription: Schema.String,
  asnLocationAlpha2: Schema.String,
  asnName: Schema.String,
  asnOrgName: Schema.String,
  continent: Schema.String,
  geonameId: Schema.String,
  ip: Schema.String,
  ipVersion: Schema.String,
  latitude: Schema.String,
  locationAlpha2: Schema.String,
  locationName: Schema.String,
  longitude: Schema.String,
  subdivision1Name: Schema.String,
  subdivision2Name: Schema.String
}))
})),
  links: Schema.optional(Schema.Struct({
  link: Schema.optional(Schema.Struct({
  href: Schema.String,
  text: Schema.String
}))
})),
  meta: Schema.Struct({
  processors: Schema.Struct({
  categories: Schema.Struct({
  content: Schema.Array(Schema.Struct({
  id: Schema.Number,
  name: Schema.String,
  super_category_id: Schema.optional(Schema.Number)
})),
  risks: Schema.Array(Schema.Struct({
  id: Schema.Number,
  name: Schema.String,
  super_category_id: Schema.Number
}))
}),
  phishing: Schema.Array(Schema.String),
  rank: Schema.Struct({
  bucket: Schema.String,
  name: Schema.String,
  rank: Schema.optional(Schema.Number)
}),
  tech: Schema.Array(Schema.Struct({
  categories: Schema.Array(Schema.Struct({
  groups: Schema.Array(Schema.Number),
  id: Schema.Number,
  name: Schema.String,
  priority: Schema.Number,
  slug: Schema.String
})),
  confidence: Schema.Number,
  description: Schema.optional(Schema.String),
  evidence: Schema.Struct({
  impliedBy: Schema.Array(Schema.String),
  patterns: Schema.Array(Schema.Struct({
  confidence: Schema.Number,
  excludes: Schema.Array(Schema.String),
  implies: Schema.Array(Schema.String),
  match: Schema.String,
  name: Schema.String,
  regex: Schema.String,
  type: Schema.String,
  value: Schema.String,
  version: Schema.String
}))
}),
  icon: Schema.String,
  name: Schema.String,
  slug: Schema.String,
  website: Schema.String
}))
})
}),
  page: Schema.Struct({
  asn: Schema.String,
  asnLocationAlpha2: Schema.String,
  asnname: Schema.String,
  console: Schema.Array(Schema.Struct({
  category: Schema.String,
  text: Schema.String,
  type: Schema.String,
  url: Schema.optional(Schema.String)
})),
  cookies: Schema.Array(Schema.Struct({
  domain: Schema.String,
  expires: Schema.Number,
  httpOnly: Schema.Boolean,
  name: Schema.String,
  path: Schema.String,
  priority: Schema.optional(Schema.String),
  sameParty: Schema.Boolean,
  secure: Schema.Boolean,
  session: Schema.Boolean,
  size: Schema.Number,
  sourcePort: Schema.Number,
  sourceScheme: Schema.String,
  value: Schema.String
})),
  country: Schema.String,
  countryLocationAlpha2: Schema.String,
  domain: Schema.String,
  headers: Schema.Array(Schema.Struct({
  name: Schema.String,
  value: Schema.String
})),
  ip: Schema.String,
  js: Schema.Struct({
  variables: Schema.Array(Schema.Struct({
  name: Schema.String,
  type: Schema.String
}))
}),
  securityViolations: Schema.Array(Schema.Struct({
  category: Schema.String,
  text: Schema.String,
  url: Schema.String
})),
  status: Schema.Number,
  subdivision1Name: Schema.String,
  subdivision2name: Schema.String,
  url: Schema.String
}),
  performance: Schema.Array(Schema.Struct({
  connectEnd: Schema.Number,
  connectStart: Schema.Number,
  decodedBodySize: Schema.Number,
  domComplete: Schema.Number,
  domContentLoadedEventEnd: Schema.Number,
  domContentLoadedEventStart: Schema.Number,
  domInteractive: Schema.Number,
  domainLookupEnd: Schema.Number,
  domainLookupStart: Schema.Number,
  duration: Schema.Number,
  encodedBodySize: Schema.Number,
  entryType: Schema.String,
  fetchStart: Schema.Number,
  initiatorType: Schema.String,
  loadEventEnd: Schema.Number,
  loadEventStart: Schema.Number,
  name: Schema.String,
  nextHopProtocol: Schema.String,
  redirectCount: Schema.Number,
  redirectEnd: Schema.Number,
  redirectStart: Schema.Number,
  requestStart: Schema.Number,
  responseEnd: Schema.Number,
  responseStart: Schema.Number,
  secureConnectionStart: Schema.Number,
  startTime: Schema.Number,
  transferSize: Schema.Number,
  type: Schema.String,
  unloadEventEnd: Schema.Number,
  unloadEventStart: Schema.Number,
  workerStart: Schema.Number
})),
  task: Schema.Struct({
  clientLocation: Schema.String,
  clientType: Schema.Literal("Site", "Automatic", "Api"),
  effectiveUrl: Schema.String,
  errors: Schema.Array(Schema.Struct({
  message: Schema.String
})),
  scannedFrom: Schema.Struct({
  colo: Schema.String
}),
  status: Schema.Literal("Queued", "InProgress", "InPostProcessing", "Finished"),
  success: Schema.Boolean,
  time: Schema.String,
  timeEnd: Schema.String,
  url: Schema.String,
  uuid: Schema.String,
  visibility: Schema.Literal("Public", "Unlisted")
}),
  verdicts: Schema.Struct({
  overall: Schema.Struct({
  categories: Schema.Array(Schema.Struct({
  id: Schema.Number,
  name: Schema.String,
  super_category_id: Schema.Number
})),
  malicious: Schema.Boolean,
  phishing: Schema.Array(Schema.String)
})
})
})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetScanResponse" }) as unknown as Schema.Schema<GetScanResponse>;

export const getScan: (
  input: GetScanRequest
) => Effect.Effect<
  GetScanResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetScanRequest,
  output: GetScanResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetScanHarRequest {
  scan_id: string;
  account_id: string;
}

export const GetScanHarRequest = Schema.Struct({
  scan_id: Schema.UUID.pipe(T.HttpPath("scan_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/urlscanner/scan/{scan_id}/har" }),
).annotations({ identifier: "GetScanHarRequest" }) as unknown as Schema.Schema<GetScanHarRequest>;

export interface GetScanHarResponse {
  result: { har: { log: { creator: { comment: string; name: string; version: string }; entries: { _initialPriority: string; _initiator_type: string; _priority: string; _requestId: string; _requestTime: number; _resourceType: string; cache: Record<string, unknown>; connection: string; pageref: string; request: { bodySize: number; headers: { name: string; value: string }[]; headersSize: number; httpVersion: string; method: string; url: string }; response: { _transferSize: number; bodySize: number; content: { compression?: number; mimeType: string; size: number }; headers: { name: string; value: string }[]; headersSize: number; httpVersion: string; redirectURL: string; status: number; statusText: string }; serverIPAddress: string; startedDateTime: string; time: number }[]; pages: { id: string; pageTimings: { onContentLoad: number; onLoad: number }; startedDateTime: string; title: string }[]; version: string } } };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetScanHarResponse = Schema.Struct({
  result: Schema.Struct({
  har: Schema.Struct({
  log: Schema.Struct({
  creator: Schema.Struct({
  comment: Schema.String,
  name: Schema.String,
  version: Schema.String
}),
  entries: Schema.Array(Schema.Struct({
  _initialPriority: Schema.String,
  _initiator_type: Schema.String,
  _priority: Schema.String,
  _requestId: Schema.String,
  _requestTime: Schema.Number,
  _resourceType: Schema.String,
  cache: Schema.Struct({}),
  connection: Schema.String,
  pageref: Schema.String,
  request: Schema.Struct({
  bodySize: Schema.Number,
  headers: Schema.Array(Schema.Struct({
  name: Schema.String,
  value: Schema.String
})),
  headersSize: Schema.Number,
  httpVersion: Schema.String,
  method: Schema.String,
  url: Schema.String
}),
  response: Schema.Struct({
  _transferSize: Schema.Number,
  bodySize: Schema.Number,
  content: Schema.Struct({
  compression: Schema.optional(Schema.Number),
  mimeType: Schema.String,
  size: Schema.Number
}),
  headers: Schema.Array(Schema.Struct({
  name: Schema.String,
  value: Schema.String
})),
  headersSize: Schema.Number,
  httpVersion: Schema.String,
  redirectURL: Schema.String,
  status: Schema.Number,
  statusText: Schema.String
}),
  serverIPAddress: Schema.String,
  startedDateTime: Schema.String,
  time: Schema.Number
})),
  pages: Schema.Array(Schema.Struct({
  id: Schema.String,
  pageTimings: Schema.Struct({
  onContentLoad: Schema.Number,
  onLoad: Schema.Number
}),
  startedDateTime: Schema.String,
  title: Schema.String
})),
  version: Schema.String
})
})
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetScanHarResponse" }) as unknown as Schema.Schema<GetScanHarResponse>;

export const getScanHar: (
  input: GetScanHarRequest
) => Effect.Effect<
  GetScanHarResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetScanHarRequest,
  output: GetScanHarResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetScanScreenshotRequest {
  scan_id: string;
  account_id: string;
  resolution?: "desktop" | "mobile" | "tablet";
}

export const GetScanScreenshotRequest = Schema.Struct({
  scan_id: Schema.UUID.pipe(T.HttpPath("scan_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  resolution: Schema.optional(Schema.Literal("desktop", "mobile", "tablet")).pipe(T.HttpQuery("resolution"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/urlscanner/scan/{scan_id}/screenshot" }),
).annotations({ identifier: "GetScanScreenshotRequest" }) as unknown as Schema.Schema<GetScanScreenshotRequest>;

export interface GetScanScreenshotResponse {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetScanScreenshotResponse = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetScanScreenshotResponse" }) as unknown as Schema.Schema<GetScanScreenshotResponse>;

export const getScanScreenshot: (
  input: GetScanScreenshotRequest
) => Effect.Effect<
  GetScanScreenshotResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetScanScreenshotRequest,
  output: GetScanScreenshotResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateScanBulkV2Request {
  account_id: string;
  body: { customHeaders?: Record<string, unknown>; customagent?: string; referer?: string; screenshotsResolutions?: "desktop" | "mobile" | "tablet"[]; url: string; visibility?: "Public" | "Unlisted" }[];
}

export const CreateScanBulkV2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Struct({
  customHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  customagent: Schema.optional(Schema.String),
  referer: Schema.optional(Schema.String),
  screenshotsResolutions: Schema.optional(Schema.Array(Schema.Literal("desktop", "mobile", "tablet"))),
  url: Schema.String,
  visibility: Schema.optional(Schema.Literal("Public", "Unlisted"))
})).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/urlscanner/v2/bulk" }),
).annotations({ identifier: "CreateScanBulkV2Request" }) as unknown as Schema.Schema<CreateScanBulkV2Request>;

export interface CreateScanBulkV2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateScanBulkV2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateScanBulkV2Response" }) as unknown as Schema.Schema<CreateScanBulkV2Response>;

export const createScanBulkV2: (
  input: CreateScanBulkV2Request
) => Effect.Effect<
  CreateScanBulkV2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateScanBulkV2Request,
  output: CreateScanBulkV2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetScanDomV2Request {
  scan_id: string;
  account_id: string;
}

export const GetScanDomV2Request = Schema.Struct({
  scan_id: Schema.UUID.pipe(T.HttpPath("scan_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/urlscanner/v2/dom/{scan_id}" }),
).annotations({ identifier: "GetScanDomV2Request" }) as unknown as Schema.Schema<GetScanDomV2Request>;

export interface GetScanDomV2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetScanDomV2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetScanDomV2Response" }) as unknown as Schema.Schema<GetScanDomV2Response>;

export const getScanDomV2: (
  input: GetScanDomV2Request
) => Effect.Effect<
  GetScanDomV2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetScanDomV2Request,
  output: GetScanDomV2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetScanHarV2Request {
  scan_id: string;
  account_id: string;
}

export const GetScanHarV2Request = Schema.Struct({
  scan_id: Schema.UUID.pipe(T.HttpPath("scan_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/urlscanner/v2/har/{scan_id}" }),
).annotations({ identifier: "GetScanHarV2Request" }) as unknown as Schema.Schema<GetScanHarV2Request>;

export interface GetScanHarV2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetScanHarV2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetScanHarV2Response" }) as unknown as Schema.Schema<GetScanHarV2Response>;

export const getScanHarV2: (
  input: GetScanHarV2Request
) => Effect.Effect<
  GetScanHarV2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetScanHarV2Request,
  output: GetScanHarV2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetResponseV2Request {
  response_id: string;
  account_id: string;
}

export const GetResponseV2Request = Schema.Struct({
  response_id: Schema.String.pipe(T.HttpPath("response_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/urlscanner/v2/responses/{response_id}" }),
).annotations({ identifier: "GetResponseV2Request" }) as unknown as Schema.Schema<GetResponseV2Request>;

export interface GetResponseV2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetResponseV2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetResponseV2Response" }) as unknown as Schema.Schema<GetResponseV2Response>;

export const getResponseV2: (
  input: GetResponseV2Request
) => Effect.Effect<
  GetResponseV2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetResponseV2Request,
  output: GetResponseV2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetScanV2Request {
  scan_id: string;
  account_id: string;
}

export const GetScanV2Request = Schema.Struct({
  scan_id: Schema.UUID.pipe(T.HttpPath("scan_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/urlscanner/v2/result/{scan_id}" }),
).annotations({ identifier: "GetScanV2Request" }) as unknown as Schema.Schema<GetScanV2Request>;

export interface GetScanV2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetScanV2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetScanV2Response" }) as unknown as Schema.Schema<GetScanV2Response>;

export const getScanV2: (
  input: GetScanV2Request
) => Effect.Effect<
  GetScanV2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetScanV2Request,
  output: GetScanV2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateScanV2Request {
  account_id: string;
  body: { country?: "AF" | "AL" | "DZ" | "AD" | "AO" | "AG" | "AR" | "AM" | "AU" | "AT" | "AZ" | "BH" | "BD" | "BB" | "BY" | "BE" | "BZ" | "BJ" | "BM" | "BT" | "BO" | "BA" | "BW" | "BR" | "BN" | "BG" | "BF" | "BI" | "KH" | "CM" | "CA" | "CV" | "KY" | "CF" | "TD" | "CL" | "CN" | "CO" | "KM" | "CG" | "CR" | "CI" | "HR" | "CU" | "CY" | "CZ" | "CD" | "DK" | "DJ" | "DM" | "DO" | "EC" | "EG" | "SV" | "GQ" | "ER" | "EE" | "SZ" | "ET" | "FJ" | "FI" | "FR" | "GA" | "GE" | "DE" | "GH" | "GR" | "GL" | "GD" | "GT" | "GN" | "GW" | "GY" | "HT" | "HN" | "HU" | "IS" | "IN" | "ID" | "IR" | "IQ" | "IE" | "IL" | "IT" | "JM" | "JP" | "JO" | "KZ" | "KE" | "KI" | "KW" | "KG" | "LA" | "LV" | "LB" | "LS" | "LR" | "LY" | "LI" | "LT" | "LU" | "MO" | "MG" | "MW" | "MY" | "MV" | "ML" | "MR" | "MU" | "MX" | "FM" | "MD" | "MC" | "MN" | "MS" | "MA" | "MZ" | "MM" | "NA" | "NR" | "NP" | "NL" | "NZ" | "NI" | "NE" | "NG" | "KP" | "MK" | "NO" | "OM" | "PK" | "PS" | "PA" | "PG" | "PY" | "PE" | "PH" | "PL" | "PT" | "QA" | "RO" | "RU" | "RW" | "SH" | "KN" | "LC" | "VC" | "WS" | "SM" | "ST" | "SA" | "SN" | "RS" | "SC" | "SL" | "SK" | "SI" | "SB" | "SO" | "ZA" | "KR" | "SS" | "ES" | "LK" | "SD" | "SR" | "SE" | "CH" | "SY" | "TW" | "TJ" | "TZ" | "TH" | "BS" | "GM" | "TL" | "TG" | "TO" | "TT" | "TN" | "TR" | "TM" | "UG" | "UA" | "AE" | "GB" | "US" | "UY" | "UZ" | "VU" | "VE" | "VN" | "YE" | "ZM" | "ZW"; customHeaders?: Record<string, unknown>; customagent?: string; referer?: string; screenshotsResolutions?: "desktop" | "mobile" | "tablet"[]; url: string; visibility?: "Public" | "Unlisted" };
}

export const CreateScanV2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  country: Schema.optional(Schema.Literal("AF", "AL", "DZ", "AD", "AO", "AG", "AR", "AM", "AU", "AT", "AZ", "BH", "BD", "BB", "BY", "BE", "BZ", "BJ", "BM", "BT", "BO", "BA", "BW", "BR", "BN", "BG", "BF", "BI", "KH", "CM", "CA", "CV", "KY", "CF", "TD", "CL", "CN", "CO", "KM", "CG", "CR", "CI", "HR", "CU", "CY", "CZ", "CD", "DK", "DJ", "DM", "DO", "EC", "EG", "SV", "GQ", "ER", "EE", "SZ", "ET", "FJ", "FI", "FR", "GA", "GE", "DE", "GH", "GR", "GL", "GD", "GT", "GN", "GW", "GY", "HT", "HN", "HU", "IS", "IN", "ID", "IR", "IQ", "IE", "IL", "IT", "JM", "JP", "JO", "KZ", "KE", "KI", "KW", "KG", "LA", "LV", "LB", "LS", "LR", "LY", "LI", "LT", "LU", "MO", "MG", "MW", "MY", "MV", "ML", "MR", "MU", "MX", "FM", "MD", "MC", "MN", "MS", "MA", "MZ", "MM", "NA", "NR", "NP", "NL", "NZ", "NI", "NE", "NG", "KP", "MK", "NO", "OM", "PK", "PS", "PA", "PG", "PY", "PE", "PH", "PL", "PT", "QA", "RO", "RU", "RW", "SH", "KN", "LC", "VC", "WS", "SM", "ST", "SA", "SN", "RS", "SC", "SL", "SK", "SI", "SB", "SO", "ZA", "KR", "SS", "ES", "LK", "SD", "SR", "SE", "CH", "SY", "TW", "TJ", "TZ", "TH", "BS", "GM", "TL", "TG", "TO", "TT", "TN", "TR", "TM", "UG", "UA", "AE", "GB", "US", "UY", "UZ", "VU", "VE", "VN", "YE", "ZM", "ZW")),
  customHeaders: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.String })),
  customagent: Schema.optional(Schema.String),
  referer: Schema.optional(Schema.String),
  screenshotsResolutions: Schema.optional(Schema.Array(Schema.Literal("desktop", "mobile", "tablet"))),
  url: Schema.String,
  visibility: Schema.optional(Schema.Literal("Public", "Unlisted"))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/urlscanner/v2/scan" }),
).annotations({ identifier: "CreateScanV2Request" }) as unknown as Schema.Schema<CreateScanV2Request>;

export interface CreateScanV2Response {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateScanV2Response = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateScanV2Response" }) as unknown as Schema.Schema<CreateScanV2Response>;

export const createScanV2: (
  input: CreateScanV2Request
) => Effect.Effect<
  CreateScanV2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateScanV2Request,
  output: CreateScanV2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetScanScreenshotV2Request {
  scan_id: string;
  account_id: string;
  resolution?: "desktop" | "mobile" | "tablet";
}

export const GetScanScreenshotV2Request = Schema.Struct({
  scan_id: Schema.UUID.pipe(T.HttpPath("scan_id")),
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  resolution: Schema.optional(Schema.Literal("desktop", "mobile", "tablet")).pipe(T.HttpQuery("resolution"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/urlscanner/v2/screenshots/{scan_id}.png" }),
).annotations({ identifier: "GetScanScreenshotV2Request" }) as unknown as Schema.Schema<GetScanScreenshotV2Request>;

export interface GetScanScreenshotV2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetScanScreenshotV2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetScanScreenshotV2Response" }) as unknown as Schema.Schema<GetScanScreenshotV2Response>;

export const getScanScreenshotV2: (
  input: GetScanScreenshotV2Request
) => Effect.Effect<
  GetScanScreenshotV2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetScanScreenshotV2Request,
  output: GetScanScreenshotV2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UrlscannerSearchScansV2Request {
  account_id: string;
  size?: number;
  q?: string;
}

export const UrlscannerSearchScansV2Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  size: Schema.optional(Schema.Number).pipe(T.HttpQuery("size")),
  q: Schema.optional(Schema.String).pipe(T.HttpQuery("q"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/urlscanner/v2/search" }),
).annotations({ identifier: "UrlscannerSearchScansV2Request" }) as unknown as Schema.Schema<UrlscannerSearchScansV2Request>;

export interface UrlscannerSearchScansV2Response {
  result: unknown | null;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UrlscannerSearchScansV2Response = Schema.Struct({
  result: Schema.NullOr(Schema.Unknown),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UrlscannerSearchScansV2Response" }) as unknown as Schema.Schema<UrlscannerSearchScansV2Response>;

export const urlscannerSearchScansV2: (
  input: UrlscannerSearchScansV2Request
) => Effect.Effect<
  UrlscannerSearchScansV2Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UrlscannerSearchScansV2Request,
  output: UrlscannerSearchScansV2Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListVectorizeIndexesRequest {
  account_id: string;
}

export const ListVectorizeIndexesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/vectorize/indexes" }),
).annotations({ identifier: "ListVectorizeIndexesRequest" }) as unknown as Schema.Schema<ListVectorizeIndexesRequest>;

export interface ListVectorizeIndexesResponse {
  result: { config?: { dimensions: number; metric: "cosine" | "euclidean" | "dot-product" }; created_on?: string; description?: string; modified_on?: string; name?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListVectorizeIndexesResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  config: Schema.optional(Schema.Struct({
  dimensions: Schema.Number,
  metric: Schema.Literal("cosine", "euclidean", "dot-product")
})),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListVectorizeIndexesResponse" }) as unknown as Schema.Schema<ListVectorizeIndexesResponse>;

export const listVectorizeIndexes: (
  input: ListVectorizeIndexesRequest
) => Effect.Effect<
  ListVectorizeIndexesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListVectorizeIndexesRequest,
  output: ListVectorizeIndexesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateVectorizeIndexRequest {
  account_id: string;
  body: { config: unknown; description?: string; name: string };
}

export const CreateVectorizeIndexRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  config: Schema.Union(Schema.Struct({
  dimensions: Schema.Number,
  metric: Schema.Literal("cosine", "euclidean", "dot-product")
}), Schema.Struct({
  preset: Schema.Literal("@cf/baai/bge-small-en-v1.5", "@cf/baai/bge-base-en-v1.5", "@cf/baai/bge-large-en-v1.5", "openai/text-embedding-ada-002", "cohere/embed-multilingual-v2.0")
})),
  description: Schema.optional(Schema.String),
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/vectorize/indexes" }),
).annotations({ identifier: "CreateVectorizeIndexRequest" }) as unknown as Schema.Schema<CreateVectorizeIndexRequest>;

export interface CreateVectorizeIndexResponse {
  result: { config?: { dimensions: number; metric: "cosine" | "euclidean" | "dot-product" }; created_on?: string; description?: string; modified_on?: string; name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateVectorizeIndexResponse = Schema.Struct({
  result: Schema.Struct({
  config: Schema.optional(Schema.Struct({
  dimensions: Schema.Number,
  metric: Schema.Literal("cosine", "euclidean", "dot-product")
})),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateVectorizeIndexResponse" }) as unknown as Schema.Schema<CreateVectorizeIndexResponse>;

export const createVectorizeIndex: (
  input: CreateVectorizeIndexRequest
) => Effect.Effect<
  CreateVectorizeIndexResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateVectorizeIndexRequest,
  output: CreateVectorizeIndexResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetVectorizeIndexRequest {
  account_id: string;
  index_name: string;
}

export const GetVectorizeIndexRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/vectorize/indexes/{index_name}" }),
).annotations({ identifier: "GetVectorizeIndexRequest" }) as unknown as Schema.Schema<GetVectorizeIndexRequest>;

export interface GetVectorizeIndexResponse {
  result: { config?: { dimensions: number; metric: "cosine" | "euclidean" | "dot-product" }; created_on?: string; description?: string; modified_on?: string; name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetVectorizeIndexResponse = Schema.Struct({
  result: Schema.Struct({
  config: Schema.optional(Schema.Struct({
  dimensions: Schema.Number,
  metric: Schema.Literal("cosine", "euclidean", "dot-product")
})),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetVectorizeIndexResponse" }) as unknown as Schema.Schema<GetVectorizeIndexResponse>;

export const getVectorizeIndex: (
  input: GetVectorizeIndexRequest
) => Effect.Effect<
  GetVectorizeIndexResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetVectorizeIndexRequest,
  output: GetVectorizeIndexResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateVectorizeIndexRequest {
  account_id: string;
  index_name: string;
  body: { description: string };
}

export const UpdateVectorizeIndexRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name")),
  body: Schema.Struct({
  description: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/vectorize/indexes/{index_name}" }),
).annotations({ identifier: "UpdateVectorizeIndexRequest" }) as unknown as Schema.Schema<UpdateVectorizeIndexRequest>;

export interface UpdateVectorizeIndexResponse {
  result: { config?: { dimensions: number; metric: "cosine" | "euclidean" | "dot-product" }; created_on?: string; description?: string; modified_on?: string; name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateVectorizeIndexResponse = Schema.Struct({
  result: Schema.Struct({
  config: Schema.optional(Schema.Struct({
  dimensions: Schema.Number,
  metric: Schema.Literal("cosine", "euclidean", "dot-product")
})),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateVectorizeIndexResponse" }) as unknown as Schema.Schema<UpdateVectorizeIndexResponse>;

export const updateVectorizeIndex: (
  input: UpdateVectorizeIndexRequest
) => Effect.Effect<
  UpdateVectorizeIndexResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateVectorizeIndexRequest,
  output: UpdateVectorizeIndexResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteVectorizeIndexRequest {
  account_id: string;
  index_name: string;
}

export const DeleteVectorizeIndexRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/vectorize/indexes/{index_name}" }),
).annotations({ identifier: "DeleteVectorizeIndexRequest" }) as unknown as Schema.Schema<DeleteVectorizeIndexRequest>;

export interface DeleteVectorizeIndexResponse {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteVectorizeIndexResponse = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteVectorizeIndexResponse" }) as unknown as Schema.Schema<DeleteVectorizeIndexResponse>;

export const deleteVectorizeIndex: (
  input: DeleteVectorizeIndexRequest
) => Effect.Effect<
  DeleteVectorizeIndexResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteVectorizeIndexRequest,
  output: DeleteVectorizeIndexResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteVectorsByIdRequest {
  account_id: string;
  index_name: string;
  body: { ids?: string[] };
}

export const DeleteVectorsByIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name")),
  body: Schema.Struct({
  ids: Schema.optional(Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/vectorize/indexes/{index_name}/delete-by-ids" }),
).annotations({ identifier: "DeleteVectorsByIdRequest" }) as unknown as Schema.Schema<DeleteVectorsByIdRequest>;

export interface DeleteVectorsByIdResponse {
  result: { count?: number; ids?: string[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteVectorsByIdResponse = Schema.Struct({
  result: Schema.Struct({
  count: Schema.optional(Schema.Number),
  ids: Schema.optional(Schema.Array(Schema.String))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteVectorsByIdResponse" }) as unknown as Schema.Schema<DeleteVectorsByIdResponse>;

export const deleteVectorsById: (
  input: DeleteVectorsByIdRequest
) => Effect.Effect<
  DeleteVectorsByIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteVectorsByIdRequest,
  output: DeleteVectorsByIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetVectorsByIdRequest {
  account_id: string;
  index_name: string;
  body: { ids?: string[] };
}

export const GetVectorsByIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name")),
  body: Schema.Struct({
  ids: Schema.optional(Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/vectorize/indexes/{index_name}/get-by-ids" }),
).annotations({ identifier: "GetVectorsByIdRequest" }) as unknown as Schema.Schema<GetVectorsByIdRequest>;

export interface GetVectorsByIdResponse {
  result: { id?: string; metadata?: Record<string, unknown>; namespace?: string; values?: number[] }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetVectorsByIdResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String),
  metadata: Schema.optional(Schema.Struct({})),
  namespace: Schema.optional(Schema.String),
  values: Schema.optional(Schema.Array(Schema.Number))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetVectorsByIdResponse" }) as unknown as Schema.Schema<GetVectorsByIdResponse>;

export const getVectorsById: (
  input: GetVectorsByIdRequest
) => Effect.Effect<
  GetVectorsByIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetVectorsByIdRequest,
  output: GetVectorsByIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface VectorizeDeprecatedInsertVectorRequest {
  account_id: string;
  index_name: string;
}

export const VectorizeDeprecatedInsertVectorRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/vectorize/indexes/{index_name}/insert" }),
).annotations({ identifier: "VectorizeDeprecatedInsertVectorRequest" }) as unknown as Schema.Schema<VectorizeDeprecatedInsertVectorRequest>;

export interface VectorizeDeprecatedInsertVectorResponse {
  result: { count?: number; ids?: string[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const VectorizeDeprecatedInsertVectorResponse = Schema.Struct({
  result: Schema.Struct({
  count: Schema.optional(Schema.Number),
  ids: Schema.optional(Schema.Array(Schema.String))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "VectorizeDeprecatedInsertVectorResponse" }) as unknown as Schema.Schema<VectorizeDeprecatedInsertVectorResponse>;

export const vectorizeDeprecatedInsertVector: (
  input: VectorizeDeprecatedInsertVectorRequest
) => Effect.Effect<
  VectorizeDeprecatedInsertVectorResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: VectorizeDeprecatedInsertVectorRequest,
  output: VectorizeDeprecatedInsertVectorResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface VectorizeDeprecatedQueryVectorRequest {
  account_id: string;
  index_name: string;
  body: { filter?: Record<string, unknown>; returnMetadata?: boolean; returnValues?: boolean; topK?: number; vector: number[] };
}

export const VectorizeDeprecatedQueryVectorRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name")),
  body: Schema.Struct({
  filter: Schema.optional(Schema.Struct({})),
  returnMetadata: Schema.optional(Schema.Boolean),
  returnValues: Schema.optional(Schema.Boolean),
  topK: Schema.optional(Schema.Number),
  vector: Schema.Array(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/vectorize/indexes/{index_name}/query" }),
).annotations({ identifier: "VectorizeDeprecatedQueryVectorRequest" }) as unknown as Schema.Schema<VectorizeDeprecatedQueryVectorRequest>;

export interface VectorizeDeprecatedQueryVectorResponse {
  result: { count?: number; matches?: { id?: string; metadata?: Record<string, unknown>; score?: number; values?: number[] }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const VectorizeDeprecatedQueryVectorResponse = Schema.Struct({
  result: Schema.Struct({
  count: Schema.optional(Schema.Number),
  matches: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String),
  metadata: Schema.optional(Schema.Struct({})),
  score: Schema.optional(Schema.Number),
  values: Schema.optional(Schema.Array(Schema.Number))
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "VectorizeDeprecatedQueryVectorResponse" }) as unknown as Schema.Schema<VectorizeDeprecatedQueryVectorResponse>;

export const vectorizeDeprecatedQueryVector: (
  input: VectorizeDeprecatedQueryVectorRequest
) => Effect.Effect<
  VectorizeDeprecatedQueryVectorResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: VectorizeDeprecatedQueryVectorRequest,
  output: VectorizeDeprecatedQueryVectorResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface VectorizeDeprecatedUpsertVectorRequest {
  account_id: string;
  index_name: string;
}

export const VectorizeDeprecatedUpsertVectorRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/vectorize/indexes/{index_name}/upsert" }),
).annotations({ identifier: "VectorizeDeprecatedUpsertVectorRequest" }) as unknown as Schema.Schema<VectorizeDeprecatedUpsertVectorRequest>;

export interface VectorizeDeprecatedUpsertVectorResponse {
  result: { count?: number; ids?: string[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const VectorizeDeprecatedUpsertVectorResponse = Schema.Struct({
  result: Schema.Struct({
  count: Schema.optional(Schema.Number),
  ids: Schema.optional(Schema.Array(Schema.String))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "VectorizeDeprecatedUpsertVectorResponse" }) as unknown as Schema.Schema<VectorizeDeprecatedUpsertVectorResponse>;

export const vectorizeDeprecatedUpsertVector: (
  input: VectorizeDeprecatedUpsertVectorRequest
) => Effect.Effect<
  VectorizeDeprecatedUpsertVectorResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: VectorizeDeprecatedUpsertVectorRequest,
  output: VectorizeDeprecatedUpsertVectorResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListVectorizeIndexes1Request {
  account_id: string;
}

export const ListVectorizeIndexes1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/vectorize/v2/indexes" }),
).annotations({ identifier: "ListVectorizeIndexes1Request" }) as unknown as Schema.Schema<ListVectorizeIndexes1Request>;

export interface ListVectorizeIndexes1Response {
  result: { config?: { dimensions: number; metric: "cosine" | "euclidean" | "dot-product" }; created_on?: string; description?: string; modified_on?: string; name?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListVectorizeIndexes1Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  config: Schema.optional(Schema.Struct({
  dimensions: Schema.Number,
  metric: Schema.Literal("cosine", "euclidean", "dot-product")
})),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListVectorizeIndexes1Response" }) as unknown as Schema.Schema<ListVectorizeIndexes1Response>;

export const listVectorizeIndexes1: (
  input: ListVectorizeIndexes1Request
) => Effect.Effect<
  ListVectorizeIndexes1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListVectorizeIndexes1Request,
  output: ListVectorizeIndexes1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateVectorizeIndex1Request {
  account_id: string;
  body: { config: unknown; description?: string; name: string };
}

export const CreateVectorizeIndex1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  config: Schema.Union(Schema.Struct({
  dimensions: Schema.Number,
  metric: Schema.Literal("cosine", "euclidean", "dot-product")
}), Schema.Struct({
  preset: Schema.Literal("@cf/baai/bge-small-en-v1.5", "@cf/baai/bge-base-en-v1.5", "@cf/baai/bge-large-en-v1.5", "openai/text-embedding-ada-002", "cohere/embed-multilingual-v2.0")
})),
  description: Schema.optional(Schema.String),
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/vectorize/v2/indexes" }),
).annotations({ identifier: "CreateVectorizeIndex1Request" }) as unknown as Schema.Schema<CreateVectorizeIndex1Request>;

export interface CreateVectorizeIndex1Response {
  result: { config?: { dimensions: number; metric: "cosine" | "euclidean" | "dot-product" }; created_on?: string; description?: string; modified_on?: string; name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateVectorizeIndex1Response = Schema.Struct({
  result: Schema.Struct({
  config: Schema.optional(Schema.Struct({
  dimensions: Schema.Number,
  metric: Schema.Literal("cosine", "euclidean", "dot-product")
})),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateVectorizeIndex1Response" }) as unknown as Schema.Schema<CreateVectorizeIndex1Response>;

export const createVectorizeIndex1: (
  input: CreateVectorizeIndex1Request
) => Effect.Effect<
  CreateVectorizeIndex1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateVectorizeIndex1Request,
  output: CreateVectorizeIndex1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetVectorizeIndex1Request {
  account_id: string;
  index_name: string;
}

export const GetVectorizeIndex1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/vectorize/v2/indexes/{index_name}" }),
).annotations({ identifier: "GetVectorizeIndex1Request" }) as unknown as Schema.Schema<GetVectorizeIndex1Request>;

export interface GetVectorizeIndex1Response {
  result: { config?: { dimensions: number; metric: "cosine" | "euclidean" | "dot-product" }; created_on?: string; description?: string; modified_on?: string; name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetVectorizeIndex1Response = Schema.Struct({
  result: Schema.Struct({
  config: Schema.optional(Schema.Struct({
  dimensions: Schema.Number,
  metric: Schema.Literal("cosine", "euclidean", "dot-product")
})),
  created_on: Schema.optional(Schema.Date),
  description: Schema.optional(Schema.String),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetVectorizeIndex1Response" }) as unknown as Schema.Schema<GetVectorizeIndex1Response>;

export const getVectorizeIndex1: (
  input: GetVectorizeIndex1Request
) => Effect.Effect<
  GetVectorizeIndex1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetVectorizeIndex1Request,
  output: GetVectorizeIndex1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteVectorizeIndex1Request {
  account_id: string;
  index_name: string;
}

export const DeleteVectorizeIndex1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/vectorize/v2/indexes/{index_name}" }),
).annotations({ identifier: "DeleteVectorizeIndex1Request" }) as unknown as Schema.Schema<DeleteVectorizeIndex1Request>;

export interface DeleteVectorizeIndex1Response {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteVectorizeIndex1Response = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteVectorizeIndex1Response" }) as unknown as Schema.Schema<DeleteVectorizeIndex1Response>;

export const deleteVectorizeIndex1: (
  input: DeleteVectorizeIndex1Request
) => Effect.Effect<
  DeleteVectorizeIndex1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteVectorizeIndex1Request,
  output: DeleteVectorizeIndex1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteVectorsById1Request {
  account_id: string;
  index_name: string;
  body: { ids?: string[] };
}

export const DeleteVectorsById1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name")),
  body: Schema.Struct({
  ids: Schema.optional(Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/vectorize/v2/indexes/{index_name}/delete_by_ids" }),
).annotations({ identifier: "DeleteVectorsById1Request" }) as unknown as Schema.Schema<DeleteVectorsById1Request>;

export interface DeleteVectorsById1Response {
  result: { mutationId?: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteVectorsById1Response = Schema.Struct({
  result: Schema.Struct({
  mutationId: Schema.optional(Schema.Unknown)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteVectorsById1Response" }) as unknown as Schema.Schema<DeleteVectorsById1Response>;

export const deleteVectorsById1: (
  input: DeleteVectorsById1Request
) => Effect.Effect<
  DeleteVectorsById1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteVectorsById1Request,
  output: DeleteVectorsById1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetVectorsById1Request {
  account_id: string;
  index_name: string;
  body: { ids?: string[] };
}

export const GetVectorsById1Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name")),
  body: Schema.Struct({
  ids: Schema.optional(Schema.Array(Schema.String))
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/vectorize/v2/indexes/{index_name}/get_by_ids" }),
).annotations({ identifier: "GetVectorsById1Request" }) as unknown as Schema.Schema<GetVectorsById1Request>;

export interface GetVectorsById1Response {
  result: { id?: string; metadata?: Record<string, unknown>; namespace?: string; values?: number[] }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetVectorsById1Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String),
  metadata: Schema.optional(Schema.Struct({})),
  namespace: Schema.optional(Schema.String),
  values: Schema.optional(Schema.Array(Schema.Number))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetVectorsById1Response" }) as unknown as Schema.Schema<GetVectorsById1Response>;

export const getVectorsById1: (
  input: GetVectorsById1Request
) => Effect.Effect<
  GetVectorsById1Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetVectorsById1Request,
  output: GetVectorsById1Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface VectorizeIndexInfoRequest {
  account_id: string;
  index_name: string;
}

export const VectorizeIndexInfoRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/vectorize/v2/indexes/{index_name}/info" }),
).annotations({ identifier: "VectorizeIndexInfoRequest" }) as unknown as Schema.Schema<VectorizeIndexInfoRequest>;

export interface VectorizeIndexInfoResponse {
  result: { dimensions?: number; processedUpToDatetime?: string; processedUpToMutation?: unknown; vectorCount?: number };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const VectorizeIndexInfoResponse = Schema.Struct({
  result: Schema.Struct({
  dimensions: Schema.optional(Schema.Number),
  processedUpToDatetime: Schema.optional(Schema.Date),
  processedUpToMutation: Schema.optional(Schema.Unknown),
  vectorCount: Schema.optional(Schema.Number)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "VectorizeIndexInfoResponse" }) as unknown as Schema.Schema<VectorizeIndexInfoResponse>;

export const vectorizeIndexInfo: (
  input: VectorizeIndexInfoRequest
) => Effect.Effect<
  VectorizeIndexInfoResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: VectorizeIndexInfoRequest,
  output: VectorizeIndexInfoResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface VectorizeInsertVectorRequest {
  account_id: string;
  index_name: string;
  "unparsable-behavior"?: "error" | "discard";
}

export const VectorizeInsertVectorRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name")),
  "unparsable-behavior": Schema.optional(Schema.Literal("error", "discard")).pipe(T.HttpQuery("unparsable-behavior"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/vectorize/v2/indexes/{index_name}/insert" }),
).annotations({ identifier: "VectorizeInsertVectorRequest" }) as unknown as Schema.Schema<VectorizeInsertVectorRequest>;

export interface VectorizeInsertVectorResponse {
  result: { mutationId?: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const VectorizeInsertVectorResponse = Schema.Struct({
  result: Schema.Struct({
  mutationId: Schema.optional(Schema.Unknown)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "VectorizeInsertVectorResponse" }) as unknown as Schema.Schema<VectorizeInsertVectorResponse>;

export const vectorizeInsertVector: (
  input: VectorizeInsertVectorRequest
) => Effect.Effect<
  VectorizeInsertVectorResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: VectorizeInsertVectorRequest,
  output: VectorizeInsertVectorResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListVectorsRequest {
  account_id: string;
  index_name: string;
  count?: number;
  cursor?: string;
}

export const ListVectorsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name")),
  count: Schema.optional(Schema.Number).pipe(T.HttpQuery("count")),
  cursor: Schema.optional(Schema.String).pipe(T.HttpQuery("cursor"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/vectorize/v2/indexes/{index_name}/list" }),
).annotations({ identifier: "ListVectorsRequest" }) as unknown as Schema.Schema<ListVectorsRequest>;

export interface ListVectorsResponse {
  result: { count: number; cursorExpirationTimestamp?: string; isTruncated: boolean; nextCursor?: string; totalCount: number; vectors: { id: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListVectorsResponse = Schema.Struct({
  result: Schema.Struct({
  count: Schema.Number,
  cursorExpirationTimestamp: Schema.optional(Schema.Date),
  isTruncated: Schema.Boolean,
  nextCursor: Schema.optional(Schema.String),
  totalCount: Schema.Number,
  vectors: Schema.Array(Schema.Struct({
  id: Schema.String
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListVectorsResponse" }) as unknown as Schema.Schema<ListVectorsResponse>;

export const listVectors: (
  input: ListVectorsRequest
) => Effect.Effect<
  ListVectorsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListVectorsRequest,
  output: ListVectorsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateMetadataIndexRequest {
  account_id: string;
  index_name: string;
  body: { indexType: "string" | "number" | "boolean"; propertyName: string };
}

export const CreateMetadataIndexRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name")),
  body: Schema.Struct({
  indexType: Schema.Literal("string", "number", "boolean"),
  propertyName: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/vectorize/v2/indexes/{index_name}/metadata_index/create" }),
).annotations({ identifier: "CreateMetadataIndexRequest" }) as unknown as Schema.Schema<CreateMetadataIndexRequest>;

export interface CreateMetadataIndexResponse {
  result: { mutationId?: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateMetadataIndexResponse = Schema.Struct({
  result: Schema.Struct({
  mutationId: Schema.optional(Schema.Unknown)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateMetadataIndexResponse" }) as unknown as Schema.Schema<CreateMetadataIndexResponse>;

export const createMetadataIndex: (
  input: CreateMetadataIndexRequest
) => Effect.Effect<
  CreateMetadataIndexResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateMetadataIndexRequest,
  output: CreateMetadataIndexResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteMetadataIndexRequest {
  account_id: string;
  index_name: string;
  body: { propertyName: string };
}

export const DeleteMetadataIndexRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name")),
  body: Schema.Struct({
  propertyName: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/vectorize/v2/indexes/{index_name}/metadata_index/delete" }),
).annotations({ identifier: "DeleteMetadataIndexRequest" }) as unknown as Schema.Schema<DeleteMetadataIndexRequest>;

export interface DeleteMetadataIndexResponse {
  result: { mutationId?: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteMetadataIndexResponse = Schema.Struct({
  result: Schema.Struct({
  mutationId: Schema.optional(Schema.Unknown)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteMetadataIndexResponse" }) as unknown as Schema.Schema<DeleteMetadataIndexResponse>;

export const deleteMetadataIndex: (
  input: DeleteMetadataIndexRequest
) => Effect.Effect<
  DeleteMetadataIndexResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteMetadataIndexRequest,
  output: DeleteMetadataIndexResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListMetadataIndexesRequest {
  account_id: string;
  index_name: string;
}

export const ListMetadataIndexesRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/vectorize/v2/indexes/{index_name}/metadata_index/list" }),
).annotations({ identifier: "ListMetadataIndexesRequest" }) as unknown as Schema.Schema<ListMetadataIndexesRequest>;

export interface ListMetadataIndexesResponse {
  result: { metadataIndexes?: { indexType?: "string" | "number" | "boolean"; propertyName?: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListMetadataIndexesResponse = Schema.Struct({
  result: Schema.Struct({
  metadataIndexes: Schema.optional(Schema.Array(Schema.Struct({
  indexType: Schema.optional(Schema.Literal("string", "number", "boolean")),
  propertyName: Schema.optional(Schema.String)
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListMetadataIndexesResponse" }) as unknown as Schema.Schema<ListMetadataIndexesResponse>;

export const listMetadataIndexes: (
  input: ListMetadataIndexesRequest
) => Effect.Effect<
  ListMetadataIndexesResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListMetadataIndexesRequest,
  output: ListMetadataIndexesResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface VectorizeQueryVectorRequest {
  account_id: string;
  index_name: string;
  body: { filter?: Record<string, unknown>; returnMetadata?: "none" | "indexed" | "all"; returnValues?: boolean; topK?: number; vector: number[] };
}

export const VectorizeQueryVectorRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name")),
  body: Schema.Struct({
  filter: Schema.optional(Schema.Struct({})),
  returnMetadata: Schema.optional(Schema.Literal("none", "indexed", "all")),
  returnValues: Schema.optional(Schema.Boolean),
  topK: Schema.optional(Schema.Number),
  vector: Schema.Array(Schema.Number)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/vectorize/v2/indexes/{index_name}/query" }),
).annotations({ identifier: "VectorizeQueryVectorRequest" }) as unknown as Schema.Schema<VectorizeQueryVectorRequest>;

export interface VectorizeQueryVectorResponse {
  result: { count?: number; matches?: { id?: string; metadata?: Record<string, unknown>; namespace?: string; score?: number; values?: number[] }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const VectorizeQueryVectorResponse = Schema.Struct({
  result: Schema.Struct({
  count: Schema.optional(Schema.Number),
  matches: Schema.optional(Schema.Array(Schema.Struct({
  id: Schema.optional(Schema.String),
  metadata: Schema.optional(Schema.Struct({})),
  namespace: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number),
  values: Schema.optional(Schema.Array(Schema.Number))
})))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "VectorizeQueryVectorResponse" }) as unknown as Schema.Schema<VectorizeQueryVectorResponse>;

export const vectorizeQueryVector: (
  input: VectorizeQueryVectorRequest
) => Effect.Effect<
  VectorizeQueryVectorResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: VectorizeQueryVectorRequest,
  output: VectorizeQueryVectorResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface VectorizeUpsertVectorRequest {
  account_id: string;
  index_name: string;
  "unparsable-behavior"?: "error" | "discard";
}

export const VectorizeUpsertVectorRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  index_name: Schema.String.pipe(T.HttpPath("index_name")),
  "unparsable-behavior": Schema.optional(Schema.Literal("error", "discard")).pipe(T.HttpQuery("unparsable-behavior"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/vectorize/v2/indexes/{index_name}/upsert" }),
).annotations({ identifier: "VectorizeUpsertVectorRequest" }) as unknown as Schema.Schema<VectorizeUpsertVectorRequest>;

export interface VectorizeUpsertVectorResponse {
  result: { mutationId?: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const VectorizeUpsertVectorResponse = Schema.Struct({
  result: Schema.Struct({
  mutationId: Schema.optional(Schema.Unknown)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "VectorizeUpsertVectorResponse" }) as unknown as Schema.Schema<VectorizeUpsertVectorResponse>;

export const vectorizeUpsertVector: (
  input: VectorizeUpsertVectorRequest
) => Effect.Effect<
  VectorizeUpsertVectorResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: VectorizeUpsertVectorRequest,
  output: VectorizeUpsertVectorResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListWaitingRoomsAccountRequest {
  account_id: string;
}

export const ListWaitingRoomsAccountRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/waiting_rooms" }),
).annotations({ identifier: "ListWaitingRoomsAccountRequest" }) as unknown as Schema.Schema<ListWaitingRoomsAccountRequest>;

export interface ListWaitingRoomsAccountResponse {
  result: { additional_routes?: { host?: string; path?: string }[]; cookie_attributes?: { samesite?: "auto" | "lax" | "none" | "strict"; secure?: "auto" | "always" | "never" }; cookie_suffix?: string; created_on?: string; custom_page_html?: string; default_template_language?: "en-US" | "es-ES" | "de-DE" | "fr-FR" | "it-IT" | "ja-JP" | "ko-KR" | "pt-BR" | "zh-CN" | "zh-TW" | "nl-NL" | "pl-PL" | "id-ID" | "tr-TR" | "ar-EG" | "ru-RU" | "fa-IR" | "bg-BG" | "hr-HR" | "cs-CZ" | "da-DK" | "fi-FI" | "lt-LT" | "ms-MY" | "nb-NO" | "ro-RO" | "el-GR" | "he-IL" | "hi-IN" | "hu-HU" | "sr-BA" | "sk-SK" | "sl-SI" | "sv-SE" | "tl-PH" | "th-TH" | "uk-UA" | "vi-VN"; description?: string; disable_session_renewal?: boolean; enabled_origin_commands?: "revoke"[]; host?: string; id?: string; json_response_enabled?: boolean; modified_on?: string; name?: string; new_users_per_minute?: number; next_event_prequeue_start_time?: string; next_event_start_time?: string; path?: string; queue_all?: boolean; queueing_method?: "fifo" | "random" | "passthrough" | "reject"; queueing_status_code?: 200 | 202 | 429; session_duration?: number; suspended?: boolean; total_active_users?: number; turnstile_action?: "log" | "infinite_queue"; turnstile_mode?: "off" | "invisible" | "visible_non_interactive" | "visible_managed" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListWaitingRoomsAccountResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  additional_routes: Schema.optional(Schema.Array(Schema.Struct({
  host: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String)
}))),
  cookie_attributes: Schema.optional(Schema.Struct({
  samesite: Schema.optional(Schema.Literal("auto", "lax", "none", "strict")),
  secure: Schema.optional(Schema.Literal("auto", "always", "never"))
})),
  cookie_suffix: Schema.optional(Schema.String),
  created_on: Schema.optional(Schema.Date),
  custom_page_html: Schema.optional(Schema.String),
  default_template_language: Schema.optional(Schema.Literal("en-US", "es-ES", "de-DE", "fr-FR", "it-IT", "ja-JP", "ko-KR", "pt-BR", "zh-CN", "zh-TW", "nl-NL", "pl-PL", "id-ID", "tr-TR", "ar-EG", "ru-RU", "fa-IR", "bg-BG", "hr-HR", "cs-CZ", "da-DK", "fi-FI", "lt-LT", "ms-MY", "nb-NO", "ro-RO", "el-GR", "he-IL", "hi-IN", "hu-HU", "sr-BA", "sk-SK", "sl-SI", "sv-SE", "tl-PH", "th-TH", "uk-UA", "vi-VN")),
  description: Schema.optional(Schema.String),
  disable_session_renewal: Schema.optional(Schema.Boolean),
  enabled_origin_commands: Schema.optional(Schema.Array(Schema.Literal("revoke"))),
  host: Schema.optional(Schema.String),
  id: Schema.optional(Schema.String),
  json_response_enabled: Schema.optional(Schema.Boolean),
  modified_on: Schema.optional(Schema.Date),
  name: Schema.optional(Schema.String),
  new_users_per_minute: Schema.optional(Schema.Number),
  next_event_prequeue_start_time: Schema.optional(Schema.String),
  next_event_start_time: Schema.optional(Schema.String),
  path: Schema.optional(Schema.String),
  queue_all: Schema.optional(Schema.Boolean),
  queueing_method: Schema.optional(Schema.Literal("fifo", "random", "passthrough", "reject")),
  queueing_status_code: Schema.optional(Schema.Literal(200, 202, 429)),
  session_duration: Schema.optional(Schema.Number),
  suspended: Schema.optional(Schema.Boolean),
  total_active_users: Schema.optional(Schema.Number),
  turnstile_action: Schema.optional(Schema.Literal("log", "infinite_queue")),
  turnstile_mode: Schema.optional(Schema.Literal("off", "invisible", "visible_non_interactive", "visible_managed"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListWaitingRoomsAccountResponse" }) as unknown as Schema.Schema<ListWaitingRoomsAccountResponse>;

export const listWaitingRoomsAccount: (
  input: ListWaitingRoomsAccountRequest
) => Effect.Effect<
  ListWaitingRoomsAccountResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListWaitingRoomsAccountRequest,
  output: ListWaitingRoomsAccountResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface ListWarpConnectorTunnelsRequest {
  account_id: string;
  name?: string;
  is_deleted?: boolean;
  existed_at?: string;
  uuid?: string;
  was_active_at?: string;
  was_inactive_at?: string;
  include_prefix?: string;
  exclude_prefix?: string;
  status?: "inactive" | "degraded" | "healthy" | "down";
  per_page?: number;
  page?: number;
}

export const ListWarpConnectorTunnelsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  is_deleted: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_deleted")),
  existed_at: Schema.optional(Schema.String).pipe(T.HttpQuery("existed_at")),
  uuid: Schema.optional(Schema.UUID).pipe(T.HttpQuery("uuid")),
  was_active_at: Schema.optional(Schema.Date).pipe(T.HttpQuery("was_active_at")),
  was_inactive_at: Schema.optional(Schema.Date).pipe(T.HttpQuery("was_inactive_at")),
  include_prefix: Schema.optional(Schema.String).pipe(T.HttpQuery("include_prefix")),
  exclude_prefix: Schema.optional(Schema.String).pipe(T.HttpQuery("exclude_prefix")),
  status: Schema.optional(Schema.Literal("inactive", "degraded", "healthy", "down")).pipe(T.HttpQuery("status")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/warp_connector" }),
).annotations({ identifier: "ListWarpConnectorTunnelsRequest" }) as unknown as Schema.Schema<ListWarpConnectorTunnelsRequest>;

export interface ListWarpConnectorTunnelsResponse {
  result: { account_tag?: string; connections?: unknown[]; conns_active_at?: string; conns_inactive_at?: string; created_at?: string; deleted_at?: string; id?: string; metadata?: Record<string, unknown>; name?: string; status?: "inactive" | "degraded" | "healthy" | "down"; tun_type?: "cfd_tunnel" | "warp_connector" | "warp" | "magic" | "ip_sec" | "gre" | "cni" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const ListWarpConnectorTunnelsResponse = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  account_tag: Schema.optional(Schema.String),
  connections: Schema.optional(Schema.Array(Schema.Unknown)),
  conns_active_at: Schema.optional(Schema.Date),
  conns_inactive_at: Schema.optional(Schema.Date),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.UUID),
  metadata: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("inactive", "degraded", "healthy", "down")),
  tun_type: Schema.optional(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "ListWarpConnectorTunnelsResponse" }) as unknown as Schema.Schema<ListWarpConnectorTunnelsResponse>;

export const listWarpConnectorTunnels: (
  input: ListWarpConnectorTunnelsRequest
) => Effect.Effect<
  ListWarpConnectorTunnelsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListWarpConnectorTunnelsRequest,
  output: ListWarpConnectorTunnelsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface CreateAWarpConnectorTunnelRequest {
  account_id: string;
  body: { name: string };
}

export const CreateAWarpConnectorTunnelRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  name: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/warp_connector" }),
).annotations({ identifier: "CreateAWarpConnectorTunnelRequest" }) as unknown as Schema.Schema<CreateAWarpConnectorTunnelRequest>;

export interface CreateAWarpConnectorTunnelResponse {
  result: { account_tag?: string; connections?: unknown[]; conns_active_at?: string; conns_inactive_at?: string; created_at?: string; deleted_at?: string; id?: string; metadata?: Record<string, unknown>; name?: string; status?: "inactive" | "degraded" | "healthy" | "down"; tun_type?: "cfd_tunnel" | "warp_connector" | "warp" | "magic" | "ip_sec" | "gre" | "cni" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const CreateAWarpConnectorTunnelResponse = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.optional(Schema.String),
  connections: Schema.optional(Schema.Array(Schema.Unknown)),
  conns_active_at: Schema.optional(Schema.Date),
  conns_inactive_at: Schema.optional(Schema.Date),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.UUID),
  metadata: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("inactive", "degraded", "healthy", "down")),
  tun_type: Schema.optional(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "CreateAWarpConnectorTunnelResponse" }) as unknown as Schema.Schema<CreateAWarpConnectorTunnelResponse>;

export const createAWarpConnectorTunnel: (
  input: CreateAWarpConnectorTunnelRequest
) => Effect.Effect<
  CreateAWarpConnectorTunnelResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAWarpConnectorTunnelRequest,
  output: CreateAWarpConnectorTunnelResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAWarpConnectorTunnelRequest {
  account_id: string;
  tunnel_id: string;
}

export const GetAWarpConnectorTunnelRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  tunnel_id: Schema.UUID.pipe(T.HttpPath("tunnel_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/warp_connector/{tunnel_id}" }),
).annotations({ identifier: "GetAWarpConnectorTunnelRequest" }) as unknown as Schema.Schema<GetAWarpConnectorTunnelRequest>;

export interface GetAWarpConnectorTunnelResponse {
  result: { account_tag?: string; connections?: unknown[]; conns_active_at?: string; conns_inactive_at?: string; created_at?: string; deleted_at?: string; id?: string; metadata?: Record<string, unknown>; name?: string; status?: "inactive" | "degraded" | "healthy" | "down"; tun_type?: "cfd_tunnel" | "warp_connector" | "warp" | "magic" | "ip_sec" | "gre" | "cni" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAWarpConnectorTunnelResponse = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.optional(Schema.String),
  connections: Schema.optional(Schema.Array(Schema.Unknown)),
  conns_active_at: Schema.optional(Schema.Date),
  conns_inactive_at: Schema.optional(Schema.Date),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.UUID),
  metadata: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("inactive", "degraded", "healthy", "down")),
  tun_type: Schema.optional(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAWarpConnectorTunnelResponse" }) as unknown as Schema.Schema<GetAWarpConnectorTunnelResponse>;

export const getAWarpConnectorTunnel: (
  input: GetAWarpConnectorTunnelRequest
) => Effect.Effect<
  GetAWarpConnectorTunnelResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAWarpConnectorTunnelRequest,
  output: GetAWarpConnectorTunnelResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface DeleteAWarpConnectorTunnelRequest {
  account_id: string;
  tunnel_id: string;
  body: Record<string, unknown>;
}

export const DeleteAWarpConnectorTunnelRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  tunnel_id: Schema.UUID.pipe(T.HttpPath("tunnel_id")),
  body: Schema.Struct({}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/warp_connector/{tunnel_id}" }),
).annotations({ identifier: "DeleteAWarpConnectorTunnelRequest" }) as unknown as Schema.Schema<DeleteAWarpConnectorTunnelRequest>;

export interface DeleteAWarpConnectorTunnelResponse {
  result: { account_tag?: string; connections?: unknown[]; conns_active_at?: string; conns_inactive_at?: string; created_at?: string; deleted_at?: string; id?: string; metadata?: Record<string, unknown>; name?: string; status?: "inactive" | "degraded" | "healthy" | "down"; tun_type?: "cfd_tunnel" | "warp_connector" | "warp" | "magic" | "ip_sec" | "gre" | "cni" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const DeleteAWarpConnectorTunnelResponse = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.optional(Schema.String),
  connections: Schema.optional(Schema.Array(Schema.Unknown)),
  conns_active_at: Schema.optional(Schema.Date),
  conns_inactive_at: Schema.optional(Schema.Date),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.UUID),
  metadata: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("inactive", "degraded", "healthy", "down")),
  tun_type: Schema.optional(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "DeleteAWarpConnectorTunnelResponse" }) as unknown as Schema.Schema<DeleteAWarpConnectorTunnelResponse>;

export const deleteAWarpConnectorTunnel: (
  input: DeleteAWarpConnectorTunnelRequest
) => Effect.Effect<
  DeleteAWarpConnectorTunnelResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAWarpConnectorTunnelRequest,
  output: DeleteAWarpConnectorTunnelResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateAWarpConnectorTunnelRequest {
  account_id: string;
  tunnel_id: string;
  body: { name?: string; tunnel_secret?: string };
}

export const UpdateAWarpConnectorTunnelRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  tunnel_id: Schema.UUID.pipe(T.HttpPath("tunnel_id")),
  body: Schema.Struct({
  name: Schema.optional(Schema.String),
  tunnel_secret: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/warp_connector/{tunnel_id}" }),
).annotations({ identifier: "UpdateAWarpConnectorTunnelRequest" }) as unknown as Schema.Schema<UpdateAWarpConnectorTunnelRequest>;

export interface UpdateAWarpConnectorTunnelResponse {
  result: { account_tag?: string; connections?: unknown[]; conns_active_at?: string; conns_inactive_at?: string; created_at?: string; deleted_at?: string; id?: string; metadata?: Record<string, unknown>; name?: string; status?: "inactive" | "degraded" | "healthy" | "down"; tun_type?: "cfd_tunnel" | "warp_connector" | "warp" | "magic" | "ip_sec" | "gre" | "cni" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateAWarpConnectorTunnelResponse = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.optional(Schema.String),
  connections: Schema.optional(Schema.Array(Schema.Unknown)),
  conns_active_at: Schema.optional(Schema.Date),
  conns_inactive_at: Schema.optional(Schema.Date),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.UUID),
  metadata: Schema.optional(Schema.Struct({})),
  name: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("inactive", "degraded", "healthy", "down")),
  tun_type: Schema.optional(Schema.Literal("cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateAWarpConnectorTunnelResponse" }) as unknown as Schema.Schema<UpdateAWarpConnectorTunnelResponse>;

export const updateAWarpConnectorTunnel: (
  input: UpdateAWarpConnectorTunnelRequest
) => Effect.Effect<
  UpdateAWarpConnectorTunnelResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAWarpConnectorTunnelRequest,
  output: UpdateAWarpConnectorTunnelResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetAWarpConnectorTunnelTokenRequest {
  account_id: string;
  tunnel_id: string;
}

export const GetAWarpConnectorTunnelTokenRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  tunnel_id: Schema.UUID.pipe(T.HttpPath("tunnel_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/warp_connector/{tunnel_id}/token" }),
).annotations({ identifier: "GetAWarpConnectorTunnelTokenRequest" }) as unknown as Schema.Schema<GetAWarpConnectorTunnelTokenRequest>;

export interface GetAWarpConnectorTunnelTokenResponse {
  result: string;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetAWarpConnectorTunnelTokenResponse = Schema.Struct({
  result: Schema.String,
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetAWarpConnectorTunnelTokenResponse" }) as unknown as Schema.Schema<GetAWarpConnectorTunnelTokenResponse>;

export const getAWarpConnectorTunnelToken: (
  input: GetAWarpConnectorTunnelTokenRequest
) => Effect.Effect<
  GetAWarpConnectorTunnelTokenResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAWarpConnectorTunnelTokenRequest,
  output: GetAWarpConnectorTunnelTokenResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetConnectivitySettingsRequest {
  account_id: string;
}

export const GetConnectivitySettingsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/zerotrust/connectivity_settings" }),
).annotations({ identifier: "GetConnectivitySettingsRequest" }) as unknown as Schema.Schema<GetConnectivitySettingsRequest>;

export interface GetConnectivitySettingsResponse {
  result: { icmp_proxy_enabled?: boolean; offramp_warp_enabled?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetConnectivitySettingsResponse = Schema.Struct({
  result: Schema.Struct({
  icmp_proxy_enabled: Schema.optional(Schema.Boolean),
  offramp_warp_enabled: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetConnectivitySettingsResponse" }) as unknown as Schema.Schema<GetConnectivitySettingsResponse>;

export const getConnectivitySettings: (
  input: GetConnectivitySettingsRequest
) => Effect.Effect<
  GetConnectivitySettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetConnectivitySettingsRequest,
  output: GetConnectivitySettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface PatchConnectivitySettingsRequest {
  account_id: string;
  body: { icmp_proxy_enabled?: boolean; offramp_warp_enabled?: boolean };
}

export const PatchConnectivitySettingsRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  icmp_proxy_enabled: Schema.optional(Schema.Boolean),
  offramp_warp_enabled: Schema.optional(Schema.Boolean)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/zerotrust/connectivity_settings" }),
).annotations({ identifier: "PatchConnectivitySettingsRequest" }) as unknown as Schema.Schema<PatchConnectivitySettingsRequest>;

export interface PatchConnectivitySettingsResponse {
  result: { icmp_proxy_enabled?: boolean; offramp_warp_enabled?: boolean };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const PatchConnectivitySettingsResponse = Schema.Struct({
  result: Schema.Struct({
  icmp_proxy_enabled: Schema.optional(Schema.Boolean),
  offramp_warp_enabled: Schema.optional(Schema.Boolean)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "PatchConnectivitySettingsResponse" }) as unknown as Schema.Schema<PatchConnectivitySettingsResponse>;

export const patchConnectivitySettings: (
  input: PatchConnectivitySettingsRequest
) => Effect.Effect<
  PatchConnectivitySettingsResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchConnectivitySettingsRequest,
  output: PatchConnectivitySettingsResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List44Request {
  account_id: string;
  id?: string;
  hostname?: string;
  tunnel_id?: string;
  comment?: string;
  existed_at?: string;
  is_deleted?: boolean;
  per_page?: number;
  page?: number;
}

export const List44Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.optional(Schema.UUID).pipe(T.HttpQuery("id")),
  hostname: Schema.optional(Schema.String).pipe(T.HttpQuery("hostname")),
  tunnel_id: Schema.optional(Schema.UUID).pipe(T.HttpQuery("tunnel_id")),
  comment: Schema.optional(Schema.String).pipe(T.HttpQuery("comment")),
  existed_at: Schema.optional(Schema.String).pipe(T.HttpQuery("existed_at")),
  is_deleted: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_deleted")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/zerotrust/routes/hostname" }),
).annotations({ identifier: "List44Request" }) as unknown as Schema.Schema<List44Request>;

export interface List44Response {
  result: { comment?: string; created_at?: string; deleted_at?: string; hostname?: string; id?: string; tunnel_id?: string; tunnel_name?: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List44Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  hostname: Schema.optional(Schema.String),
  id: Schema.optional(Schema.UUID),
  tunnel_id: Schema.optional(Schema.UUID),
  tunnel_name: Schema.optional(Schema.String)
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List44Response" }) as unknown as Schema.Schema<List44Response>;

export const list44: (
  input: List44Request
) => Effect.Effect<
  List44Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List44Request,
  output: List44Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create18Request {
  account_id: string;
  body: { comment?: string; hostname?: string; tunnel_id?: string };
}

export const Create18Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  comment: Schema.optional(Schema.String),
  hostname: Schema.optional(Schema.String),
  tunnel_id: Schema.optional(Schema.UUID)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/zerotrust/routes/hostname" }),
).annotations({ identifier: "Create18Request" }) as unknown as Schema.Schema<Create18Request>;

export interface Create18Response {
  result: { comment?: string; created_at?: string; deleted_at?: string; hostname?: string; id?: string; tunnel_id?: string; tunnel_name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create18Response = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  hostname: Schema.optional(Schema.String),
  id: Schema.optional(Schema.UUID),
  tunnel_id: Schema.optional(Schema.UUID),
  tunnel_name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create18Response" }) as unknown as Schema.Schema<Create18Response>;

export const create18: (
  input: Create18Request
) => Effect.Effect<
  Create18Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create18Request,
  output: Create18Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_13Request {
  account_id: string;
  hostname_route_id: string;
}

export const Get_13Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  hostname_route_id: Schema.UUID.pipe(T.HttpPath("hostname_route_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/zerotrust/routes/hostname/{hostname_route_id}" }),
).annotations({ identifier: "Get_13Request" }) as unknown as Schema.Schema<Get_13Request>;

export interface Get_13Response {
  result: { comment?: string; created_at?: string; deleted_at?: string; hostname?: string; id?: string; tunnel_id?: string; tunnel_name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_13Response = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  hostname: Schema.optional(Schema.String),
  id: Schema.optional(Schema.UUID),
  tunnel_id: Schema.optional(Schema.UUID),
  tunnel_name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_13Response" }) as unknown as Schema.Schema<Get_13Response>;

export const get_13: (
  input: Get_13Request
) => Effect.Effect<
  Get_13Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_13Request,
  output: Get_13Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_22Request {
  account_id: string;
  hostname_route_id: string;
}

export const Delete_22Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  hostname_route_id: Schema.UUID.pipe(T.HttpPath("hostname_route_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/zerotrust/routes/hostname/{hostname_route_id}" }),
).annotations({ identifier: "Delete_22Request" }) as unknown as Schema.Schema<Delete_22Request>;

export interface Delete_22Response {
  result: { comment?: string; created_at?: string; deleted_at?: string; hostname?: string; id?: string; tunnel_id?: string; tunnel_name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_22Response = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  hostname: Schema.optional(Schema.String),
  id: Schema.optional(Schema.UUID),
  tunnel_id: Schema.optional(Schema.UUID),
  tunnel_name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_22Response" }) as unknown as Schema.Schema<Delete_22Response>;

export const delete_22: (
  input: Delete_22Request
) => Effect.Effect<
  Delete_22Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_22Request,
  output: Delete_22Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update21Request {
  account_id: string;
  hostname_route_id: string;
  body: { comment?: string; hostname?: string; tunnel_id?: string };
}

export const Update21Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  hostname_route_id: Schema.UUID.pipe(T.HttpPath("hostname_route_id")),
  body: Schema.Struct({
  comment: Schema.optional(Schema.String),
  hostname: Schema.optional(Schema.String),
  tunnel_id: Schema.optional(Schema.UUID)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/zerotrust/routes/hostname/{hostname_route_id}" }),
).annotations({ identifier: "Update21Request" }) as unknown as Schema.Schema<Update21Request>;

export interface Update21Response {
  result: { comment?: string; created_at?: string; deleted_at?: string; hostname?: string; id?: string; tunnel_id?: string; tunnel_name?: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update21Response = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  hostname: Schema.optional(Schema.String),
  id: Schema.optional(Schema.UUID),
  tunnel_id: Schema.optional(Schema.UUID),
  tunnel_name: Schema.optional(Schema.String)
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update21Response" }) as unknown as Schema.Schema<Update21Response>;

export const update21: (
  input: Update21Request
) => Effect.Effect<
  Update21Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update21Request,
  output: Update21Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List45Request {
  account_id: string;
  name?: string;
  comment?: string;
  network?: unknown;
  existed_at?: string;
  address_family?: "v4" | "v6";
  is_default_network?: boolean;
  is_deleted?: boolean;
  sort_order?: "asc" | "desc";
  subnet_types?: "cloudflare_source" | "warp";
  per_page?: number;
  page?: number;
}

export const List45Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  comment: Schema.optional(Schema.String).pipe(T.HttpQuery("comment")),
  network: Schema.optional(Schema.String).pipe(T.HttpQuery("network")),
  existed_at: Schema.optional(Schema.String).pipe(T.HttpQuery("existed_at")),
  address_family: Schema.optional(Schema.Literal("v4", "v6")).pipe(T.HttpQuery("address_family")),
  is_default_network: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_default_network")),
  is_deleted: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_deleted")),
  sort_order: Schema.optional(Schema.Literal("asc", "desc")).pipe(T.HttpQuery("sort_order")),
  subnet_types: Schema.optional(Schema.Literal("cloudflare_source", "warp")).pipe(T.HttpQuery("subnet_types")),
  per_page: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/zerotrust/subnets" }),
).annotations({ identifier: "List45Request" }) as unknown as Schema.Schema<List45Request>;

export interface List45Response {
  result: { comment?: string; created_at?: string; deleted_at?: string; id?: string; is_default_network?: boolean; name?: string; network?: string; subnet_type?: "cloudflare_source" }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List45Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.UUID),
  is_default_network: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  subnet_type: Schema.optional(Schema.Literal("cloudflare_source"))
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List45Response" }) as unknown as Schema.Schema<List45Response>;

export const list45: (
  input: List45Request
) => Effect.Effect<
  List45Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List45Request,
  output: List45Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface UpdateCloudflareSourceRequest {
  account_id: string;
  address_family: "v4" | "v6";
  body: { comment?: string; name?: string; network?: string };
}

export const UpdateCloudflareSourceRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  address_family: Schema.Literal("v4", "v6").pipe(T.HttpPath("address_family")),
  body: Schema.Struct({
  comment: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String)
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/zerotrust/subnets/cloudflare_source/{address_family}" }),
).annotations({ identifier: "UpdateCloudflareSourceRequest" }) as unknown as Schema.Schema<UpdateCloudflareSourceRequest>;

export interface UpdateCloudflareSourceResponse {
  result: { comment?: string; created_at?: string; deleted_at?: string; id?: string; is_default_network?: boolean; name?: string; network?: string; subnet_type?: "cloudflare_source" };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const UpdateCloudflareSourceResponse = Schema.Struct({
  result: Schema.Struct({
  comment: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.Date),
  deleted_at: Schema.optional(Schema.Date),
  id: Schema.optional(Schema.UUID),
  is_default_network: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  subnet_type: Schema.optional(Schema.Literal("cloudflare_source"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "UpdateCloudflareSourceResponse" }) as unknown as Schema.Schema<UpdateCloudflareSourceResponse>;

export const updateCloudflareSource: (
  input: UpdateCloudflareSourceRequest
) => Effect.Effect<
  UpdateCloudflareSourceResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateCloudflareSourceRequest,
  output: UpdateCloudflareSourceResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_14Request {
  account_id: string;
}

export const Get_14Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/zt_risk_scoring/behaviors" }),
).annotations({ identifier: "Get_14Request" }) as unknown as Schema.Schema<Get_14Request>;

export interface Get_14Response {
  result: { behaviors: Record<string, unknown> };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_14Response = Schema.Struct({
  result: Schema.Struct({
  behaviors: Schema.Record({ key: Schema.String, value: Schema.Struct({
  description: Schema.String,
  enabled: Schema.Boolean,
  name: Schema.String,
  risk_level: Schema.Literal("low", "medium", "high")
}) })
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_14Response" }) as unknown as Schema.Schema<Get_14Response>;

export const get_14: (
  input: Get_14Request
) => Effect.Effect<
  Get_14Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_14Request,
  output: Get_14Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Put3Request {
  account_id: string;
  body: { behaviors: Record<string, unknown> };
}

export const Put3Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  behaviors: Schema.Record({ key: Schema.String, value: Schema.Struct({
  enabled: Schema.Boolean,
  risk_level: Schema.Literal("low", "medium", "high")
}) })
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/zt_risk_scoring/behaviors" }),
).annotations({ identifier: "Put3Request" }) as unknown as Schema.Schema<Put3Request>;

export interface Put3Response {
  result: { behaviors: Record<string, unknown> };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Put3Response = Schema.Struct({
  result: Schema.Struct({
  behaviors: Schema.Record({ key: Schema.String, value: Schema.Struct({
  enabled: Schema.Boolean,
  risk_level: Schema.Literal("low", "medium", "high")
}) })
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Put3Response" }) as unknown as Schema.Schema<Put3Response>;

export const put3: (
  input: Put3Request
) => Effect.Effect<
  Put3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Put3Request,
  output: Put3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface List46Request {
  account_id: string;
}

export const List46Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/zt_risk_scoring/integrations" }),
).annotations({ identifier: "List46Request" }) as unknown as Schema.Schema<List46Request>;

export interface List46Response {
  result: { account_tag: string; active: boolean; created_at: string; id: string; integration_type: "Okta"; reference_id: string; tenant_url: string; well_known_url: string }[];
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const List46Response = Schema.Struct({
  result: Schema.Array(Schema.Struct({
  account_tag: Schema.String,
  active: Schema.Boolean,
  created_at: Schema.Date,
  id: Schema.UUID,
  integration_type: Schema.Literal("Okta"),
  reference_id: Schema.String,
  tenant_url: Schema.String,
  well_known_url: Schema.String
})),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "List46Response" }) as unknown as Schema.Schema<List46Response>;

export const list46: (
  input: List46Request
) => Effect.Effect<
  List46Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: List46Request,
  output: List46Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Create19Request {
  account_id: string;
  body: { integration_type: "Okta"; reference_id?: string; tenant_url: string };
}

export const Create19Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Struct({
  integration_type: Schema.Literal("Okta"),
  reference_id: Schema.optional(Schema.String),
  tenant_url: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/zt_risk_scoring/integrations" }),
).annotations({ identifier: "Create19Request" }) as unknown as Schema.Schema<Create19Request>;

export interface Create19Response {
  result: { account_tag: string; active: boolean; created_at: string; id: string; integration_type: "Okta"; reference_id: string; tenant_url: string; well_known_url: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Create19Response = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.String,
  active: Schema.Boolean,
  created_at: Schema.Date,
  id: Schema.UUID,
  integration_type: Schema.Literal("Okta"),
  reference_id: Schema.String,
  tenant_url: Schema.String,
  well_known_url: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Create19Response" }) as unknown as Schema.Schema<Create19Response>;

export const create19: (
  input: Create19Request
) => Effect.Effect<
  Create19Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Create19Request,
  output: Create19Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetByReferenceIdRequest {
  account_id: string;
  reference_id: string;
}

export const GetByReferenceIdRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  reference_id: Schema.String.pipe(T.HttpPath("reference_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/zt_risk_scoring/integrations/reference_id/{reference_id}" }),
).annotations({ identifier: "GetByReferenceIdRequest" }) as unknown as Schema.Schema<GetByReferenceIdRequest>;

export interface GetByReferenceIdResponse {
  result: { account_tag: string; active: boolean; created_at: string; id: string; integration_type: "Okta"; reference_id: string; tenant_url: string; well_known_url: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetByReferenceIdResponse = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.String,
  active: Schema.Boolean,
  created_at: Schema.Date,
  id: Schema.UUID,
  integration_type: Schema.Literal("Okta"),
  reference_id: Schema.String,
  tenant_url: Schema.String,
  well_known_url: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetByReferenceIdResponse" }) as unknown as Schema.Schema<GetByReferenceIdResponse>;

export const getByReferenceId: (
  input: GetByReferenceIdRequest
) => Effect.Effect<
  GetByReferenceIdResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetByReferenceIdRequest,
  output: GetByReferenceIdResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_15Request {
  account_id: string;
  integration_id: string;
}

export const Get_15Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  integration_id: Schema.UUID.pipe(T.HttpPath("integration_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/zt_risk_scoring/integrations/{integration_id}" }),
).annotations({ identifier: "Get_15Request" }) as unknown as Schema.Schema<Get_15Request>;

export interface Get_15Response {
  result: { account_tag: string; active: boolean; created_at: string; id: string; integration_type: "Okta"; reference_id: string; tenant_url: string; well_known_url: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_15Response = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.String,
  active: Schema.Boolean,
  created_at: Schema.Date,
  id: Schema.UUID,
  integration_type: Schema.Literal("Okta"),
  reference_id: Schema.String,
  tenant_url: Schema.String,
  well_known_url: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_15Response" }) as unknown as Schema.Schema<Get_15Response>;

export const get_15: (
  input: Get_15Request
) => Effect.Effect<
  Get_15Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_15Request,
  output: Get_15Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Update22Request {
  account_id: string;
  integration_id: string;
  body: { active: boolean; reference_id?: string; tenant_url: string };
}

export const Update22Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  integration_id: Schema.UUID.pipe(T.HttpPath("integration_id")),
  body: Schema.Struct({
  active: Schema.Boolean,
  reference_id: Schema.optional(Schema.String),
  tenant_url: Schema.String
}).pipe(T.HttpBody())
}).pipe(
  T.Http({ method: "PUT", path: "/accounts/{account_id}/zt_risk_scoring/integrations/{integration_id}" }),
).annotations({ identifier: "Update22Request" }) as unknown as Schema.Schema<Update22Request>;

export interface Update22Response {
  result: { account_tag: string; active: boolean; created_at: string; id: string; integration_type: "Okta"; reference_id: string; tenant_url: string; well_known_url: string };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Update22Response = Schema.Struct({
  result: Schema.Struct({
  account_tag: Schema.String,
  active: Schema.Boolean,
  created_at: Schema.Date,
  id: Schema.UUID,
  integration_type: Schema.Literal("Okta"),
  reference_id: Schema.String,
  tenant_url: Schema.String,
  well_known_url: Schema.String
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Update22Response" }) as unknown as Schema.Schema<Update22Response>;

export const update22: (
  input: Update22Request
) => Effect.Effect<
  Update22Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Update22Request,
  output: Update22Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Delete_23Request {
  account_id: string;
  integration_id: string;
}

export const Delete_23Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  integration_id: Schema.UUID.pipe(T.HttpPath("integration_id"))
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/zt_risk_scoring/integrations/{integration_id}" }),
).annotations({ identifier: "Delete_23Request" }) as unknown as Schema.Schema<Delete_23Request>;

export interface Delete_23Response {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Delete_23Response = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Delete_23Response" }) as unknown as Schema.Schema<Delete_23Response>;

export const delete_23: (
  input: Delete_23Request
) => Effect.Effect<
  Delete_23Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Delete_23Request,
  output: Delete_23Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Get_16Request {
  account_id: string;
}

export const Get_16Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/zt_risk_scoring/summary" }),
).annotations({ identifier: "Get_16Request" }) as unknown as Schema.Schema<Get_16Request>;

export interface Get_16Response {
  result: { users: { email: string; event_count: number; last_event: string; max_risk_level: "low" | "medium" | "high"; name: string; user_id: string }[] };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Get_16Response = Schema.Struct({
  result: Schema.Struct({
  users: Schema.Array(Schema.Struct({
  email: Schema.String,
  event_count: Schema.Number,
  last_event: Schema.Date,
  max_risk_level: Schema.Literal("low", "medium", "high"),
  name: Schema.String,
  user_id: Schema.UUID
}))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Get_16Response" }) as unknown as Schema.Schema<Get_16Response>;

export const get_16: (
  input: Get_16Request
) => Effect.Effect<
  Get_16Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Get_16Request,
  output: Get_16Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface GetForUserRequest {
  account_id: string;
  user_id: string;
}

export const GetForUserRequest = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  user_id: Schema.UUID.pipe(T.HttpPath("user_id"))
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/zt_risk_scoring/{user_id}" }),
).annotations({ identifier: "GetForUserRequest" }) as unknown as Schema.Schema<GetForUserRequest>;

export interface GetForUserResponse {
  result: { email: string; events: { event_details?: unknown; id: string; name: string; risk_level: "low" | "medium" | "high"; timestamp: string }[]; last_reset_time?: string; name: string; risk_level?: unknown };
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const GetForUserResponse = Schema.Struct({
  result: Schema.Struct({
  email: Schema.String,
  events: Schema.Array(Schema.Struct({
  event_details: Schema.optional(Schema.Unknown),
  id: Schema.String,
  name: Schema.String,
  risk_level: Schema.Literal("low", "medium", "high"),
  timestamp: Schema.Date
})),
  last_reset_time: Schema.optional(Schema.Date),
  name: Schema.String,
  risk_level: Schema.optional(Schema.Literal("low", "medium", "high"))
}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "GetForUserResponse" }) as unknown as Schema.Schema<GetForUserResponse>;

export const getForUser: (
  input: GetForUserRequest
) => Effect.Effect<
  GetForUserResponse,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetForUserRequest,
  output: GetForUserResponse,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));

export interface Post3Request {
  account_id: string;
  user_id: string;
}

export const Post3Request = Schema.Struct({
  account_id: Schema.String.pipe(T.HttpPath("account_id")),
  user_id: Schema.UUID.pipe(T.HttpPath("user_id"))
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/zt_risk_scoring/{user_id}/reset" }),
).annotations({ identifier: "Post3Request" }) as unknown as Schema.Schema<Post3Request>;

export interface Post3Response {
  result: Record<string, unknown>;
  result_info?: { page?: number; per_page?: number; count?: number; total_count?: number; cursor?: string };
}

export const Post3Response = Schema.Struct({
  result: Schema.Struct({}),
  result_info: Schema.optional(Schema.Struct({
    page: Schema.optional(Schema.Number),
    per_page: Schema.optional(Schema.Number),
    count: Schema.optional(Schema.Number),
    total_count: Schema.optional(Schema.Number),
    cursor: Schema.optional(Schema.String),
  })),
}).annotations({ identifier: "Post3Response" }) as unknown as Schema.Schema<Post3Response>;

export const post3: (
  input: Post3Request
) => Effect.Effect<
  Post3Response,
  RateLimited | TooManyRequests | AuthenticationError | InvalidToken | MissingToken | TokenExpired | Unauthorized | CloudflareError | UnknownCloudflareError | CloudflareNetworkError | CloudflareHttpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: Post3Request,
  output: Post3Response,
  errors: [RateLimited, TooManyRequests, AuthenticationError, InvalidToken, MissingToken, TokenExpired, Unauthorized],
}));
